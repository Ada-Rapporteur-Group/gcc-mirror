          General information

The hsa branch is a development and experimental branch which can
produce HSAIL code for HSA capable accelerators.  Its contents can be
roughly divided into two parts.  First, the files with the hsa prefix
contain expansion of specially marked gimple functions to HSAIL and
while they still need a lot of work they are meant as the basis for
future inclusion in trunk.  Changes in the rest of the gcc,
particularly in omp-low.c are of a much more experimental nature and
we are aware that many of them will need to be re-worked.

In particular, the branch currently attempts to compile all OMP
parallel regions as HSA kernels and strives to strip as much control
flow from simple single OMP parallel loops.  This makes experimenting
with current OMP tests and benchmarks easier but of course it is not
how thing s are eventually expected to work and we are aware that what
will remain will have to be implemented differently.  In particular,
integration with gomp4 branch development is planned as well.

======================================================================

          Setup

HSA branch now produces HSAIL version 1.0f which isn't currently
supported by the only simulator I am aware of.  Until it is upgraded
you will need real HSA capable hardware to execute code generated by
this branch.

In order to run the code produced by the HSA branch on such hardware,
you'll need the following (assuming you run on x86_64-linux, so far we
have not tested anything else):

1. Kernel driver.  This step is out of scope of this document and
   depends heavily on your environment, especially on what Linux
   distribution you are running.

2. libhsakmt.so.1 from HSA-Drivers-Linux-AMD repository.  This is the
   same repository where you might have your kernel from.  If not,
   check it out from github:

   $ mkdir $HOME/testhsa
   $ cd $HOME/testhsa
   $ git clone 'https://github.com/HSAFoundation/HSA-Drivers-Linux-AMD'

   The steps below were tested with revision 6c125e0 from March 24,
   2015.  Make sure the path to the shared object is in your
   LD_LIBRARY_PATH. If you use bash, in the example above you would
   issue:

   $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$HOME/testhsa/HSA-Drivers-Linux-AMD/kfd-1.2/libhsakmt/lnx64a

3. libhsa-runtime64.so from HSA-Runtime-AMD repository, which you can
   clone from github too.  Also make sure the shared object is in your
   LD_LIBRARY_PATH:

   $ git clone 'https://github.com/HSAFoundation/HSA-Runtime-AMD'
   $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$HOME/testhsa/HSA-Runtime-AMD/lib/x86_64

   These and the steps below were tested with revision 48e1f4c from
   April 22 2015.

   You can now try the checks and samples shipped with in both
   repositories above to test whether your setup works.  Look at
   HSA-Drivers-Linux-AMD/kfd_check_installation.sh and into
   HSA-Runtime-AMD/sample/ for details.

OK, now you are ready to compile and run your first example.
Configure and compile the hsa branch gcc as usual and install it into
some directory.  Mine is in $HOME/gcc/hsa/inst/ and I will be using
that in the following example.  Lets assume you have the following
source code in file omp_veccopy.c:

----------------------------------------
#include <omp.h>
#include <stdio.h>
#include <string.h>
#define N 256
void printList(int *src, int *dst, int size) {
  int idx = 0;
  for (; idx < size; idx++) {
    printf ("Src[%d] : %d Dst[%d] : %d \n", idx, src[idx], idx, dst[idx]);
  }
}

void veccpy(int *a, int *b, int n) {

   int j;
   #pragma omp parallel for
   for( j = 0; j<n;j++) {
      b[j] = a[j];
   }
}

int main() {
  int a[N], b[N], i;

  for (i = 0; i< N; i++) {
    a[i] = i;
  }
  
  veccpy(a, b, N);

  if (memcmp(a, b, N * sizeof (int)) != 0) {
    printList((int *)a, (int *)b, N);
    printf ("Vector Copy C case    - Failed \n");
  } else {
    printf ("Vector Copy C case    - Passed \n");
  }
  return 0;
}
----------------------------------------

Compile it with the branch:

  $ $HOME/gcc/hsa/inst/bin/gcc -lm -fopenmp -O -c omp_veccopy.c

If you also provide the -fdump-tree-ompexp-details option to the
compiler, it will create a file with .ompexp suffix which you can
search for optimization notes indicating whether the compiler has
succeeded in turning OMP loops into kernels stripped off all
OMP-generated control flow and suitable for a GPGPU.  If it for some
reason failed, the note will also give you the reason why.  In this
example, however, it reports success like this:

omp_veccopy.c:15:12: note: Parallel construct will be turned into an HSA kernel

Now link the program as usual, providing a path to libgomp of the
installed hsa branch gcc and the HSA run-time and the shared libraries
of the HSA run-time and driver:

  $ $HOME/gcc/hsa/inst/bin/gcc omp_veccopy.o -lm -fopenmp -Wl,-rpath,$HOME/gcc/hsa/inst/lib64 -L$HOME/hsa/HSA-Runtime-AMD/lib/ -lhsa-runtime64 -lhsakmt -o omp_veccopy

Assuming you have all necessary libraries in your LD_LIBRARY_PATH, you
can now run the example:

  $ ./omp_veccopy

and should get a brief message that it has passed.  If you got the
correct result, you can experiment more on your own but be prepare to
find a lot of missing functionality :-)

