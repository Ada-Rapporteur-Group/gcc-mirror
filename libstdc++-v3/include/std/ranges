// <ranges> -*- C++ -*-

// Copyright (C) 2019-2020 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received __a copy of the GNU General Public License and
// __a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/ranges
 *  This is a Standard C++ Library header.
 *  @ingroup concepts
 */

#ifndef _GLIBCXX_RANGES
#define _GLIBCXX_RANGES 1

#if __cplusplus > 201703L

#pragma GCC system_header

#include <concepts>

#if __cpp_lib_concepts

#include <compare>
#include <functional> // std::ref
#include <initializer_list>
#include <iterator>
#include <limits>
#include <optional>

/**
 * @defgroup ranges Ranges
 *
 * Components for dealing with ranges of elements.
 */

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION
namespace ranges
{
  // [range.range] The range concept.
  // [range.sized] The sized_range concept.
  // Defined in <bits/range_access.h>

  // [range.refinements]
  // Defined in <bits/range_access.h>

  struct view_base { };

  namespace __detail
  {
    template<typename _Tp>
      concept __deep_const_range = range<_Tp> && range<const _Tp>
	&& same_as<range_reference_t<_Tp>, range_reference_t<const _Tp>>;

    template<typename _Tp>
      inline constexpr bool __enable_view_impl
	= derived_from<_Tp, view_base> || (!__deep_const_range<_Tp>);

    template<typename _Tp>
      inline constexpr bool __enable_view_impl<std::initializer_list<_Tp>>
	= false;

  } // namespace __detail

  template<typename _Tp>
    inline constexpr bool enable_view
      = __detail::__enable_view_impl<remove_cv_t<_Tp>>;

  template<typename _Tp>
    concept view
      = range<_Tp> && movable<_Tp> && default_initializable<_Tp>
	&& enable_view<_Tp>;

  /// A range which can be safely converted to a view.
  template<typename _Tp>
    concept viewable_range = range<_Tp>
      && (safe_range<_Tp> || view<decay_t<_Tp>>);

  namespace __detail
  {
    template<typename _Range>
      concept __simple_view = view<_Range> && range<const _Range>
	&& same_as<iterator_t<_Range>, iterator_t<const _Range>>
	&& same_as<sentinel_t<_Range>, sentinel_t<const _Range>>;

    template<typename _It>
      concept __has_arrow = input_iterator<_It>
	&& (is_pointer_v<_It> || requires(_It __it) { __it.operator->(); });

    template<typename _Tp, typename _Up>
      concept __not_same_as
	= !same_as<remove_cvref_t<_Tp>, remove_cvref_t<_Up>>;
  } // namespace __detail

  template<typename _Derived>
    requires is_class_v<_Derived> && same_as<_Derived, remove_cv_t<_Derived>>
    class view_interface : public view_base
    {
    private:
      constexpr _Derived& _M_derived() noexcept
      {
	static_assert(derived_from<_Derived, view_interface<_Derived>>);
	static_assert(view<_Derived>);
	return static_cast<_Derived&>(*this);
      }

      constexpr const _Derived& _M_derived() const noexcept
      {
	static_assert(derived_from<_Derived, view_interface<_Derived>>);
	static_assert(view<_Derived>);
	return static_cast<const _Derived&>(*this);
      }

    public:
      constexpr bool
      empty() requires forward_range<_Derived>
      { return ranges::begin(_M_derived()) == ranges::end(_M_derived()); }

      constexpr bool
      empty() const requires forward_range<const _Derived>
      { return ranges::begin(_M_derived()) == ranges::end(_M_derived()); }

      constexpr explicit
      operator bool() requires requires { ranges::empty(_M_derived()); }
      { return !ranges::empty(_M_derived()); }

      constexpr explicit
      operator bool() const requires requires { ranges::empty(_M_derived()); }
      { return !ranges::empty(_M_derived()); }

      constexpr auto
      data() requires contiguous_iterator<iterator_t<_Derived>>
      { return to_address(ranges::begin(_M_derived())); }

      constexpr auto
      data() const
      requires range<const _Derived>
	&& contiguous_iterator<iterator_t<const _Derived>>
      { return to_address(ranges::begin(_M_derived())); }

      constexpr auto
      size()
      requires forward_range<_Derived>
	&& sized_sentinel_for<sentinel_t<_Derived>, iterator_t<_Derived>>
      { return ranges::end(_M_derived()) - ranges::begin(_M_derived()); }

      constexpr auto
      size() const
      requires forward_range<const _Derived>
	&& sized_sentinel_for<sentinel_t<const _Derived>,
			      iterator_t<const _Derived>>
      { return ranges::end(_M_derived()) - ranges::begin(_M_derived()); }

      constexpr decltype(auto)
      front() requires forward_range<_Derived>
      {
	__glibcxx_assert(!empty());
	return *ranges::begin(_M_derived());
      }

      constexpr decltype(auto)
      front() const requires forward_range<const _Derived>
      {
	__glibcxx_assert(!empty());
	return *ranges::begin(_M_derived());
      }

      constexpr decltype(auto)
      back()
      requires bidirectional_range<_Derived> && common_range<_Derived>
      {
	__glibcxx_assert(!empty());
	return *ranges::prev(ranges::end(_M_derived()));
      }

      constexpr decltype(auto)
      back() const
      requires bidirectional_range<const _Derived>
	&& common_range<const _Derived>
      {
	__glibcxx_assert(!empty());
	return *ranges::prev(ranges::end(_M_derived()));
      }

      template<random_access_range _Range = _Derived>
	constexpr decltype(auto)
	operator[](range_difference_t<_Range> __n)
	{ return ranges::begin(_M_derived())[__n]; }

      template<random_access_range _Range = const _Derived>
	constexpr decltype(auto)
	operator[](range_difference_t<_Range> __n) const
	{ return ranges::begin(_M_derived())[__n]; }
    };

  namespace __detail
  {
    template<typename _Tp>
      concept __pair_like
	= !is_reference_v<_Tp> && requires(_Tp __t)
	{
	  typename tuple_size<_Tp>::type;
	  requires derived_from<tuple_size<_Tp>, integral_constant<size_t, 2>>;
	  typename tuple_element_t<0, remove_const_t<_Tp>>;
	  typename tuple_element_t<1, remove_const_t<_Tp>>;
	  { get<0>(__t) } -> convertible_to<const tuple_element_t<0, _Tp>&>;
	  { get<1>(__t) } -> convertible_to<const tuple_element_t<1, _Tp>&>;
	};

    template<typename _Tp, typename _Up, typename _Vp>
      concept __pair_like_convertible_to
	= !range<_Tp> && __pair_like<remove_reference_t<_Tp>>
	&& requires(_Tp&& __t)
	{
	  { get<0>(std::forward<_Tp>(__t)) } -> convertible_to<_Up>;
	  { get<1>(std::forward<_Tp>(__t)) } -> convertible_to<_Vp>;
	};

    template<typename _Tp, typename _Up, typename _Vp>
      concept __pair_like_convertible_from
	= !range<_Tp> && __pair_like<_Tp>
	&& constructible_from<_Tp, _Up, _Vp>;

    template<typename _Tp>
      concept __iterator_sentinel_pair
	= !range<_Tp> && __pair_like<_Tp>
	&& sentinel_for<tuple_element_t<1, _Tp>, tuple_element_t<0, _Tp>>;

  } // namespace __detail

  enum class subrange_kind : bool { unsized, sized };

  template<input_or_output_iterator _It, sentinel_for<_It> _Sent = _It,
	   subrange_kind _Kind = sized_sentinel_for<_Sent, _It>
	     ? subrange_kind::sized : subrange_kind::unsized>
    requires (_Kind == subrange_kind::sized || !sized_sentinel_for<_Sent, _It>)
    class subrange : public view_interface<subrange<_It, _Sent, _Kind>>
    {
    private:
      static constexpr bool _S_store_size
	= _Kind == subrange_kind::sized && !sized_sentinel_for<_Sent, _It>;

      _It _M_begin = _It();
      _Sent _M_end = _Sent();

      template<typename, bool = _S_store_size>
	struct _Size
	{ };

      template<typename _Tp>
	struct _Size<_Tp, true>
	{ __detail::__make_unsigned_like_t<_Tp> _M_size; };

      [[no_unique_address]] _Size<iter_difference_t<_It>> _M_size = {};

    public:
      subrange() = default;

      constexpr
      subrange(_It __i, _Sent __s) requires (!_S_store_size)
      : _M_begin(std::move(__i)), _M_end(__s)
      { }

      constexpr
      subrange(_It __i, _Sent __s,
	       __detail::__make_unsigned_like_t<iter_difference_t<_It>> __n)
	requires (_Kind == subrange_kind::sized)
      : _M_begin(std::move(__i)), _M_end(__s)
      {
	using __detail::__to_unsigned_like;
	__glibcxx_assert(__n == __to_unsigned_like(ranges::distance(__i, __s)));
	if constexpr (_S_store_size)
	  _M_size._M_size = __n;
      }

      template<__detail::__not_same_as<subrange> _Rng>
	requires safe_range<_Rng>
	  && convertible_to<iterator_t<_Rng>, _It>
	  && convertible_to<sentinel_t<_Rng>, _Sent>
	constexpr
	subrange(_Rng&& __r) requires (!_S_store_size || sized_range<_Rng>)
	: subrange{ranges::begin(__r), ranges::end(__r)}
	{
	  if constexpr (_S_store_size)
	    _M_size._M_size = ranges::size(__r);
	}

      template<safe_range _Rng>
	requires convertible_to<iterator_t<_Rng>, _It>
	  && convertible_to<sentinel_t<_Rng>, _Sent>
	constexpr
	subrange(_Rng&& __r,
		 __detail::__make_unsigned_like_t<iter_difference_t<_It>> __n)
	requires (_Kind == subrange_kind::sized)
	: subrange{ranges::begin(__r), ranges::end(__r), __n}
	{ }

      template<__detail::__not_same_as<subrange> _PairLike>
	requires __detail::__pair_like_convertible_to<_PairLike, _It, _Sent>
	constexpr
	subrange(_PairLike&& __r) requires (!_S_store_size)
	: subrange{std::get<0>(std::forward<_PairLike>(__r)),
		   std::get<1>(std::forward<_PairLike>(__r))}
	{ }

      template<__detail::__pair_like_convertible_to<_It, _Sent> _PairLike>
	constexpr
	subrange(_PairLike&& __r,
		 __detail::__make_unsigned_like_t<iter_difference_t<_It>> __n)
	requires (_Kind == subrange_kind::sized)
	: subrange{std::get<0>(std::forward<_PairLike>(__r)),
		   std::get<1>(std::forward<_PairLike>(__r)), __n}
	{ }

      template<__detail::__not_same_as<subrange> _PairLike>
	requires __detail::__pair_like_convertible_from<_PairLike, const _It&,
							const _Sent&>
      constexpr
      operator _PairLike() const
      { return _PairLike(_M_begin, _M_end); }

      constexpr _It
      begin() const requires copyable<_It>
      { return _M_begin; }

      [[nodiscard]] constexpr _It
      begin() requires (!copyable<_It>)
      { return std::move(_M_begin); }

      constexpr _Sent end() const { return _M_end; }

      constexpr bool empty() const { return _M_begin == _M_end; }

      constexpr __detail::__make_unsigned_like_t<iter_difference_t<_It>>
      size() const requires (_Kind == subrange_kind::sized)
      {
	if constexpr (_S_store_size)
	  return _M_size._M_size;
	else
	  return __detail::__to_unsigned_like(_M_end - _M_begin);
      }

      [[nodiscard]] constexpr subrange
      next(iter_difference_t<_It> __n = 1) const &
	requires forward_iterator<_It>
      {
	auto __tmp = *this;
	__tmp.advance(__n);
	return __tmp;
      }

      [[nodiscard]] constexpr subrange
      next(iter_difference_t<_It> __n = 1) &&
      {
	advance(__n);
	return std::move(*this);
      }

      [[nodiscard]] constexpr subrange
      prev(iter_difference_t<_It> __n = 1) const
	requires bidirectional_iterator<_It>
      {
	auto __tmp = *this;
	__tmp.advance(--__n);
	return __tmp;
      }

      constexpr subrange&
      advance(iter_difference_t<_It> __n)
      {
	if constexpr (_S_store_size)
	  {
	    auto __d = __n - ranges::advance(_M_begin, __n, _M_end);
	    if (__d >= 0)
	      _M_size._M_size -= __detail::__to_unsigned_like(__d);
	    else
	      _M_size._M_size += __detail::__to_unsigned_like(-__d);
	  }
	else
	  ranges::advance(_M_begin, __n, _M_end);
	return *this;
      }
    };

  template<input_or_output_iterator _It, sentinel_for<_It> _Sent>
    subrange(_It, _Sent,
	     __detail::__make_unsigned_like_t<iter_difference_t<_It>>)
      -> subrange<_It, _Sent, subrange_kind::sized>;

  template<__detail::__iterator_sentinel_pair _Pr>
    subrange(_Pr)
      -> subrange<tuple_element_t<0, _Pr>, tuple_element_t<1, _Pr>>;

  template<__detail::__iterator_sentinel_pair _Pr>
    subrange(_Pr, __detail::__make_unsigned_like_t<iter_difference_t<
						     tuple_element_t<0, _Pr>>>)
      -> subrange<tuple_element_t<0, _Pr>, tuple_element_t<1, _Pr>,
		  subrange_kind::sized>;

  template<safe_range _Rng>
    subrange(_Rng&&)
      -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>,
		 (sized_range<_Rng>
		  || sized_sentinel_for<sentinel_t<_Rng>, iterator_t<_Rng>>)
		 ? subrange_kind::sized : subrange_kind::unsized>;

  template<safe_range _Rng>
    subrange(_Rng&&,
	     __detail::__make_unsigned_like_t<range_difference_t<_Rng>>)
      -> subrange<iterator_t<_Rng>, sentinel_t<_Rng>, subrange_kind::sized>;

  template<size_t _Num, class _It, class _Sent, subrange_kind _Kind>
    requires (_Num < 2)
    constexpr auto
    get(const subrange<_It, _Sent, _Kind>& __r)
    {
      if constexpr (_Num == 0)
	return __r.begin();
      else
	return __r.end();
    }

  template<size_t _Num, class _It, class _Sent, subrange_kind _Kind>
    requires (_Num < 2)
    constexpr auto
    get(subrange<_It, _Sent, _Kind>&& __r)
    {
      if constexpr (_Num == 0)
	return __r.begin();
      else
	return __r.end();
    }

  template<input_or_output_iterator _It, sentinel_for<_It> _Sent,
	   subrange_kind _Kind>
    inline constexpr bool
      enable_safe_range<subrange<_It, _Sent, _Kind>> = true;

} // namespace ranges

  using ranges::get;

namespace ranges
{
  /// Type returned by algorithms instead of a dangling iterator or subrange.
  struct dangling
  {
    constexpr dangling() noexcept = default;
    template<typename... _Args>
      constexpr dangling(_Args&&...) noexcept { }
  };

  template<range _Range>
    using safe_iterator_t = conditional_t<safe_range<_Range>,
					  iterator_t<_Range>,
					  dangling>;

  template<range _Range>
    using safe_subrange_t = conditional_t<safe_range<_Range>,
					  subrange<iterator_t<_Range>>,
					  dangling>;

  template<typename _Tp> requires is_object_v<_Tp>
    class empty_view
    : public view_interface<empty_view<_Tp>>
    {
    public:
      static constexpr _Tp* begin() noexcept { return nullptr; }
      static constexpr _Tp* end() noexcept { return nullptr; }
      static constexpr _Tp* data() noexcept { return nullptr; }
      static constexpr size_t size() noexcept { return 0; }
      static constexpr bool empty() noexcept { return true; }
    };

  template<typename _Tp>
    inline constexpr bool enable_safe_range<empty_view<_Tp>> = true;

  namespace __detail
  {
    template<copy_constructible _Tp> requires is_object_v<_Tp>
      struct __box : std::optional<_Tp>
      {
	using std::optional<_Tp>::optional;

	constexpr
	__box()
	noexcept(is_nothrow_default_constructible_v<_Tp>)
	requires default_initializable<_Tp>
	: std::optional<_Tp>{std::in_place}
	{ }

	constexpr
	__box(const __box&) = default;

	using std::optional<_Tp>::operator=;

	__box&
	operator=(const __box& __that)
	noexcept(is_nothrow_copy_constructible_v<_Tp>)
	requires (!assignable_from<_Tp&, const _Tp&>)
	{
	  if ((bool)__that)
	    this->emplace(*__that);
	  else
	    this->reset();
	  return *this;
	}

	__box&
	operator=(__box&& __that)
	noexcept(is_nothrow_move_constructible_v<_Tp>)
	requires (!assignable_from<_Tp&, _Tp>)
	{
	  if ((bool)__that)
	    this->emplace(std::move(*__that));
	  else
	    this->reset();
	  return *this;
	}
      };

  } // namespace __detail

  /// A view that contains exactly one element.
  template<copy_constructible _Tp> requires is_object_v<_Tp>
    class single_view : public view_interface<single_view<_Tp>>
    {
    public:
      single_view() = default;

      constexpr explicit
      single_view(const _Tp& __t)
      : _M_value(__t)
      { }

      constexpr explicit
      single_view(_Tp&& __t)
      : _M_value(std::move(__t))
      { }

      template<typename... _Args>
	requires constructible_from<_Tp, _Args...>
	constexpr
	single_view(in_place_t, _Args&&... __args)
	: _M_value{in_place, std::forward<_Args>(__args)...}
	{ }

      constexpr _Tp*
      begin() noexcept
      { return data(); }

      constexpr const _Tp*
      begin() const noexcept
      { return data(); }

      constexpr _Tp*
      end() noexcept
      { return data() + 1; }

      constexpr const _Tp*
      end() const noexcept
      { return data() + 1; }

      static constexpr size_t
      size() noexcept
      { return 1; }

      constexpr _Tp*
      data() noexcept
      { return _M_value.operator->(); }

      constexpr const _Tp*
      data() const noexcept
      { return _M_value.operator->(); }

    private:
      __detail::__box<_Tp> _M_value;
    };

  namespace __detail
  {
    template<typename _Wp>
      constexpr auto __to_signed_like(_Wp __w) noexcept
      {
	if constexpr (!integral<_Wp>)
	  return iter_difference_t<_Wp>();
	else if constexpr (sizeof(iter_difference_t<_Wp>) > sizeof(_Wp))
	  return iter_difference_t<_Wp>(__w);
	else if constexpr (sizeof(ptrdiff_t) > sizeof(_Wp))
	  return ptrdiff_t(__w);
	else if constexpr (sizeof(long long) > sizeof(_Wp))
	  return (long long)(__w);
#ifdef __SIZEOF_INT128__
	else if constexpr (__SIZEOF_INT128__ > sizeof(_Wp))
	  return __int128(__w);
#endif
	else
	  return __max_diff_type(__w);
      }

    template<typename _Wp>
      using __iota_diff_t = decltype(__to_signed_like(std::declval<_Wp>()));

    template<typename _It>
      concept __decrementable = incrementable<_It>
	&& requires(_It __i)
	{
	    { --__i } -> same_as<_It&>;
	    { __i-- } -> same_as<_It>;
	};

    template<typename _It>
      concept __advanceable = __decrementable<_It> && totally_ordered<_It>
	&& requires( _It __i, const _It __j, const __iota_diff_t<_It> __n)
	{
	  { __i += __n } -> same_as<_It&>;
	  { __i -= __n } -> same_as<_It&>;
	  _It(__j + __n);
	  _It(__n + __j);
	  _It(__j - __n);
	  { __j - __j } -> convertible_to<__iota_diff_t<_It>>;
	};

  } // namespace __detail

  template<weakly_incrementable _Winc,
	   semiregular _Bound = unreachable_sentinel_t>
    requires std::__detail::__weakly_eq_cmp_with<_Winc, _Bound>
    class iota_view : public view_interface<iota_view<_Winc, _Bound>>
    {
    private:
      struct _Iterator
      {
      private:
	static auto
	_S_iter_cat()
	{
	  using namespace __detail;
	  if constexpr (__advanceable<_Winc>)
	    return random_access_iterator_tag{};
	  else if constexpr (__decrementable<_Winc>)
	    return bidirectional_iterator_tag{};
	  else if constexpr (incrementable<_Winc>)
	    return forward_iterator_tag{};
	  else
	    return input_iterator_tag{};
	}

      public:
	using iterator_category = decltype(_S_iter_cat());
	using value_type = _Winc;
	using difference_type = __detail::__iota_diff_t<_Winc>;

	_Iterator() = default;

	constexpr explicit
	_Iterator(_Winc __value)
	: _M_value(__value) { }

	constexpr _Winc
	operator*() const noexcept(is_nothrow_copy_constructible_v<_Winc>)
	{ return _M_value; }

	constexpr _Iterator&
	operator++()
	{
	  ++_M_value;
	  return *this;
	}

	constexpr void
	operator++(int)
	{ ++*this; }

	constexpr _Iterator
	operator++(int) requires incrementable<_Winc>
	{
	  auto __tmp = *this;
	  ++*this;
	  return __tmp;
	}

	constexpr _Iterator&
	operator--() requires __detail::__decrementable<_Winc>
	{
	  --_M_value;
	  return *this;
	}

	constexpr _Iterator
	operator--(int) requires __detail::__decrementable<_Winc>
	{
	  auto __tmp = *this;
	  --*this;
	  return __tmp;
	}

	constexpr _Iterator&
	operator+=(difference_type __n) requires __detail::__advanceable<_Winc>
	{
	  using __detail::__is_integer_like;
	  using __detail::__is_signed_integer_like;
	  if constexpr (__is_integer_like<_Winc>
	      && !__is_signed_integer_like<_Winc>)
	    {
	      if (__n >= difference_type(0))
		_M_value += static_cast<_Winc>(__n);
	      else
		_M_value -= static_cast<_Winc>(-__n);
	    }
	  else
	    _M_value += __n;
	  return *this;
	}

	constexpr _Iterator&
	operator-=(difference_type __n) requires __detail::__advanceable<_Winc>
	{
	  using __detail::__is_integer_like;
	  using __detail::__is_signed_integer_like;
	  if constexpr (__is_integer_like<_Winc>
	      && !__is_signed_integer_like<_Winc>)
	    {
	      if (__n >= difference_type(0))
		_M_value -= static_cast<_Winc>(__n);
	      else
		_M_value += static_cast<_Winc>(-__n);
	    }
	  else
	    _M_value -= __n;
	  return *this;
	}

	constexpr _Winc
	operator[](difference_type __n) const
	requires __detail::__advanceable<_Winc>
	{ return _Winc(_M_value + __n); }

	friend constexpr bool
	operator==(const _Iterator& __x, const _Iterator& __y)
	requires equality_comparable<_Winc>
	{ return __x._M_value == __y._M_value; }

	friend constexpr bool
	operator<(const _Iterator& __x, const _Iterator& __y)
	requires totally_ordered<_Winc>
	{ return __x._M_value < __y._M_value; }

	friend constexpr bool
	operator>(const _Iterator& __x, const _Iterator& __y)
	  requires totally_ordered<_Winc>
	{ return __y < __x; }

	friend constexpr bool
	operator<=(const _Iterator& __x, const _Iterator& __y)
	  requires totally_ordered<_Winc>
	{ return !(__y < __x); }

	friend constexpr bool
	operator>=(const _Iterator& __x, const _Iterator& __y)
	  requires totally_ordered<_Winc>
	{ return !(__x < __y); }

#ifdef __cpp_lib_threeway_comparison
	friend constexpr compare_three_way_result_t<_Winc>
	operator<=>(const _Iterator& __x, const _Iterator& __y)
	  requires totally_ordered<_Winc> && three_way_comparable<_Winc>
	{ return __x._M_value <=> __y._M_value; }
#endif

	friend constexpr _Iterator
	operator+(_Iterator __i, difference_type __n)
	  requires __detail::__advanceable<_Winc>
	{ return __i += __n; }

	friend constexpr _Iterator
	operator+(difference_type __n, _Iterator __i)
	  requires __detail::__advanceable<_Winc>
	{ return __i += __n; }

	friend constexpr _Iterator
	operator-(_Iterator __i, difference_type __n)
	  requires __detail::__advanceable<_Winc>
	{ return __i -= __n; }

	friend constexpr difference_type
	operator-(const _Iterator& __x, const _Iterator& __y)
	  requires __detail::__advanceable<_Winc>
	{
	  using __detail::__is_integer_like;
	  using __detail::__is_signed_integer_like;
	  using _Dt = difference_type;
	  if constexpr (__is_integer_like<_Winc>)
	    {
	      if constexpr (__is_signed_integer_like<_Winc>)
		return _Dt(_Dt(__x._M_value) - _Dt(__y._M_value));
	      else
		return (__y._M_value > __x._M_value)
		  ? _Dt(-_Dt(__y._M_value - __x._M_value))
		  : _Dt(__x._M_value - __y._M_value);
	    }
	  else
	    return __x._M_value - __y._M_value;
	}

      private:
	_Winc _M_value = _Winc();
      };

      struct _Sentinel
      {
      private:
	_Bound _M_bound = _Bound();

      public:
	_Sentinel() = default;

	constexpr explicit
	_Sentinel(_Bound __bound)
	: _M_bound(__bound) { }

	friend constexpr bool
	operator==(const _Iterator& __x, const _Sentinel& __y)
	{ return __x._M_value == __y._M_bound; }

	friend constexpr iter_difference_t<_Winc>
	operator-(const _Iterator& __x, const _Sentinel& __y)
	  requires sized_sentinel_for<_Bound, _Winc>
	{ return __x._M_value - __y._M_bound; }

	friend constexpr iter_difference_t<_Winc>
	operator-(const _Sentinel& __x, const _Iterator& __y)
	  requires sized_sentinel_for<_Bound, _Winc>
	{ return -(__y - __x); }
      };

      _Winc _M_value = _Winc();
      _Bound _M_bound = _Bound();

    public:
      iota_view() = default;

      constexpr explicit
      iota_view(_Winc __value)
      : _M_value(__value)
      { }

      constexpr
      iota_view(type_identity_t<_Winc> __value,
		type_identity_t<_Bound> __bound)
      : _M_value(__value), _M_bound(__bound)
      {
	if constexpr (totally_ordered_with<_Winc, _Bound>)
	  __glibcxx_assert( bool(__value <= __bound) );
      }

      constexpr _Iterator
      begin() const { return _Iterator{_M_value}; }

      constexpr auto
      end() const
      {
	if constexpr (same_as<_Bound, unreachable_sentinel_t>)
	  return unreachable_sentinel;
	else
	  return _Sentinel{_M_bound};
      }

      constexpr _Iterator
      end() const requires same_as<_Winc, _Bound>
      { return _Iterator{_M_bound}; }

      constexpr auto
      size() const
      requires (same_as<_Winc, _Bound> && __detail::__advanceable<_Winc>)
      || (integral<_Winc> && integral<_Bound>)
      || sized_sentinel_for<_Bound, _Winc>
      {
	using __detail::__is_integer_like;
	using __detail::__to_unsigned_like;
	if constexpr (__is_integer_like<_Winc> && __is_integer_like<_Bound>)
	  return (_M_value < 0)
	    ? ((_M_bound < 0)
		? __to_unsigned_like(-_M_value) - __to_unsigned_like(-_M_bound)
		: __to_unsigned_like(_M_bound) + __to_unsigned_like(-_M_value))
	    : __to_unsigned_like(_M_bound) - __to_unsigned_like(_M_value);
	else
	  return __to_unsigned_like(_M_bound - _M_value);
      }
    };

  template<typename _Winc, typename _Bound>
    requires (!__detail::__is_integer_like<_Winc>
	|| !__detail::__is_integer_like<_Bound>
	|| (__detail::__is_signed_integer_like<_Winc>
	    == __detail::__is_signed_integer_like<_Bound>))
    iota_view(_Winc, _Bound) -> iota_view<_Winc, _Bound>;

  template<weakly_incrementable _Winc, semiregular _Bound>
    inline constexpr bool enable_safe_range<iota_view<_Winc, _Bound>> = true;

namespace views
{
  template<typename _Tp>
    inline constexpr empty_view<_Tp> empty{};

  struct _Single
  {
    template<typename _Tp>
      constexpr auto
      operator()(_Tp&& __e) const
      { return single_view{std::forward<_Tp>(__e)}; }
  };

  inline constexpr _Single single{};

  struct _Iota
  {
    template<typename _Tp>
      constexpr auto
      operator()(_Tp&& __e) const
      { return iota_view{std::forward<_Tp>(__e)}; }

    template<typename _Tp, typename _Up>
      constexpr auto
      operator()(_Tp&& __e, _Up&& __f) const
      { return iota_view{std::forward<_Tp>(__e), std::forward<_Tp>(__f)}; }
  };

  inline constexpr _Iota iota{};
} // namespace views

namespace views
{
  template<typename _Callable, bool = is_default_constructible_v<_Callable>>
    struct _RangeAdaptorClosure;

  template<typename _Callable>
    requires is_default_constructible_v<_Callable>
    struct _RangeAdaptorClosure<_Callable, true>
    {
      constexpr
      _RangeAdaptorClosure()
      { }

      constexpr
      _RangeAdaptorClosure(_Callable __object)
      { }

      template<viewable_range _Range>
	friend constexpr auto
	operator|(_Range&& __r, const _RangeAdaptorClosure& __o)
	{ return __o(std::forward<_Range>(__r)); }

      template<viewable_range _Range>
	constexpr auto
	operator()(_Range&& __r) const
	{ return _Callable{}(std::forward<_Range>(__r)); }

      template<typename _Tp, typename... _Args>
	requires (!viewable_range<_Tp>)
	constexpr auto
	operator()(_Tp&& __e, _Args&&... __args) const
	{
	  // TODO: Should we capture by reference or not here?
	  // ideally we should write "<viewable_range _Range>" but that breaks things
	  auto __closure = [=] <typename _Range> (_Range&& __r) {
	    return _Callable{}(std::forward<_Range>(__r), __e, __args...);
	  };
	  return _RangeAdaptorClosure<decltype(__closure)>(std::move(__closure));
	}
    };

  template<typename _Callable>
    requires (!is_default_constructible_v<_Callable>)
    struct _RangeAdaptorClosure<_Callable, false>
    {
      _Callable _M_storage;

      constexpr
      _RangeAdaptorClosure(_Callable __object)
	: _M_storage(std::move(__object))
      { }

      template<viewable_range _Range>
	friend constexpr auto
	operator|(_Range&& __r, const _RangeAdaptorClosure& __o)
	{ return __o(std::forward<_Range>(__r)); }

      template<viewable_range _Range>
	constexpr auto
	operator()(_Range&& __r) const
	{ return _M_storage(std::forward<_Range>(__r)); }
    };

  template<typename _Callable>
    _RangeAdaptorClosure(_Callable) -> _RangeAdaptorClosure<_Callable>;

  template<typename _Tp, typename _Up>
    constexpr auto
    operator|(_RangeAdaptorClosure<_Tp> __x, _RangeAdaptorClosure<_Up> __y)
    {
      if constexpr (is_default_constructible_v<_Tp>
		    && is_default_constructible_v<_Up>)
	{
	  auto __closure = [] <typename _Vp> (_Vp&& __e) {
	    return (std::forward<_Vp>(__e) | decltype(__x){}) | decltype(__y){};
	  };
	  return _RangeAdaptorClosure(__closure);
	}
      else if constexpr (is_default_constructible_v<_Tp>
			 && !is_default_constructible_v<_Up>)
	{
	  // TODO: Should we capture by reference or not here?
	  auto __closure = [__y] <typename _Vp> (_Vp&& __e) {
	    return (std::forward<_Vp>(__e) | decltype(__x){}) | __y;
	  };
	  return _RangeAdaptorClosure(__closure);
	}
      else if constexpr (!is_default_constructible_v<_Tp>
			 && is_default_constructible_v<_Up>)
	{
	  // TODO: Should we capture by reference or not here?
	  auto __closure = [__x] <typename _Vp> (_Vp&& __e) {
	    return (std::forward<_Vp>(__e) | __x) | decltype(__y){};
	  };
	  return _RangeAdaptorClosure(__closure);
	}
      else
	{
	  // TODO: Should we capture by reference or not here?
	  auto __closure = [__x, __y] <typename _Vp> (_Vp&& __e) {
	    return (std::forward<_Vp>(__e) | __x) | __y;
	  };
	  return _RangeAdaptorClosure(__closure);
	}
    }
} // namespace views

  template<range _Range> requires is_object_v<_Range>
    class ref_view : public view_interface<ref_view<_Range>>
    {
    private:
      _Range* _M_r = nullptr;

      static void _S_fun(_Range&);
      static void _S_fun(_Range&&) = delete;

    public:
      constexpr
      ref_view() noexcept = default;

      template<__detail::__not_same_as<ref_view> _Tp>
	requires convertible_to<_Tp, _Range&&>
	  && requires { _S_fun(declval<_Tp>()); }
	constexpr
	ref_view(_Tp&& __t)
	  : _M_r(addressof(static_cast<_Range&>(std::forward<_Tp>(__t))))
	{ }

      constexpr _Range&
      base() const
      { return *_M_r; }

      constexpr iterator_t<_Range>
      begin() const
      { return ranges::begin(*_M_r); }

      constexpr sentinel_t<_Range>
      end() const
      { return ranges::end(*_M_r); }

      constexpr bool
      empty() const requires requires { ranges::empty(*_M_r); }
      { return ranges::empty(*_M_r); }

      constexpr auto
      size() const requires sized_range<_Range>
      { return ranges::size(*_M_r); }

      constexpr auto
      data() const requires contiguous_range<_Range>
      { return ranges::data(*_M_r); }
    };

  template<typename _Range>
    ref_view(_Range&) -> ref_view<_Range>;

  template<typename _Tp>
    inline constexpr bool enable_safe_range<ref_view<_Tp>> = true;

namespace views
{
  inline constexpr _RangeAdaptorClosure all
    = [] <viewable_range _Range> (_Range&& __r)
    {
      if constexpr (view<decay_t<_Range>>)
	return __r;
      else if (requires { ref_view{std::forward<_Range>(__r)}; })
	return ref_view{std::forward<_Range>(__r)};
      else
	return subrange{std::forward<_Range>(__r)};
    };
} // namespace views

  template<viewable_range _Range>
    using all_view = decltype(views::all(declval<_Range>()));

  // TODO: COPYPASTED from ranges_algo.h
  template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
	   typename _Proj = identity,
	   indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
    constexpr _Iter
    __find_if(_Iter __first, _Sent __last, _Pred __pred, _Proj __proj = {})
    {
      while (__first != __last
	  && !(bool)std::__invoke(__pred, std::__invoke(__proj, *__first)))
	++__first;
      return __first;
    }

  template<input_range _Range, typename _Proj = identity,
	   indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
	     _Pred>
    constexpr safe_iterator_t<_Range>
    __find_if(_Range&& __r, _Pred __pred, _Proj __proj = {})
    {
      return ranges::__find_if(ranges::begin(__r), ranges::end(__r),
			     std::move(__pred), std::move(__proj));
    }

  template<input_iterator _Iter, sentinel_for<_Iter> _Sent,
	   typename _Proj = identity,
	   indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>
    constexpr _Iter
    __find_if_not(_Iter __first, _Sent __last, _Pred __pred, _Proj __proj = {})
    {
      while (__first != __last
	  && (bool)std::__invoke(__pred, std::__invoke(__proj, *__first)))
	++__first;
      return __first;
    }

  template<input_range _Range, typename _Proj = identity,
	   indirect_unary_predicate<projected<iterator_t<_Range>, _Proj>>
	     _Pred>
    constexpr safe_iterator_t<_Range>
    __find_if_not(_Range&& __r, _Pred __pred, _Proj __proj = {})
    {
      return ranges::__find_if_not(ranges::begin(__r), ranges::end(__r),
				 std::move(__pred), std::move(__proj));
    }

  template<typename _Tp, typename _Proj = identity,
	   indirect_strict_weak_order<projected<const _Tp*, _Proj>>
	     _Comp = ranges::less>
    constexpr const _Tp&
    __min(const _Tp& __a, const _Tp& __b, _Comp __comp = {}, _Proj __proj = {})
    {
      if (std::__invoke(std::move(__comp),
			std::__invoke(__proj, __b),
			std::__invoke(__proj, __a)))
	return __b;
      else
	return __a;
    }

  template<input_range _Vp,
	   indirect_unary_predicate<iterator_t<_Vp>> _Pred>
    requires view<_Vp> && is_object_v<_Pred>
    class filter_view : public view_interface<filter_view<_Vp, _Pred>>
    {
    private:
      _Vp _M_base = _Vp();
      __detail::__box<_Pred> _M_pred;

      struct _Sentinel;

      struct _Iterator
      {
      private:
	iterator_t<_Vp> _M_current = iterator_t<_Vp>();
	filter_view* _M_parent = nullptr;

	static auto
	_S_iter_concept()
	{
	  if constexpr (bidirectional_range<_Vp>)
	    return bidirectional_iterator_tag{};
	  else if constexpr (forward_range<_Vp>)
	    return forward_iterator_tag{};
	  else
	    return input_iterator_tag{};
	}

	static auto
	_S_iter_cat()
	{
	  using _Cat = iterator_traits<iterator_t<_Vp>>::iterator_category;
	  if constexpr (derived_from<bidirectional_iterator_tag, _Cat>)
	    return bidirectional_iterator_tag{};
	  else if constexpr (derived_from<forward_iterator_tag, _Cat>)
	    return forward_iterator_tag{};
	  else
	    return input_iterator_tag{};
	}

      public:
	using iterator_concept  = decltype(_S_iter_concept());
	using iterator_category = decltype(_S_iter_cat());
	using value_type        = range_value_t<_Vp>;
	using difference_type   = range_difference_t<_Vp>;

	_Iterator() = default;

	constexpr
	_Iterator(filter_view& __parent, iterator_t<_Vp> __current)
	  : _M_current(std::move(__current)),
	    _M_parent(addressof(__parent))
	{ }

	constexpr iterator_t<_Vp>
	base() const &
	  requires copyable<iterator_t<_Vp>>
	{ return _M_current; }

	constexpr iterator_t<_Vp>
	base() &&
	{ return std::move(_M_current); }

	constexpr range_reference_t<_Vp>
	operator*() const
	{ return *_M_current; }

	constexpr iterator_t<_Vp>
	operator->() const
	  requires __detail::__has_arrow<iterator_t<_Vp>>
	    && copyable<iterator_t<_Vp>>
	{ return _M_current; }

	constexpr _Iterator&
	operator++()
	{
	  _M_current = ranges::__find_if(std::move(++_M_current),
					 ranges::end(_M_parent->_M_base),
					 std::ref(*_M_parent->_M_pred));
	  return *this;
	}

	constexpr void
	operator++(int)
	{ ++*this; }

	constexpr _Iterator
	operator++(int) requires forward_range<_Vp>
	{
	  auto __tmp = *this;
	  ++*this;
	  return __tmp;
	}

	constexpr _Iterator&
	operator--() requires bidirectional_range<_Vp>
	{
	  do
	    --_M_current;
	  while (!invoke(*_M_parent->_M_pred, *_M_current));
	  return *this;
	}

	constexpr _Iterator
	operator--(int) requires bidirectional_range<_Vp>
	{
	  auto __tmp = *this;
	  --*this;
	  return __tmp;
	}

	friend constexpr bool
	operator==(const _Iterator& __x, const _Iterator& __y)
	  requires equality_comparable<iterator_t<_Vp>>
	{ return __x._M_current == __y._M_current; }

	friend constexpr range_rvalue_reference_t<_Vp>
	iter_move(const _Iterator& __i)
	  noexcept(noexcept(ranges::iter_move(__i._M_current)))
	{ return ranges::iter_move(__i._M_current); }

	friend constexpr void
	iter_swap(const _Iterator& __x, const _Iterator& __y)
	  noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))
	  requires indirectly_swappable<iterator_t<_Vp>>
	{ ranges::iter_swap(__x._M_current, __y._M_current); }

	// TODO: this does not appear in the spec
	friend constexpr bool
	operator==(const _Iterator& __x, const _Sentinel& __y);
      };

      struct _Sentinel
      {
      private:
	sentinel_t<_Vp> _M_end = sentinel_t<_Vp>();

      public:
	_Sentinel() = default;

	constexpr explicit
	_Sentinel(filter_view& __parent)
	  : _M_end(ranges::end(__parent._M_base))
	{ }

	constexpr sentinel_t<_Vp>
	base() const
	{ return _M_end; }

	friend constexpr bool
	operator==(const _Iterator& __x, const _Sentinel& __y)
	{ return __x._M_current == __y._M_end; }
      };

    public:
      filter_view() = default;

      constexpr
      filter_view(_Vp __base, _Pred __pred)
	: _M_base(std::move(__base)), _M_pred(std::move(__pred))
      { }

      template<input_range _Range>
	requires viewable_range<_Range>
	  && constructible_from<_Vp, all_view<_Range>>
	constexpr
	filter_view(_Range&& __r, _Pred __pred)
	  : _M_base(views::all(std::forward<_Range>(__r))),
	    _M_pred(std::move(__pred))
	{ }

      constexpr _Vp
      base() const& requires copy_constructible<_Vp>
      { return _M_base; }

      constexpr _Vp
      base() &&
      { return std::move(_M_base); }

      constexpr _Iterator
      begin()
      {
	__glibcxx_assert(_M_pred.has_value());
	// TODO: cache?
	return {*this, ranges::__find_if(_M_base, std::ref(*_M_pred))};
      }

      constexpr auto
      end()
      {
	if constexpr (common_range<_Vp>)
	  return _Iterator{*this, ranges::end(_M_base)};
	else
	  return _Sentinel{*this};
      }
    };

  template<typename _Range, typename _Pred>
    filter_view(_Range&&, _Pred) -> filter_view<all_view<_Range>, _Pred>;

namespace views
{
  inline constexpr _RangeAdaptorClosure filter
    = [] <viewable_range _Range, typename _Pred> (_Range&& __r, _Pred&& __p)
    {
	return filter_view{std::forward<_Range>(__r), std::forward<_Pred>(__p)};
    };
} // namespace views

  template<input_range _Vp, copy_constructible _F>
    requires view<_Vp> && is_object_v<_F>
      && regular_invocable<_F&, range_reference_t<_Vp>>
    class transform_view : public view_interface<transform_view<_Vp, _F>>
    {
    private:
      _Vp _M_base = _Vp();
      __detail::__box<_F> _M_fun;

      template<bool _Const>
	struct _Sentinel;

      template<bool _Const>
	struct _Iterator
	{
	private:
	  using _Parent
	    = conditional_t<_Const, const transform_view, transform_view>;
	  using _Base = conditional_t<_Const, const _Vp, _Vp>;

	  iterator_t<_Base> _M_current = iterator_t<_Base>();
	  _Parent* _M_parent = nullptr;

	  static auto
	  _S_iter_concept()
	  {
	    if constexpr (random_access_range<_Vp>)
	      return random_access_iterator_tag{};
	    else if constexpr (bidirectional_range<_Vp>)
	      return bidirectional_iterator_tag{};
	    else if constexpr (forward_range<_Vp>)
	      return forward_iterator_tag{};
	    else
	      return input_iterator_tag{};
	  }

	  static auto
	  _S_iter_cat()
	  {
	    using _Cat = iterator_traits<iterator_t<_Vp>>::iterator_category;
	    if constexpr (derived_from<contiguous_iterator_tag, _Cat>)
	      return random_access_iterator_tag{};
	    else
	      return _Cat{};
	  }

	public:
	  using iterator_concept = decltype(_S_iter_concept());
	  using iterator_category = decltype(_S_iter_cat());
	  using value_type
	    = remove_cvref_t<invoke_result_t<_F&, range_reference_t<_Base>>>;
	  using difference_type = range_difference_t<_Base>;

	  _Iterator() = default;

	  constexpr
	  _Iterator(_Parent& __parent, iterator_t<_Base> current)
	    : _M_current(std::move(current)), _M_parent(addressof(__parent))
	  { }

	  constexpr
	  _Iterator(_Iterator<!_Const> __i)
	    requires _Const
	      && convertible_to<iterator_t<_Vp>, iterator_t<_Base>>
	    : _M_current(std::move(__i._M_current)), _M_parent(__i._M_parent)
	  { }

	  constexpr iterator_t<_Base>
	  base() const &
	    requires copyable<iterator_t<_Base>>
	  { return _M_current; }

	  constexpr iterator_t<_Base>
	  base() &&
	  { return std::move(_M_current); }

	  constexpr decltype(auto)
	  operator*() const
	  { return invoke(*_M_parent->_M_fun, *_M_current); }

	  constexpr _Iterator&
	  operator++()
	  {
	    ++_M_current;
	    return *this;
	  }

	  constexpr void
	  operator++(int)
	  { ++_M_current; }

	  constexpr _Iterator
	  operator++(int) requires forward_range<_Base>
	  {
	    auto __tmp = *this;
	    ++*this;
	    return __tmp;
	  }

	  constexpr _Iterator&
	  operator--() requires bidirectional_range<_Base>
	  {
	    --_M_current;
	    return *this;
	  }

	  constexpr _Iterator
	  operator--(int) requires bidirectional_range<_Base>
	  {
	    auto __tmp = *this;
	    --*this;
	    return __tmp;
	  }

	  constexpr _Iterator&
	  operator+=(difference_type __n) requires random_access_range<_Base>
	  {
	    _M_current += __n;
	    return *this;
	  }

	  constexpr _Iterator&
	  operator-=(difference_type __n) requires random_access_range<_Base>
	  {
	    _M_current -= __n;
	    return *this;
	  }

	  constexpr decltype(auto)
	  operator[](difference_type __n) const
	    requires random_access_range<_Base>
	  { return invoke(*_M_parent->_M_fun, _M_current[__n]); }

	  friend constexpr bool
	  operator==(const _Iterator& __x, const _Iterator& __y)
	    requires equality_comparable<iterator_t<_Base>>
	  { return __x._M_current == __y._M_current; }

	  friend constexpr bool
	  operator<(const _Iterator& __x, const _Iterator& __y)
	    requires random_access_range<_Base>
	  { return __x._M_current < __y._M_current; }

	  friend constexpr bool
	  operator>(const _Iterator& __x, const _Iterator& __y)
	    requires random_access_range<_Base>
	  { return __y < __x; }

	  friend constexpr bool
	  operator<=(const _Iterator& __x, const _Iterator& __y)
	    requires random_access_range<_Base>
	  { return !(__y < __x); }

	  friend constexpr bool
	  operator>=(const _Iterator& __x, const _Iterator& __y)
	    requires random_access_range<_Base>
	  { return !(__x < __y); }

#ifdef __cpp_lib_threeway_comparison
	  friend constexpr compare_three_way_result_t<iterator_t<_Base>>
	  operator<=>(const _Iterator& __x, const _Iterator& __y)
	    requires random_access_range<_Base>
	      && three_way_comparable<iterator_t<_Base>>
	  { return __x._M_current <=> __y._M_current; }
#endif

	  friend constexpr _Iterator
	  operator+(_Iterator __i, difference_type n)
	    requires random_access_range<_Base>
	  { return {*__i._M_parent, __i._M_current + n}; }

	  friend constexpr _Iterator
	  operator+(difference_type n, _Iterator __i)
	    requires random_access_range<_Base>
	  { return {*__i._M_parent, __i._M_current + n}; }

	  friend constexpr _Iterator
	  operator-(_Iterator __i, difference_type n)
	    requires random_access_range<_Base>
	  { return {*__i._M_parent, __i._M_current - n}; }

	  friend constexpr difference_type
	  operator-(const _Iterator& __x, const _Iterator& __y)
	    requires random_access_range<_Base>
	  { return __x._M_current - __y._M_current; }

	  /* TODO: doesn't compile
	  friend constexpr decltype(auto)
	  iter_move(const _Iterator& __i)
	    noexcept(noexcept(invoke(*__i._M_parent->_M_fun, *__i._M_current)))
	  {
	    if constexpr (is_lvalue_reference_v<decltype(*__i)>)
	      return std::move(*__i);
	    else
	      return *__i;
	  }
	  */

	  friend constexpr void
	  iter_swap(const _Iterator& __x, const _Iterator& __y)
	    noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))
	    requires indirectly_swappable<iterator_t<_Base>>
	  { return ranges::iter_swap(__x._M_current, __y._M_current); }

	  // TODO: this friend does not appear in spec
	  friend constexpr bool
	  operator==(const _Iterator& __x, const _Sentinel<_Const>& __y);
	};

      template<bool _Const>
	struct _Sentinel
	{
	  private:
	    using _Parent
	      = conditional_t<_Const, const transform_view, transform_view>;
	    using _Base = conditional_t<_Const, const _Vp, _Vp>;

	    sentinel_t<_Base> _M_end = sentinel_t<_Base>();

	  public:
	    _Sentinel() = default;

	    constexpr explicit
	    _Sentinel(sentinel_t<_Base> __end)
	      : _M_end(__end)
	    { }

	    constexpr
	    _Sentinel(_Sentinel<!_Const> __i)
	      requires _Const
		&& convertible_to<sentinel_t<_Vp>, sentinel_t<_Base>>
	      : _M_end(std::move(__i._M_end))
	    { }

	    constexpr sentinel_t<_Base>
	    base() const
	    { return _M_end; }

	    friend constexpr bool
	    operator==(const _Iterator<_Const>& __x, const _Sentinel& __y)
	    { return __x._M_current == __y._M_end; }

	    friend constexpr range_difference_t<_Base>
	    operator-(const _Iterator<_Const>& __x, const _Sentinel& __y)
	      requires sized_sentinel_for<sentinel_t<_Base>, iterator_t<_Base>>
	    { return __x._M_current - __y._M_end; }

	    friend constexpr range_difference_t<_Base>
	    operator-(const _Sentinel& __y, const _Iterator<_Const>& __x)
	      requires sized_sentinel_for<sentinel_t<_Base>, iterator_t<_Base>>
	    { return __y._M_end - __x._M_current; }
	  };

    public:
      transform_view() = default;

      constexpr
      transform_view(_Vp __base, _F __fun)
	: _M_base(std::move(__base)), _M_fun(std::move(__fun))
      { }

      template<input_range _Range>
	requires viewable_range<_Range>
	  && constructible_from<_Vp, all_view<_Range>>
	constexpr
	transform_view(_Range&& __r, _F __fun)
	  : _M_base(views::all(std::forward<_Range>(__r)))
	{
	}

      constexpr _Vp
      base() const& requires copy_constructible<_Vp>
      { return _M_base ; }

      constexpr _Vp
      base() &&
      { return std::move(_M_base); }

      constexpr _Iterator<false>
      begin()
      { return _Iterator<false>{*this, ranges::begin(_M_base)}; }

      constexpr _Iterator<true>
      begin() const
	requires range<const _Vp>
	  && regular_invocable<const _F&, range_reference_t<const _Vp>>
      { return _Iterator<true>{*this, ranges::begin(_M_base)}; }

      constexpr _Sentinel<false>
      end()
      { return _Sentinel<false>{ranges::end(_M_base)}; }

      constexpr _Iterator<false>
      end() requires common_range<_Vp>
      { return _Iterator<false>{*this, ranges::end(_M_base)}; }

      constexpr _Sentinel<true>
      end() const
	requires range<const _Vp>
	  && regular_invocable<const _F&, range_reference_t<const _Vp>>
      { return _Sentinel<true>{ranges::end(_M_base)}; }

      constexpr _Iterator<true>
      end() const
	requires common_range<const _Vp>
	  && regular_invocable<const _F&, range_reference_t<const _Vp>>
      { return _Iterator<true>{*this, ranges::end(_M_base)}; }

      constexpr auto
      size() requires sized_range<_Vp>
      { return ranges::size(_M_base); }

      constexpr auto
      size() const requires sized_range<const _Vp>
      { return ranges::size(_M_base); }
    };

  template<typename _Range, typename _F>
    transform_view(_Range&&, _F) -> transform_view<all_view<_Range>, _F>;

namespace views
{
  inline constexpr _RangeAdaptorClosure transform
    = [] <viewable_range _Range, typename _F> (_Range&& __r, _F&& __f)
    {
      return transform_view{std::forward<_Range>(__r), std::forward<_F>(__f)};
    };
} // namespace views

  template<view _Vp>
    class take_view : public view_interface<take_view<_Vp>>
    {
    private:
      _Vp _M_base = _Vp();
      range_difference_t<_Vp> _M_count = 0;

      template<bool Const>
	struct _Sentinel
	{
	private:
	  using _Base = conditional_t<Const, const _Vp, _Vp>;
	  using _CI = counted_iterator<iterator_t<_Base>>;
	  sentinel_t<_Base> _M_end = sentinel_t<_Base>();

	public:
	  _Sentinel() = default;

	  constexpr explicit
	  _Sentinel(sentinel_t<_Base> end)
	    : _M_end(end)
	  { }

	  constexpr
	  _Sentinel(_Sentinel<!Const> s)
	    requires Const && convertible_to<sentinel_t<_Vp>, sentinel_t<_Base>>
	    : _M_end(std::move(s._M_end))
	  { }

	  constexpr sentinel_t<_Base>
	  base() const
	  { return _M_end; }

	  friend constexpr bool operator==(const _CI& __y, const _Sentinel& __x)
	  { return __y.count() == 0 || __y.base() == __x._M_end; }
	};

    public:
      take_view() = default;

      constexpr
      take_view(_Vp base, range_difference_t<_Vp> __count)
	: _M_base(std::move(base)), _M_count(std::move(__count))
      { }

      template<viewable_range _Range>
	requires constructible_from<_Vp, all_view<_Range>>
      constexpr
      take_view(_Range&& __r, range_difference_t<_Vp> __count)
	: _M_base(views::all(std::forward<_Range>(__r))), _M_count(__count)
      { }

      constexpr _Vp
      base() const& requires copy_constructible<_Vp>
      { return _M_base; }

      constexpr _Vp
      base() &&
      { return std::move(_M_base); }

      constexpr auto
      begin() requires (!__detail::__simple_view<_Vp>)
      {
	if constexpr (sized_range<_Vp>) {
	  if constexpr (random_access_range<_Vp>)
	    return ranges::begin(_M_base);
	  else
	    return counted_iterator{ranges::begin(_M_base), size()};
	} else
	  return counted_iterator{ranges::begin(_M_base), _M_count};
      }

      constexpr auto
      begin() const requires range<const _Vp>
      {
	if constexpr (sized_range<const _Vp>) {
	  if constexpr (random_access_range<const _Vp>)
	    return ranges::begin(_M_base);
	  else
	    return counted_iterator{ranges::begin(_M_base), size()};
	} else
	  return counted_iterator{ranges::begin(_M_base), _M_count};
      }

      constexpr auto
      end() requires (!__detail::__simple_view<_Vp>)
      {
	if constexpr (sized_range<_Vp>) {
	  if constexpr (random_access_range<_Vp>)
	    return ranges::begin(_M_base) + size();
	  else
	    return default_sentinel;
	} else
	  return _Sentinel<false>{ranges::end(_M_base)};
      }

      constexpr auto
      end() const requires range<const _Vp>
      {
	if constexpr (sized_range<const _Vp>) {
	  if constexpr (random_access_range<const _Vp>)
	    return ranges::begin(_M_base) + size();
	  else
	    return default_sentinel;
	} else
	  return _Sentinel<true>{ranges::end(_M_base)};
      }

      constexpr auto
      size() requires sized_range<_Vp>
      {
	auto n = ranges::size(_M_base);
	return ranges::__min(n, static_cast<decltype(n)>(_M_count));
      }

      constexpr auto
      size() const requires sized_range<const _Vp>
      {
	auto n = ranges::size(_M_base);
	return ranges::__min(n, static_cast<decltype(n)>(_M_count));
      }
    };

  template<range _Range>
    take_view(_Range&&, range_difference_t<_Range>)
      -> take_view<all_view<_Range>>;

namespace views
{
  inline constexpr _RangeAdaptorClosure take
    = [] <viewable_range _Range, typename _Tp> (_Range&& __r, _Tp&& __n)
    {
      return take_view{std::forward<_Range>(__r), std::forward<_Tp>(__n)};
    };
} // namespace views

  template<view _Vp, typename _Pred>
    requires input_range<_Vp> && is_object_v<_Pred>
      && indirect_unary_predicate<const _Pred, iterator_t<_Vp>>
    class take_while_view : public view_interface<take_while_view<_Vp, _Pred>>
    {
      template<bool Const>
	struct _Sentinel
	{
	private:
	  using _Base = conditional_t<Const, const _Vp, _Vp>;

	  sentinel_t<_Base> _M_end = sentinel_t<_Base>();
	  const _Pred* _M_pred = nullptr;

	public:
	  _Sentinel() = default;

	  constexpr explicit
	  _Sentinel(sentinel_t<_Base> __end, const _Pred* __pred)
	    : _M_end(__end), _M_pred(__pred)
	  { }

	  constexpr
	  _Sentinel(_Sentinel<!Const> __s)
	    requires Const && convertible_to<sentinel_t<_Vp>, sentinel_t<_Base>>
	    : _M_end(__s._M_end), _M_pred(__s._M_pred)
	  { }

	  constexpr sentinel_t<_Base>
	  base() const { return _M_end; }

	  friend constexpr bool
	  operator==(const iterator_t<_Base>& __x, const _Sentinel& __y)
	  { return __y._M_end == __x || !invoke(*__y._M_pred, *__x); }
	};

      _Vp _M_base;
      __detail::__box<_Pred> _M_pred;

    public:
      take_while_view() = default;

      constexpr
      take_while_view(_Vp base, _Pred __pred)
	: _M_base(std::move(base)), _M_pred(std::move(__pred))
      {
      }

      constexpr _Vp
      base() const& requires copy_constructible<_Vp>
      { return _M_base; }

      constexpr _Vp
      base() &&
      { return std::move(_M_base); }

      constexpr const _Pred&
      pred() const
      { return *_M_pred; }

      constexpr auto
      begin() requires (!__detail::__simple_view<_Vp>)
      { return ranges::begin(_M_base); }

      constexpr auto
      begin() const requires range<const _Vp>
      { return ranges::begin(_M_base); }

      constexpr auto
      end() requires (!__detail::__simple_view<_Vp>)
      { return _Sentinel<false>(ranges::end(_M_base),
				addressof(*_M_pred)); }

      constexpr auto
      end() const requires range<const _Vp>
      { return _Sentinel<true>(ranges::end(_M_base),
			       addressof(*_M_pred)); }
    };

  template<class _Range, typename _Pred>
    take_while_view(_Range&&, _Pred)
      -> take_while_view<all_view<_Range>, _Pred>;

namespace views
{
  inline constexpr _RangeAdaptorClosure take_while
    = [] <viewable_range _Range, typename _Pred> (_Range&& __r, _Pred&& __f)
    {
      return take_while_view{std::forward<_Range>(__r), std::forward<_Pred>(__f)};
    };
} // namespace views

  template<view _Vp>
    class drop_view : public view_interface<drop_view<_Vp>>
    {
    public:
      drop_view() = default;

      constexpr
      drop_view(_Vp __base, range_difference_t<_Vp> __count)
	: _M_base(std::move(__base)), _M_count(__count)
      { __glibcxx_assert(__count >= 0); }

      constexpr _Vp
      base() const& requires copy_constructible<_Vp>
      { return _M_base; }

      constexpr _Vp
      base() &&
      { return std::move(_M_base); }

      constexpr auto
      begin() requires (!(__detail::__simple_view<_Vp>
			  && random_access_range<_Vp>))
      {
	// TODO: cache?
	return ranges::next(ranges::begin(_M_base), _M_count,
			    ranges::end(_M_base));
      }

      constexpr auto
      begin() const requires random_access_range<const _Vp>
      {
	return ranges::next(ranges::begin(_M_base), _M_count,
			    ranges::end(_M_base));
      }

      constexpr auto
      end() requires (!__detail::__simple_view<_Vp>)
      { return ranges::end(_M_base); }

      constexpr auto
      end() const requires range<const _Vp>
      { return ranges::end(_M_base); }

      constexpr auto
      size() requires sized_range<_Vp>
      {
	const auto s = ranges::size(_M_base);
	const auto c = static_cast<decltype(s)>(_M_count);
	return s < c ? 0 : s - c;
      }

      constexpr auto
      size() const requires sized_range<const _Vp>
      {
	const auto s = ranges::size(_M_base);
	const auto c = static_cast<decltype(s)>(_M_count);
	return s < c ? 0 : s - c;
      }

    private:
      _Vp _M_base;
      range_difference_t<_Vp> _M_count;
    };

  template<class _Range>
    drop_view(_Range&&, range_difference_t<_Range>)
      -> drop_view<all_view<_Range>>;

namespace views
{
  inline constexpr _RangeAdaptorClosure drop
    = [] <viewable_range _Range, typename _Tp> (_Range&& __r, _Tp&& __n)
    {
      return drop_view{std::forward<_Range>(__r), std::forward<_Tp>(__n)};
    };
} // namespace views

  template<view _Vp, typename _Pred>
    requires input_range<_Vp> && is_object_v<_Pred>
      && indirect_unary_predicate<const _Pred, iterator_t<_Vp>>
    class drop_while_view : public view_interface<drop_while_view<_Vp, _Pred>>
    {
    public:
      drop_while_view() = default;

      constexpr
      drop_while_view(_Vp __base, _Pred __pred)
	: _M_base(std::move(__base)), _M_pred(std::move(__pred))
      { }

      constexpr _Vp
      base() const& requires copy_constructible<_Vp>
      { return _M_base; }

      constexpr _Vp
      base() &&
      { return std::move(_M_base); }

      constexpr const _Pred&
      pred() const
      { return *_M_pred; }

      constexpr auto
      begin()
      {
	// TODO: cache?
	return ranges::__find_if_not(_M_base, cref(*_M_pred));
      }

      constexpr auto
      end()
      { return ranges::end(_M_base); }

    private:
      _Vp _M_base;
      __detail::__box<_Pred> _M_pred;
    };

  template<class _Range, typename _Pred>
    drop_while_view(_Range&&, _Pred)
      -> drop_while_view<all_view<_Range>, _Pred>;

namespace views
{
  inline constexpr _RangeAdaptorClosure drop_while
    = [] <viewable_range _Range, typename _Pred> (_Range&& __r, _Pred&& __f)
    {
      return drop_while_view{std::forward<_Range>(__r), std::forward<_Pred>(__f)};
    };
} // namespace views

  template<input_range _Vp>
    requires view<_Vp> && input_range<range_reference_t<_Vp>>
      && (is_reference_v<range_reference_t<_Vp>>
	  || view<range_value_t<_Vp>>)
    class join_view : public view_interface<join_view<_Vp>>
    {
    private:
      using _InnerRng = range_reference_t<_Vp>;

      template<bool Const>
	struct _Iterator
	{
	private:
	  using _Parent = conditional_t<Const, const join_view, join_view>;
	  using _Base = conditional_t<Const, const _Vp, _Vp>;

	  static constexpr bool _S_ref_is_glvalue
	    = is_reference_v<range_reference_t<_Base>>;

	  iterator_t<_Base> _M_outer = iterator_t<_Base>();
	  iterator_t<range_reference_t<_Base>> _M_inner
	    = iterator_t<range_reference_t<_Base>>();
	  _Parent* _M_parent = nullptr;

	  constexpr void
	  __satisfy()
	  {
	    auto update_inner = [this] (range_reference_t<_Base> x) -> auto& {
	      if constexpr (_S_ref_is_glvalue)
		return x;
	      else
		return (_M_parent->_M_inner = views::all(std::move(x)));
	    };

	    for (; _M_outer != ranges::end(_M_parent->_M_base); ++_M_outer)
	      {
		auto& inner = update_inner(*_M_outer);
		_M_inner = ranges::begin(inner);
		if (_M_inner != ranges::end(inner))
		  return;
	      }
	    if constexpr (_S_ref_is_glvalue)
	      _M_inner = iterator_t<range_reference_t<_Base>>();
	  }

	  static auto
	  _S_iter_concept()
	  {
	    if constexpr (_S_ref_is_glvalue
			  && bidirectional_range<_Base>
			  && bidirectional_range<range_reference_t<_Base>>)
	      return bidirectional_iterator_tag{};
	    else if constexpr (_S_ref_is_glvalue
			       && forward_range<_Base>
			       && forward_range<range_reference_t<_Base>>)
	      return forward_iterator_tag{};
	    else
	      return input_iterator_tag{};
	  }

	  static auto
	  _S_iter_cat()
	  {
	    using _OuterCat
	      = iterator_traits<iterator_t<_Base>>::iterator_category;
	    using _InnerCat
	      = iterator_traits<iterator_t<range_reference_t<_Base>>>
		::iterator_category;
	    if constexpr (_S_ref_is_glvalue
			  && derived_from<bidirectional_iterator_tag, _OuterCat>
			  && derived_from<bidirectional_iterator_tag, _InnerCat>)
	      return bidirectional_iterator_tag{};
	    else if constexpr (_S_ref_is_glvalue
			       && derived_from<forward_iterator_tag, _OuterCat>
			       && derived_from<forward_iterator_tag, _InnerCat>)
	      return forward_iterator_tag{};
	    else if constexpr (derived_from<input_iterator_tag, _OuterCat>
			       && derived_from<input_iterator_tag, _InnerCat>)
	      return input_iterator_tag{};
	    else
	      return output_iterator_tag{};
	  }

	public:
	  using iterator_concept = decltype(_S_iter_concept());
	  using iterator_category = decltype(_S_iter_cat());
	  using value_type = range_value_t<range_reference_t<_Base>>;
	  using difference_type
	    = common_type_t<range_difference_t<_Base>,
			    range_difference_t<range_reference_t<_Base>>>;

	  _Iterator() = default;

	  constexpr _Iterator(_Parent& __parent, iterator_t<_Vp> __outer)
	    : _M_outer(std::move(__outer)), _M_parent(addressof(__parent))
	  { __satisfy(); }

	  constexpr _Iterator(_Iterator<!Const> __i)
	    requires Const
	      && convertible_to<iterator_t<_Vp>, iterator_t<_Base>>
	      && convertible_to<iterator_t<_InnerRng>,
				iterator_t<range_reference_t<_Base>>>
	    : _M_outer(std::move(__i._M_outer)), _M_inner(__i._M_inner),
	      _M_parent(__i._M_parent)
	  { }

	  constexpr decltype(auto)
	  operator*() const
	  { return *_M_inner; }

	  constexpr iterator_t<_Base>
	  operator->() const
	    requires __detail::__has_arrow<iterator_t<_Base>>
	      && copyable<iterator_t<_Base>>
	  { return _M_inner; }

	  constexpr _Iterator&
	  operator++()
	  {
	    // TODO: code duplication?
	    if constexpr (_S_ref_is_glvalue)
	      {
		auto&& __inner_rng = *_M_outer;
		if (++_M_inner == ranges::end(__inner_rng))
		  {
		    ++_M_outer;
		    __satisfy();
		  }
		return *this;
	      }
	    else
	      {
		auto&& __inner_rng = _M_parent->_M_inner;
		if (++_M_inner == ranges::end(__inner_rng))
		  {
		    ++_M_outer;
		    __satisfy();
		  }
		return *this;
	      }
	  }

	  constexpr void
	  operator++(int)
	  { ++*this; }

	  constexpr _Iterator
	  operator++(int)
	    requires _S_ref_is_glvalue && forward_range<_Base>
	      && forward_range<range_reference_t<_Base>>
	  {
	    auto __tmp = *this;
	    ++*this;
	    return __tmp;
	  }

	  constexpr _Iterator&
	  operator--()
	    requires _S_ref_is_glvalue && bidirectional_range<_Base>
	      && bidirectional_range<range_reference_t<_Base>>
	  {
	    if (_M_outer == ranges::end(_M_parent->_M_base))
	      _M_inner = ranges::end(*--_M_outer);
	    while (_M_inner == ranges::begin(*_M_outer))
	      _M_inner = ranges::end(*--_M_outer);
	    --_M_inner;
	    return *this;
	  }

	  constexpr _Iterator
	  operator--(int)
	    requires _S_ref_is_glvalue && bidirectional_range<_Base>
	      && bidirectional_range<range_reference_t<_Base>>
	  {
	    auto __tmp = *this;
	    --*this;
	    return __tmp;
	  }

	  friend constexpr bool
	  operator==(const _Iterator& __x, const _Iterator& __y)
	    requires _S_ref_is_glvalue
	      && equality_comparable<iterator_t<_Base>>
	      && equality_comparable<iterator_t<range_reference_t<_Base>>>
	  {
	    return (__x._M_outer == __y._M_outer
		    && __x._M_inner == __y._M_inner);
	  }

	  friend constexpr decltype(auto)
	  iter_move(const _Iterator& __i)
	  noexcept(noexcept(ranges::iter_move(__i._M_inner)))
	  { return ranges::iter_move(__i._M_inner); }

	  friend constexpr void
	  iter_swap(const _Iterator& __x, const _Iterator& __y)
	    noexcept(noexcept(ranges::iter_swap(__x._M_inner, __y._M_inner)))
	  { return ranges::iter_swap(__x._M_inner, __y._M_inner); }
	};

      template<bool Const>
	struct _Sentinel
	{
	private:
	  using _Parent = conditional_t<Const, const join_view, join_view>;
	  using _Base = conditional_t<Const, const _Vp, _Vp>;

	  sentinel_t<_Base> _M_end = sentinel_t<_Base>();

	public:
	  _Sentinel() = default;

	  constexpr explicit
	  _Sentinel(_Parent& __parent)
	    : _M_end(ranges::end(__parent._M_base))
	  { }

	  constexpr
	  _Sentinel(_Sentinel<!Const> s)
	    requires Const && convertible_to<sentinel_t<_Vp>, sentinel_t<_Base>>
	    : _M_end(std::move(s._M_end))
	  { }

	  friend constexpr bool
	  operator==(const _Iterator<Const>& __x, const _Sentinel& __y)
	  { return __x._M_outer == __y._M_end; }
	};

      _Vp _M_base = _Vp();
      // TODO: conditional field
      conditional_t<!is_reference_v<_InnerRng>, all_view<_InnerRng>, char>
	_M_inner{};

    public:
      join_view() = default;

      constexpr explicit
      join_view(_Vp __base)
	: _M_base(std::move(__base))
      { }

      template<input_range _Range>
	requires viewable_range<_Range>
	  && constructible_from<_Vp, all_view<_Range>>
      constexpr explicit
      join_view(_Range&& __r)
	: _M_base(views::all(std::forward<_Range>(__r)))
      { }

      constexpr _Vp
      base() const& requires copy_constructible<_Vp>
      { return _M_base; }

      constexpr _Vp
      base() &&
      { return std::move(_M_base); }

      constexpr auto
      begin()
      {
	return _Iterator<__detail::__simple_view<_Vp>>{*this,
						       ranges::begin(_M_base)};
      }

      constexpr auto
      begin() const
	requires input_range<const _Vp>
	  && is_reference_v<range_reference_t<const _Vp>>
      {
	return _Iterator<true>{*this, ranges::begin(_M_base)};
      }

      constexpr auto
      end()
      {
	if constexpr (forward_range<_Vp> && is_reference_v<_InnerRng>
		      && forward_range<_InnerRng>
		      && common_range<_Vp> && common_range<_InnerRng>)
	  return _Iterator<__detail::__simple_view<_Vp>>{*this,
							 ranges::end(_M_base)};
	else
	  return _Sentinel<__detail::__simple_view<_Vp>>{*this};
      }

      constexpr auto
      end() const
	requires input_range<const _Vp>
	  && is_reference_v<range_reference_t<const _Vp>>
      {
	if constexpr (forward_range<const _Vp>
		      && is_reference_v<range_reference_t<const _Vp>>
		      && forward_range<range_reference_t<const _Vp>>
		      && common_range<const _Vp>
		      && common_range<range_reference_t<const _Vp>>)
	  return _Iterator<true>{*this, ranges::end(_M_base)};
	else
	  return _Sentinel<true>{*this};
      }
    };

  template<class _Range>
    explicit join_view(_Range&&) -> join_view<all_view<_Range>>;

namespace views
{
  inline constexpr _RangeAdaptorClosure join
    = [] <viewable_range _Range> (_Range&& __r)
    {
      return join_view{std::forward<_Range>(__r)};
    };
} // namespace views

} // namespace ranges
_GLIBCXX_END_NAMESPACE_VERSION
} // namespace
#endif // library concepts
#endif // C++2a
#endif /* _GLIBCXX_RANGES */
