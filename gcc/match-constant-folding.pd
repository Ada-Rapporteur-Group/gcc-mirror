/* match-and-simplify patterns for simple constant foldings to substitute gimple_fold_stmt_to_constant_2
   Copyright (C) 2014 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING3.  If not see
<http://www.gnu.org/licenses/>.  */

(for op in plus pointer_plus minus bit_ior bit_xor
  (simplify
    (op @0 integer_zerop)
    (if (GENERIC && !in_gimple_form)
      /* ???  fold_binary adds non_lvalue here and "fixes" the C++
	 run of Wsizeof-pointer-memaccess1.c, preserving enough of
	 sizeof (&a) + 0 because sizeof (&a) is maybe_lvalue_p ()
	 for no good reason.  The C frontend is fine as it doesn't
	 fold too early.  */
     (non_lvalue @0))
    @0))

(simplify
  (minus @0 @0)
  (if (!HONOR_NANS (TYPE_MODE (type)))
   { build_zero_cst (type); }))

(simplify
  (mult @0 integer_zerop@1)
  @1)

/* Make sure to preserve divisions by zero.  This is the reason why
   we don't simplify x / x to 1 or 0 / x to 0.  */
(for op in mult trunc_div ceil_div floor_div round_div
  (simplify
    (op @0 integer_onep)
    @0))

(simplify
  (trunc_mod @0 integer_onep)
  { build_zero_cst (type); })
/* Same applies to modulo operations, but fold is inconsistent here
   and simplifies 0 % x to 0.  */
(simplify
  (trunc_mod integer_zerop@0 @1)
  (if (!integer_zerop (@1))
   @0))

(simplify
  (bit_ior @0 integer_all_onesp@1)
  @1)

(simplify
  (bit_and @0 integer_all_onesp)
  @0)

(simplify
  (bit_and @0 integer_zerop@1)
  @1)

(simplify
  (bit_xor @0 @0)
  { build_zero_cst (type); })


