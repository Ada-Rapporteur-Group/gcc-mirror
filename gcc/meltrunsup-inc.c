/** Copyright (C) 2011 Free Software Foundation, Inc.
  This generated file meltrunsup-inc.c is part of GCC.

                  [DON'T EDIT THIS GENERATED FILE]

    GCC is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.

    GCC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.
**/


/** generated by generate_runtypesupport_forwcopy_fun **/


/* cheney like forwarding generated function */
melt_ptr_t 
melt_forwarded_copy (melt_ptr_t p)
{ /* header generated by generate_runtypesupport_forwcopy_fun */
  melt_ptr_t n = 0;
  int mag = 0;
  gcc_assert (melt_is_young (p));
  gcc_assert (p->u_discr && p->u_discr != MELT_FORWARDED_DISCR);
  if (p->u_discr->meltobj_class == MELT_FORWARDED_DISCR)
    mag =
      ((meltobject_ptr_t)
       (((struct meltforward_st *) p->u_discr)->forward))->meltobj_magic;
  else
    mag = p->u_discr->meltobj_magic;
  melt_forward_counter++;
  switch (mag) { /* end of generated header */

 /* value descriptor forward copy for melt_forwarded_copy  */

 /*valdesc #1 VALDESC_BOX*/
 case MELTOBMAG_BOX: {
  struct meltbox_st*src = (struct meltbox_st*) p;
  struct meltbox_st*dst = NULL;
   /* from VALDESC_BOX */
     dst = ggc_alloc_meltbox_st ();
     *dst = *src;
  
  n = (melt_ptr_t) dst;
  break; }
 
 /*valdesc #2 VALDESC_CLOSURE*/
 case MELTOBMAG_CLOSURE: {
  struct meltclosure_st*src = (struct meltclosure_st*) p;
  struct meltclosure_st*dst = NULL;
   /* copy VALDESC_CLOSURE in warmelt-base.melt  */
     int nbv = (int) src->nbval;
     int ix = 0;
     dst = 
   /* Don't need a cleared allocation!  */
       ggc_alloc_meltclosure_st 
         (nbv*sizeof(void*) + offsetof(struct meltclosure_st, tabval));
     dst->discr = src->discr;
     dst->rout = src->rout;
     dst->nbval = (unsigned) nbv;
     for (ix = 0; ix < nbv; ix++)
       dst->tabval[ix] = src->tabval[ix];
  
  n = (melt_ptr_t) dst;
  break; }
 
 /*valdesc #3 VALDESC_DECAY*/
 case MELTOBMAG_DECAY: {
  struct meltdecay_st*src = (struct meltdecay_st*) p;
  struct meltdecay_st*dst = NULL;
   /* from VALDESC_DECAY */
     dst = ggc_alloc_meltdecay_st ();
     *dst = *src;
  
  n = (melt_ptr_t) dst;
  break; }
 
 /*valdesc #4 VALDESC_INT*/
 case MELTOBMAG_INT: {
  struct meltint_st*src = (struct meltint_st*) p;
  struct meltint_st*dst = NULL;
   /* from VALDESC_INT */
     dst = 
        /* Don't need a cleared allocation.  */
	  ggc_alloc_meltint_st ();
     *dst = *src;
  
  n = (melt_ptr_t) dst;
  break; }
 
 /*valdesc #5 VALDESC_LIST*/
 case MELTOBMAG_LIST: {
  struct meltlist_st*src = (struct meltlist_st*) p;
  struct meltlist_st*dst = NULL;
   /* from VALDESC_LIST */
     dst = 
	  /* Don't need a cleared allocation!  */
	 ggc_alloc_meltlist_st ();
     *dst = *src;
  
  n = (melt_ptr_t) dst;
  break; }
 
 /*valdesc #6 VALDESC_MAPOBJECTS*/
 case MELTOBMAG_MAPOBJECTS: {
  struct meltmapobjects_st*src = (struct meltmapobjects_st*) p;
  struct meltmapobjects_st*dst = NULL;
   /* copy VALDESC_MAPOBJECTS in warmelt-base.melt */
     int siz = melt_primtab[src->lenix];
     dst = 
	  /* Don't need a cleared allocation.  */
	  ggc_alloc_meltmapobjects_st ();
     dst->discr = src->discr;
     dst->count = src->count;
     dst->lenix = src->lenix;
     if (siz > 0 && src->entab)
       {
       /* Don't need a cleared allocation.  */
         dst->entab = ggc_alloc_vec_entryobjectsmelt_st (siz);
         memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
       }
     else
       dst->entab = NULL;
  
  n = (melt_ptr_t) dst;
  break; }
 
 /*valdesc #7 VALDESC_MAPSTRINGS*/
 case MELTOBMAG_MAPSTRINGS: {
  struct meltmapstrings_st*src = (struct meltmapstrings_st*) p;
  struct meltmapstrings_st*dst = NULL;
   /* copy VALDESC_MAPSTRINGS in warmelt-base.melt */
        int siz = melt_primtab[src->lenix];
	dst = 
	  /* Don't need a cleared allocation.  */
	  ggc_alloc_meltmapstrings_st ();
        dst->discr = src->discr;
        dst->count = src->count;
        dst->lenix = src->lenix;
        if (siz > 0 && src->entab)
          {
          /* Don't need a cleared allocation.  */
            dst->entab = ggc_alloc_vec_entrystringsmelt_st (siz);
            memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
          }
        else
          dst->entab = NULL;
  
  n = (melt_ptr_t) dst;
  break; }
 
 /*valdesc #8 VALDESC_MIXBIGINT*/
 case MELTOBMAG_MIXBIGINT: {
  struct meltmixbigint_st*src = (struct meltmixbigint_st*) p;
  struct meltmixbigint_st*dst = NULL;
   /* from VALDESC_MIXBIGINT */
     unsigned blen = src->biglen;
     dst = 
       /* Don't need a cleared allocation.  */
       ggc_alloc_meltmixbigint_st 
       (blen*sizeof(long) + offsetof(struct meltmixbigint_st, tabig));
     dst->discr = src->discr;
     dst->ptrval = src->ptrval;
     dst->negative = src->negative;
     dst->biglen = blen;
     memcpy (dst->tabig, src->tabig, blen*sizeof(dst->tabig[0]));
  
  n = (melt_ptr_t) dst;
  break; }
 
 /*valdesc #9 VALDESC_MIXINT*/
 case MELTOBMAG_MIXINT: {
  struct meltmixint_st*src = (struct meltmixint_st*) p;
  struct meltmixint_st*dst = NULL;
   /* from VALDESC_MIXINT */
    dst = 
      /* Don't need a cleared allocation.  */
        ggc_alloc_meltmixint_st ();
    *dst = *src;
  
  n = (melt_ptr_t) dst;
  break; }
 
 /*valdesc #10 VALDESC_MIXLOC*/
 case MELTOBMAG_MIXLOC: {
  struct meltmixloc_st*src = (struct meltmixloc_st*) p;
  struct meltmixloc_st*dst = NULL;
   /* from VALDESC_MIXLOC */
    dst = 
       /* Don't need a cleared allocation.  */
       ggc_alloc_meltmixloc_st ();
    *dst = *src;
  
  n = (melt_ptr_t) dst;
  break; }
 
 /*valdesc #11 VALDESC_MULTIPLE*/
 case MELTOBMAG_MULTIPLE: {
  struct meltmultiple_st*src = (struct meltmultiple_st*) p;
  struct meltmultiple_st*dst = NULL;
    /* from VALDESC_MULTIPLE */
    int nbv = (int) src->nbval;
    int ix = 0;
    dst = 
      /* Don't need a cleared allocation!  */
      ggc_alloc_meltmultiple_st 
      (nbv*sizeof(void*) + offsetof(struct meltmultiple_st, tabval));
    /* we cannot copy the whole src, because FLEXIBLE_DIM might be
       1 and nbval could be 0 */
    dst->discr = src->discr;
    dst->nbval = src->nbval;
    for (ix = 0; ix < nbv; ix++)
      dst->tabval[ix] = src->tabval[ix];
  
  n = (melt_ptr_t) dst;
  break; }
 
 /*valdesc #12 VALDESC_OBJECT*/
 case MELTOBMAG_OBJECT: {
  struct meltobject_st*src = (struct meltobject_st*) p;
  struct meltobject_st*dst = NULL;
   /* from VALDESC_OBJECT */
    int ix = 0;
    int oblen = (int) (src->obj_len);
    /* We don't need to clear at allocation, since the object is
       explicitly filled here! */
    dst = ggc_alloc_meltobject_st
      (oblen*sizeof(void*)
       + offsetof(struct meltobject_st, obj_vartab));
    /* we cannot copy the whole src, because FLEXIBLE_DIM might be 1 */
    dst->meltobj_class = src->meltobj_class;
    dst->obj_hash = src->obj_hash;
    dst->obj_num = src->obj_num;
    dst->obj_len = oblen;
    for (ix = 0; ix < oblen; ix++)
        dst->obj_vartab[ix] = src->obj_vartab[ix];
  
  n = (melt_ptr_t) dst;
  break; }
 
 /*valdesc #13 VALDESC_PAIR*/
 case MELTOBMAG_PAIR: {
  struct meltpair_st*src = (struct meltpair_st*) p;
  struct meltpair_st*dst = NULL;
   /* copy VALDESC_PAIR in warmelt-base.melt */
    dst = /* Don't need a cleared allocation.  */
	  ggc_alloc_meltpair_st ();
    *dst = *src;
  
  n = (melt_ptr_t) dst;
  break; }
 
 /*valdesc #14 VALDESC_REAL*/
 case MELTOBMAG_REAL: {
  struct meltreal_st*src = (struct meltreal_st*) p;
  struct meltreal_st*dst = NULL;
   /* from VALDESC_REAL */
    dst =
        /* Don't need a cleared allocation.  */
	ggc_alloc_meltreal_st ();
    *dst = *src;
  
  n = (melt_ptr_t) dst;
  break; }
 
 /*valdesc #15 VALDESC_ROUTINE*/
 case MELTOBMAG_ROUTINE: {
  struct meltroutine_st*src = (struct meltroutine_st*) p;
  struct meltroutine_st*dst = NULL;
   /* from VALDESC_ROUTINE */
     int nbv = (int) src->nbval;
     int ix = 0;
     dst =
       /* Don't need a cleared allocation!  */
       ggc_alloc_meltroutine_st
       (nbv*sizeof(void*) + offsetof(struct meltroutine_st, tabval));
     dst->discr = src->discr;
     strncpy (dst->routdescr, src->routdescr, MELT_ROUTDESCR_LEN);
     dst->routdescr[MELT_ROUTDESCR_LEN - 1] = 0;
     dst->nbval = (unsigned) nbv;
     dst->routfunad = src->routfunad;
     for (ix = 0; ix < nbv; ix++)
       dst->tabval[ix] = src->tabval[ix];
     dst->routdata = src->routdata;
  
  n = (melt_ptr_t) dst;
  break; }
 
 /*valdesc #16 VALDESC_SPECIAL_FILE*/
 case MELTOBMAG_SPEC_FILE: {
  struct meltspecialfile_st*src = (struct meltspecialfile_st*) p;
  struct meltspecialfile_st*dst = NULL;
   /* from VALDESC_SPECIAL_FILE */
    dst = ggc_alloc_meltspecialfile_st ();
    *dst = *src;
    /* mark the new copy! */
    dst->mark = 1;
    /* add the new copy to the old (major) special list */
    dst->nextspec = melt_oldspeclist;
    melt_oldspeclist = (struct meltspecial_st*)dst;
  
  n = (melt_ptr_t) dst;
  break; }
 
 /*valdesc #17 VALDESC_SPECIAL_MPFR*/
 case MELTOBMAG_SPEC_MPFR: {
  struct meltspecialmpfr_st*src = (struct meltspecialmpfr_st*) p;
  struct meltspecialmpfr_st*dst = NULL;
   /* from VALDESC_SPECIAL_MPFR */
    dst = ggc_alloc_meltspecialmpfr_st ();
    *dst = *src;
    /* mark the new copy! */
    dst->mark = 1;
    /* add the new copy to the old (major) special list */
    dst->nextspec = melt_oldspeclist;
    melt_oldspeclist = (struct meltspecial_st*)dst;
  
  n = (melt_ptr_t) dst;
  break; }
 
 /*valdesc #18 VALDESC_SPECIAL_PPL_COEFFICIENT*/
 case MELTOBMAG_SPECPPL_COEFFICIENT: {
  struct meltspecialpplcoefficient_st*src = (struct meltspecialpplcoefficient_st*) p;
  struct meltspecialpplcoefficient_st*dst = NULL;
   /* from VALDESC_SPECIAL_PPL_COEFFICIENT */
    dst = ggc_alloc_meltspecialpplcoefficient_st ();
    *dst = *src;
    /* mark the new copy! */
    dst->mark = 1;
    /* add the new copy to the old (major) special list */
    dst->nextspec = melt_oldspeclist;
    melt_oldspeclist = (struct meltspecial_st*)dst;
  
  n = (melt_ptr_t) dst;
  break; }
 
 /*valdesc #19 VALDESC_SPECIAL_PPL_CONSTRAINT*/
 case MELTOBMAG_SPECPPL_CONSTRAINT: {
  struct meltspecialpplconstraint_st*src = (struct meltspecialpplconstraint_st*) p;
  struct meltspecialpplconstraint_st*dst = NULL;
   /* from VALDESC_SPECIAL_PPL_CONSTRAINT */
    dst = ggc_alloc_meltspecialpplconstraint_st ();
    *dst = *src;
    /* mark the new copy! */
    dst->mark = 1;
    /* add the new copy to the old (major) special list */
    dst->nextspec = melt_oldspeclist;
    melt_oldspeclist = (struct meltspecial_st*)dst;
  
  n = (melt_ptr_t) dst;
  break; }
 
 /*valdesc #20 VALDESC_SPECIAL_PPL_CONSTRAINT_SYSTEM*/
 case MELTOBMAG_SPECPPL_CONSTRAINT_SYSTEM: {
  struct meltspecialpplconstraintsystem_st*src = (struct meltspecialpplconstraintsystem_st*) p;
  struct meltspecialpplconstraintsystem_st*dst = NULL;
   /* from VALDESC_SPECIAL_PPL_CONSTRAINT_SYSTEM */
    dst = ggc_alloc_meltspecialpplconstraintsystem_st ();
    *dst = *src;
    /* mark the new copy! */
    dst->mark = 1;
    /* add the new copy to the old (major) special list */
    dst->nextspec = melt_oldspeclist;
    melt_oldspeclist = (struct meltspecial_st*)dst;
  
  n = (melt_ptr_t) dst;
  break; }
 
 /*valdesc #21 VALDESC_SPECIAL_PPL_GENERATOR*/
 case MELTOBMAG_SPECPPL_GENERATOR: {
  struct meltspecialpplgenerator_st*src = (struct meltspecialpplgenerator_st*) p;
  struct meltspecialpplgenerator_st*dst = NULL;
   /* from VALDESC_SPECIAL_PPL_GENERATOR */
    dst = ggc_alloc_meltspecialpplgenerator_st ();
    *dst = *src;
    /* mark the new copy! */
    dst->mark = 1;
    /* add the new copy to the old (major) special list */
    dst->nextspec = melt_oldspeclist;
    melt_oldspeclist = (struct meltspecial_st*)dst;
  
  n = (melt_ptr_t) dst;
  break; }
 
 /*valdesc #22 VALDESC_SPECIAL_PPL_GENERATOR_SYSTEM*/
 case MELTOBMAG_SPECPPL_GENERATOR_SYSTEM: {
  struct meltspecialpplgeneratorsystem_st*src = (struct meltspecialpplgeneratorsystem_st*) p;
  struct meltspecialpplgeneratorsystem_st*dst = NULL;
   /* from VALDESC_SPECIAL_PPL_GENERATOR_SYSTEM */
    dst = ggc_alloc_meltspecialpplgeneratorsystem_st ();
    *dst = *src;
    /* mark the new copy! */
    dst->mark = 1;
    /* add the new copy to the old (major) special list */
    dst->nextspec = melt_oldspeclist;
    melt_oldspeclist = (struct meltspecial_st*)dst;
  
  n = (melt_ptr_t) dst;
  break; }
 
 /*valdesc #23 VALDESC_SPECIAL_PPL_LINEAR_EXPRESSION*/
 case MELTOBMAG_SPECPPL_LINEAR_EXPRESSION: {
  struct meltspecialppllinearexpression_st*src = (struct meltspecialppllinearexpression_st*) p;
  struct meltspecialppllinearexpression_st*dst = NULL;
   /* from VALDESC_SPECIAL_PPL_LINEAR_EXPRESSION */
    dst = ggc_alloc_meltspecialppllinearexpression_st ();
    *dst = *src;
    /* mark the new copy! */
    dst->mark = 1;
    /* add the new copy to the old (major) special list */
    dst->nextspec = melt_oldspeclist;
    melt_oldspeclist = (struct meltspecial_st*)dst;
  
  n = (melt_ptr_t) dst;
  break; }
 
 /*valdesc #24 VALDESC_SPECIAL_PPL_POLYHEDRON*/
 case MELTOBMAG_SPECPPL_POLYHEDRON: {
  struct meltspecialpplpolyhedron_st*src = (struct meltspecialpplpolyhedron_st*) p;
  struct meltspecialpplpolyhedron_st*dst = NULL;
   /* from VALDESC_SPECIAL_PPL_POLYHEDRON */
    dst = ggc_alloc_meltspecialpplpolyhedron_st ();
    *dst = *src;
    /* mark the new copy! */
    dst->mark = 1;
    /* add the new copy to the old (major) special list */
    dst->nextspec = melt_oldspeclist;
    melt_oldspeclist = (struct meltspecial_st*)dst;
  
  n = (melt_ptr_t) dst;
  break; }
 
 /*valdesc #25 VALDESC_SPECIAL_RAW_FILE*/
 case MELTOBMAG_SPEC_RAWFILE: {
  struct meltspecialrawfile_st*src = (struct meltspecialrawfile_st*) p;
  struct meltspecialrawfile_st*dst = NULL;
   /* from VALDESC_SPECIAL_RAW_FILE */
    dst = ggc_alloc_meltspecialrawfile_st ();
    *dst = *src;
    /* mark the new copy! */
    dst->mark = 1;
    /* add the new copy to the old (major) special list */
    dst->nextspec = melt_oldspeclist;
    melt_oldspeclist = (struct meltspecial_st*)dst;
  
  n = (melt_ptr_t) dst;
  break; }
 
 /*valdesc #26 VALDESC_STRBUF*/
 case MELTOBMAG_STRBUF: {
  struct meltstrbuf_st*src = (struct meltstrbuf_st*) p;
  struct meltstrbuf_st*dst = NULL;
   /* from VALDESC_STRBUF */
     unsigned blen = melt_primtab[src->buflenix];
     dst = 
       /* Don't need a cleared allocation.  */
       ggc_alloc_meltstrbuf_st ();
     dst->discr = src->discr;
     dst->bufstart = src->bufstart;
     dst->bufend = src->bufend;
     dst->buflenix = src->buflenix;
     if (blen > 0)
        {
#if BUILDING_GCC_VERSION > 4005
          dst->bufzn = CONST_CAST (char *, ggc_alloc_string (src->bufzn, blen+1));
#else /*GCC 4.5*/ 
          dst->bufzn = (char *) ggc_alloc_cleared (1 + blen);
          memcpy (dst->bufzn, src->bufzn, blen);
#endif  /*!GCC 4.5*/
          dst->bufzn[blen] = (char)0;
        }
      else
        dst->bufzn = NULL;
  
  n = (melt_ptr_t) dst;
  break; }
 
 /*valdesc #27 VALDESC_STRING*/
 case MELTOBMAG_STRING: {
  struct meltstring_st*src = (struct meltstring_st*) p;
  struct meltstring_st*dst = NULL;
   /* from VALDESC_STRING file warmelt-base.melt*/  
     int srclen = (src->val)?strlen (src->val):0;
     dst = 
       /* Don't need a cleared allocation.  */
       ggc_alloc_meltstring_st 
         (offsetof(struct meltstring_st, val) + (srclen+1));
     dst->discr = src->discr;
     memcpy (dst->val, src->val, srclen);
     dst->val[srclen] = (char)0;
  
  n = (melt_ptr_t) dst;
  break; }
 

/* gty ctype forward copy for melt_forwarded_copy */
/*gtyctype #1 CTYPE_BASIC_BLOCK*/
 case MELTOBMAG_BASICBLOCK: {
  struct meltbasicblock_st *src = (struct meltbasicblock_st*) p;
  struct meltbasicblock_st *dst = ggc_alloc_meltbasicblock_st ();
   *dst = *src;
   n = (melt_ptr_t) dst;
  break; }
 case MELTOBMAG_MAPBASICBLOCKS: {
  struct meltmapbasicblocks_st *src = (struct meltmapbasicblocks_st*) p;
  int siz = melt_primtab[src->lenix];
  struct meltmapbasicblocks_st *dst = ggc_alloc_meltmapbasicblocks_st ();
  dst->discr = src->discr;
  dst->count = src->count;
  dst->lenix = src->lenix;
  if (siz > 0 && src->entab) {
   dst->entab = ggc_alloc_vec_entrybasicblockmelt_st (siz);
   memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
  } else dst->entab = NULL;
   n = (melt_ptr_t) dst;
  break; }
 /*gtyctype #2 CTYPE_BITMAP*/
 case MELTOBMAG_BITMAP: {
  struct meltbitmap_st *src = (struct meltbitmap_st*) p;
  struct meltbitmap_st *dst = ggc_alloc_meltbitmap_st ();
   *dst = *src;
   n = (melt_ptr_t) dst;
  break; }
 case MELTOBMAG_MAPBITMAPS: {
  struct meltmapbitmaps_st *src = (struct meltmapbitmaps_st*) p;
  int siz = melt_primtab[src->lenix];
  struct meltmapbitmaps_st *dst = ggc_alloc_meltmapbitmaps_st ();
  dst->discr = src->discr;
  dst->count = src->count;
  dst->lenix = src->lenix;
  if (siz > 0 && src->entab) {
   dst->entab = ggc_alloc_vec_entrybitmapmelt_st (siz);
   memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
  } else dst->entab = NULL;
   n = (melt_ptr_t) dst;
  break; }
 /*gtyctype #3 CTYPE_EDGE*/
 case MELTOBMAG_EDGE: {
  struct meltedge_st *src = (struct meltedge_st*) p;
  struct meltedge_st *dst = ggc_alloc_meltedge_st ();
   *dst = *src;
   n = (melt_ptr_t) dst;
  break; }
 case MELTOBMAG_MAPEDGES: {
  struct meltmapedges_st *src = (struct meltmapedges_st*) p;
  int siz = melt_primtab[src->lenix];
  struct meltmapedges_st *dst = ggc_alloc_meltmapedges_st ();
  dst->discr = src->discr;
  dst->count = src->count;
  dst->lenix = src->lenix;
  if (siz > 0 && src->entab) {
   dst->entab = ggc_alloc_vec_entryedgemelt_st (siz);
   memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
  } else dst->entab = NULL;
   n = (melt_ptr_t) dst;
  break; }
 /*gtyctype #4 CTYPE_GIMPLE*/
 case MELTOBMAG_GIMPLE: {
  struct meltgimple_st *src = (struct meltgimple_st*) p;
  struct meltgimple_st *dst = ggc_alloc_meltgimple_st ();
   *dst = *src;
   n = (melt_ptr_t) dst;
  break; }
 case MELTOBMAG_MAPGIMPLES: {
  struct meltmapgimples_st *src = (struct meltmapgimples_st*) p;
  int siz = melt_primtab[src->lenix];
  struct meltmapgimples_st *dst = ggc_alloc_meltmapgimples_st ();
  dst->discr = src->discr;
  dst->count = src->count;
  dst->lenix = src->lenix;
  if (siz > 0 && src->entab) {
   dst->entab = ggc_alloc_vec_entrygimplemelt_st (siz);
   memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
  } else dst->entab = NULL;
   n = (melt_ptr_t) dst;
  break; }
 /*gtyctype #5 CTYPE_GIMPLE_SEQ*/
 case MELTOBMAG_GIMPLESEQ: {
  struct meltgimpleseq_st *src = (struct meltgimpleseq_st*) p;
  struct meltgimpleseq_st *dst = ggc_alloc_meltgimpleseq_st ();
   *dst = *src;
   n = (melt_ptr_t) dst;
  break; }
 case MELTOBMAG_MAPGIMPLESEQS: {
  struct meltmapgimpleseqs_st *src = (struct meltmapgimpleseqs_st*) p;
  int siz = melt_primtab[src->lenix];
  struct meltmapgimpleseqs_st *dst = ggc_alloc_meltmapgimpleseqs_st ();
  dst->discr = src->discr;
  dst->count = src->count;
  dst->lenix = src->lenix;
  if (siz > 0 && src->entab) {
   dst->entab = ggc_alloc_vec_entrygimpleseqmelt_st (siz);
   memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
  } else dst->entab = NULL;
   n = (melt_ptr_t) dst;
  break; }
 /*gtyctype #6 CTYPE_LOOP*/
 case MELTOBMAG_LOOP: {
  struct meltloop_st *src = (struct meltloop_st*) p;
  struct meltloop_st *dst = ggc_alloc_meltloop_st ();
   *dst = *src;
   n = (melt_ptr_t) dst;
  break; }
 case MELTOBMAG_MAPLOOPS: {
  struct meltmaploops_st *src = (struct meltmaploops_st*) p;
  int siz = melt_primtab[src->lenix];
  struct meltmaploops_st *dst = ggc_alloc_meltmaploops_st ();
  dst->discr = src->discr;
  dst->count = src->count;
  dst->lenix = src->lenix;
  if (siz > 0 && src->entab) {
   dst->entab = ggc_alloc_vec_entryloopmelt_st (siz);
   memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
  } else dst->entab = NULL;
   n = (melt_ptr_t) dst;
  break; }
 /*gtyctype #7 CTYPE_RTVEC*/
 case MELTOBMAG_RTVEC: {
  struct meltrtvec_st *src = (struct meltrtvec_st*) p;
  struct meltrtvec_st *dst = ggc_alloc_meltrtvec_st ();
   *dst = *src;
   n = (melt_ptr_t) dst;
  break; }
 case MELTOBMAG_MAPRTVECS: {
  struct meltmaprtvecs_st *src = (struct meltmaprtvecs_st*) p;
  int siz = melt_primtab[src->lenix];
  struct meltmaprtvecs_st *dst = ggc_alloc_meltmaprtvecs_st ();
  dst->discr = src->discr;
  dst->count = src->count;
  dst->lenix = src->lenix;
  if (siz > 0 && src->entab) {
   dst->entab = ggc_alloc_vec_entryrtvecmelt_st (siz);
   memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
  } else dst->entab = NULL;
   n = (melt_ptr_t) dst;
  break; }
 /*gtyctype #8 CTYPE_RTX*/
 case MELTOBMAG_RTX: {
  struct meltrtx_st *src = (struct meltrtx_st*) p;
  struct meltrtx_st *dst = ggc_alloc_meltrtx_st ();
   *dst = *src;
   n = (melt_ptr_t) dst;
  break; }
 case MELTOBMAG_MAPRTXS: {
  struct meltmaprtxs_st *src = (struct meltmaprtxs_st*) p;
  int siz = melt_primtab[src->lenix];
  struct meltmaprtxs_st *dst = ggc_alloc_meltmaprtxs_st ();
  dst->discr = src->discr;
  dst->count = src->count;
  dst->lenix = src->lenix;
  if (siz > 0 && src->entab) {
   dst->entab = ggc_alloc_vec_entryrtxmelt_st (siz);
   memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
  } else dst->entab = NULL;
   n = (melt_ptr_t) dst;
  break; }
 /*gtyctype #9 CTYPE_TREE*/
 case MELTOBMAG_TREE: {
  struct melttree_st *src = (struct melttree_st*) p;
  struct melttree_st *dst = ggc_alloc_melttree_st ();
   *dst = *src;
   n = (melt_ptr_t) dst;
  break; }
 case MELTOBMAG_MAPTREES: {
  struct meltmaptrees_st *src = (struct meltmaptrees_st*) p;
  int siz = melt_primtab[src->lenix];
  struct meltmaptrees_st *dst = ggc_alloc_meltmaptrees_st ();
  dst->discr = src->discr;
  dst->count = src->count;
  dst->lenix = src->lenix;
  if (siz > 0 && src->entab) {
   dst->entab = ggc_alloc_vec_entrytreemelt_st (siz);
   memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
  } else dst->entab = NULL;
   n = (melt_ptr_t) dst;
  break; }
  /* trailer generated by generate_runtypesupport_forwcopy_fun  */
    default:
      fatal_error ("corruption: forward invalid p=%p discr=%p magic=%d",
		   (void *) p, (void *) p->u_discr, mag);
   } /* end switch (mag) */

    melt_debuggc_eprintf ("melt_forwarded_copy#%ld/%04ld %p => %p %s", 
			  melt_nb_garbcoll, melt_forward_counter, (void*)p, 
                          (void*)n, melt_obmag_string (mag));
  if (n)
    {
#if ENABLE_CHECKING
      if (melt_alptr_1 && (void*)melt_alptr_1 == (void*)n) 
	{
	  fprintf (stderr, "melt_forwarded_copy to alptr_1 %p mag %d\n",  melt_alptr_1, mag);
	  fflush (stderr);
	  melt_debuggc_eprintf("melt_forwarded_copy #%ld alptr_1 %p mag %d", 
			       melt_nb_garbcoll, melt_alptr_1, mag);
	  melt_break_alptr_1 ("forwarded copy to alptr_1");
	}
      if (melt_alptr_2 && (void*)melt_alptr_2 == (void*)n) 
	{
	  fprintf (stderr, "melt_forwarded_copy to alptr_2 %p mag %d\n",  melt_alptr_2, mag);
	  fflush (stderr);
	  melt_debuggc_eprintf("melt_forwarded_copy #%ld alptr_2 %p", 
			       melt_nb_garbcoll, melt_alptr_2);
	  melt_break_alptr_2 ("forwarded copy to alptr_2");
	};
#endif /*ENABLE_CHECKING*/

      p->u_forward.discr = MELT_FORWARDED_DISCR;
      p->u_forward.forward = n;
      VEC_safe_push (melt_ptr_t, gc, melt_bscanvec, n);
    }
  return n;
}  /* end of melt_forwarded_copy generated by generate_runtypesupport_forwcopy_fun */

/** end of code generated by generate_runtypesupport_forwcopy_fun **/



/** start of code generated by generate_runtypesupport_scanning **/
 /* header from generate_runtypesupport_scanning */
/* The melt_scanning routine is mostly Chesney like ; however some types,
   including objects, strbuf, stringmaps, objectmaps, all the other
   *maps, contain a pointer to a non value ; this pointer should be
   carefully updated if it was young. */
static void
melt_scanning (melt_ptr_t p)
{
  unsigned omagic = 0;
  if (!p)
    return;
  gcc_assert (p != (void *) HTAB_DELETED_ENTRY);
  gcc_assert (p->u_discr && p->u_discr != (meltobject_ptr_t) 1);
  MELT_FORWARDED (p->u_discr);
  gcc_assert (!melt_is_young (p));
  omagic = p->u_discr->meltobj_magic;
  switch (omagic)
    {
/* end of header from generate_runtypesupport_scanning*/

 /*valdesc #1 VALDESC_BOX*/
 case MELTOBMAG_BOX: {
  struct meltbox_st*src = (struct meltbox_st*) p;
   /* from VALDESC_BOX */
     MELT_FORWARDED (src->val);
  
  break; }
 
 /*valdesc #2 VALDESC_CLOSURE*/
 case MELTOBMAG_CLOSURE: {
  struct meltclosure_st*src = (struct meltclosure_st*) p;
   /* from VALDESC_CLOSURE */
     int nbval = (int) src->nbval;
     int ix = 0;
     MELT_FORWARDED (src->rout);
     for (ix = 0; ix < nbval; ix++)
       MELT_FORWARDED (src->tabval[ix]);
  
  break; }
 
 /*valdesc #3 VALDESC_DECAY*/
 case MELTOBMAG_DECAY: {
  struct meltdecay_st*src = (struct meltdecay_st*) p;
   /* from VALDESC_DECAY */
     MELT_FORWARDED (src->val);
  
  break; }
 
 /*valdesc #4 VALDESC_INT*/
 case MELTOBMAG_INT: {
  break; }
 
 /*valdesc #5 VALDESC_LIST*/
 case MELTOBMAG_LIST: {
  struct meltlist_st*src = (struct meltlist_st*) p;
   /* from VALDESC_LIST */
     MELT_FORWARDED (src->first);
     MELT_FORWARDED (src->last);
  
  break; }
 
 /*valdesc #6 VALDESC_MAPOBJECTS*/
 case MELTOBMAG_MAPOBJECTS: {
  struct meltmapobjects_st*src = (struct meltmapobjects_st*) p;
   /* from VALDESC_MAPOBJECTS */
    int siz, ix;
    if (!src->entab)
      break;
    siz = melt_primtab[src->lenix];
    gcc_assert (siz > 0);
    if (melt_is_young (src->entab))
      {
        struct entryobjectsmelt_st *newtab = 
          /* Don't need a cleared allocation!  */
          ggc_alloc_vec_entryobjectsmelt_st (siz);
        memcpy (newtab, src->entab,
                siz * sizeof (struct entryobjectsmelt_st));
        src->entab = newtab;
      }
    for (ix = 0; ix < siz; ix++)
      {
        meltobject_ptr_t at = src->entab[ix].e_at;
        if (!at || at == (void *) HTAB_DELETED_ENTRY)
          {
            src->entab[ix].e_va = NULL;
            continue;
          }
        MELT_FORWARDED (at);
        src->entab[ix].e_at = at;
        MELT_FORWARDED (src->entab[ix].e_va);
      }
  
  break; }
 
 /*valdesc #7 VALDESC_MAPSTRINGS*/
 case MELTOBMAG_MAPSTRINGS: {
  struct meltmapstrings_st*src = (struct meltmapstrings_st*) p;
   /* from VALDESC_MAPSTRINGS */
     int ix, siz;
     if (!src->entab)
       break;
     siz = melt_primtab[src->lenix];
     gcc_assert (siz > 0);
     if (melt_is_young (src->entab))
       {
         struct entrystringsmelt_st *newtab
           /* Don't need a cleared allocation!  */
           = ggc_alloc_vec_entrystringsmelt_st (siz);
         memcpy (newtab, src->entab,
                 siz * sizeof (struct entrystringsmelt_st));
         src->entab = newtab;
       }
     for (ix = 0; ix < siz; ix++)
       {
         const char *at = src->entab[ix].e_at;
         if (!at || at == (void *) HTAB_DELETED_ENTRY)
           {
             src->entab[ix].e_va = NULL;
             continue;
           }
         if (melt_is_young ((const void *) at))
           src->entab[ix].e_at = (const char *) ggc_strdup (at);
         MELT_FORWARDED (src->entab[ix].e_va);
       }
  
  break; }
 
 /*valdesc #8 VALDESC_MIXBIGINT*/
 case MELTOBMAG_MIXBIGINT: {
  struct meltmixbigint_st*src = (struct meltmixbigint_st*) p;
   /* from VALDESC_MIXBIGINT */
    MELT_FORWARDED (src->ptrval);
  
  break; }
 
 /*valdesc #9 VALDESC_MIXINT*/
 case MELTOBMAG_MIXINT: {
  struct meltmixint_st*src = (struct meltmixint_st*) p;
   /* from VALDESC_MIXINT */
    MELT_FORWARDED (src->ptrval);
  
  break; }
 
 /*valdesc #10 VALDESC_MIXLOC*/
 case MELTOBMAG_MIXLOC: {
  struct meltmixloc_st*src = (struct meltmixloc_st*) p;
   /* from VALDESC_MIXLOC */
    MELT_FORWARDED (src->ptrval);
  
  break; }
 
 /*valdesc #11 VALDESC_MULTIPLE*/
 case MELTOBMAG_MULTIPLE: {
  struct meltmultiple_st*src = (struct meltmultiple_st*) p;
   /* from VALDESC_MULTIPLE */
     int nbval = (int) src->nbval;
     int ix = 0;
     for (ix = 0; ix < nbval; ix++)
       MELT_FORWARDED (src->tabval[ix]);
  
  break; }
 
 /*valdesc #12 VALDESC_OBJECT*/
 case MELTOBMAG_OBJECT: {
  struct meltobject_st*src = (struct meltobject_st*) p;
   /* from VALDESC_OBJECT */
    int ix = 0;
    int oblen = (int) (src->obj_len);
    for (ix = 0; ix < oblen; ix++)
      MELT_FORWARDED (src->obj_vartab[ix]);
  
  break; }
 
 /*valdesc #13 VALDESC_PAIR*/
 case MELTOBMAG_PAIR: {
  struct meltpair_st*src = (struct meltpair_st*) p;
   /* forward VALDESC_PAIR in warmelt-base.melt */
     MELT_FORWARDED (src->hd);
     MELT_FORWARDED (src->tl);
  
  break; }
 
 /*valdesc #14 VALDESC_REAL*/
 case MELTOBMAG_REAL: {
  break; }
 
 /*valdesc #15 VALDESC_ROUTINE*/
 case MELTOBMAG_ROUTINE: {
  struct meltroutine_st*src = (struct meltroutine_st*) p;
   /* from VALDESC_ROUTINE */
     int nbval = (int) src->nbval;
     int ix = 0;
     for (ix = 0; ix < nbval; ix++)
       MELT_FORWARDED (src->tabval[ix]);
  
  break; }
 
 /*valdesc #16 VALDESC_SPECIAL_FILE*/
 case MELTOBMAG_SPEC_FILE: {
  struct meltspecialfile_st*src = (struct meltspecialfile_st*) p;
   /* from VALDESC_SPECIAL_FILE */
    src->mark = 1;
  
  break; }
 
 /*valdesc #17 VALDESC_SPECIAL_MPFR*/
 case MELTOBMAG_SPEC_MPFR: {
  struct meltspecialmpfr_st*src = (struct meltspecialmpfr_st*) p;
   /* from VALDESC_SPECIAL_MPFR */
    src->mark = 1;
  
  break; }
 
 /*valdesc #18 VALDESC_SPECIAL_PPL_COEFFICIENT*/
 case MELTOBMAG_SPECPPL_COEFFICIENT: {
  struct meltspecialpplcoefficient_st*src = (struct meltspecialpplcoefficient_st*) p;
   /* from VALDESC_SPECIAL_PPL_COEFFICIENT */
    src->mark = 1;
  
  break; }
 
 /*valdesc #19 VALDESC_SPECIAL_PPL_CONSTRAINT*/
 case MELTOBMAG_SPECPPL_CONSTRAINT: {
  struct meltspecialpplconstraint_st*src = (struct meltspecialpplconstraint_st*) p;
   /* from VALDESC_SPECIAL_PPL_CONSTRAINT */
    src->mark = 1;
  
  break; }
 
 /*valdesc #20 VALDESC_SPECIAL_PPL_CONSTRAINT_SYSTEM*/
 case MELTOBMAG_SPECPPL_CONSTRAINT_SYSTEM: {
  struct meltspecialpplconstraintsystem_st*src = (struct meltspecialpplconstraintsystem_st*) p;
   /* from VALDESC_SPECIAL_PPL_CONSTRAINT_SYSTEM */
    src->mark = 1;
  
  break; }
 
 /*valdesc #21 VALDESC_SPECIAL_PPL_GENERATOR*/
 case MELTOBMAG_SPECPPL_GENERATOR: {
  struct meltspecialpplgenerator_st*src = (struct meltspecialpplgenerator_st*) p;
   /* from VALDESC_SPECIAL_PPL_GENERATOR */
    src->mark = 1;
  
  break; }
 
 /*valdesc #22 VALDESC_SPECIAL_PPL_GENERATOR_SYSTEM*/
 case MELTOBMAG_SPECPPL_GENERATOR_SYSTEM: {
  struct meltspecialpplgeneratorsystem_st*src = (struct meltspecialpplgeneratorsystem_st*) p;
   /* from VALDESC_SPECIAL_PPL_GENERATOR_SYSTEM */
    src->mark = 1;
  
  break; }
 
 /*valdesc #23 VALDESC_SPECIAL_PPL_LINEAR_EXPRESSION*/
 case MELTOBMAG_SPECPPL_LINEAR_EXPRESSION: {
  struct meltspecialppllinearexpression_st*src = (struct meltspecialppllinearexpression_st*) p;
   /* from VALDESC_SPECIAL_PPL_LINEAR_EXPRESSION */
    src->mark = 1;
  
  break; }
 
 /*valdesc #24 VALDESC_SPECIAL_PPL_POLYHEDRON*/
 case MELTOBMAG_SPECPPL_POLYHEDRON: {
  struct meltspecialpplpolyhedron_st*src = (struct meltspecialpplpolyhedron_st*) p;
   /* from VALDESC_SPECIAL_PPL_POLYHEDRON */
    src->mark = 1;
  
  break; }
 
 /*valdesc #25 VALDESC_SPECIAL_RAW_FILE*/
 case MELTOBMAG_SPEC_RAWFILE: {
  struct meltspecialrawfile_st*src = (struct meltspecialrawfile_st*) p;
   /* from VALDESC_SPECIAL_RAW_FILE */
    src->mark = 1;
  
  break; }
 
 /*valdesc #26 VALDESC_STRBUF*/
 case MELTOBMAG_STRBUF: {
  break; }
 
 /*valdesc #27 VALDESC_STRING*/
 case MELTOBMAG_STRING: {
  break; }
 
/* GTY-ed ctypes scan forward for melt_scanning  */
/*gtyctype #1 CTYPE_BASIC_BLOCK*/
 case MELTOBMAG_BASICBLOCK:
  break;
 case MELTOBMAG_MAPBASICBLOCKS: {
   struct meltmapbasicblocks_st *src = (struct meltmapbasicblocks_st*) p;
  int siz=0, ix=0;
  if (!src->entab) break;
  siz = melt_primtab[src->lenix];
  gcc_assert (siz>0);
  if (melt_is_young (src->entab)) {
    struct entrybasicblockmelt_st* newtab = ggc_alloc_vec_entrybasicblockmelt_st (siz);
    memcpy (newtab, src->entab, siz * sizeof (struct entrybasicblockmelt_st));
    src->entab = newtab;
    } /*end if young entab */
  for (ix = 0; ix < siz; ix++) {
    basic_block at = src->entab[ix].e_at;
    if (!at || (void*) at == (void*) HTAB_DELETED_ENTRY) {
      src->entab[ix].e_va = NULL;
      continue;
    } /*end if empty at */
    MELT_FORWARDED (src->entab[ix].e_va);
  } /*end for ix*/
  };    /* end case MELTOBMAG_MAPBASICBLOCKS */
  break;
  /*gtyctype #2 CTYPE_BITMAP*/
 case MELTOBMAG_BITMAP:
  break;
 case MELTOBMAG_MAPBITMAPS: {
   struct meltmapbitmaps_st *src = (struct meltmapbitmaps_st*) p;
  int siz=0, ix=0;
  if (!src->entab) break;
  siz = melt_primtab[src->lenix];
  gcc_assert (siz>0);
  if (melt_is_young (src->entab)) {
    struct entrybitmapmelt_st* newtab = ggc_alloc_vec_entrybitmapmelt_st (siz);
    memcpy (newtab, src->entab, siz * sizeof (struct entrybitmapmelt_st));
    src->entab = newtab;
    } /*end if young entab */
  for (ix = 0; ix < siz; ix++) {
    bitmap at = src->entab[ix].e_at;
    if (!at || (void*) at == (void*) HTAB_DELETED_ENTRY) {
      src->entab[ix].e_va = NULL;
      continue;
    } /*end if empty at */
    MELT_FORWARDED (src->entab[ix].e_va);
  } /*end for ix*/
  };    /* end case MELTOBMAG_MAPBITMAPS */
  break;
  /*gtyctype #3 CTYPE_EDGE*/
 case MELTOBMAG_EDGE:
  break;
 case MELTOBMAG_MAPEDGES: {
   struct meltmapedges_st *src = (struct meltmapedges_st*) p;
  int siz=0, ix=0;
  if (!src->entab) break;
  siz = melt_primtab[src->lenix];
  gcc_assert (siz>0);
  if (melt_is_young (src->entab)) {
    struct entryedgemelt_st* newtab = ggc_alloc_vec_entryedgemelt_st (siz);
    memcpy (newtab, src->entab, siz * sizeof (struct entryedgemelt_st));
    src->entab = newtab;
    } /*end if young entab */
  for (ix = 0; ix < siz; ix++) {
    edge at = src->entab[ix].e_at;
    if (!at || (void*) at == (void*) HTAB_DELETED_ENTRY) {
      src->entab[ix].e_va = NULL;
      continue;
    } /*end if empty at */
    MELT_FORWARDED (src->entab[ix].e_va);
  } /*end for ix*/
  };    /* end case MELTOBMAG_MAPEDGES */
  break;
  /*gtyctype #4 CTYPE_GIMPLE*/
 case MELTOBMAG_GIMPLE:
  break;
 case MELTOBMAG_MAPGIMPLES: {
   struct meltmapgimples_st *src = (struct meltmapgimples_st*) p;
  int siz=0, ix=0;
  if (!src->entab) break;
  siz = melt_primtab[src->lenix];
  gcc_assert (siz>0);
  if (melt_is_young (src->entab)) {
    struct entrygimplemelt_st* newtab = ggc_alloc_vec_entrygimplemelt_st (siz);
    memcpy (newtab, src->entab, siz * sizeof (struct entrygimplemelt_st));
    src->entab = newtab;
    } /*end if young entab */
  for (ix = 0; ix < siz; ix++) {
    gimple at = src->entab[ix].e_at;
    if (!at || (void*) at == (void*) HTAB_DELETED_ENTRY) {
      src->entab[ix].e_va = NULL;
      continue;
    } /*end if empty at */
    MELT_FORWARDED (src->entab[ix].e_va);
  } /*end for ix*/
  };    /* end case MELTOBMAG_MAPGIMPLES */
  break;
  /*gtyctype #5 CTYPE_GIMPLE_SEQ*/
 case MELTOBMAG_GIMPLESEQ:
  break;
 case MELTOBMAG_MAPGIMPLESEQS: {
   struct meltmapgimpleseqs_st *src = (struct meltmapgimpleseqs_st*) p;
  int siz=0, ix=0;
  if (!src->entab) break;
  siz = melt_primtab[src->lenix];
  gcc_assert (siz>0);
  if (melt_is_young (src->entab)) {
    struct entrygimpleseqmelt_st* newtab = ggc_alloc_vec_entrygimpleseqmelt_st (siz);
    memcpy (newtab, src->entab, siz * sizeof (struct entrygimpleseqmelt_st));
    src->entab = newtab;
    } /*end if young entab */
  for (ix = 0; ix < siz; ix++) {
    gimple_seq at = src->entab[ix].e_at;
    if (!at || (void*) at == (void*) HTAB_DELETED_ENTRY) {
      src->entab[ix].e_va = NULL;
      continue;
    } /*end if empty at */
    MELT_FORWARDED (src->entab[ix].e_va);
  } /*end for ix*/
  };    /* end case MELTOBMAG_MAPGIMPLESEQS */
  break;
  /*gtyctype #6 CTYPE_LOOP*/
 case MELTOBMAG_LOOP:
  break;
 case MELTOBMAG_MAPLOOPS: {
   struct meltmaploops_st *src = (struct meltmaploops_st*) p;
  int siz=0, ix=0;
  if (!src->entab) break;
  siz = melt_primtab[src->lenix];
  gcc_assert (siz>0);
  if (melt_is_young (src->entab)) {
    struct entryloopmelt_st* newtab = ggc_alloc_vec_entryloopmelt_st (siz);
    memcpy (newtab, src->entab, siz * sizeof (struct entryloopmelt_st));
    src->entab = newtab;
    } /*end if young entab */
  for (ix = 0; ix < siz; ix++) {
    loop_p at = src->entab[ix].e_at;
    if (!at || (void*) at == (void*) HTAB_DELETED_ENTRY) {
      src->entab[ix].e_va = NULL;
      continue;
    } /*end if empty at */
    MELT_FORWARDED (src->entab[ix].e_va);
  } /*end for ix*/
  };    /* end case MELTOBMAG_MAPLOOPS */
  break;
  /*gtyctype #7 CTYPE_RTVEC*/
 case MELTOBMAG_RTVEC:
  break;
 case MELTOBMAG_MAPRTVECS: {
   struct meltmaprtvecs_st *src = (struct meltmaprtvecs_st*) p;
  int siz=0, ix=0;
  if (!src->entab) break;
  siz = melt_primtab[src->lenix];
  gcc_assert (siz>0);
  if (melt_is_young (src->entab)) {
    struct entryrtvecmelt_st* newtab = ggc_alloc_vec_entryrtvecmelt_st (siz);
    memcpy (newtab, src->entab, siz * sizeof (struct entryrtvecmelt_st));
    src->entab = newtab;
    } /*end if young entab */
  for (ix = 0; ix < siz; ix++) {
    rtvec at = src->entab[ix].e_at;
    if (!at || (void*) at == (void*) HTAB_DELETED_ENTRY) {
      src->entab[ix].e_va = NULL;
      continue;
    } /*end if empty at */
    MELT_FORWARDED (src->entab[ix].e_va);
  } /*end for ix*/
  };    /* end case MELTOBMAG_MAPRTVECS */
  break;
  /*gtyctype #8 CTYPE_RTX*/
 case MELTOBMAG_RTX:
  break;
 case MELTOBMAG_MAPRTXS: {
   struct meltmaprtxs_st *src = (struct meltmaprtxs_st*) p;
  int siz=0, ix=0;
  if (!src->entab) break;
  siz = melt_primtab[src->lenix];
  gcc_assert (siz>0);
  if (melt_is_young (src->entab)) {
    struct entryrtxmelt_st* newtab = ggc_alloc_vec_entryrtxmelt_st (siz);
    memcpy (newtab, src->entab, siz * sizeof (struct entryrtxmelt_st));
    src->entab = newtab;
    } /*end if young entab */
  for (ix = 0; ix < siz; ix++) {
    rtx at = src->entab[ix].e_at;
    if (!at || (void*) at == (void*) HTAB_DELETED_ENTRY) {
      src->entab[ix].e_va = NULL;
      continue;
    } /*end if empty at */
    MELT_FORWARDED (src->entab[ix].e_va);
  } /*end for ix*/
  };    /* end case MELTOBMAG_MAPRTXS */
  break;
  /*gtyctype #9 CTYPE_TREE*/
 case MELTOBMAG_TREE:
  break;
 case MELTOBMAG_MAPTREES: {
   struct meltmaptrees_st *src = (struct meltmaptrees_st*) p;
  int siz=0, ix=0;
  if (!src->entab) break;
  siz = melt_primtab[src->lenix];
  gcc_assert (siz>0);
  if (melt_is_young (src->entab)) {
    struct entrytreemelt_st* newtab = ggc_alloc_vec_entrytreemelt_st (siz);
    memcpy (newtab, src->entab, siz * sizeof (struct entrytreemelt_st));
    src->entab = newtab;
    } /*end if young entab */
  for (ix = 0; ix < siz; ix++) {
    tree at = src->entab[ix].e_at;
    if (!at || (void*) at == (void*) HTAB_DELETED_ENTRY) {
      src->entab[ix].e_va = NULL;
      continue;
    } /*end if empty at */
    MELT_FORWARDED (src->entab[ix].e_va);
  } /*end for ix*/
  };    /* end case MELTOBMAG_MAPTREES */
  break;
   /* trailer generated by generate_runtypesupport_scanning */
    default:
      /* gcc_unreachable (); */
      fatal_error ("melt melt_scanning GC: corrupted heap, p=%p omagic=%d\n",
		   (void *) p, (int) omagic);
    }
} /* end of melt_scanning generated by generate_runtypesupport_scanning */
   
/**end of code generated by generate_runtypesupport_scanning **/

/*** End of code file meltrunsup-inc.c generated on 2011 Feb 01
 * by GCC MELT 4.6.0 20110201 (experimental) [melt-branch revision 169469] . ***/
