;; -*- Lisp -*-
;; file ana-base.bysl
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(comment "
    Copyright 2008, 2009 Free Software Foundation, Inc.
    Contributed by Basile Starynkevitch <basile@starynkevitch.net>

    This file is part of GCC.

    GCC is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.

    GCC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.
")

;; the copyright notice above apply both to ana-base.bysl and 
;; to the generated file  ana-base*.c

;; a class containing the analysis state
(defclass class_analysis_state
  :super class_proped
  :fields (
))


;;; primitive to access the gdbmstate

(defprimitive fetch_gdbmstate_constr (:cstring keystr) :value
  "(basilysgc_fetch_gdbmstate_const((" keystr ")))")

(defprimitive fetch_gdbmstate (key) :value
  "(basilysgc_fetch_gdbmstate((" key ")))")

(defprimitive put_gdbmstate_constr (:cstring keystr :value data) :void
  "basilysgc_put_gdbmstate_const((" keystr "), (basilys_ptr_t) (" data "))")

(defprimitive put_gdbmstate (key data) :void
  "basilysgc_put_gdbmstate((basilys_ptr_t)(" key "), (basilys_ptr_t)(" data "))")

(defun install_gcc_pass (pass)
  (assert_msg "check pass" (is_a pass class_gcc_pass))
  (mapstring_putstr (unsafe_get_field :sysdata_pass_dict initial_system_data)
		 (unsafe_get_field :named_name pass)
		 pass)
  (debug_msg pass "installed gcc pass")
)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; gimple & tree related primitives

(defprimitive is_gimple (v) :long
  "(basilys_magic_discr((basilys_ptr_t)(" v ")) == OBMAG_GIMPLE)")

(defprimitive make_gimple (discr :gimple g) :value
  "(basilysgc_new_gimple((basilysobject_ptr_t)(" discr "),(" g ")))")

(defprimitive gimple_content (v) :gimple
  "(basilys_gimple_content((basilys_ptr_t)(" v ")))")

;; match a gimple value & extract the gimple of it
(defcmatcher gimpleval
  (gv)					;match & no ins
  (:gimple g) 				;outs
  gimpsta				;statesymb
  (					;test expansion
  "(basilys_magic_discr((basilys_ptr_t)(" gv ")) == OBMAG_GIMPLE)"
  )
  (					;fill expansion
   g " = basilys_gimple_content(((basilys_ptr_t)(" gv ")));"
   )
  (					;operator expansion
   "(basilysgc_new_gimple((basilysobject_ptr_t)NULL, (" g ")))"
   )
)

;; match a gimple single assign
(defcmatcher gimple_assign_single
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs				;first right operand
  )					;outs
  gimpasg
  (					;test expansion
   "(" ga " && gimple_assign_single_p (" ga "))"
   )
  (					;fill expansion
   lhs " = gimple_assign_lhs(" ga ");"
   rhs " = gimple_assign_rhs1(" ga ");"
   )
)


;; match a gimple cast assign
(defcmatcher gimple_assign_cast
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs				;first right operand
  )					;outs
  gimpasg
  (					;test expansion
   "(" ga " && gimple_assign_cast_p (" ga "))"
   )
  (					;fill expansion
   lhs " = gimple_assign_lhs(" ga ");"
   rhs " = gimple_assign_rhs1(" ga ");"
   )
)

;; match a gimple copy assign
(defcmatcher gimple_assign_copy
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs				;first right operand
  )					;outs
  gimpasg
  (					;test expansion
   "(" ga " && gimple_assign_copy_p (" ga "))"
   )
  (					;fill expansion
   lhs " = gimple_assign_lhs(" ga ");"
   rhs " = gimple_assign_rhs1(" ga ");"
   )
)

;; match a gimple copy assign with ssa name
(defcmatcher gimple_assign_ssa_name_copy
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs				;first right operand
  )					;outs
  gimpasg
  (					;test expansion
   "(" ga " && gimple_assign_ssa_name_copy_p (" ga "))"
   )
  (					;fill expansion
   lhs " = gimple_assign_lhs(" ga ");"
   rhs " = gimple_assign_rhs1(" ga ");"
   )
)

;; match a gimple unary nop assign
(defcmatcher gimple_assign_unary_nop
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs				;first right operand
  )					;outs
  gimpasg
  (					;test expansion
   "(" ga " && gimple_assign_unary_nop_p (" ga "))"
   )
  (					;fill expansion
   lhs " = gimple_assign_lhs(" ga ");"
   rhs " = gimple_assign_rhs1(" ga ");"
   )
)


;;;; match a gimple assign with addition ie X = Y + Z

(defcmatcher gimple_assign_plus
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gasplus
  (; test
   ga " && is_gimple_assign(" ga ") && gimple_expr_code(" ga ") == PLUS_EXPR"
   )
  (; fill
   lhs " = gimple_assign_lhs(" ga ");\n"
   rhs1 " = gimple_assign_rhs1(" ga ");\n"
   rhs2 " = gimple_assign_rhs2(" ga ");\n"
   ))


(defcmatcher gimple_assign_pointerplus
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gasplus
  (; test
   ga " && is_gimple_assign(" ga ") && gimple_expr_code(" ga ") == POINTER_PLUS_EXPR"
   )
  (; fill
   lhs " = gimple_assign_lhs(" ga ");\n"
   rhs1 " = gimple_assign_rhs1(" ga ");\n"
   rhs2 " = gimple_assign_rhs2(" ga ");\n"
   ))


;;;; match a gimple assign with multiplication ie X = Y * Z

(defcmatcher gimple_assign_mult
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gasmult
  (; test
   ga " && is_gimple_assign(" ga ") && gimple_expr_code(" ga ") == MULT_EXPR"
   )
  (; fill
   lhs " = gimple_assign_lhs(" ga ");\n"
   rhs1 " = gimple_assign_rhs1(" ga ");\n"
   rhs2 " = gimple_assign_rhs2(" ga ");\n"
   ))



;;; match a gimple assign binary op
(defcmatcher gimple_assign_binaryop
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   :long opcode
   )
  gasplus
  (; test
   ga " && is_gimple_assign(" ga ") && gimple_num_ops(" ga ")>=3"
   )
  (; fill
   lhs " = gimple_assign_lhs(" ga ");\n"
   rhs1 " = gimple_assign_rhs1(" ga ");\n"
   rhs2 " = gimple_assign_rhs2(" ga ");\n"
   opcode " = gimple_assign_rhs_code(" ga ");\n"
   ))

;;;;;;;;;;;;;;;;
;;; match a gimple cond less or equal
(defcmatcher gimple_cond_lessequal
  (:gimple gc)
  (:tree lhs 
   :tree rhs
   :tree truelab
   :tree falselab
   )
  gimpcondle
  (; test expansion
   gc " && gimple_code(" gc ")==GIMPLE_COND "
      " && gimple_cond_code(" gc ")==LE_EXPR" 
   )
  (; fill expansion
   lhs "= gimple_cond_lhs(" gc ");\n"
   rhs "= gimple_cond_rhs(" gc ");\n"
   truelab "= gimple_cond_true_label(" gc ");\n"
   falselab "= gimple_cond_false_label(" gc ");\n"
   )
  )
;;;;;;;;;;;;;;;;
;;; match a gimple cond not equal
(defcmatcher gimple_cond_notequal
  (:gimple gc)
  (:tree lhs 
   :tree rhs
   :tree truelab
   :tree falselab
   )
  gimpcondle
  (; test expansion
   gc " && gimple_code(" gc ")==GIMPLE_COND "
      " && gimple_cond_code(" gc ")==NE_EXPR" 
   )
  (; fill expansion
   lhs "= gimple_cond_lhs(" gc ");\n"
   rhs "= gimple_cond_rhs(" gc ");\n"
   truelab "= gimple_cond_true_label(" gc ");\n"
   falselab "= gimple_cond_false_label(" gc ");\n"
   )
  )

;;; match a gimple cond greater
(defcmatcher gimple_cond_greater
  (:gimple gc)
  (:tree lhs 
   :tree rhs
   :tree truelab
   :tree falselab
   )
  gimpcondle
  (; test expansion
   gc " && gimple_code(" gc ")==GIMPLE_COND "
      " && gimple_cond_code(" gc ")==GT_EXPR" 
   )
  (; fill expansion
   lhs "= gimple_cond_lhs(" gc ");\n"
   rhs "= gimple_cond_rhs(" gc ");\n"
   truelab "= gimple_cond_true_label(" gc ");\n"
   falselab "= gimple_cond_false_label(" gc ");\n"
   )
  )

;; match a gimple cond true
(defcmatcher gimple_cond_true
  (:gimple gc)
  (:tree truelab falselab)
  gimpcondtr
  (;test
   gc " && gimple_code(" gc ")==GIMPLE_COND "
      " && gimple_cond_true_p(" gc ")")
  (;fill
   truelab "= gimple_cond_true_label(" gc ");\n"
   falselab "= gimple_cond_false_label(" gc ");\n"
   ))


;; match a gimple cond false
(defcmatcher gimple_cond_false
  (:gimple gc)
  (:tree truelab falselab)
  gimpcondtr
  (;test
   gc " && gimple_code(" gc ")==GIMPLE_COND "
      " && gimple_cond_false_p(" gc ")")
  (;fill
   truelab "= gimple_cond_true_label(" gc ");\n"
   falselab "= gimple_cond_false_label(" gc ");\n"
   ))


;;; match a gimple call to a direct function
(defcmatcher gimple_call
  (:gimple gc)
  (:tree lhs
	 fndecl
   :long nbargs
   )
  gimpcall
  (; test 
   gc " && gimple_code(" gc ")==GIMPLE_CALL"
   )
  (; fill
   lhs " = gimple_call_lhs(" gc ");\n"
   fndecl " = gimple_call_fndecl(" gc ");\n"
   nbargs " = gimple_call_num_args(" gc ");\n"
   ))

;;;; fetch the nth argument inside a call
(defprimitive gimple_call_nth_arg (:gimple gc :long n) :tree
  "(( " gc " && gimple_code(" gc ") == GIMPLE_CALL && (" n ")>=0 "
  "&& (" n ") < gimple_call_num_args(" gc ")) "
  " ? gimple_call_arg((" gc "), (" n ")) : (tree)0)")

;;;;  match a gimple return
(defcmatcher gimple_return
  (:gimple gr)
  (:tree retval
   )
  gimpret
  (; test 
   gr " && gimple_code(" gr ")==GIMPLE_RETURN"
   )
  (; fill
   retval " = gimple_return_retval(" gr ");\n"
   ))
 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defprimitive is_gimpleseq (v) :long
  "(basilys_magic_discr((basilys_ptr_t)(" v ")) == OBMAG_GIMPLESEQ)")

(defprimitive make_gimpleseq (discr :gimpleseq g) :value
  "(basilysgc_new_gimpleseq((basilysobject_ptr_t)(" discr "),(" g ")))")

(defprimitive gimpleseq_content (v) :gimpleseq
  "(basilys_gimpleseq_content((basilys_ptr_t)(" v ")))")



(defprimitive is_tree (v) :long
  "(basilys_magic_discr((basilys_ptr_t)(" v ")) == OBMAG_TREE)")

(defprimitive make_tree (discr :tree g) :value
  "(basilysgc_new_tree((basilysobject_ptr_t)(" discr "),(" g ")))")

(defprimitive tree_content (v) :tree
  "(basilys_tree_content((basilys_ptr_t)(" v ")))")

(defprimitive inform_at_tree (:tree tr :cstring msg) :void
  ;; if DECL_P(tr) use DECL_SOURCE_LOCATION(tr)
  ;; if EXPR_P(tr) use EXPR_LOCATION(tr)
  ;; otherwise no location
  "inform((DECL_P(" tr ")? DECL_SOURCE_LOCATION(" tr 
  ") : EXPR_P(" tr ") ? EXPR_LOCATION(" tr ") : UNKNOWN_LOCATION), "
  msg ");"
)



;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;; pattern (tree_function_decl <funame> <initialtree>) match a tree for a function
;; declaration
(defcmatcher tree_function_decl 
  (:tree tr) 				;matched
  ;; output 
  (:cstring funame
   :tree initialdcl
   )
  treefun				;state symbol
  (; test expansion
   "((" tr ") && TREE_CODE(" tr ") == FUNCTION_DECL)"
   )
  (;; fill expansion
   funame "=NULL; "
   initialdcl "=NULL; "
   "if (DECL_NAME(" tr "))"
   funame "= IDENTIFIER_POINTER(DECL_NAME(" tr ")); "
   initialdcl  "=DECL_INITIAL(" tr "); "
   )
)

;;;;;;;;;;;;;;;;
;; similarily pattern (tree_variable_decl <funame>)
(defcmatcher tree_variable_decl 
  (:tree tr)
  (:cstring varname
   )
  treevar				;statesym
  (; test expansion
   "((" tr ") && TREE_CODE(" tr ") == VAR_DECL)"
   )
  (;; fill expansion
   varname "=NULL; "
   "if (DECL_NAME(" tr ")) "
   varname "= IDENTIFIER_POINTER(DECL_NAME(" tr ")); ")
)
	   
;;;;;;;;;;;;;;;;
;; pattern tree_block matches a block
(defcmatcher tree_block 
  (:tree tr)
  (					;output
   :tree trvars  trsubblocks 	 
   )
  treeblock				;statesym
  (; test expander
   "((" tr ") && TREE_CODE(" tr ") == BLOCK)"
   )
  (; fill expander
   trvars "= BLOCK_VARS(" tr "); "
   trsubblocks "=BLOCK_SUBBLOCKS(" tr ");"  
   ))

;;;;;;;;;;;;;;;;
;;; pattern tree_parm_decl matches a formal parameter declaration
(defcmatcher tree_parm_decl 
  (:tree tr)
  (					;output
   :tree trargtype trdecl
   :cstring name
   )
  treeparmdecl				;statesym
  (; test expander
   "((" tr ") && TREE_CODE(" tr ") == PARM_DECL)"
   )
  (; fill expander
   trargtype "= DECL_ARG_TYPE(" tr "); \n"
   trdecl "= DECL_NAME(" tr ");\n"
   name "= DECL_NAME(" tr ") ? IDENTIFIER_POINTER(DECL_NAME(" tr ")) : NULL;\n"
   ))


;;;;;;;;;;;;;;;;
;;; pattern tree_integer_type
(defcmatcher tree_integer_type 
  (:tree tr)
  (					;output
   :cstring name
   :long min max
   )
  treeinty				;statesym
  (; test expander
   "((" tr ") && TREE_CODE(" tr ") == INTEGER_TYPE)"
   )
  (; fill expander
   "tree " treeinty "_ty=TYPE_NAME(" tr ");\n"
   "tree " treeinty "_mint=TYPE_MIN_VALUE(" tr ");\n"
   "tree " treeinty "_maxt=TYPE_MAX_VALUE(" tr ");\n"
   "if (" treeinty "_ty && TREE_CODE(" treeinty "_ty) == IDENTIFIER_NODE)\n"
   name " = IDENTIFIER_POINTER("treeinty "_ty);\n"
   "if (" treeinty "_mint && TREE_CODE(" treeinty "_mint) == INTEGER_CST)\n"
   min " = tree_low_cst(" treeinty "_mint,0);"
   "if (" treeinty "_maxt && TREE_CODE(" treeinty "_maxt) == INTEGER_CST)\n"
   max " = tree_low_cst(" treeinty "_maxt,0);"
   ))


;;; pattern tree_integer_cst
(defcmatcher tree_integer_cst
  (:tree tr)
  (					;output
   :long n
	 )
  treeintk
  (; test expander
   "((" tr ") && TREE_CODE(" tr ") == INTEGER_CST)"
   )
  (; fill expander
   n " = tree_low_cst((" tr "), 0);"
     ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  
(defprimitive is_basicblock (v) :long
  "(basilys_magic_discr((basilys_ptr_t)(" v ")) == OBMAG_BASICBLOCK)")

(defprimitive null_basicblock (:basicblock bb) :long
  "(" bb "== (basic_block)0)")

(defprimitive notnull_basicblock (:basicblock bb) :long
  "(" bb "!= (basic_block)0)")

(defprimitive make_basicblock (discr :basicblock bb) :value
  "(basilysgc_new_basicblock((basilysobject_ptr_t)(" discr "),(" bb ")))")


(defprimitive basicblock_content (v) :basicblock
  "(basilys_basicblock_content((basilys_ptr_t)(" v ")))")

(defprimitive basicblock_gimpleseq (v) :gimpleseq
  "(basilys_basicblock_gimpleseq((basilys_ptr_t)(" v ")))")
  
(defprimitive basicblock_phinodes (v) :gimpleseq
  "(basilys_basicblock_phinodes((basilys_ptr_t)(" v ")))")
  
(defprimitive ppstrbuf_gimple (sbuf :long indent :gimple g) :void
  "basilysgc_ppstrbuf_gimple((basilys_ptr_t)(" sbuf 
  "), (int) (" indent "), (" g "))")

(defprimitive ppstrbuf_gimple_seq (sbuf :long indent :gimpleseq gseq) :void
  "basilysgc_ppstrbuf_gimple_seq((basilys_ptr_t)(" sbuf 
  "), (int) (" indent "), (" gseq "))")

(defprimitive ppstrbuf_tree (sbuf :long indent :tree t) :void
  "basilysgc_ppstrbuf_tree((basilys_ptr_t)(" sbuf 
  "), (int) (" indent "), (" t "))")

(defprimitive ppstrbuf_basicblock (sbuf :long indent :basicblock bb) :void
  "basilysgc_ppstrbuf_basicblock((basilys_ptr_t)(" sbuf 
  "), (int) (" indent "), (" bb "))")

(defprimitive basicblock_single_succ (:basicblock bb) :basicblock
  "(single_succ_p(" bb ")?single_succ(" bb "):NULL)")

;;;;;;;;;;;;;;;;

(defprimitive is_mapbasicblock (map) :long
  "(basilys_magic_discr((basilys_ptr_t)(" map ")) == OBMAG_MAPBASICBLOCKS)")
(defprimitive mapbasicblock_size (map) :long
  "(basilys_size_mapbasicblocks((struct basilysmapbasicblocks_st*)(" map ")))")
;; primitive to get the attribute count of a mapbasicblock
(defprimitive mapbasicblock_count (map) :long
  "(basilys_count_mapbasicblocks((struct basilysmapbasicblocks_st*)(" map ")))")
;; get an entry in a mapbasicblock from a C basicblock
(defprimitive mapbasicblock_get (map :basicblock bb) :value
  "(basilys_get_mapbasicblocks((" map
  "), (" bb ")))")
;; primitive for making a new map of basicblocks
(defprimitive make_mapbasicblock (discr :long len) :value
  " (basilysgc_new_mapbasicblocks( (basilysobject_ptr_t) (" discr "), (" len ")))")
;; primitive for putting into a map of basicblocks
(defprimitive mapbasicblock_put (map :basicblock key :value val) :void
  " basilys_put_mapbasicblocks( (struct basilysmapbasicblocks_st *) (" map "), (" key "), (basilys_ptr_t) (" val "))")
;; primivite for removing from a map of basicblocks
(defprimitive mapbasicblock_remove (map :basicblock key) :void
  " basilysgc_remove_mapbasicblocks( (struct basilysmapbasicblocks_st*) (" map "), (" key "))")

;; primitive to get the nth basicblock of a mapbasicblock
(defprimitive mapbasicblock_nth_attr (map :long n) :basicblock
  "(basilys_nthattr_mapbasicblocks((struct basilysmapbasicblocks_st*)(" map "), (int)(" n ")))")
;; primitive to get the nth value of a mapobject
(defprimitive mapbasicblock_nth_val (map :long n) :value
  "(basilys_nthval_mapbasicblocks((struct basilysmapbasicblocks_st*)(" map "), (int)(" n ")))")
(defciterator foreach_mapbasicblock 
  (bbmap)				; startformals
  eachmapbb 				;state symbol
  (:basicblock bbatt :value bbval)	;local formals
  (					;; before expansion
   "/*eachbbmap*/ int " eachmapbb "_rk=0;\n"
   "for (" eachmapbb "_rk=0; " 
   eachmapbb "_rk<basilys_size_mapbasicblocks((struct basilysmapbasicblocks_st*)(" bbmap ")); " eachmapbb "_rk++) {\n"
   "basic_block " eachmapbb "_bb=basilys_nthattr_mapbasicblocks((struct basilysmapbasicblocks_st*)(" bbmap "), " eachmapbb "_rk);\n"
   "if (!" eachmapbb "_bb) continue;\n"
   bbatt " = " eachmapbb "_bb;\n"
   bbval " =basilys_nthval_mapbasicblocks((struct basilysmapbasicblocks_st*)(" bbmap "), " eachmapbb "_rk);\n"
   )
  ( ;;after expansion
   "} /*endeachbbmap*/"
   )
  )

;;;;;;;;;;;;;;;;

(defprimitive is_maptree (map) :long
  "(basilys_magic_discr((basilys_ptr_t)(" map ")) == OBMAG_MAPTREES)")
(defprimitive maptree_size (map) :long
  "(basilys_size_maptrees((struct basilysmaptrees_st*)(" map ")))")
;; primitive to get the attribute count of a maptree
(defprimitive maptree_count (map) :long
  "(basilys_count_maptrees((struct basilysmaptrees_st*)(" map ")))")
;; get an entry in a maptree from a C tree
(defprimitive maptree_get (map :tree bb) :value
  "(basilys_get_maptrees((" map
  "), (" bb ")))")
;; primitive for making a new map of trees
(defprimitive make_maptree (discr :long len) :value
  " (basilysgc_new_maptrees( (basilysobject_ptr_t) (" discr "), (" len ")))")
;; primitive for putting into a map of trees
(defprimitive maptree_put (map :tree key :value val) :void
  " basilys_put_maptrees( (struct basilysmaptrees_st *) (" map "), (" key "), (basilys_ptr_t) (" val "))")
;; primivite for removing from a map of trees
(defprimitive maptree_remove (map :tree key) :void
  " basilysgc_remove_maptrees( (struct basilysmaptrees_st*) (" map "), (" key "))")

;; primitive to get the nth tree of a maptree
(defprimitive maptree_nth_attr (map :long n) :tree
  "(basilys_nthattr_maptrees((struct basilysmaptrees_st*)(" map "), (int)(" n ")))")
;; primitive to get the nth value of a mapobject
(defprimitive maptree_nth_val (map :long n) :value
  "(basilys_nthval_maptrees((struct basilysmaptrees_st*)(" map "), (int)(" n ")))")
(defciterator foreach_maptree 
  (trmap)				; startformals
  eachmaptr 				;state symbol
  (:tree tratt :value trval)	;local formals
  (					;; before expansion
   "/*eachtrmap*/ int " eachmaptr "_rk=0;\n"
   "for (" eachmaptr "_rk=0; " 
   eachmaptr "_rk<basilys_size_maptrees((struct basilysmaptrees_st*)(" trmap ")); " eachmaptr "_rk++) {\n"
   "tree " eachmaptr "_tr=basilys_nthattr_maptrees((struct basilysmaptrees_st*)(" trmap "), " eachmaptr "_rk);\n"
   "if (!" eachmaptr "_tr) continue;\n"
   tratt " = " eachmaptr "_tr;\n"
   trval " =basilys_nthval_maptrees((struct basilysmaptrees_st*)(" trmap "), " eachmaptr "_rk);\n"
   )
  ( ;;after expansion
   "} /*endeachtrmap*/"
   )
  )

;;;;;;;;;;;;;;;;
;;; primitive to push the cfun asociated with a function declaration
;;; this is required otherwise dump of gimple crashes
(defprimitive push_cfun_decl (:tree fundecl) :void
"push_cfun(DECL_STRUCT_FUNCTION(" fundecl "))")
(defprimitive pop_cfun () :void
"pop_cfun()")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; Parma Polyhedra Library stuff (aka PPL)
(defprimitive ppl_new_empty_constraint_system (discr) :value
  "basilysgc_new_ppl_constraint_system((" 
  discr "), BASILYS_PPL_EMPTY_CONSTRAINT_SYSTEM)")

(defprimitive ppl_new_unsatisfiable_constraint_system (discr) :value
  "basilysgc_new_ppl_constraint_system((" 
  discr "), BASILYS_PPL_UNSATISFIABLE_CONSTRAINT_SYSTEM)")

(defprimitive ppl_ppstrbuf (sbuf ppl :long indent :value varnamvect) :void
  "basilysgc_ppstrbuf_ppl_varnamvect ((" sbuf "), (" indent "), (" ppl "), (" varnamvect "))")

(defprimitive ppl_coefficient_from_tree (:tree tr) :ppl_coefficient
  "(basilys_make_ppl_coefficient_from_tree(" tr "))")

(defprimitive ppl_coefficient_from_long (:long l) :ppl_coefficient
  "(basilys_make_ppl_coefficient_from_long(" l "))")

(defprimitive ppl_delete_Coefficient (:ppl_coefficient coef) :void
  "{ if (" coef ") ppl_delete_Coefficient(" coef "); " coef "=NULL;}")

(defprimitive make_ppl_linear_expression () :ppl_linear_expression
  "basilys_make_ppl_linear_expression()")

(defprimitive ppl_delete_Linear_Expression (:ppl_linear_expression liex) :void
"{ if (" liex ") ppl_delete_Linear_Expression(" liex "); " liex "=NULL;}")

(defprimitive ppl_delete_Constraint (:ppl_constraint cons) :void
  "{ if (" cons ") ppl_delete_Constraint(" cons "); " cons "=NULL;}")

(defprimitive ppl_Linear_Expression_add_to_coefficient 
  (:ppl_linear_expression liex 
   :long vardim
   :ppl_coefficient coef) :void
"{ if ((" liex ") && (" coef ")) ppl_Linear_Expression_add_to_coefficient((" liex "), (" vardim "), (" coef ")); else debugeprintf(\"failed ppl_Linear_Expression_coefficient\");}")

(defprimitive ppl_Linear_Expression_add_to_inhomogeneous
  (:ppl_linear_expression liex :ppl_coefficient coef) :void
"{ if ((" liex ") && (" coef ")) ppl_Linear_Expression_add_to_inhomogeneous((" liex "), (" coef ")); }")

(defprimitive make_ppl_constraint 
  (:ppl_linear_expression liex
   :cstring constyp) :ppl_constraint
"basilys_make_ppl_constraint_cstrtype((" liex "), (" constyp "))")

(defprimitive clear_special (v) :void
  "basilys_clear_special(" v ")")

(defprimitive insert_ppl_constraint_in_boxed_system 
  (:ppl_constraint cons :value sysv) :void
  "basilys_insert_ppl_constraint_in_boxed_system((" cons "), (" sysv "))")

(defprimitive debug_ppl_coefficient
  (:cstring msg :ppl_coefficient coef) :void
"if (flag_basilys_debug) {char*s=0; ppl_io_asprint_Coefficient(&s, " coef "); debugeprintf(\"debug_ppl_coefficient %s @%p %s\", " msg ", (void*)" coef ", s); free(s);}")

(defprimitive debug_ppl_linear_expression
  (:cstring msg :ppl_linear_expression liex) :void
"if (flag_basilys_debug) {char*s=0; ppl_io_asprint_Linear_Expression(&s, " liex "); debugeprintf(\"debug_ppl_linear_expression %s @%p %s\", " msg ", (void*)" liex ", s); free(s);}")

(defprimitive debug_ppl_constraint (:cstring msg :ppl_constraint cons) :void
  "if (flag_basilys_debug) {char*s=0; ppl_io_asprint_Constraint(&s, " cons "); debugeprintf(\"debug_ppl_constraint %s @%p %s\", " msg ", (void*)" cons ", s); free(s);}")
  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; DEBUG OUTPUT 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; boxed gimple debug
(defun dbgout_boxgimple_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (let ( (dis (discrim self)) 
	 (sbuf  (unsafe_get_field :dbgi_sbuf dbgi)) ) 
    (add2sbuf_strconst sbuf " ?/")
    (if (is_a dis class_named) (add2sbuf_string sbuf (unsafe_get_field :named_name dis)))
    (add2sbuf_strconst sbuf "/{")
    (ppstrbuf_gimple sbuf depth (gimple_content self))
    (add2sbuf_strconst sbuf "}/ ")
    )
  )
(install_method discr_gimple dbg_output dbgout_boxgimple_method)

;;;; boxed gimple seq debug
(defun dbgout_boxgimpleseq_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (let ( (dis (discrim self)) 
	 (sbuf  (unsafe_get_field :dbgi_sbuf dbgi)) ) 
    (add2sbuf_strconst sbuf " ?/")
    (if (is_a dis class_named) (add2sbuf_string sbuf (unsafe_get_field :named_name dis)))
    (add2sbuf_strconst sbuf "/{")
    (ppstrbuf_gimple_seq sbuf depth (gimpleseq_content self))
    (add2sbuf_strconst sbuf "}/ ")
    )
  )
(install_method discr_gimpleseq dbg_output dbgout_boxgimpleseq_method)

;;;; boxed tree debug
(defun dbgout_boxtree_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (let ( (dis (discrim self)) 
	 (sbuf  (unsafe_get_field :dbgi_sbuf dbgi)) ) 
    (add2sbuf_strconst sbuf " ?/")
    (if (is_a dis class_named) (add2sbuf_string sbuf (unsafe_get_field :named_name dis)))
    (add2sbuf_strconst sbuf "/{")
    (ppstrbuf_tree sbuf depth (tree_content self))
    (add2sbuf_strconst sbuf "}/ ")
    )
  )
(install_method discr_tree dbg_output dbgout_boxtree_method)

;;;; boxed basicblock debug
(defun dbgout_boxbasicblock_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (let ( (dis (discrim self)) 
	 (sbuf  (unsafe_get_field :dbgi_sbuf dbgi)) ) 
    (add2sbuf_strconst sbuf " ?/")
    (if (is_a dis class_named) (add2sbuf_string sbuf (unsafe_get_field :named_name dis)))
    (add2sbuf_strconst sbuf "/{")
    (ppstrbuf_basicblock sbuf depth (basicblock_content self))
    (add2sbuf_strconst sbuf "}/ ")
    )
  )
(install_method discr_basicblock dbg_output dbgout_boxbasicblock_method)



;;;; basicblockmap debug
(defun dbgout_mapbasicblock_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (assert_msg "check self" (is_mapbasicblock self))
  (let ( (dis (discrim self)) 
	 (:long mapcount (mapbasicblock_count self))
	 (sbuf  (unsafe_get_field :dbgi_sbuf dbgi)) ) 
    (add2sbuf_strconst sbuf " !bbmap.")
    (if (is_a dis class_named) (add2sbuf_string sbuf (unsafe_get_field :named_name dis)))
    (add2sbuf_strconst sbuf "/")
    (add2sbuf_longdec sbuf mapcount)
    (add2sbuf_strconst sbuf "!{")
    (foreach_mapbasicblock
     (self)
     (:basicblock bbatt :value bbval)
     (add2sbuf_indentnl sbuf (+i depth 1))
     (add2sbuf_strconst sbuf "*")
     (ppstrbuf_basicblock sbuf (+i depth 1) bbatt)
     (add2sbuf_strconst sbuf " == ")
     (dbg_out bbval dbgi (+i depth 2))
     )
    (add2sbuf_strconst sbuf "}!")
    (add2sbuf_indentnl sbuf depth)
    ))
(install_method discr_mapbasicblocks dbg_output dbgout_mapbasicblock_method)


;;;; treemap debug
(defun dbgout_maptree_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (assert_msg "check self" (is_maptree self))
  (let ( (dis (discrim self)) 
	 (:long mapcount (maptree_count self))
	 (sbuf  (unsafe_get_field :dbgi_sbuf dbgi)) ) 
    (add2sbuf_strconst sbuf " !bbmap.")
    (if (is_a dis class_named) (add2sbuf_string sbuf (unsafe_get_field :named_name dis)))
    (add2sbuf_strconst sbuf "/")
    (add2sbuf_longdec sbuf mapcount)
    (add2sbuf_strconst sbuf "!{ ")
    (foreach_maptree
     (self)
     (:tree tratt :value trval)
     (add2sbuf_indentnl sbuf (+i depth 1))
     (add2sbuf_strconst sbuf "*")
     (ppstrbuf_tree sbuf (+i depth 1) tratt)
     (add2sbuf_strconst sbuf " == ")
     (dbg_out trval dbgi (+i depth 2))
     )
    (add2sbuf_strconst sbuf "}!")
    (add2sbuf_indentnl sbuf depth)
    ))
(install_method discr_maptrees dbg_output dbgout_maptree_method)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;; G C C      P A S S E S 
;; the named_name of passes is builtin in gcc/basilys.c [lowercase]


;;;;;;;;;;;;;;;;;; lowering pass
;; the CFG is available, but the tree is not in SSA form
(definstance basilys_lowering_gccpass 
  class_gcc_pass
  :named_name (make_stringconst discr_string "basilys-lowering")
  :gccpass_data ()
)
(install_gcc_pass basilys_lowering_gccpass)

;;;;;;;;;;;;;;;;;; ipa (interprocedural analysis) pass
;; the CFG is available & tree is in SSA form
(definstance basilys_ipa_gccpass 
  class_gcc_pass
  :named_name (make_stringconst discr_string "basilys-ipa")
  :gccpass_gate ()
  :gccpass_exec ()
  :gccpass_data ()
)
(install_gcc_pass basilys_ipa_gccpass)


;;;;;;;;;;;;;;;;;; early optimisation pass
;; code in SSA
(definstance basilys_earlyopt_gccpass
  class_gcc_pass
  :named_name (make_stringconst discr_string "basilys-earlyopt")
  :gccpass_data ()
)
(install_gcc_pass basilys_earlyopt_gccpass)

;;;;;;;;;;;;;;;;;; late optimisation pass
;; code in SSA, soon to be removed
(definstance basilys_lateopt_gccpass class_gcc_pass
  :named_name (make_stringconst discr_string "basilys-lateopt")
  :gccpass_data ()
)
(install_gcc_pass basilys_lateopt_gccpass)


;;;;;;;;;;;;;;;;;; late ssa pass
;; code in SSA, soon to be removed
(definstance basilys_latessa_gccpass class_gcc_pass
  :named_name (make_stringconst discr_string "basilys-latessa")
  :gccpass_data ()
)
(install_gcc_pass basilys_latessa_gccpass)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; iterators needed in our analysis

;;; an iterator is simply something which translates to a for loop in
;;; C. It usually binds some variables (local to the iterated body)
;;; to some C stuff.

;;; Be careful to not declare any iterator related stuff in
;;; warmelt*.bysl file, because we want to be able to bootstrap
;;; Basilys/MELT (ie to generate the warmelt*.c files) even when GCC
;;; internal representation changes a little.

;;;;;;;;;;;;;;;;
;;;; iterate on every cgraph_node which is a function with a body
(defciterator each_cgraph_fun_body 
  ()					; startformals
  eachcgrfun 				;state symbol
  (:tree funtree :gimpleseq funbody)	;local formals
  (					;; before expansion
   "struct cgraph_node *" eachcgrfun "_nd=0; "
   "for (" eachcgrfun "_nd = cgraph_nodes; "
   eachcgrfun "_nd != 0; "
   eachcgrfun "_nd = " eachcgrfun "_nd->next) {\n"
   "tree " eachcgrfun "_dcl = 0;\n"
   "gimple_seq " eachcgrfun "_bdy = 0;\n"
  ; "if (flag_basilys_debug) "
  ; "{ debugeprintf(\"" eachcgrfun " nd=%p\", (void*)"  eachcgrfun "_nd);"
  ; "debug_cgraph_node(" eachcgrfun "_nd);};\n"
   eachcgrfun "_dcl = " eachcgrfun "_nd->decl;\n"
   "if (!" eachcgrfun "_dcl) continue;\n"
   "if (TREE_CODE(" eachcgrfun "_dcl) != FUNCTION_DECL) continue;\n"
   eachcgrfun "_bdy = gimple_body(" eachcgrfun "_dcl);\n"
   "if (!" eachcgrfun "_bdy) continue;\n"
   funtree " = " eachcgrfun "_dcl;\n"
   funbody " = " eachcgrfun "_bdy;\n"
   )
  ( ;;after expansion
   "}"
   )
  )


;;; iterate on every cgraph_node which is a function with a CFG and an
;;; entryblock
(defciterator each_cgraph_fun_entryblock
  ()					;startformals
  eachcgrblo				;state symbol
  (:tree funtree :basicblock funbb)	;local formals
  (					;before expansion
   "struct cgraph_node *" eachcgrblo "_nd=0; "
   "for (" eachcgrblo "_nd = cgraph_nodes; "
   eachcgrblo "_nd != 0; "
   eachcgrblo "_nd = " eachcgrblo "_nd->next) {\n"
   "tree " eachcgrblo "_dcl = 0;\n"
   "basic_block " eachcgrblo "_bb = 0;\n"
   "struct function *" eachcgrblo "_fun = 0;\n"
 ;  "if (flag_basilys_debug) "
 ;  "{ debugeprintf(\"" eachcgrblo " nd=%p\", (void*)"  eachcgrblo "_nd);"
 ;  "debug_cgraph_node(" eachcgrblo "_nd);};\n"
   eachcgrblo "_dcl = " eachcgrblo "_nd->decl;\n"
   "if (!" eachcgrblo "_dcl) continue;\n"
   "if (TREE_CODE(" eachcgrblo "_dcl) != FUNCTION_DECL) continue;\n"
   eachcgrblo "_fun = DECL_STRUCT_FUNCTION("eachcgrblo "_dcl);\n"
   "if (!"eachcgrblo "_fun) continue;\n"
   eachcgrblo "_bb = ENTRY_BLOCK_PTR_FOR_FUNCTION(" eachcgrblo "_fun);\n"
   "if (!" eachcgrblo "_bb) continue;\n"
   funtree " = " eachcgrblo "_dcl;\n"
   funbb " = " eachcgrblo "_bb;\n"
   )
  (					;after expansion
   "}"
   )
)


;;; iterate on evey basicblock of the current cfun
(defciterator each_bb_cfun
  ()					;startformals
  eachbbcfun				;state symbol
  (					;local formals
   :basicblock cfunbb 
   :tree cfundecl
   )	
  (					;before expansion
   "/*start " eachbbcfun "*/\n"
   "basic_block " eachbbcfun  "_bb=NULL;\n"
   ; "debugeprintf(\" each_bb_cfun " eachbbcfun " cfun=%p\", cfun);\n"
   "if (cfun) {\n"
   " " cfundecl " = cfun->decl;\n"
   " FOR_EACH_BB_FN("eachbbcfun "_bb, cfun) {"
   "  if (flag_basilys_debug) { debugeprintf(\"each_bb_cfun " 
   eachbbcfun  "_bb =%p\", (void*)" eachbbcfun "_bb);\n"
   "    debug_bb(" eachbbcfun "_bb);};\n"
   "  if (!" eachbbcfun "_bb) continue;\n"
   "  " cfunbb " = " eachbbcfun "_bb;\n"
   )
  (					;after expansion
   ; "debugeprintf(\" each_bb_cfun " eachbbcfun " done cfun=%p\", cfun);\n"
   "}}/*end " eachbbcfun "*/\n"
   )
  )


(defprimitive debugtree (:cstring msg :tree tr) :void
  " do{debugeprintfnonl(\"debugtree %s @%p /%s. \", " msg ", (void*)" tr ", "
  "(" tr ")?tree_code_name[TREE_CODE(" tr ")]:\"*niltree*\");\n"
  "if (flag_basilys_debug && " tr ") debug_tree(" tr ");}while(0) "
)

(defprimitive debugtreecodenum  (:cstring msg :long opcod) :void
  "debugeprintf(\"debugtreecodenum %s #%ld %s\", " msg ", " opcod ", tree_code_name[" opcod "]);")

(defprimitive debuggimple(:cstring msg :gimple g) :void
  " do{debugeprintfnonl(\"debuggimple %s @%p /%s. \", " msg ", (void*)" g 
  ", ("g ")?gimple_code_name[gimple_code(" g ")]: \"*nil*\");"
  "if (" g " && gimple_location(" g ")) "
  "  debugeprintf_raw(\"{%s:%d} \", LOCATION_FILE(gimple_location(" g ")), LOCATION_LINE(gimple_location(" g ")));"
  "if (flag_basilys_debug && " g ") debug_gimple_stmt(" g ");}while(0) "
)

(defprimitive debuggimpleseq(:cstring msg :gimpleseq gs) :void
  " do{debugeprintf(\"debuggimpleseq %s @%p\", " msg ", (void*)" gs ");"
  "if (flag_basilys_debug && " gs ") debug_gimple_seq(" gs ");}while(0) "
)

(defprimitive debugbasicblock(:cstring msg :basicblock bb) :void
  " do{debugeprintf(\"debugbasicblock %s @%p\", " msg ", (void*)" bb ");"
  "if (flag_basilys_debug && " bb ") debug_bb(" bb ");}while(0) "
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;; gimpleseq iteration
;;;; iterate on a gimpleseq
(defciterator each_in_gimpleseq
  (:gimpleseq gseq)			;start formals
  eachgimplseq
  (:gimple g)				;local formals
  ( ;;; before expansion
   "gimple_stmt_iterator gsi_" eachgimplseq ";\n"
   "if (" gseq ") for (gsi_" eachgimplseq " = gsi_start (" gseq
        "); !gsi_end_p (gsi_" eachgimplseq ");"
   " gsi_next (&gsi_" eachgimplseq ")) {\n"
    g " = gsi_stmt (gsi_" eachgimplseq ");"
   )
  ( ;;; after expansion
   "}"
   )
)

;;;; reverseiterate on a gimpleseq
(defciterator reveach_in_gimpleseq
  (:gimpleseq gseq)			;start formals
  eachgimplseq
  (:gimple g)				;local formals
  ( ;;; before expansion
   "gimple_stmt_iterator gsi_" eachgimplseq ";\n"
   "if (" gseq ") for (gsi_" eachgimplseq " = gsi_last (" gseq "); !gsi_end_p (gsi_" eachgimplseq ");"
   " gsi_prev (&gsi_" eachgimplseq ")) {\n"
    g " = gsi_stmt (gsi_" eachgimplseq ");"
   )
  ( ;;; after expansion
   "}"
   )
)

;; apply a function to each boxed gimple in a gimple seq
(defun do_each_gimpleseq (f :gimpleseq gseq)
  (each_in_gimpleseq 
   (gseq) (:gimple g)
   (let ( (gplval (make_gimple discr_gimple g)) )
     (f gplval)))
)


;; apply a function to each boxed gimple in a gimple seq
(defun do_reveach_gimpleseq (f :gimpleseq gseq)
  (reveach_in_gimpleseq 
   (gseq) (:gimple g)
   (let ( (gplval (make_gimple discr_gimple g)) )
     (f gplval)))
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;; basicblock iteration

(defciterator eachgimple_in_basicblock
  (:basicblock bb)			;start formals
  eachgimpbb
  (:gimple g)				;local formals
  ( ;;; before expansion
   "/* " eachgimpbb "*/ gimple_stmt_iterator gsi_" eachgimpbb ";\n"
   "if (" bb ") for (gsi_" eachgimpbb " = gsi_start_bb (" bb
        "); !gsi_end_p (gsi_" eachgimpbb ");"
   " gsi_next (&gsi_" eachgimpbb ")) {\n"
    g " = gsi_stmt (gsi_" eachgimpbb ");"
   )
  ( ;;; after expansion
   "} /* end " eachgimpbb "*/"
   )
)

(defun do_eachgimple_in_basicblock (f :basicblock bb)
  (eachgimple_in_basicblock 
   (bb) (:gimple g)
   (let ( (gplval (make_gimple discr_gimple g)) )
     (f gplval)))
   )

;;;;;;;;;;;;;;;;;;;;;;;;;;;; gimpleseq iteration
;;;; iterate on a function formal parameters
(defciterator each_param_in_fundecl
  ( :tree fundeclt )			;start formals
  eachparamfun
  ( :tree paramdclt )				;local formals
  ( ;;; before expansion
   "/*eachparaminfunctiondecl*/\n"
   "tree " eachparamfun "_tr=NULL;\n"
   "if ((" fundeclt ") && TREE_CODE(" fundeclt ") == FUNCTION_DECL)\n"
   "for (" eachparamfun "_tr = DECL_ARGUMENTS(" fundeclt "); "
           eachparamfun "_tr != NULL;"
           eachparamfun "_tr = TREE_CHAIN(" eachparamfun "_tr)) {\n"
	   paramdclt " = " eachparamfun "_tr;" 
   )
  ( ;;; after expansion
   "}/*end eachparaminfunctiondecl*/ "
   )
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; small analysis

(defclass class_smallcfun
  :super class_named
  :fields (scfun_decl
	   scfun_entbb
	   ))

(defclass class_smallbb
  :super class_proped
  :fields (sbb_bbcont
	   ))

(defclass class_smallanalysis 
  :super class_analysis_state
  :fields (sman_cfuns			;list of class_smallcfun-s
	   sman_cfundict		;dict of class_smallcfun-s
	   sman_cfuntreemap		;treemap of class_smallcfun-s
	   sman_bbtable			;hashtable bb -> class_smallbb
	   ))

(defclass class_smallabstractenv
  :super class_proped
  :fields (abenv_maptree		;a maptree C ident -> abstract values
	   abenv_parenv			;the parent abstract env
	   abenv_pplconsys		;the PPL constraint system
	   abenv_vectname		;the vector naming PPL variables
))

(defun put_abstrenv (abenv :tree tr :value val)
  (assert_msg "check abenv" (is_a abenv class_smallabstractenv))
  (assert_msg "check tr" tr)
  (maptree_put (get_field :abenv_maptree abenv) tr val)
)

(defun get_abstrenv (abenv :tree tr)
  (assert_msg "check abenv" (is_a abenv class_smallabstractenv))
  (maptree_get (get_field :abenv_maptree abenv) tr)
)

(defun fresh_abstrenv (abpar)
  (assert_msg "check abpar" (is_a abpar class_smallabstractenv))
  (let ( (newabenv (instance class_smallabstractenv
			     :abenv_maptree (make_maptree discr_maptrees 10)
			     :abenv_parenv abpar)) )
    (return newabenv)
))


(defun dbgout_smallabstractenv (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debuginfo))
  (assert_msg "check self" (is_a self class_smallabstractenv))
  (let ( (dis (discrim self)) 
	 (sbuf  (unsafe_get_field :dbgi_sbuf dbgi)) 
	 (:long oserial (obj_serial self))
	 (:long onum (obj_num self)) 
	 ) 
    (add2sbuf_strconst sbuf "|")
    (add2sbuf_string sbuf (get_field :named_name dis))
    (add2sbuf_strconst sbuf "/")
    (add2sbuf_longhex sbuf (obj_hash self))
    (if onum
	(progn
	  (add2sbuf_strconst sbuf "#")
	  (add2sbuf_longdec sbuf onum)))
    (if oserial
	(progn
	  (add2sbuf_strconst sbuf "##")
	  (add2sbuf_longdec sbuf oserial)))
    (add2sbuf_strconst sbuf "{")
    (let ( (:long offpar (get_int abenv_parenv)) 
	   (:long offvnam (get_int abenv_vectname)) 
	   (:long oldmaxdepth (get_int (unsafe_get_field :dbgi_maxdepth dbgi)))
	   (:long newmaxdepth  (-i (/i oldmaxdepth 2) 1))
	   )
      (if (<i newmaxdepth 0) (setq newmaxdepth 0))
      (if (need_dbglim depth oldmaxdepth)
	  (progn
	    (and (>i depth 0) (>i oldmaxdepth 3)
		 (put_int (unsafe_get_field :dbgi_maxdepth dbgi) newmaxdepth))
	    (dbgout_fields self dbgi (+i depth 1) 0 offpar)
	    ;(add2sbuf_indentnl sbuf depth)
	    (add2sbuf_strconst sbuf "@ppl.cons.sys@[")
	    (ppl_ppstrbuf sbuf 
			  (get_field :abenv_pplconsys self)
			  depth 
			  (get_field :abenv_vectname self))
	    (add2sbuf_strconst sbuf "]@")
	    (add2sbuf_indentnl sbuf depth)
	    (if (need_dbglim (+i depth 2) newmaxdepth)
		(dbgout_fields self dbgi (+i depth 2) offvnam -1)
	      (add2sbuf_strconst sbuf ".._.."))
	    (put_int (unsafe_get_field :dbgi_maxdepth dbgi) oldmaxdepth)
	    )))
    (add2sbuf_strconst sbuf "}")
    )
  )
(install_method class_smallabstractenv dbg_output dbgout_smallabstractenv)

(definstance initial_smallabstractenv class_smallabstractenv
  :abenv_maptree (make_maptree discr_maptrees 20))

(definstance smallana_cont class_container)


(defun smallana_cfun_entbb (sman :tree decltree :basicblock bbent)
  (debug_msg sman "smallana_cfun_entbb sman")
  (debugtree "smallana_cfun_entbb start decltree" decltree)
  (match 
   decltree
   ;; the joker below is acutally nil
   ( ?(tree_function_decl ?funam ?(tree_block ?treevars ?_))
      (debugtree "smallana_cfun_entbb treevars of function" treevars)
      (push_cfun_decl decltree)
      ;;;;;
      (each_param_in_fundecl
       (decltree)
       (:tree argdtree)
       (debugtree "smallana_cfun_entbb argdtree" argdtree)
       (match 
	argdtree
	( ?(tree_parm_decl ?(as ?argdtype ?(tree_integer_type ?typname ?imin ?imax)) ?argdcl ?argname)
	   (debugtree "smallana_cfun_entbb integer argdtype" argdtype)
	   (debugcstring "smallana_cfun_entbb integer argname" argname)
	   (debugcstring "smallana_cfun_entbb integer typname" typname)
	   (messagenum_dbg  "smallana_cfun_entbb integer imin" imin)
	   (messagenum_dbg  "smallana_cfun_entbb integer imax" imax)
	   )
	( ?(tree_parm_decl ?argdtype ?argdcl ?argname)
	   (debugtree "smallana_cfun_entbb argdtype" argdtype)
	   (debugtree "smallana_cfun_entbb argdcl" argdcl)
	   (debugcstring "smallana_cfun_entbb argname" argname)
	   )
	( ?_ 
	  ;; (assert_msg "unexpected argdtree" ())	  
	  (shortbacktrace_dbg "unexpected tree in smallana_cfun_entbb" 12)
	  )
	)
       (debugtree "smallana_cfun_entbb argdecltree" argdtree)
       )
      ;;;;
      (let ( (fname (make_stringconst discr_string funam)) 
	    (scf (instance class_smallcfun
			    :named_name fname
			    :scfun_decl (make_tree discr_tree decltree)
			    :scfun_entbb (make_basicblock discr_basicblock bbent)))
	     )
	(debug_msg fname "smallana_cfun_entbb fname")
	(list_append (get_field :sman_cfuns sman) scf)
	(mapstring_putstr (get_field :sman_cfundict sman) fname scf)
	(maptree_put (get_field :sman_cfuntreemap sman) decltree scf)
	)
      (pop_cfun)
      )
   ( ?(tree_variable_decl ?_)
      (debugtree  "smallana_cfun_entbb decl of variable" decltree)
      (inform_at_tree decltree "smallana: global variable not analyzed")
      )
   ( ?_
     (debugtree "smallana_cfun_entbb other decl" decltree)
     (inform_at_tree decltree "smallana: other declaration not analyzed")
     ;; (assert_msg "smallana_cfun_entbb @$@UNIMPLEMENTED DECL" ())
     (shortbacktrace_dbg "smallana_cfun_entbb unexepcted declree" 14)
     () )
   )
  (debug_msg sman "smallana_cfun_entbb sman")
  )


(defun smallana_gimple (sman :gimple g)
  (debuggimple "smallana_gimple gimple" g)
  (match 
   g
   ( ?(gimple_assign_single ?lhs ?rhs)
      (debugtree "smallana_gimple gimple_assign_single lhs" lhs)
      (debugtree "smallana_gimple gimple_assign_single rhs" rhs)
      )
   ( ?(gimple_assign_cast ?lhs ?rhs)
      (debugtree "smallana_gimple gimple_assign_cast lhs" lhs)
      (debugtree "smallana_gimple gimple_assign_cast rhs" rhs)
      )
   ( ?(gimple_assign_copy ?lhs ?rhs)
      (debugtree "smallana_gimple gimple_assign_copy lhs" lhs)
      (debugtree "smallana_gimple gimple_assign_copy rhs" rhs)
      )
   ( ?(gimple_assign_ssa_name_copy ?lhs ?rhs)
      (debugtree "smallana_gimple gimple_assign_ssa_name_copy lhs" lhs)
      (debugtree "smallana_gimple gimple_assign_ssa_name_copy rhs" rhs)
      )
   ( ?(gimple_assign_unary_nop ?lhs ?rhs)
      (debugtree "smallana_gimple gimple_assign_unary_nop lhs" lhs)
      (debugtree "smallana_gimple gimple_assign_unary_nop rhs" rhs)
      )
   ( ?(gimple_assign_plus ?lhs ?rhs1 ?rhs2)
      (debugtree "smallana_gimple gimple_assign_plus lhs" lhs)
      (debugtree "smallana_gimple gimple_assign_plus rhs1" rhs1)
      (debugtree "smallana_gimple gimple_assign_plus rhs2" rhs2)
      )
   ( ?(gimple_assign_pointerplus ?lhs ?rhs1 ?rhs2)
      (debugtree "smallana_gimple gimple_assign_pointerplus lhs" lhs)
      (debugtree "smallana_gimple gimple_assign_pointerplus rhs1" rhs1)
      (debugtree "smallana_gimple gimple_assign_pointerplus rhs2" rhs2)
      )
   ( ?(gimple_assign_mult ?lhs ?rhs1 ?rhs2)
      (debugtree "smallana_gimple gimple_assign_mult lhs" lhs)
      (debugtree "smallana_gimple gimple_assign_mult rhs1" rhs1)
      (debugtree "smallana_gimple gimple_assign_mult rhs2" rhs2)
      )
   ( ?(gimple_assign_binaryop ?lhs ?rhs1 ?rhs2 ?opcod)
      (debugtree "smallana_gimple gimple_assign_binaryop lhs" lhs)
      (debugtree "smallana_gimple gimple_assign_binaryop rhs1" rhs1)
      (debugtree "smallana_gimple gimple_assign_binaryop rhs2" rhs2)
      (debugtreecodenum  "smallana_gimple gimple_assign_binaryop opcod" opcod)
      ;;(shortbacktrace_dbg "smallana_gimple gimple_assign_binaryop unexpected" 15)
      (assert_msg "smallana_gimple gimple_assign_binaryop unhandled" ())
      )
   ( ?(gimple_cond_lessequal ?lhs ?rhs ?truelab ?falselab)
      (debugtree "smallana_gimple gimple_cond_lessequal lhs" lhs)
      (debugtree "smallana_gimple gimple_cond_lessequal rhs" rhs)
      (debugtree "smallana_gimple gimple_cond_lessequal truelab" truelab)
      (debugtree "smallana_gimple gimple_cond_lessequal falselab" falselab)
      (shortbacktrace_dbg "@$@unimplemented smallana_gimple gimple_cond_lessequal" 15)
      )
   ( ?(gimple_cond_notequal ?lhs ?rhs ?truelab ?falselab)
      (debugtree "smallana_gimple gimple_cond_notequal lhs" lhs)
      (debugtree "smallana_gimple gimple_cond_notequal rhs" rhs)
      (debugtree "smallana_gimple gimple_cond_notequal truelab" truelab)
      (debugtree "smallana_gimple gimple_cond_notequal falselab" falselab)
      (shortbacktrace_dbg "@$@unimplemented smallana_gimple gimple_cond_notequal" 15)
      )
   ( ?(gimple_cond_greater ?lhs ?rhs ?truelab ?falselab)
      (debugtree "smallana_gimple gimple_cond_greater lhs" lhs)
      (debugtree "smallana_gimple gimple_cond_greater rhs" rhs)
      (debugtree "smallana_gimple gimple_cond_greater truelab" truelab)
      (debugtree "smallana_gimple gimple_cond_greater falselab" falselab)
      (shortbacktrace_dbg "@$@unimplemented smallana_gimple gimple_cond_greater" 15)
      )
   ( ?(gimple_cond_true ?truelab ?falselab)
      (debugtree "smallana_gimple gimple_cond_true truelab" truelab)
      (debugtree "smallana_gimple gimple_cond_true falselab" falselab)
      (shortbacktrace_dbg "@$@unimplemented smallana_gimple gimple_cond_true" 15)
      )
   ( ?(gimple_call ?lhs ?fndecl ?_)
      (debugtree "smallana_gimple gimple_call lhs" lhs)
      (debugtree "smallana_gimple gimple_call fndecl" fndecl)
      (shortbacktrace_dbg "@$@unimplemented smallana_gimple gimple_call" 15)
      )
   ( ?(gimple_return ?retval)
      (debugtree "smallana_gimple gimple_return retval" retval)
      (shortbacktrace_dbg "@$@unimplemented smallana_gimple gimple_return" 15)
      )
   ( ?_
     (debuggimple "smallana_gimple other!gimple" g)
     ;;(shortbacktrace_dbg "smallana_gimple unexpected gimple" 15)
     (assert_msg "smallana_gimple @$@ UNIMPLEMENTED GIMPLE" ())
     )
   )
  )

(defun smallana_bb (sman :basicblock bb)
  (debug_msg sman "smallana_bb start sman")
  (assert_msg "check sman" (is_a sman class_smallanalysis))
  (debugbasicblock "smallana_bb bb" bb)
  (let ( (bbtab (get_field :sman_bbtable sman)) 
	 )
    (assert_msg "check bbtab" (is_mapbasicblock bbtab))
    (let ( (sbb (mapbasicblock_get bbtab bb)) )
      (if sbb (return))
      (setq sbb (instance class_smallbb
			  :sbb_bbcont (make_basicblock discr_basicblock bb)))
      (mapbasicblock_put bbtab bb sbb)
      (eachgimple_in_basicblock 
       (bb)
       (:gimple g)
       (smallana_gimple sman g)
       )
      (debug_msg sman "smallana_bb end sman")
      )))


(defun smallana_cfun_bb (sman :tree cfdecl :basicblock fbb)
  (debug_msg sman "smallana_bb_cfun start sman")
  (debugtree "smallana_bb_cfun cfdecl" cfdecl)
  (assert_msg "check sman" (is_a sman class_smallanalysis))
  (match cfdecl
	 ( ?(as ?decltree ?(tree_function_decl ?funam ?(tree_block ?treevars ?_)))
	    (debugtree "smallana_bb_cfun decltree" decltree)
	    (debugtree "smallana_bb_cfun treevars of function" treevars)
	    (debugcstring "smallana_cfun_entrybb funam" funam)
	    ))
  (smallana_bb sman fbb)
  (debug_msg sman "smallana_bb_cfun end sman")
  )


(defun smaninterp_cfun (sman abenv cfun)
  (debug_msg sman "smaninterp_fun sman")
  (debug_msg cfun "smaninterp_fun cfun")
  (debug_msg abenv "smaninterp_fun abenv")
  (assert_msg "check sman" (is_a sman class_smallanalysis))
  (assert_msg "check abenv" (is_a abenv class_smallabstractenv))
  (assert_msg "check cfun" (is_a cfun class_smallcfun))
  (let ( (:basicblock bbent 
		      (basicblock_content (get_field :scfun_entbb cfun)))
	 (:tree fundecl (tree_content (get_field :scfun_decl cfun)))
	 )
    (push_cfun_decl fundecl)
    (smaninterp_basicblock sman abenv bbent)
    ;(assert_msg "@$@unimplemented smaninterp_fun" ())
    (shortbacktrace_dbg "@$@unimplemented smaninterp_fun" 15)
    (pop_cfun)
    ))


(defun smaninterp_basicblock (sman abenv :basicblock bb)
  (debug_msg abenv "smaninterp_basicblock abenv")
  (assert_msg "check sman" (is_a sman class_smallanalysis))
  (assert_msg "check abenv" (is_a abenv class_smallabstractenv))
  (forever 
   bbloop
   (debugbasicblock "smaninterp_basicblock bb" bb)
   (if (null_basicblock bb)
       (exit bbloop))
   (eachgimple_in_basicblock 
    (bb)
    (:gimple g)
    (debuggimple "smaninterp_basicblock g" g)
    (smaninterp_gimple sman abenv g bb)
    )
   (setq bb (basicblock_single_succ bb))
   (debugbasicblock "smaninterp_basicblock succ bb" bb)
   )
  (debug_msg () "smaninterp_basicblock done")
  ;(assert_msg "@$@unimplemented smaninterp_basicblock" ())
  (shortbacktrace_dbg "@$@unimplemented smaninterp_basicblock" 15)
  )


;;;;;;;;;;;;;;;;
(defun sman_propagate_constraints_call (abenv newabenv tupvarbind)
  (debug_msg tupvarbind "sman_propagate_constraints_call tupvarbind")
  (assert_msg "check newabenv" (is_a newabenv class_smallabstractenv))
  (let ( (pplvarslist (make_list discr_list)) 
	 (pplconsysval (ppl_new_empty_constraint_system discr_ppl_constraint_system))
	 (:long nbpplvars 0)
	 )
    (debug_msg pplconsysval "sman_propagate_constraints_call pplconsysval")
    (foreach_in_multiple
     (tupvarbind)
     (curvarbind :long bindix)
     (debug_msg curvarbind "sman_propagate_constraints_call curvarbind")
     (let ( (:tree parmtype (tree_content (multiple_nth curvarbind 0)))
	    (parmdeclval (multiple_nth curvarbind 1))
	    (:tree parmdecl (tree_content parmdeclval))
	    (:tree curarg (tree_content (multiple_nth curvarbind 2)))
	    )
       (debugtree "sman_propagate_constraints_call parmtype" parmtype)
       (debugtree "sman_propagate_constraints_call parmdecl" parmdecl)
       (debugtree "sman_propagate_constraints_call curarg" curarg)
       (messagenum_dbg  "sman_propagate_constraints_call nbpplvars" nbpplvars)
       (match 
	curarg
	( ?(tree_integer_cst ?k)
	   (messagenum_dbg  "sman_propagate_constraints_call curarg const.int. k" k)
	   ;; add the constraint {parmdecl == k}
	   (let (
		 (:ppl_coefficient coefarg (ppl_coefficient_from_tree curarg)) 
		 (:ppl_coefficient coefm1 (ppl_coefficient_from_long -1)) 
		 (:ppl_linear_expression liex (make_ppl_linear_expression))
		 )
	     (debug_ppl_coefficient "sman_propagate_constraints_call coefarg" coefarg)
	     (messagenum_dbg  "sman_propagate_constraints_call nbpplvars" nbpplvars)
	     (ppl_Linear_Expression_add_to_coefficient liex nbpplvars coefm1)
	     (ppl_Linear_Expression_add_to_inhomogeneous liex coefarg)
	     (debug_ppl_linear_expression "sman_propagate_constraints_call liex" liex)
	     (let ( (:ppl_constraint cons (make_ppl_constraint liex "==")) )
	       (debug_ppl_constraint "sman_propagate_constraints_call cons" cons)
	       (insert_ppl_constraint_in_boxed_system cons pplconsysval)
	       (ppl_delete_Constraint cons)
	       )
	     (ppl_delete_Coefficient coefm1)
	     (ppl_delete_Coefficient coefarg)
	     (ppl_delete_Linear_Expression liex)
	     )
	   (setq  nbpplvars (+i nbpplvars 1)) 
	   (list_append pplvarslist parmdeclval)
	   )
	( ?_
	  (assert_msg "sman_propagate_constraints_call @$@unimplemented curarg tree" ())))
       ))
    (put_fields newabenv 
		:abenv_pplconsys pplconsysval
		:abenv_vectname (list_to_multiple pplvarslist))
    )
  (debug_msg newabenv "sman_propagate_constraints_call final newabenv")
  )

;;;;;;;;;;;;;;;;
(defun smaninterp_gimple  (sman abenv :gimple g :basicblock bb)
  (assert_msg "check sman" (is_a sman class_smallanalysis))
  (assert_msg "check abenv" (is_a abenv class_smallabstractenv))
  (debug_msg abenv "smaninterp_gimple abenv")
  (debuggimple "smaninterp_gimple g" g)
  (debugbasicblock "smaninterp_gimple bb" bb)
;; we really should count the number of times we are calling
;; smaninterp_gimple and returns immediately with a warning if calling
;; too often/too deeply. The point is that an small analysis of a
;; buggy program could make the compiler loop.
  (compile_warning "we should check that we don't call too often or too deeply in smaninterp_gimple" ())
  (match 
   g
   ;; handle calls
   (?(gimple_call ?lhs ?fndecl ?nargs)
     (debugtree "smaninterp_gimple call lhs" lhs)
     (debugtree "smaninterp_gimple call fndecl" fndecl)
     (let ( (:long argix 0) 
	    (newabenv (fresh_abstrenv abenv))
	    (tupvarbind (make_multiple discr_multiple nargs))
	    )
       (each_param_in_fundecl 
	(fndecl)
	(:tree curparamdcl)
	(messagenum_dbg  "smaninterp_gimple curparamdecl argix" argix)
	(debugtree "smaninterp_gimple curparamdecl" curparamdcl)
	(let ( (:tree curarg (gimple_call_nth_arg g argix)) )
	  (debugtree "smaninterp_gimple curarg" curarg)
	  (match 
	   curparamdcl
	   (?(tree_parm_decl ?parmtype ?parmdecl ?parmname)
	     (debugtree "smaninterp_gimple parmtype" parmtype)
	     (debugtree "smaninterp_gimple parmdecl" parmdecl)
	     (debugcstring "smaninterp_gimple parmname" parmname)
	     (multiple_put_nth tupvarbind argix
			       (make_tuple3 discr_multiple 
					    (make_tree discr_tree parmtype)
					    (make_tree discr_tree parmdecl)
					    (make_tree discr_tree curarg)))
	     )
	   (?_ 
	    (assert_msg "inexpected curparamdcl" ())
	    )
	   )
	  (setq argix (+i argix 1))
	  ))
       (debug_msg tupvarbind "smaninterp_gimple tupvarbind")
       (sman_propagate_constraints_call abenv newabenv tupvarbind)
       (debug_msg newabenv "smaninterp_gimple newabenv propagated")
       (debugtree "smaninterp_gimple call should go into fndecl" fndecl)
       (debug_msg sman "smaninterp_gimple sman")
       (let (
	     (calledcfun (maptree_get (get_field :sman_cfuntreemap sman) fndecl)) )
	 (debug_msg calledcfun "smaninterp_gimple calledcfun")
	 (if calledcfun
	     (smaninterp_cfun sman newabenv calledcfun)
	   )
	 )
       (shortbacktrace_dbg "@$@unimplemented smaninterp_gimple call" 15)
       ;(assert_msg "@$@unimplemented smaninterp_gimple call" ())
       )
     )
   ;; handle conditional <=
   ( ?(gimple_cond_lessequal ?lhs ?rhs ?truelab ?falselab)
      (debugtree "smaninterp_gimple cond<= lhs" lhs)
      (debugtree "smaninterp_gimple cond<= rhs" rhs)
      (debugtree "smaninterp_gimple cond<= truelab" truelab)
      (debugtree "smaninterp_gimple cond<= falselab" falselab)
      (shortbacktrace_dbg "@$@unimplemented smaninterp_gimple cond<=" 15)
      ;(assert_msg "@$@unimplemented smaninterp_gimple cond<=" ())
      )
   ;; handle conditional <=
   ( ?(gimple_cond_lessequal ?lhs ?rhs ?truelab ?falselab)
      (debugtree "smaninterp_gimple cond<= lhs" lhs)
      (debugtree "smaninterp_gimple cond<= rhs" rhs)
      (debugtree "smaninterp_gimple cond<= truelab" truelab)
      (debugtree "smaninterp_gimple cond<= falselab" falselab)
      (shortbacktrace_dbg "@$@unimplemented smaninterp_gimple cond<=" 15)
      ;(assert_msg "@$@unimplemented smaninterp_gimple cond<=" ())
      )
   ;; handle conditional <=
   ( ?(gimple_cond_lessequal ?lhs ?rhs ?truelab ?falselab)
      (debugtree "smaninterp_gimple cond<= lhs" lhs)
      (debugtree "smaninterp_gimple cond<= rhs" rhs)
      (debugtree "smaninterp_gimple cond<= truelab" truelab)
      (debugtree "smaninterp_gimple cond<= falselab" falselab)
      (shortbacktrace_dbg "@$@unimplemented smaninterp_gimple cond<=" 15)
      ;(assert_msg "@$@unimplemented smaninterp_gimple cond<=" ())
      )
   ;; handle conditional true
   ( ?(gimple_cond_true ?truelab ?falselab)
      (debugtree "smaninterp_gimple condtrue truelab" truelab)
      (debugtree "smaninterp_gimple condtrue falselab" falselab)
      (shortbacktrace_dbg "@$@unimplemented smaninterp_gimple condtrue" 15)
      ;(assert_msg "@$@unimplemented smaninterp_gimple condtrue" ())
      )
   ;; handle conditional false
   ( ?(gimple_cond_false ?truelab ?falselab)
      (debugtree "smaninterp_gimple condfalse truelab" truelab)
      (debugtree "smaninterp_gimple condfalse falselab" falselab)
      (shortbacktrace_dbg "@$@unimplemented smaninterp_gimple condfalse" 15)
      ;(assert_msg "@$@unimplemented smaninterp_gimple condfalse" ())
      )
   ;; default 
   (?_ 
    (assert_msg "@$@unimplemented smaninterp_gimple" ()))
   )
  )

(defun smallana_interpret (sman)
  (debug_msg sman "smallana_interpret sman")
  (assert_msg "check sman" (is_a sman class_smallanalysis))
  (let ( (mainf (mapstring_rawget (get_field :sman_cfundict sman) "main")) 
	 )
    (debug_msg mainf "smallana_interpret mainf")
    (assert_msg "check mainf" (is_a mainf class_smallcfun))
    (smaninterp_cfun sman initial_smallabstractenv mainf)
    (debug_msg sman "smallana_interpret end sman")
    )
)

;;; our small analysis gate for latessa
;; for some reason, the smallana is triggered twice, and the first run
;; is enough...
(defun smallanapass_gate (latessapass)
  (debug_msg smallana_cont "smallanapass_gate smallana_cont at start")
  (let ( (oldsman (get_field  :container_value smallana_cont)) )
    (if oldsman
	(progn
	  (shortbacktrace_dbg "smallanapass_gate already got oldsman" 20)
	  (debug_msg oldsman "smallanapass_gate already got oldsman")
	  (return ()))
      (return smallana_cont)
      )))


;;; apparently only the entrybb loop matter in the latessa pass...
(defun smallanapass_exec (latessapass)
  (debug_msg latessapass "smallanapass_exec start")
  (let ( (cfuns (make_list discr_list))
	 (cfundict (make_mapstring discr_mapstrings 20))
	 (cfuntreemap (make_maptree discr_maptrees 20))
	 (sman (instance class_smallanalysis
			 :sman_cfuns cfuns
			 :sman_cfundict cfundict
			 :sman_cfuntreemap cfuntreemap
			 :sman_bbtable (make_mapbasicblock discr_mapbasicblocks 20)
			 )) 
	 )
    (debug_msg sman "smallanapass_exec sman at start")
    ;; don't bother do_each_cfun_body here.. it is not done...
    (each_cgraph_fun_entryblock
     ()
     (:tree decl :basicblock bbent)
     (debugtree "smallana exec eachcgraph decl" decl)
     (smallana_cfun_entbb sman decl bbent)
     )
    ;;
    (debug_msg sman "smallanapass_exec sman after eachentrybb")
    ;;
    (each_bb_cfun
     ()
     (:basicblock cfbb :tree cfdecl)
     (smallana_cfun_bb sman cfdecl cfbb)
     )
    ;;
    (debug_msg sman "smallanapass_exec sman after eachbbcfun")
    ;;
    (smallana_interpret sman)
    ;;
    (put_fields  smallana_cont :container_value sman)
    (debug_msg smallana_cont "smallanapass_exec final smallana_cont")
    ))

;;; our small analysis command -fbasilys=smallana
(defun smallana_command (dispatcher arg secarg moduldata)
  ;; fill the ipa pass
  (put_fields basilys_ipa_gccpass
  :gccpass_gate smallanapass_gate
  :gccpass_exec smallanapass_exec)
  (debug_msg basilys_latessa_gccpass "smallana sets basilys_latessa_gccpass")
  (return dispatcher)			;return non-nil to continue compilation
  )

(initial_command_install smallana_command "smallana")



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(export_values
 basilys_earlyopt_gccpass
 basilys_ipa_gccpass
 basilys_lateopt_gccpass
 basilys_latessa_gccpass
 basilys_lowering_gccpass
 each_cgraph_fun_body
 each_cgraph_fun_entryblock
 each_in_gimpleseq
 fetch_gdbmstate
 fetch_gdbmstate_constr
 install_gcc_pass
 put_gdbmstate
 put_gdbmstate_constr
 reveach_in_gimpleseq
)

(export_class
 class_analysis_state
 class_smallcfun
 class_smallanalysis
)
;; eof ana-base.bysl