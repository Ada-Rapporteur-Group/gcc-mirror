; -*- Lisp -*-
;; file warmelt-hooks.melt
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(comment "***
    Copyright 2012 - 2014  Free Software Foundation, Inc.
    Contributed by Basile Starynkevitch <basile@starynkevitch.net>

    This file is part of GCC.

    GCC is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.

    GCC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.
***")

;; the copyright notice above apply both to warmelt-hooks.melt and 
;; to the generated files  warmelt-hooks*.c

;; This MELT module is GPL compatible since it is GPLv3+ licensed.
(module_is_gpl_compatible "GPLv3+")


;;;====================================================================
;;;******************* low level debug at routine *********************
;;;see the melt_low_debug_value macro in melt-runtime.h
(defhook hook_low_debug_value_at (:value val 
				  :cstring filename :long lineno
				  :cstring msg :long count) () :void
  :predef HOOK_LOW_DEBUG_VALUE_AT
  :doc #{$HOOK_LOW_DEBUG_VALUE_AT is an internal hook for the
  melt_low_debug_value macro in @file{melt-runtime.h}. Output on the
  dump file or else the standard errror.}#
  (melt_debug_fun () count filename lineno msg val)
)

(defhook hook_low_stderr_value_at (:value val 
				  :cstring filename :long lineno
				  :cstring msg :long count) () :void
  :predef HOOK_LOW_STDERR_VALUE_AT
  :doc #{$HOOK_LOW_STDERR_VALUE_AT is an internal hook for the
  melt_low_stderr_value macro in @file{melt-runtime.h}. 
  Output always on standard errror.}#
  (block_signals 
   () ()
   (let ( (:long dbgcounter 0)
	  (stderrf (get_field :sysdata_stderr initial_system_data)) 
	  (occmap (make_mapobject discr_map_objects 50))
	  (boxedmaxdepth (constant_box (+i 2 (debug_depth)))) ;;;; @@@ DEBUGDEPTH
	  (dbgi (instance class_debug_information
			  :dbgi_out stderrf
			  :dbgi_occmap occmap
			  :dbgi_maxdepth boxedmaxdepth))
	  (:long framdepth (the_framedepth)) 
	  )
     (code_chunk getdbgcounter 
		 #{/*hook_low_stderr_value_at $GETDBGCOUNTER*/ $DBGCOUNTER = melt_dbgcounter ;
		 }#)
     (add2out_strconst stderrf "!!!!****####")
     (add2out_longdec stderrf dbgcounter)
     (add2out_strconst stderrf "#^")
     (add2out_longdec stderrf (-i framdepth 1))
     (add2out_strconst stderrf ":")
     (when filename
       (add2out_strconst stderrf filename)
       (add2out_strconst stderrf ":")
       (add2out_longdec stderrf lineno)
       (add2out_strconst stderrf ":")
       )
     (add2out_strconst stderrf msg)
     (when (>i count 0) 
       (add2out_strconst stderrf " !")
       (add2out_longdec stderrf count)
       (add2out_strconst stderrf ": ")
       )
     (if val 
	 (dbg_out val dbgi 0)
       (add2out_strconst stderrf "() ;;;NIL!!!")
       )
     (add2out_indentnl stderrf 0)
     ))
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Nota Bene: environment management hooks are so crucial that they
;;; have to be in warmelt-first.melt,
;;; i.e. hook_fresh_environment_reference_maker, hook_value_importer,
;;; hook_value_exporter, hook_macro_exporter, hook_patmacro_exporter...


;;;====================================================================
;;;******************* OVERRIDE_GATE plugin event *********************
(definstance override_gate_delayed_queue class_delayed_queue
  :named_name '"override_gate_delayed_queue"
  :delqu_first (make_list discr_list)
  :delqu_last (make_list discr_list)
)

(defhook hook_override_gate (:long beforegate) (:long aftergate) :void
  :predef HOOK_OVERRIDE_GATE
  :doc #{The internal $HOOK_OVERRIDE_GATE handles
  @t{PLUGIN_OVERRIDE_GATE} events. See $REGISTER_OVERRIDE_GATE_FIRST
  etc...}#
  (debug "hook_override_gate beforegate=" beforegate)
  (let ( 
	(gateflag (if beforegate :true ()))
	(passname ())
	(:long passnum 0)
	(memref (reference ()))
	(revlastlist (make_list discr_list))
	(qufirst (get_field :delqu_first override_gate_delayed_queue))
	(qulast (get_field :delqu_last override_gate_delayed_queue))
	)
    ;; retrieve the passname and pass number
    (code_chunk 
     getpassname_chk 
     #{ /* hook_override_gate $GETPASSNAME_CHK */
     gcc_assert (current_pass != NULL);
     $PASSNAME =  meltgc_new_stringdup
	((meltobject_ptr_t) MELT_PREDEF(DISCR_STRING), current_pass->name);
     $PASSNUM = current_pass->static_pass_number;
     }#)
    ;; call the first closures in natural order
    (debug "hook_override_gate memref=" memref 
	   "\n gateflag=" gateflag
	   "\n override_gate_delayed_queue=" override_gate_delayed_queue
	   "\n passname=" passname " passnum=" passnum)
    ;; apply the first closures in order
    (foreach_pair_component_in_list
     (qufirst)
     (curpair curclo)
     (debug "hook_override_gate first curclo=" curclo " memref=" memref)
     (if (is_closure curclo)
	 (let ( (clores (curclo gateflag memref passname passnum))
		)
	   (debug "hook_override_gate first clores=" clores)
	   (setq gateflag clores)
	 )))
    ;; reverse the last closures list
    (foreach_pair_component_in_list
     (qulast)
     (curlpair curlclo)
     (if (is_closure curlclo)
	 (list_append revlastlist curlclo)))
    ;; apply the last closures in reverse order
    (foreach_pair_component_in_list
     (revlastlist)
     (curlpair curlclo)
     (debug "hook_override_gate last curlclo=" curlclo " memref=" memref)
     (assert_msg "check curlclo" (is_closure curlclo) curlclo)
     (let ( (clores (curlclo gateflag memref passname passnum))
	    )
       (debug "hook_override_gate last clores=" clores)
       (setq gateflag clores)))
    ;;
    (debug "hook_override_gate final gateflag=" gateflag
	   "\n passname=" passname " passnum=" passnum)
    (if gateflag
	(setq aftergate 1)
      (setq aftergate 0))
  )
)

(cheader 
 #{ /* cheader for override gate in warmelt-hooks.melt */
   static void 
   melt_override_gate_callback (void* gccdata, 
				void* userdata ATTRIBUTE_UNUSED)
   {
     bool *pgatestatus = (bool*) gccdata;
     bool gatsta = false;
     long oldgatstalng = 0, newgatstalng = 0;
     gcc_assert (pgatestatus != NULL);
     gatsta = *pgatestatus;
     oldgatstalng = newgatstalng = (long)gatsta;
     melthookproc_HOOK_OVERRIDE_GATE (oldgatstalng, &newgatstalng);
     gatsta = (newgatstalng != 0L);
     *pgatestatus = gatsta;
   } /* end of  melt_override_gate_callback */
 }#)


;; internal flag set when PLUGIN_OVERRIDE_GATE registered

(cheader #{/* flag for PLUGIN_OVERRIDE_GATE */
MELT_EXTERN bool MELT_MODULE_VISIBILITY  melthk_override_gate_registered_flag;
}#)

(cimplement #{/* flag for PLUGIN_OVERRIDE_GATE */
bool  melthk_override_gate_registered_flag;
}#)

;; internal function to enable the plugin hook
(defun enable_override_gate ()
    (code_chunk 
     regpluginoverride_gate_chk
     #{ /* enable_override_gate $REGPLUGINOVERRIDE_GATE_CHK */
     if (!melthk_override_gate_registered_flag) 
       {
         melthk_override_gate_registered_flag = true;
         register_callback (melt_plugin_name, PLUGIN_OVERRIDE_GATE,
			    melt_override_gate_callback,
			    NULL);
       }
     }#)
)

;; internal function to disable the plugin hook
(defun maybe_disable_override_gate ()
  (when (and 
	     (null (list_first (get_field :delqu_first override_gate_delayed_queue)))
	     (null (list_first (get_field :delqu_last override_gate_delayed_queue))))
    (code_chunk
     unregpluginoverride_gate_chk
     #{ /* disable_override_gate $UNREGPLUGINOVERRIDE_GATE_CHK */
     if (melthk_override_gate_registered_flag)
       {
         melthk_override_gate_registered_flag = false;
         unregister_callback (melt_plugin_name, PLUGIN_OVERRIDE_GATE);
       }
     }#)
))

;; public functions to register
(defun register_override_gate_first (clo)
  :doc #{Register a function $CLO for @code{PLUGIN_OVERRIDE_GATE} at first place. 
See also $UNREGISTER_OVERRIDE_GATE_FIRST, $REGISTER_OVERRIDE_GATE_LAST, etc..}#
  (debug "register_override_gate_first clo=" clo)
  (when (is_closure clo)
    (list_append (get_field :delqu_first override_gate_delayed_queue) clo)
    (enable_override_gate)))

(defun register_override_gate_last (clo)
  :doc #{Register a function $CLO for @code{PLUGIN_OVERRIDE_GATE} at last place. 
See also $UNREGISTER_OVERRIDE_GATE_LAST, $REGISTER_OVERRIDE_GATE_FIRST, etc...}#
  (debug "register_override_gate_last clo=" clo)
  (when (is_closure clo)
    (list_append (get_field :delqu_last override_gate_delayed_queue) clo)
    (enable_override_gate)))

(defun unregister_override_gate_first (clo)
  :doc #{Unregister a function $CLO previously registered with
  $REGISTER_OVERRIDE_GATE_FIRST for @code{PLUGIN_OVERRIDE_GATE},
  return the boxed count of removed closures or null on failure.}#
  (debug "unregister_override_gate_first clo=" clo)
  (let ( (oldlis (get_field :delqu_first override_gate_delayed_queue))
	 (newlis (make_list discr_list))
	 (:long count 0)
	 )
    (foreach_pair_component_in_list
     (oldlis)
     (curpair curclo)
     (if (== curclo clo) 
	 (setq count (+i count 1))
       (list_append newlis curclo)))
    (when count
      (put_fields override_gate_delayed_queue :delqu_first newlis)
      (maybe_disable_override_gate)
      (debug "unregister_override_gate_first count=" count)
      (return (constant_box count)))
    (debug "unregister_override_gate_first fail")
    (return ())))

(defun unregister_override_gate_last (clo)
  :doc #{Unregister a function $CLO previously registered with
  $REGISTER_OVERRIDE_GATE_LAST for @code{PLUGIN_OVERRIDE_GATE}, 
  return the boxed count of removed closures or null on failure.}#
  (debug "unregister_override_gate_last clo=" clo)
  (let ( (oldlis (get_field :delqu_last override_gate_delayed_queue))
	 (newlis (make_list discr_list))
	 (:long count 0)
	 )
    (foreach_pair_component_in_list
     (oldlis)
     (curpair curclo)
     (if (== curclo clo) 
	 (setq count (+i count 1))
       (list_append newlis curclo)))
    (when count
      (put_fields override_gate_delayed_queue :delqu_last newlis)
      (maybe_disable_override_gate)
      (debug "unregister_override_gate_last count=" count)
      (return (constant_box count)))
    (debug "unregister_override_gate_last fail")
    (return ())))

;;;====================================================================
;;;******************* START_UNIT plugin event *********************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(cheader #{/* flag for PLUGIN_START_UNIT */
MELT_EXTERN bool MELT_MODULE_VISIBILITY  melthk_start_unit_registered_flag;
}#)

(cimplement #{/* flag for for PLUGIN_START_UNIT */
bool  melthk_start_unit_registered_flag;
}#)

;;;;;; private queue for start of compilation unit
(definstance start_unit_delayed_queue class_delayed_queue
  :named_name '"start_unit_delayed_queue"
  :delqu_first (make_list discr_list)
  :delqu_last (make_list discr_list)
  )

;; this internal hook needs to be predefined to remain alive for the
;; MELT & Ggc garbage collectors...
(defhook hook_start_unit () () :void
  :predef HOOK_START_UNIT
  (let ( (firstlist (unsafe_get_field :delqu_first start_unit_delayed_queue))
	 (lastlist (unsafe_get_field :delqu_last start_unit_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (rescont (instance class_reference))
	 )
;;; call the first routines in natural order
    (list_every 
     firstlist
     (lambda (firstproc)
       (let ( (prevres (unsafe_get_field :referenced_value rescont)) 
	      (nextres (firstproc prevres start_unit_delayed_queue))
	      )
	 (unsafe_put_fields rescont :referenced_value nextres)
	 )))
;;; reverse the last list
    (list_every 
     lastlist 
     (lambda (lastproc)
       (if (is_closure lastproc) (list_prepend revlastlist lastproc))))
;;; call the last routines in reverse order
    (list_every
     revlastlist
     (lambda (lastproc)
       (let ( (prevres (unsafe_get_field :referenced_value rescont)) 
	      (nextres (lastproc prevres start_unit_delayed_queue))
	      )
	 (unsafe_put_fields rescont :referenced_value nextres)
	 )))
    ))

(cheader #{ 
 void MELT_MODULE_VISIBILITY 
    melt_startunithook_callback (void* gcc_data ATTRIBUTE_UNUSED,
				 void* user_data ATTRIBUTE_UNUSED);
 }#)

(cimplement #{
 void 
 melt_startunithook_callback (void* gcc_data ATTRIBUTE_UNUSED,
			      void* user_data ATTRIBUTE_UNUSED)
 {
    melthookproc_HOOK_START_UNIT ();
 }
 }#)

;; internal function to enable the plugin hook
(defun enable_start_unit ()
  (code_chunk 
   enabstartunit_chk
   #{
   if (!melthk_start_unit_registered_flag) 
     {
       melthk_start_unit_registered_flag = true;
       register_callback (melt_plugin_name, PLUGIN_START_UNIT,
			  melt_startunithook_callback,
			  NULL);
     }
   }#)
  )


(defun at_start_unit_first (fun)
  :doc #{Use $AT_START_UNIT_FIRST to register a function to be run at start of translation unit, in first place.}#
  (let ( (firstlist (unsafe_get_field :delqu_first start_unit_delayed_queue))
	 )
    (when (is_closure fun) 
      (enable_start_unit)
      (list_append firstlist fun)))
  )  

(defun at_start_unit_last (fun)
  :doc #{Use $AT_START_UNIT_LAST to register a function to be run at start of translation unit, in first place.}#
  (let ( (lastlist (unsafe_get_field :delqu_last start_unit_delayed_queue))
	 )
    (when (is_closure fun) 
      (enable_start_unit)
      (list_append lastlist fun)))
  )

  
;;;====================================================================
;;;******************* FINISH_UNIT plugin event *********************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;; the private queue for compilation unit finish
(definstance finish_unit_delayed_queue class_delayed_queue
  :named_name '"finish_unit_delayed_queue"
  :delqu_first (make_list discr_list)
  :delqu_last (make_list discr_list)
  )

(cheader #{/* flag for PLUGIN_FINISH_UNIT */
MELT_EXTERN bool MELT_MODULE_VISIBILITY  melthk_finish_unit_registered_flag;
}#)

(cimplement #{/* flag for PLUGIN_FINISH_UNIT */
bool MELT_MODULE_VISIBILITY  melthk_finish_unit_registered_flag;
}#)

(defhook hook_finish_unit () () :void
  :predef HOOK_FINISH_UNIT
  (let ( (firstlist (unsafe_get_field :delqu_first finish_unit_delayed_queue))
	 (lastlist (unsafe_get_field :delqu_last finish_unit_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (rescont (instance class_reference))
	 )
;;; call the first routines in natural order
    (list_every 
     firstlist
     (lambda (firstproc)
       (let ( (prevres (unsafe_get_field :referenced_value rescont)) 
	      (nextres (firstproc prevres finish_unit_delayed_queue))
	      )
	 (unsafe_put_fields rescont :referenced_value nextres)
	 )))
;;; reverse the last list
    (list_every 
     lastlist 
     (lambda (lastproc)
       (if (is_closure lastproc) (list_prepend revlastlist lastproc))))
;;; call the last routines in reverse order
    (list_every
     revlastlist
     (lambda (lastproc)
       (let ( (prevres (unsafe_get_field :referenced_value rescont)) 
	      (nextres (lastproc prevres finish_unit_delayed_queue))
	      )
	 (unsafe_put_fields rescont :referenced_value nextres)
	 )))
;;; force a minor GC to ensure nothing stays in the young region
    (code_chunk finishunitminorgc_chk 
		#{/*hook_finish_unit $FINISHUNITMINORGC_CHK*/ melt_garbcoll (0, MELT_ONLY_MINOR)}#)
    ))


(cheader 
 #{ 
 void MELT_MODULE_VISIBILITY 
    melt_finishunithook_callback (void* gcc_data ATTRIBUTE_UNUSED,
				 void* user_data ATTRIBUTE_UNUSED);
 }#)

(cimplement
 #{
 void 
 melt_finishunithook_callback (void* gcc_data ATTRIBUTE_UNUSED,
			      void* user_data ATTRIBUTE_UNUSED)
 {
    melthookproc_HOOK_FINISH_UNIT ();
 }
 }#)
(defun enable_finish_unit ()
  (code_chunk 
   enfinishunit_chk
   #{ /* enable_finish_unit $ENFINISHUNIT_CHK */
   if (!melthk_finish_unit_registered_flag) 
     {
        melthk_finish_unit_registered_flag = true;
       register_callback (melt_plugin_name, PLUGIN_FINISH_UNIT,
			  melt_finishunithook_callback,
			  NULL);
     }
   }#)
)

(defun at_finish_unit_first (fun)
  :doc #{Use $AT_FINISH_UNIT_FIRST to register a function to be run at
end of compilation unit in first place}#
  (let ( (firstlist (unsafe_get_field :delqu_first finish_unit_delayed_queue))
	 )
    (when (is_closure fun) 
      (enable_finish_unit)
      (list_append firstlist fun)))
  )  

(defun at_finish_unit_last (fun)
  :doc #{Use $AT_FINISH_UNIT_LAST to register a function to be run at
end of compilation unit in last place}#
  (let ( (lastlist (unsafe_get_field :delqu_last finish_unit_delayed_queue))
	 )
    (when (is_closure fun) 
      (enable_finish_unit)
      (list_append lastlist fun)))
  )




  
;;;====================================================================
;;;****************** ALL_PASSES_START plugin event *******************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; handling PLUGIN_ALL_PASSES_START
;; private all_passes_start handling queue
(definstance all_passes_start_delayed_queue class_delayed_queue
  :named_name '"all_passes_start_delayed_queue"
  :delqu_first ()
  :delqu_last ()
  )

(cheader #{/* flag for PLUGIN_ALL_PASSES_START declare */
MELT_EXTERN bool MELT_MODULE_VISIBILITY  melthk_all_passes_start_registered_flag;
}#)
(cimplement  #{/* flag for PLUGIN_ALL_PASSES_START define */
 bool melthk_all_passes_start_registered_flag;
}#)

;; internal hook for PLUGIN_ALL_PASSES_START 
(defhook hook_all_passes_start () () :void
  :predef HOOK_ALL_PASSES_START
  (let ( (firstlist (get_field :delqu_first all_passes_start_delayed_queue))
	 (lastlist (get_field :delqu_last all_passes_start_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (res ())
	 )
;;; call the first routines in natural order
    (foreach_pair_component_in_list
     (firstlist)
     (firstpair firstproc)
     (setq res (firstproc res))
     )
;;; reverse the last list
    (foreach_pair_component_in_list
     (lastlist)
     (lastpair lastproc)
     (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
    (if lastlist 
	(foreach_pair_component_in_list
	 (revlastlist)
	 (revlastpair revlastproc)
	 (setq res (revlastproc res))
    ))))

(cheader #{ 
 void MELT_MODULE_VISIBILITY 
    melt_all_passes_start_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
				 void* user_data ATTRIBUTE_UNUSED);
 }#)

(cimplement #{
 void 
 melt_all_passes_start_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
			      void* user_data ATTRIBUTE_UNUSED)
 {
    melthookproc_HOOK_ALL_PASSES_START ();
 }
 }#)

(defun enable_all_passes_start ()
  (code_chunk 
   enallpassesstart_chk
   #{ /* enable_all_passes_start $ENALLPASSESSTART_CHK */
     if (!melthk_all_passes_start_registered_flag) {
       melthk_all_passes_start_registered_flag = true;
       register_callback (melt_plugin_name, PLUGIN_ALL_PASSES_START,
			  melt_all_passes_start_hook_callback,
			  NULL);
     }
   }#
  ))

(defun register_all_passes_start_first (fun)
  :doc #{Use $REGISTER_ALL_PASSES_START_FIRST to register a function $FUN to
  be run at PLUGIN_ALL_PASSES_START, in first place.  $FUN must be a closure
  which takes no arguments and whose result is ignored.}#
  (if (is_closure fun)
      (let ( (firstlist (get_field :delqu_first all_passes_start_delayed_queue))
	    )
	(enable_all_passes_start)
	(if (null firstlist)
	    (progn
	      (setq firstlist (make_list discr_list))
	      (put_fields
	        all_passes_start_delayed_queue
	        :delqu_first firstlist
	        :delqu_last (make_list discr_list))
	      ))
	(list_append firstlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_all_passes_start_hook_first")
    ))

(defun register_all_passes_start_last (fun)
  :doc #{Use $REGISTER_ALL_PASSES_START_LAST to register a function $FUN to
  be run at PLUGIN_ALL_PASSES_START, in last place.  $FUN must be a closure
  which takes no argument and whose result is ignored.}#
  (if (is_closure fun)
      (let ( (lastlist (get_field :delqu_last all_passes_start_delayed_queue))
	    )
	(enable_all_passes_start)
	(if (null lastlist)
	    (progn
	      (setq lastlist (make_list discr_list))
	      (put_fields
	        all_passes_start_delayed_queue
	        :delqu_first (make_list discr_list)
	        :delqu_last lastlist)
	      ))
	(list_append lastlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_all_passes_start_hook_last")
    ))


;;;====================================================================
;;;****************** ALL_PASSES_END plugin event *******************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



(cheader #{/* flag for PLUGIN_ALL_PASSES_END declare */
MELT_EXTERN bool MELT_MODULE_VISIBILITY  melthk_all_passes_end_registered_flag;
}#)
(cimplement #{/* flag for PLUGIN_ALL_PASSES_END define */
bool  melthk_all_passes_end_registered_flag;
}#)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; handling PLUGIN_ALL_PASSES_END
;; private all_passes_end handling queue
(definstance all_passes_end_delayed_queue class_delayed_queue
  :named_name '"all_passes_end_delayed_queue"
  :delqu_first ()
  :delqu_last ()
  )

;; internal private hook for PLUGIN_ALL_PASSES_END 
(defhook hook_all_passes_end () () :void
  :predef HOOK_ALL_PASSES_END
  (let ( (firstlist (get_field :delqu_first all_passes_end_delayed_queue))
	 (lastlist (get_field :delqu_last all_passes_end_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (res ())
	 )
;;; call the first routines in natural order
    (foreach_pair_component_in_list
     (firstlist)
     (firstpair firstproc)
     (setq res (firstproc res))
     )
;;; reverse the last list
    (foreach_pair_component_in_list
     (lastlist)
     (lastpair lastproc)
     (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
    (foreach_pair_component_in_list
     (revlastlist)
     (revlastpair revlastproc)
     (setq res (revlastproc res))
    )))

(cheader #{ 
 void MELT_MODULE_VISIBILITY 
    melt_all_passes_end_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
				 void* user_data ATTRIBUTE_UNUSED);
 }#)

(cimplement #{
 void 
 melt_all_passes_end_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
			      void* user_data ATTRIBUTE_UNUSED)
 {
    melthookproc_HOOK_ALL_PASSES_END ();
 }
 }#)

(defun enable_all_passes_end ()
  (code_chunk 
   enallpassesend_chk
   #{ /* enable_all_passes_end $ENALLPASSESEND_CHK */
     if (!melthk_all_passes_end_registered_flag) {
       melthk_all_passes_end_registered_flag = true; 
       register_callback (melt_plugin_name, PLUGIN_ALL_PASSES_END,
			  melt_all_passes_end_hook_callback,
                          NULL);
     } 
   }#
  ))

(defun register_all_passes_end_first (fun)
  :doc #{Use $REGISTER_ALL_PASSES_END_FIRST to register a function $FUN to
  be run at PLUGIN_ALL_PASSES_END, in first place.  $FUN must be a closure
  which takes no argument and whose result is ignored.}#
  (if (is_closure fun)
      (let ( (firstlist (get_field :delqu_first all_passes_end_delayed_queue))
	    )
	(enable_all_passes_end)
	(if (null firstlist)
	    (progn
	      (setq firstlist (make_list discr_list))
	      (put_fields
	        all_passes_end_delayed_queue
	        :delqu_first firstlist
	        :delqu_last (make_list discr_list))
	      ))
	(list_append firstlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_all_passes_end_first")
    ))

(defun register_all_passes_end_last (fun)
  :doc #{Use $REGISTER_ALL_PASSES_END_LAST to register a function $FUN to
  be run at PLUGIN_ALL_PASSES_END, in last place.  $FUN must be a closure
  which takes no arguments and whose result is ignored.}#
  (if (is_closure fun)
      (let ( (lastlist (get_field :delqu_last all_passes_end_delayed_queue))
	    )
	(enable_all_passes_end)
	(if (null lastlist)
	    (progn
	      (setq lastlist (make_list discr_list))
	      (put_fields
	        all_passes_end_delayed_queue
	        :delqu_first (make_list discr_list)
	        :delqu_last lastlist)
	      ))
	(list_append lastlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_all_passes_end_last")
    ))


;;;====================================================================
;;;****************** ALL_IPA_PASSES_START plugin event *******************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; handling PLUGIN_ALL_IPA_PASSES_START
;; private all_ipa_passes_start handling queue
(definstance all_ipa_passes_start_delayed_queue class_delayed_queue
  :named_name '"all_ipa_passes_start_delayed_queue"
  :delqu_first ()
  :delqu_last ()
  )

(cheader #{/* flag for PLUGIN_ALL_IPA_PASSES_START declare */
MELT_EXTERN bool MELT_MODULE_VISIBILITY  melthk_all_ipa_passes_start_registered_flag;
}#)
(cimplement  #{/* flag for PLUGIN_ALL_IPA_PASSES_START define */
 bool melthk_all_ipa_passes_start_registered_flag;
}#)

;; internal hook for PLUGIN_ALL_IPA_PASSES_START 
(defhook hook_all_ipa_passes_start () () :void
  :predef HOOK_ALL_IPA_PASSES_START
  (let ( (firstlist (get_field :delqu_first all_ipa_passes_start_delayed_queue))
	 (lastlist (get_field :delqu_last all_ipa_passes_start_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (res ())
	 )
;;; call the first routines in natural order
    (foreach_pair_component_in_list
     (firstlist)
     (firstpair firstproc)
     (setq res (firstproc res))
     )
;;; reverse the last list
    (foreach_pair_component_in_list
     (lastlist)
     (lastpair lastproc)
     (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
    (if lastlist 
	(foreach_pair_component_in_list
	 (revlastlist)
	 (revlastpair revlastproc)
	 (setq res (revlastproc res))
    ))))

(cheader #{ 
 void MELT_MODULE_VISIBILITY 
    melt_all_ipa_passes_start_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
				 void* user_data ATTRIBUTE_UNUSED);
 }#)

(cimplement #{
 void 
 melt_all_ipa_passes_start_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
			      void* user_data ATTRIBUTE_UNUSED)
 {
   melthookproc_HOOK_ALL_IPA_PASSES_START ();
 }
 }#)

(defun enable_all_ipa_passes_start ()
  (code_chunk 
   enallpassesstart_chk
   #{ /* enable_all_ipa_passes_start $ENALLPASSESSTART_CHK */
     if (!melthk_all_ipa_passes_start_registered_flag) {
       melthk_all_ipa_passes_start_registered_flag = true;
       register_callback (melt_plugin_name, PLUGIN_ALL_IPA_PASSES_START,
			  melt_all_ipa_passes_start_hook_callback,
			  NULL);
     }
   }#
  ))

(defun register_all_ipa_passes_start_first (fun)
  :doc #{Use $REGISTER_ALL_IPA_PASSES_START_FIRST to register a function $FUN to
  be run at PLUGIN_ALL_IPA_PASSES_START, in first place.  $FUN must be a closure
  which takes no arguments and whose result is ignored.}#
  (if (is_closure fun)
      (let ( (firstlist (get_field :delqu_first all_ipa_passes_start_delayed_queue))
	    )
	(enable_all_ipa_passes_start)
	(if (null firstlist)
	    (progn
	      (setq firstlist (make_list discr_list))
	      (put_fields
	        all_ipa_passes_start_delayed_queue
	        :delqu_first firstlist
	        :delqu_last (make_list discr_list))
	      ))
	(list_append firstlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_all_ipa_passes_start_hook_first")
    ))

(defun register_all_ipa_passes_start_last (fun)
  :doc #{Use $REGISTER_ALL_IPA_PASSES_START_LAST to register a function $FUN to
  be run at PLUGIN_ALL_IPA_PASSES_START, in last place.  $FUN must be a closure
  which takes no argument and whose result is ignored.}#
  (if (is_closure fun)
      (let ( (lastlist (get_field :delqu_last all_ipa_passes_start_delayed_queue))
	    )
	(enable_all_ipa_passes_start)
	(if (null lastlist)
	    (progn
	      (setq lastlist (make_list discr_list))
	      (put_fields
	        all_ipa_passes_start_delayed_queue
	        :delqu_first (make_list discr_list)
	        :delqu_last lastlist)
	      ))
	(list_append lastlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_all_ipa_passes_start_hook_last")
    ))


;;;====================================================================
;;;****************** ALL_IPA_PASSES_END plugin event *******************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



(cheader #{/* flag for PLUGIN_ALL_IPA_PASSES_END declare */
MELT_EXTERN bool MELT_MODULE_VISIBILITY  melthk_all_ipa_passes_end_registered_flag;
}#)
(cimplement #{/* flag for PLUGIN_ALL_IPA_PASSES_END define */
bool  melthk_all_ipa_passes_end_registered_flag;
}#)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; handling PLUGIN_ALL_IPA_PASSES_END
;; private all_ipa_passes_end handling queue
(definstance all_ipa_passes_end_delayed_queue class_delayed_queue
  :named_name '"all_ipa_passes_end_delayed_queue"
  :delqu_first ()
  :delqu_last ()
  )

;; internal private hook for PLUGIN_ALL_IPA_PASSES_END 
(defhook hook_all_ipa_passes_end () () :void
  :predef HOOK_ALL_IPA_PASSES_END
  (let ( (firstlist (get_field :delqu_first all_ipa_passes_end_delayed_queue))
	 (lastlist (get_field :delqu_last all_ipa_passes_end_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (res ())
	 )
;;; call the first routines in natural order
    (foreach_pair_component_in_list
     (firstlist)
     (firstpair firstproc)
     (setq res (firstproc res))
     )
;;; reverse the last list
    (foreach_pair_component_in_list
     (lastlist)
     (lastpair lastproc)
     (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
    (foreach_pair_component_in_list
     (revlastlist)
     (revlastpair revlastproc)
     (setq res (revlastproc res))
    )))

(cheader #{ 
 void MELT_MODULE_VISIBILITY 
    melt_all_ipa_passes_end_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
				 void* user_data ATTRIBUTE_UNUSED);
 }#)

(cimplement #{
 void 
 melt_all_ipa_passes_end_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
			      void* user_data ATTRIBUTE_UNUSED)
 {
    melthookproc_HOOK_ALL_IPA_PASSES_END ();
 }
 }#)

(defun enable_all_ipa_passes_end ()
  (code_chunk 
   enallpassesend_chk
   #{ /* enable_all_ipa_passes_end $ENALLPASSESEND_CHK */
     if (!melthk_all_ipa_passes_end_registered_flag) {
       melthk_all_ipa_passes_end_registered_flag = true; 
       register_callback (melt_plugin_name, PLUGIN_ALL_IPA_PASSES_END,
			  melt_all_ipa_passes_end_hook_callback,
                          NULL);
     } 
   }#
  ))

(defun register_all_ipa_passes_end_first (fun)
  :doc #{Use $REGISTER_ALL_IPA_PASSES_END_FIRST to register a function $FUN to
  be run at PLUGIN_ALL_IPA_PASSES_END, in first place.  $FUN must be a closure
  which takes no argument and whose result is ignored.}#
  (if (is_closure fun)
      (let ( (firstlist (get_field :delqu_first all_ipa_passes_end_delayed_queue))
	    )
	(enable_all_ipa_passes_end)
	(if (null firstlist)
	    (progn
	      (setq firstlist (make_list discr_list))
	      (put_fields
	        all_ipa_passes_end_delayed_queue
	        :delqu_first firstlist
	        :delqu_last (make_list discr_list))
	      ))
	(list_append firstlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_all_ipa_passes_end_first")
    ))

(defun register_all_ipa_passes_end_last (fun)
  :doc #{Use $REGISTER_ALL_IPA_PASSES_END_LAST to register a function $FUN to
  be run at PLUGIN_ALL_IPA_PASSES_END, in last place.  $FUN must be a closure
  which takes no arguments and whose result is ignored.}#
  (if (is_closure fun)
      (let ( (lastlist (get_field :delqu_last all_ipa_passes_end_delayed_queue))
	    )
	(enable_all_ipa_passes_end)
	(if (null lastlist)
	    (progn
	      (setq lastlist (make_list discr_list))
	      (put_fields
	        all_ipa_passes_end_delayed_queue
	        :delqu_first (make_list discr_list)
	        :delqu_last lastlist)
	      ))
	(list_append lastlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_all_ipa_passes_end_last")
    ))



;;;====================================================================
;;;************** EARLY_GIMPLE_PASSES_START plugin event **************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; handling PLUGIN_EARLY_GIMPLE_PASSES_START
;; private early_gimple_passes_start handling queue
(definstance early_gimple_passes_start_delayed_queue class_delayed_queue
  :named_name '"early_gimple_passes_start_delayed_queue"
  :delqu_first ()
  :delqu_last ()
  )

(cheader #{/* flag for PLUGIN_EARLY_GIMPLE_PASSES_START declare */
MELT_EXTERN bool MELT_MODULE_VISIBILITY  melthk_early_gimple_passes_start_registered_flag;
}#)
(cimplement  #{/* flag for PLUGIN_EARLY_GIMPLE_PASSES_START define */
 bool melthk_early_gimple_passes_start_registered_flag;
}#)

;; internal hook for PLUGIN_EARLY_GIMPLE_PASSES_START 
(defhook hook_early_gimple_passes_start () () :void
  :predef HOOK_EARLY_GIMPLE_PASSES_START
  (let ( (firstlist (get_field :delqu_first early_gimple_passes_start_delayed_queue))
	 (lastlist (get_field :delqu_last early_gimple_passes_start_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (res ())
	 )
;;; call the first routines in natural order
    (foreach_pair_component_in_list
     (firstlist)
     (firstpair firstproc)
     (setq res (firstproc res))
     )
;;; reverse the last list
    (foreach_pair_component_in_list
     (lastlist)
     (lastpair lastproc)
     (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
    (if lastlist 
	(foreach_pair_component_in_list
	 (revlastlist)
	 (revlastpair revlastproc)
	 (setq res (revlastproc res))
    ))))

(cheader #{ 
 void MELT_MODULE_VISIBILITY 
    melt_early_gimple_passes_start_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
				 void* user_data ATTRIBUTE_UNUSED);
 }#)

(cimplement #{
 void 
 melt_early_gimple_passes_start_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
			      void* user_data ATTRIBUTE_UNUSED)
 {
   melthookproc_HOOK_EARLY_GIMPLE_PASSES_START ();
 }
 }#)

(defun enable_early_gimple_passes_start ()
  (code_chunk 
   enallpassesstart_chk
   #{ /* enable_early_gimple_passes_start $ENALLPASSESSTART_CHK */
     if (!melthk_early_gimple_passes_start_registered_flag) {
       melthk_early_gimple_passes_start_registered_flag = true;
       register_callback (melt_plugin_name, PLUGIN_EARLY_GIMPLE_PASSES_START,
			  melt_early_gimple_passes_start_hook_callback,
			  NULL);
     }
   }#
  ))

(defun register_early_gimple_passes_start_first (fun)
  :doc #{Use $REGISTER_EARLY_GIMPLE_PASSES_START_FIRST to register a function $FUN to
  be run at PLUGIN_EARLY_GIMPLE_PASSES_START, in first place.  $FUN must be a closure
  which takes no arguments and whose result is ignored.}#
  (if (is_closure fun)
      (let ( (firstlist (get_field :delqu_first early_gimple_passes_start_delayed_queue))
	    )
	(enable_early_gimple_passes_start)
	(if (null firstlist)
	    (progn
	      (setq firstlist (make_list discr_list))
	      (put_fields
	        early_gimple_passes_start_delayed_queue
	        :delqu_first firstlist
	        :delqu_last (make_list discr_list))
	      ))
	(list_append firstlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_early_gimple_passes_start_hook_first")
    ))

(defun register_early_gimple_passes_start_last (fun)
  :doc #{Use $REGISTER_EARLY_GIMPLE_PASSES_START_LAST to register a function $FUN to
  be run at PLUGIN_EARLY_GIMPLE_PASSES_START, in last place.  $FUN must be a closure
  which takes no argument and whose result is ignored.}#
  (if (is_closure fun)
      (let ( (lastlist (get_field :delqu_last early_gimple_passes_start_delayed_queue))
	    )
	(enable_early_gimple_passes_start)
	(if (null lastlist)
	    (progn
	      (setq lastlist (make_list discr_list))
	      (put_fields
	        early_gimple_passes_start_delayed_queue
	        :delqu_first (make_list discr_list)
	        :delqu_last lastlist)
	      ))
	(list_append lastlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_early_gimple_passes_start_hook_last")
    ))


;;;=====================================================================
;;;*************** EARLY_GIMPLE_PASSES_END plugin event ****************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



(cheader #{/* flag for PLUGIN_EARLY_GIMPLE_PASSES_END declare */
MELT_EXTERN bool MELT_MODULE_VISIBILITY  melthk_early_gimple_passes_end_registered_flag;
}#)
(cimplement #{/* flag for PLUGIN_EARLY_GIMPLE_PASSES_END define */
bool  melthk_early_gimple_passes_end_registered_flag;
}#)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; handling PLUGIN_EARLY_GIMPLE_PASSES_END
;; private early_gimple_passes_end handling queue
(definstance early_gimple_passes_end_delayed_queue class_delayed_queue
  :named_name '"early_gimple_passes_end_delayed_queue"
  :delqu_first ()
  :delqu_last ()
  )

;; internal private hook for PLUGIN_EARLY_GIMPLE_PASSES_END 
(defhook hook_early_gimple_passes_end () () :void
  :predef HOOK_EARLY_GIMPLE_PASSES_END
  (let ( (firstlist (get_field :delqu_first early_gimple_passes_end_delayed_queue))
	 (lastlist (get_field :delqu_last early_gimple_passes_end_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (res ())
	 )
;;; call the first routines in natural order
    (foreach_pair_component_in_list
     (firstlist)
     (firstpair firstproc)
     (setq res (firstproc res))
     )
;;; reverse the last list
    (foreach_pair_component_in_list
     (lastlist)
     (lastpair lastproc)
     (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
    (foreach_pair_component_in_list
     (revlastlist)
     (revlastpair revlastproc)
     (setq res (revlastproc res))
    )))

(cheader #{ 
 void MELT_MODULE_VISIBILITY 
    melt_early_gimple_passes_end_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
				 void* user_data ATTRIBUTE_UNUSED);
 }#)

(cimplement #{
 void 
 melt_early_gimple_passes_end_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
			      void* user_data ATTRIBUTE_UNUSED)
 {
   melthookproc_HOOK_EARLY_GIMPLE_PASSES_END ();
 }
 }#)

(defun enable_early_gimple_passes_end ()
  (code_chunk 
   enallpassesend_chk
   #{ /* enable_early_gimple_passes_end $ENALLPASSESEND_CHK */
     if (!melthk_early_gimple_passes_end_registered_flag) {
       melthk_early_gimple_passes_end_registered_flag = true; 
       register_callback (melt_plugin_name, PLUGIN_EARLY_GIMPLE_PASSES_END,
			  melt_early_gimple_passes_end_hook_callback,
                          NULL);
     } 
   }#
  ))

(defun register_early_gimple_passes_end_first (fun)
  :doc #{Use $REGISTER_EARLY_GIMPLE_PASSES_END_FIRST to register a function $FUN to
  be run at PLUGIN_EARLY_GIMPLE_PASSES_END, in first place.  $FUN must be a closure
  which takes no argument and whose result is ignored.}#
  (if (is_closure fun)
      (let ( (firstlist (get_field :delqu_first early_gimple_passes_end_delayed_queue))
	    )
	(enable_early_gimple_passes_end)
	(if (null firstlist)
	    (progn
	      (setq firstlist (make_list discr_list))
	      (put_fields
	        early_gimple_passes_end_delayed_queue
	        :delqu_first firstlist
	        :delqu_last (make_list discr_list))
	      ))
	(list_append firstlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_early_gimple_passes_end_first")
    ))

(defun register_early_gimple_passes_end_last (fun)
  :doc #{Use $REGISTER_EARLY_GIMPLE_PASSES_END_LAST to register a function $FUN to
  be run at PLUGIN_EARLY_GIMPLE_PASSES_END, in last place.  $FUN must be a closure
  which takes no arguments and whose result is ignored.}#
  (if (is_closure fun)
      (let ( (lastlist (get_field :delqu_last early_gimple_passes_end_delayed_queue))
	    )
	(enable_early_gimple_passes_end)
	(if (null lastlist)
	    (progn
	      (setq lastlist (make_list discr_list))
	      (put_fields
	        early_gimple_passes_end_delayed_queue
	        :delqu_first (make_list discr_list)
	        :delqu_last lastlist)
	      ))
	(list_append lastlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_early_gimple_passes_end_last")
    ))



;;;=====================================================================
;;;******************* PRE_GENERICIZE plugin event *********************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; private pregenericize queue
(definstance pregenericize_delayed_queue class_delayed_queue
  :named_name '"pregenericize_delayed_queue"
  :delqu_first ()
  :delqu_last ()
  )


(cheader #{/* flag for PLUGIN_PRE_GENERICIZE declare */
MELT_EXTERN bool MELT_MODULE_VISIBILITY  melthk_pre_genericize_registered_flag;
}#)

(cimplement #{/* flag for PLUGIN_PRE_GENERICIZE define */
bool  melthk_pre_genericize_registered_flag;
}#)

(cheader #{ 
 void MELT_MODULE_VISIBILITY 
    melt_pre_genericize_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
				 void* user_data ATTRIBUTE_UNUSED);
 }#)

(cimplement #{
 void 
 melt_pre_genericize_hook_callback (void* gcc_data,
			      void* user_data ATTRIBUTE_UNUSED)
 {
   melthookproc_HOOK_PRE_GENERICIZE ((tree)gcc_data);
 }
 }#)

(defun enable_pre_genericize ()
  (code_chunk 
   enablepregen_chk
   #{ /* enable_pre_genericize $enablepregen_chk */
   if (!melthk_pre_genericize_registered_flag) {
     melthk_pre_genericize_registered_flag = true;
/*
  register_callback (melt_plugin_name, PLUGIN_PRE_GENERICIZE,
                     melt_pre_genericize_hook_callback, NULL);
*/
   }
   }#)
)

(defhook hook_pre_genericize (:tree tfndecl) () :void
  :predef HOOK_PRE_GENERICIZE
  (let ( (firstlist (get_field :delqu_first pregenericize_delayed_queue))
	 (lastlist (get_field :delqu_last pregenericize_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (res ())
	 )
    (let ( (cfndeclv (constant_box tfndecl))
	   )
;;; call the first routines in natural order
      (foreach_pair_component_in_list
       (firstlist)
       (firstpair firstproc)
       (setq res (firstproc cfndeclv res))
       )
;;; reverse the last list
      (foreach_pair_component_in_list
       (lastlist)
       (lastpair lastproc)
       (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
      (foreach_pair_component_in_list
       (revlastlist)
       (revlastpair revlastproc)
       (setq res (revlastproc cfndeclv res))
       )
      )
    )
  )					;end hook_pre_genericize 


(defun register_pre_genericize_first (fun)
  :doc #{Use $REGISTER_PRE_GENERICIZE_FIRST to register a function $FUN to
  be run at PLUGIN_PRE_GENERICIZE hook, in first place.  $FUN must be a closure
  which take 1 argument (the boxed tree of function declaration being parsed).}#
  (let ( (firstlist (get_field :delqu_first pregenericize_delayed_queue))
	     )
    (if (null firstlist)
	    (progn
	      (setq firstlist (make_list discr_list))
	      (put_fields
	        pregenericize_delayed_queue
	        :delqu_first firstlist
	        :delqu_last (make_list discr_list))
	      ))
    (if (is_closure fun)
      (progn 
	(list_append firstlist fun)
	(enable_pre_genericize))
      (errormsg_plain
        "Bad hook passed to register_pre_genericize_hook")
    ))
)

(defun register_pre_genericize_last (fun)
  :doc #{Use $REGISTER_PRE_GENERICIZE_LAST to register a function $FUN to
  be run at PLUGIN_PRE_GENERICIZE hook, in last place.  $FUN must be a closure
  which take 1 argument (the boxed tree of function declaration being parsed).}#
  (let ( (lastlist (get_field :delqu_first pregenericize_delayed_queue))
	     )
    (if (null lastlist)
	    (progn
	      (setq lastlist (make_list discr_list))
	      (put_fields
	        pregenericize_delayed_queue
	        :delqu_first lastlist
	        :delqu_last (make_list discr_list))
	      ))
    (if (is_closure fun)
	(progn
	  (list_append lastlist fun)
	  (enable_pre_genericize))
      (errormsg_plain
        "Bad hook passed to register_pre_genericize_hook")
    ))
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



;;;=====================================================================
;;;******************* FINISH_TYPE plugin event *********************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; private finishtype queue
(definstance finishtype_delayed_queue class_delayed_queue
  :named_name '"finishtype_delayed_queue"
  :delqu_first ()
  :delqu_last ()
  )


(cheader #{/* flag for PLUGIN_FINISH_TYPE declare */
MELT_EXTERN bool MELT_MODULE_VISIBILITY  melthk_finish_type_registered_flag;
}#)

(cimplement #{/* flag for PLUGIN_FINISH_TYPE define */
bool  melthk_finish_type_registered_flag;
}#)

(cheader #{ 
 void MELT_MODULE_VISIBILITY 
    melt_finish_type_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
				 void* user_data ATTRIBUTE_UNUSED);
 }#)

(cimplement #{
 void 
 melt_finish_type_hook_callback (void* gcc_data,
			      void* user_data ATTRIBUTE_UNUSED)
 {
   melthookproc_HOOK_FINISH_TYPE ((tree)gcc_data);
 }
 }#)

(defun enable_finish_type ()
  (code_chunk 
   enablepregen_chk
   #{ /* enable_finish_type $enablepregen_chk */
   if (!melthk_finish_type_registered_flag) {
     melthk_finish_type_registered_flag = true;
     register_callback (melt_plugin_name, PLUGIN_FINISH_TYPE,
			melt_finish_type_hook_callback, NULL);
   }
   }#)
)

(defhook hook_finish_type (:tree tfndecl) () :void
  :predef HOOK_FINISH_TYPE
  (let ( (firstlist (get_field :delqu_first finishtype_delayed_queue))
	 (lastlist (get_field :delqu_last finishtype_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (res ())
	 )
    (let ( (cfndeclv (constant_box tfndecl))
	   )
;;; call the first routines in natural order
      (foreach_pair_component_in_list
       (firstlist)
       (firstpair firstproc)
       (setq res (firstproc cfndeclv res))
       )
;;; reverse the last list
      (foreach_pair_component_in_list
       (lastlist)
       (lastpair lastproc)
       (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
      (foreach_pair_component_in_list
       (revlastlist)
       (revlastpair revlastproc)
       (setq res (revlastproc cfndeclv res))
       )
      )
    )
  )					;end hook_finish_type 


(defun register_finish_type_first (fun)
  :doc #{Use $REGISTER_FINISH_TYPE_FIRST to register a function $FUN to
  be run at PLUGIN_FINISH_TYPE hook, in first place.  $FUN must be a closure
  which take 1 argument (the boxed tree of function declaration being parsed).}#
  (let ( (firstlist (get_field :delqu_first finishtype_delayed_queue))
	     )
    (if (null firstlist)
	    (progn
	      (setq firstlist (make_list discr_list))
	      (put_fields
	        finishtype_delayed_queue
	        :delqu_first firstlist
	        :delqu_last (make_list discr_list))
	      ))
    (if (is_closure fun)
      (progn 
	(list_append firstlist fun)
	(enable_finish_type))
      (errormsg_plain
        "Bad hook passed to register_finish_type_first")
    ))
)

(defun register_finish_type_last (fun)
  :doc #{Use $REGISTER_FINISH_TYPE_LAST to register a function $FUN to
  be run at PLUGIN_FINISH_TYPE hook, in last place.  $FUN must be a closure
  which take 1 argument (the boxed tree of function declaration being parsed).}#
  (let ( (lastlist (get_field :delqu_first finishtype_delayed_queue))
	     )
    (if (null lastlist)
	    (progn
	      (setq lastlist (make_list discr_list))
	      (put_fields
	        finishtype_delayed_queue
	        :delqu_first lastlist
	        :delqu_last (make_list discr_list))
	      ))
    (if (is_closure fun)
	(progn
	  (list_append lastlist fun)
	  (enable_finish_type))
      (errormsg_plain
        "Bad hook passed to register_finish_type_last")
    ))
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; private endmeltpass queue

(definstance endmeltpass_delayed_queue class_delayed_queue
  :named_name '"endmeltpass_delayed_queue"
  :delqu_first ()
  :delqu_last ()
  )

(defun run_endmeltpass_functions ()
  (let ( (firstlist (get_field :delqu_first endmeltpass_delayed_queue))
	 (lastlist (get_field :delqu_last endmeltpass_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (res (instance class_container))
	 )
    (put_fields endmeltpass_delayed_queue
		:delqu_first ()
		:delqu_last ())
;;; call the first routines in natural order
    (foreach_pair_component_in_list
     (firstlist)
     (firstpair firstproc)
     (if (is_closure firstproc) 
	 (firstproc res))
     )
;;; reverse the last list
    (foreach_pair_component_in_list
     (lastlist)
     (lastpair lastproc)
     (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
    (foreach_pair_component_in_list
     (revlastlist)
     (revlastpair revlastproc)
     (revlastproc res)
     )
    )
  )

(defun at_end_of_this_melt_pass_first (fun)
  :doc #{Use $AT_END_OF_THIS_MELT_PASS_FIRST to register a function to be called at the end of the current MELT provided GCC pass, in first place.}#
  (let ( (firstlist (unsafe_get_field :delqu_first endmeltpass_delayed_queue))
	 )
    (when (null firstlist)
      (setq firstlist (make_list discr_list))
      (put_fields endmeltpass_delayed_queue :delqu_first firstlist))
    (if (is_closure fun)
	(list_append firstlist fun))))

		   
(defun at_end_of_this_melt_pass_last (fun)
  :doc #{Use $AT_END_OF_THIS_MELT_PASS_LAST to register a function to be called 
at the end of the current MELT provided GCC pass, in last place.}#
  (let ( (lastlist (unsafe_get_field :delqu_last endmeltpass_delayed_queue))
	 )
    (when (null lastlist)
      (setq lastlist (make_list discr_list))
      (put_fields endmeltpass_delayed_queue :delqu_last lastlist))
    (if (is_closure fun)
	(list_append lastlist fun))))

		   

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;=====================================================================
;;;******************* FINISH_DECL plugin event *********************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; private finishdecl queue
(definstance finishdecl_delayed_queue class_delayed_queue
  :named_name '"finishdecl_delayed_queue"
  :delqu_first ()
  :delqu_last ()
  )


(cheader #{/* flag for PLUGIN_FINISH_DECL declare */
MELT_EXTERN bool MELT_MODULE_VISIBILITY  melthk_finish_decl_registered_flag;
}#)

(cimplement #{/* flag for PLUGIN_FINISH_DECL define */
bool  melthk_finish_decl_registered_flag;
}#)

(cheader #{ 
 void MELT_MODULE_VISIBILITY 
    melt_finish_decl_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
				 void* user_data ATTRIBUTE_UNUSED);
 }#)

(cimplement #{
 void 
 melt_finish_decl_hook_callback (void* gcc_data,
			      void* user_data ATTRIBUTE_UNUSED)
 {
 melthookproc_HOOK_FINISH_DECL ((tree)gcc_data);
 }
 }#)

(defun enable_finish_decl ()
  (code_chunk 
   enablepregen_chk
   #{ /* enable_finish_decl $enablepregen_chk */
   if (!melthk_finish_decl_registered_flag) {
     melthk_finish_decl_registered_flag = true;
  register_callback (melt_plugin_name, PLUGIN_FINISH_DECL,
                     melt_finish_decl_hook_callback, NULL);
   }
   }#)
)

(defhook hook_finish_decl (:tree tfndecl) () :void
  :predef HOOK_FINISH_DECL
  (let ( (firstlist (get_field :delqu_first finishdecl_delayed_queue))
	 (lastlist (get_field :delqu_last finishdecl_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (res ())
	 )
    (let ( (cfndeclv (constant_box tfndecl))
	   )
;;; call the first routines in natural order
      (foreach_pair_component_in_list
       (firstlist)
       (firstpair firstproc)
       (setq res (firstproc cfndeclv res))
       )
;;; reverse the last list
      (foreach_pair_component_in_list
       (lastlist)
       (lastpair lastproc)
       (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
      (foreach_pair_component_in_list
       (revlastlist)
       (revlastpair revlastproc)
       (setq res (revlastproc cfndeclv res))
       )
      )
    )
  )					;end hook_finish_decl 


(defun register_finish_decl_first (fun)
  :doc #{Use $REGISTER_FINISH_DECL_FIRST to register a function $FUN to
  be run at PLUGIN_FINISH_DECL hook, in first place.  $FUN must be a closure
  which take 1 argument (the boxed tree of function declaration being parsed).}#
  (let ( (firstlist (get_field :delqu_first finishdecl_delayed_queue))
	     )
    (if (null firstlist)
	    (progn
	      (setq firstlist (make_list discr_list))
	      (put_fields
	        finishdecl_delayed_queue
	        :delqu_first firstlist
	        :delqu_last (make_list discr_list))
	      ))
    (if (is_closure fun)
      (progn 
	(list_append firstlist fun)
	(enable_finish_decl))
      (errormsg_plain
        "Bad hook passed to register_finish_decl_first")
    ))
)

(defun register_finish_decl_last (fun)
  :doc #{Use $REGISTER_FINISH_DECL_LAST to register a function $FUN to
  be run at PLUGIN_FINISH_DECL hook, in last place.  $FUN must be a closure
  which take 1 argument (the boxed tree of function declaration being parsed).}#
  (let ( (lastlist (get_field :delqu_first finishdecl_delayed_queue))
	     )
    (if (null lastlist)
	    (progn
	      (setq lastlist (make_list discr_list))
	      (put_fields
	        finishdecl_delayed_queue
	        :delqu_first lastlist
	        :delqu_last (make_list discr_list))
	      ))
    (if (is_closure fun)
	(progn
	  (list_append lastlist fun)
	  (enable_finish_decl))
      (errormsg_plain
        "Bad hook passed to register_finish_decl_last")
    ))
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



;;;=====================================================================
;;;******************* PASS_EXECUTION plugin event *********************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; private pass_execution queue
(definstance pass_execution_delayed_queue class_delayed_queue
  :named_name '"pass_execution_delayed_queue"
  :delqu_first ()
  :delqu_last ()
  )

(cheader #{/* flag for PLUGIN_PASS_EXECUTION declare */
MELT_EXTERN bool MELT_MODULE_VISIBILITY  melthk_pass_execution_registered_flag;
}#)
(cimplement #{/* flag for PLUGIN_PASS_EXECUTION define */
bool  melthk_pass_execution_registered_flag;
}#)

(cheader #{ 
 void MELT_MODULE_VISIBILITY 
    melt_pass_execution_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
				 void* user_data ATTRIBUTE_UNUSED);
 }#)

(cimplement #{
 void 
 melt_pass_execution_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
			      void* user_data ATTRIBUTE_UNUSED)
 {
   struct opt_pass* pass = (struct opt_pass*) gcc_data;
   melthookproc_HOOK_PASS_EXECUTION (pass->name, (long) pass->static_pass_number, (long) pass->type);
 }
 }#)


;; we always register the pass_execution hook, because we want the GC
;; to run there
(code_chunk 
 register_pass_execution_hook_chk
 #{ /* we always $register_pass_execution_hook_chk */
    register_callback (melt_plugin_name, PLUGIN_PASS_EXECUTION,
		       melt_pass_execution_hook_callback, NULL);
 }#)

(defhook hook_pass_execution (:cstring passname :long passnum typenum) () :void
  :predef HOOK_PASS_EXECUTION
  (let (
	(passnameval (expr_chunk
		      makepassname_chk  
		      :value
		      #{/*hook_pass_execution $MAKEPASSNAME_CHK*/
		      meltgc_new_stringdup 
		      ((meltobject_ptr_t) MELT_PREDEF(DISCR_STRING),
		       $PASSNAME)
		      }#))
	(ptype ())
	(firstlist (get_field :delqu_first pass_execution_delayed_queue))
	(lastlist (get_field :delqu_last  pass_execution_delayed_queue))
	(revlastlist (make_list discr_list))
	)
    (code_chunk 
     fillptype_chk #{ /* hook_pass_execution $FILLPTYPE_CHK */
     switch ($TYPENUM) {
     case (int) GIMPLE_PASS: 
       $(progn (setq ptype :gimple_pass) (void)); 
       break;
     case (int) RTL_PASS: 
       $(progn (setq ptype :rtl_pass) (void)); 
       break;
     case (int) SIMPLE_IPA_PASS: 
       $(progn (setq ptype :simple_ipa_pass) (void)); 
       break;
     case (int) IPA_PASS: 
       $(progn (setq ptype :ipa_pass) (void)); 
       break;
     default: 
       $(progn (setq ptype (constant_box typenum)) (void));
       break;
     } /* end switch typenum in $FILLPTYPE_CHK*/
     }#)
;;; call the first routines in natural order
    (foreach_pair_component_in_list
     (firstlist)
     (firstpair firstproc)
     (firstproc passnameval passnum ptype)
     )
;;; reverse the last list
    (foreach_pair_component_in_list
     (lastlist)
     (lastpair lastproc)
     (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
    (foreach_pair_component_in_list
     (revlastlist)
     (revlastpair revlastproc)
     (revlastproc passnameval passnum ptype)
     )
    )
  ;; always force a minor garbage collection, otherwise other GCC
  ;; passes could break havoc
  (minor_garbcoll 1024)
  )					;end hook_pass_execution 


(defun register_pass_execution_first (fun)
  :doc #{Use $REGISTER_PASS_EXECUTION_FIRST to register a function $FUN to
  be run at PLUGIN_PASS_EXECUTION hook, in first place.  $FUN must be a closure
  which take as arguments @var{boxed-pass-name} @var{raw-pass-number} @var{pass-type-keyword}.}#
  (let ( (firstlist (get_field :delqu_first pass_execution_delayed_queue))
	     )
    (if (null firstlist)
	    (progn
	      (setq firstlist (make_list discr_list))
	      (put_fields
	        pass_execution_delayed_queue
	        :delqu_first firstlist
	        :delqu_last (make_list discr_list))
	      ))
    (if (is_closure fun)
      (list_append firstlist fun)
      (errormsg_plain
        "Bad hook passed to register_pass_execution_hook")
    ))
)

(defun register_pass_execution_last (fun)
  :doc #{Use $REGISTER_PASS_EXECUTION_LAST to register a function $FUN to
  be run at PLUGIN_PASS_EXECUTION hook, in last place.  $FUN must be a closure
  which take as arguments @var{boxed-pass-name} @var{raw-pass-number} @var{pass-type-keyword}.}#
  (let ( (lastlist (get_field :delqu_first pass_execution_delayed_queue))
	     )
    (if (null lastlist)
	    (progn
	      (setq lastlist (make_list discr_list))
	      (put_fields
 	        pass_execution_delayed_queue
	        :delqu_first lastlist
	        :delqu_last (make_list discr_list))
	      ))
    (if (is_closure fun)
      (list_append lastlist fun)
      (errormsg_plain
        "Bad hook passed to register_pass_execution_last_hook")
    ))
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; gate hook for gimple passes
(defhook hook_gimple_gate
  () () :long
  :predef HOOK_GIMPLE_GATE
  (let ( (:long hasmodeflag 0)
	 (:long okres 0)
	 (passdict (unsafe_get_field :sysdata_pass_dict initial_system_data))
	 (mypass ())
	 (:long passnum 0)
	 )
    (code_chunk gethasmode_chk 
		#{ /* hook_gimple_gate $GETHASMODE_CHK */
		static const char* $GETHASMODE_CHK#modstr ;
		if (!$GETHASMODE_CHK#modstr) 
		$GETHASMODE_CHK#modstr = melt_argument("mode") ;
		$HASMODEFLAG = $GETHASMODE_CHK#modstr != NULL && $GETHASMODE_CHK#modstr[0] != (char)0 ;
		}#)
    (if (not hasmodeflag)
	(return 0))
    (debug "hook_gimple_gate passdict=" passdict "\n initial_system_data=" initial_system_data)
    (code_chunk
     thispass_chk
     #{ /* hook_gimple_gate $THISPASS_CHK */
     opt_pass* this_pass = NULL ;
     this_pass = melt_current_pass_ptr ;
     if (!this_pass) this_pass = current_pass ;
     //
     $(code_chunk 
       getmypass_chk
       #{ /* hook_gimple_gate $GETMYPASS_CHK */
       gcc_assert(this_pass != NULL)	 ;
       gcc_assert(this_pass->name != NULL) ;
       debugeprintf ("hook_gimple_gate this_pass %p named %s",
		     (void*) this_pass->name, this_pass->name) ;
       gcc_assert(this_pass->type == GIMPLE_PASS)	       ;
       $MYPASS = melt_get_mapstrings ((struct meltmapstrings_st*) $PASSDICT, 
				      this_pass->name) ;
       $PASSNUM = this_pass->static_pass_number	       ;
       }#)
     $(debug "hook_gimple_gate mypass=" mypass "\n.. passnum=" passnum)
     $(debug "hook_gimple_gate class_gcc_gimple_pass=" class_gcc_gimple_pass)
     $(if (is_a mypass class_gcc_gimple_pass)
	  (let ( (gatefun (get_field :gccpass_gate mypass))
		 (:cstring curpassname (the_null_cstring))
		 )
	    (debug "hook_gimple_gate gatefun=" gatefun)
	    (if (is_closure gatefun)
		(code_chunk 
		 dogatefun_chk
		 #{ /* hook_gimple_gate $DOGATEFUN_CHK */
		 FILE* oldf = meltgc_set_dump_file (dump_file) ;
		 $CURPASSNAME = this_pass->name ;
		 $(progn
		    (debug "hook_gimple_gate curpassname=" curpassname " mypass=" mypass)
		    (if (gatefun mypass)
			(setq okres 1))
		    (debug "hook_gimple_gate after call okres=" okres)
		    (void)
		    )
		 meltgc_restore_dump_file (oldf) ;
		 oldf = NULL ;
		 }#)
	      (setq okres 1)		;no closure
	      )
	    (void)
	    )
	(debug "hook_gimple_gate strange mypass=" mypass "\n.. of discrim=" (discrim mypass))
	)
     /* end hook_gimple_gate $THISPASS_CHK */ }#
     )
    (debug "hook_gimple_gate final okres=" okres)
    (return okres)
    )
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; execute hook for gimple passes
(defhook hook_gimple_execute
  () () :long
  :predef HOOK_GIMPLE_EXECUTE
  (let ( (:long hasmodeflag 0)
	 (:long okres 0)
	 (:long passnum 0)
	 (passdict (get_field :sysdata_pass_dict initial_system_data))
	 (mypass ())
	 )
    (debug "hook_gimple_execute start")
    (code_chunk gethasmode_chk 
		#{ /* hook_gimple_execute $GETHASMODE_CHK */
		static const char* $GETHASMODE_CHK#modstr ;
		if (!$GETHASMODE_CHK#modstr) 
		$GETHASMODE_CHK#modstr = melt_argument("mode") ;
		$HASMODEFLAG = $GETHASMODE_CHK#modstr != NULL && $GETHASMODE_CHK#modstr[0] ;
		}#)
    (when (not hasmodeflag)
      (debug "hook_gimple_execute no mode")
      (return 0))
    (code_chunk 
     getmypass_chk
     #{ /* hook_gimple_execute $GETMYPASS_CHK */		
     gcc_assert(current_pass != NULL) ;
     gcc_assert(current_pass->name != NULL) ;
     gcc_assert(current_pass->type == GIMPLE_PASS) ;
     $MYPASS = melt_get_mapstrings ((struct meltmapstrings_st*) $PASSDICT, 
				    current_pass->name)	;
     $PASSNUM = current_pass->static_pass_number ;
     }#)
    (debug "hook_gimple_execute mypass=" mypass "\n.. passnum=" passnum)
    (if (is_a mypass class_gcc_gimple_pass)
	(let ( (execfun (get_field :gccpass_exec mypass))
	       (:cstring curpassname (the_null_cstring))
	       )
	  (when (is_closure execfun)
	    (code_chunk 
	     doexecfun_chk
	     #{ /* hook_gimple_execute $DOEXECFUN_CHK */
	     FILE* oldf = meltgc_set_dump_file (dump_file) ;
	     $CURPASSNAME = current_pass->name		   ;
	     $(progn
		(debug "hook_gimple_execute curpassname=" curpassname " mypass=" mypass
		       " passnum=" passnum)
		(multicall
		 (resexec :long flagexec)
		 (execfun mypass passnum)
		 (debug "hook_gimple_execute after call resexec=" resexec 
			" flagexec=" flagexec)
		 (if (null resexec)
		     (setq okres flagexec)
		   (setq okres 1))
		 )
		(void)
		)
	     meltgc_restore_dump_file (oldf) ;
	     oldf = NULL		     ;
	     }#)
	    (run_endmeltpass_functions)
	    )))
    (return okres)
    ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; gate hook for rtl passes
(defhook hook_rtl_gate
  () () :long
  :predef HOOK_RTL_GATE
  (let ( (:long hasmodeflag 0)
	 (:long okres 0)
	 (passdict (get_field :sysdata_pass_dict initial_system_data))
	 (mypass ())
	 (:long passnum 0)
	 )
    (code_chunk gethasmode_chk 
		#{ /* hook_rtl_gate $GETHASMODE_CHK */
		static const char* $GETHASMODE_CHK#modstr ;
		if (!$GETHASMODE_CHK#modstr) 
		$GETHASMODE_CHK#modstr = melt_argument("mode") ;
		$HASMODEFLAG = $GETHASMODE_CHK#modstr != NULL && $GETHASMODE_CHK#modstr[0] ;
		}#)
    (if (not hasmodeflag)
	(return 0))
    (code_chunk 
     getmypass_chk
     #{ /* hook_rtl_gate $GETMYPASS_CHK */		
     gcc_assert(current_pass != NULL) ;
     gcc_assert(current_pass->name != NULL) ;
     gcc_assert(current_pass->type == RTL_PASS) ;
     $MYPASS = melt_get_mapstrings ((struct meltmapstrings_st*) $PASSDICT, 
				    current_pass->name)	;
     }#)
    (if (is_a mypass class_gcc_rtl_pass)
	(let ( (gatefun (get_field :gccpass_gate mypass))
	       (:cstring curpassname (the_null_cstring))
	       )
	  (if (is_closure gatefun)
	      (code_chunk 
	       dogatefun_chk
	       #{ /* hook_rtl_gate $DOGATEFUN_CHK */
	       FILE* oldf = meltgc_set_dump_file (dump_file) ;
	       $CURPASSNAME = current_pass->name;
	       $PASSNUM = current_pass->static_pass_number;
	       $(progn
		  (debug "hook_rtl_gate curpassname=" curpassname " mypass=" mypass)
		  (if (gatefun mypass passnum)
		      (setq okres 1))
		  (debug "hook_rtl_gate after call okres=" okres)
		  (void)
		  )
	       meltgc_restore_dump_file (oldf) ;
	       oldf = NULL ;
	       }#)
	    (setq okres 1)		;no closure
	    )))
    (return okres)
))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; execute hook for rtl passes
(defhook hook_rtl_execute
  () () :long
  :predef HOOK_RTL_EXECUTE
  (let ( (:long hasmodeflag 0)
	 (:long okres 0)
	 (passdict (get_field :sysdata_pass_dict initial_system_data))
	 (mypass ())
	 (:long passnum 0)
	 )
    (code_chunk gethasmode_chk 
		#{ /* hook_rtl_execute $GETHASMODE_CHK */
		static const char* $GETHASMODE_CHK#modstr ;
		if (!$GETHASMODE_CHK#modstr) 
		$GETHASMODE_CHK#modstr = melt_argument("mode") ;
		$HASMODEFLAG = $GETHASMODE_CHK#modstr != NULL && $GETHASMODE_CHK#modstr[0] ;
		}#)
    (if (not hasmodeflag)
	(return 0))
    (code_chunk 
     getmypass_chk
     #{ /* hook_rtl_execute $GETMYPASS_CHK */		
     gcc_assert(current_pass != NULL) ;
     gcc_assert(current_pass->name != NULL) ;
     gcc_assert(current_pass->type == RTL_PASS) ;
     $MYPASS = melt_get_mapstrings ((struct meltmapstrings_st*) $PASSDICT, 
				    current_pass->name)	;
     }#)
    (if (is_a mypass class_gcc_rtl_pass)
	(let ( (execfun (get_field :gccpass_exec mypass))
	       (:cstring curpassname (the_null_cstring))
	       )
	  (when (is_closure execfun)
	      (code_chunk 
	       doexecfun_chk
	       #{ /* hook_rtl_execute $DOEXECFUN_CHK */
	       $PASSNUM = current_pass->static_pass_number;
	       FILE* oldf = meltgc_set_dump_file (dump_file) ;
	       $CURPASSNAME = current_pass->name ;
	       $(progn
		 (debug "hook_rtl_execute curpassname=" curpassname " mypass=" mypass
			" passnum=" passnum)
		 (multicall
		  (resexec :long flagexec)
		  (execfun mypass passnum)
		  (debug "hook_rtl_execute after call resexec=" resexec 
			 " flagexec=" flagexec)
		  (if (null resexec)
		      (setq okres flagexec)
		    (setq okres 1))
		  )
		 (void)
		 )
	       meltgc_restore_dump_file (oldf) ;
	       oldf = NULL ;
	       }#)
	      (run_endmeltpass_functions)
	    )))
    (return okres)
))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; execute hook for simple_ipa passes
(defhook hook_simple_ipa_execute
  () () :long
  :predef HOOK_SIMPLE_IPA_EXECUTE
  (let ( (:long hasmodeflag 0)
	 (:long okres 0)
	 (passdict (get_field :sysdata_pass_dict initial_system_data))
	 (mypass ())
	 (:long passnum 0)
	 )
    (code_chunk gethasmode_chk 
		#{ /* hook_simple_ipa_execute $GETHASMODE_CHK */
		static const char* $GETHASMODE_CHK#modstr ;
		if (!$GETHASMODE_CHK#modstr) 
		$GETHASMODE_CHK#modstr = melt_argument("mode") ;
		$HASMODEFLAG = $GETHASMODE_CHK#modstr != NULL && $GETHASMODE_CHK#modstr[0] ;
		}#)
    (if (not hasmodeflag)
	(return 0))
    (code_chunk 
     getmypass_chk
     #{ /* hook_simple_ipa_execute $GETMYPASS_CHK */		
     gcc_assert(current_pass != NULL) ;
     gcc_assert(current_pass->name != NULL) ;
     gcc_assert(current_pass->type == SIMPLE_IPA_PASS) ;
     $MYPASS = melt_get_mapstrings ((struct meltmapstrings_st*) $PASSDICT, 
				    current_pass->name)	;
     }#)
    (if (is_a mypass class_gcc_simple_ipa_pass)
	(let ( (execfun (get_field :gccpass_exec mypass))
	       (:cstring curpassname (the_null_cstring))
	       )
	  (when (is_closure execfun)
	      (code_chunk 
	       doexecfun_chk
	       #{ /* hook_simple_ipa_execute $DOEXECFUN_CHK */
	       $PASSNUM = current_pass->static_pass_number;
	       FILE* oldf = meltgc_set_dump_file (dump_file) ;
	       $CURPASSNAME = current_pass->name ;
	       $(progn
		 (debug "hook_simple_ipa_execute curpassname=" curpassname " mypass=" mypass
			" passnum=" passnum)
		 (multicall
		  (resexec :long flagexec)
		  (execfun mypass passnum)
		  (debug "hook_simple_ipa_execute after call resexec=" resexec 
			 " flagexec=" flagexec)
		  (if (null resexec)
		      (setq okres flagexec)
		    (setq okres 1))
		  )
		 (void)
		 )
	       meltgc_restore_dump_file (oldf) ;
	       oldf = NULL ;
	       }#)
	      (run_endmeltpass_functions)
	    )))
    (return okres)
))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defhook hook_melt_do_initial_mode
  (:value modata  :cstring modstr)
  ()
  :void
  :predef HOOK_MELT_DO_INITIAL_MODE
  (let ( (modict (get_field :sysdata_mode_dict initial_system_data))
	 (modlist (expr_chunk modlist_chk :value
			      #{ /*hook_melt_do_initial_mode $MODLIST_CHK*/
			      (meltgc_new_split_string ($MODSTR, ',',
							(melt_ptr_t) $DISCR_STRING)) }#))
			      
	 )
    (assert_msg "check modict" (is_mapstring modict) modict initial_system_data)
    (assert_msg "check modlist" (is_list modlist) modlist)
    (foreach_pair_component_in_list
     (modlist)
     (curpair curmodstr)
     (debug "hook_melt_do_initial_mode curmodstr=" curmodstr)
     (let ( (curmod (mapstring_getstr modict curmodstr))
	    )
       (debug "hook_melt_do_initial_mode curmod=" curmod)
       (when curmod
	 (assert_msg "check curmod" (is_a curmod class_melt_mode) curmod class_melt_mode)
	 (let ( (curmodfun (get_field :meltmode_fun curmod))
		(curmodname (get_field :named_name curmod))
		)
	   (assert_msg "check curmodfun" (is_closure curmodfun) curmodfun curmod)
	   (assert_msg "check curmodname" (is_string curmodname) curmodname curmod)
	   (let ( (curmodres (curmodfun curmod modata))
		  )
	     (debug "hook_melt_do_initial_mode curmodres=" curmodres " for curmod=" curmod)
	     (cond
	      (curmodres
	       (code_chunk
		donewellmode_chk
		#{ /* hook_melt_do_initial_mode $DONEWELLMODE_CHK */
		std::string curmodstr(melt_string_str($CURMODNAME)) ;
		melt_done_modes_vector.push_back(curmodstr)	    ;
		}#)
	       )
	      (:else
	       (code_chunk
		failedmode_chk
		#{ /* hook_melt_do_initial_mode $FAILEDMODE_CHK */
		warning(0, "MELT mode %s failed, so compilation disabled",
			   melt_string_str($CURMODNAME)) ;
		exit_after_options = TRUE		 ;
		}#)
	       )))))
       ))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;; extended attribute support is in warmelt-hooks.melt since it
;;;;; uses tree but does not depend on tree operations, but needs the
;;;;; hook_handle_attribute predefined hook

(cheader #{ /* cheader for attributes in warmelt-hooks.melt */
#if  MELT_GCC_VERSION >= 4009 /* GCC 4.9 or later */
#include "attribs.h"
#endif /*GCC 4.9*/
   MELT_EXTERN tree MELT_MODULE_VISIBILITY melt_attribute_handler_glue 
   (tree *pnode, tree name, tree args, int flags, bool *no_add_attrs);
}#)

(cimplement #{ /* cimplement for attributes in warmelt-hooks.melt */
tree  
melt_attribute_handler_glue (tree *pnode, tree name, tree args, int flags, bool *pno_add_attrs) {
   long out_no_add_attrs = (long)(pno_add_attrs?(*pno_add_attrs):0);
   debugeprintf("melt_attribute_handler_glue pnode@%p (*%p) name@%p args@%p flags=%d pno_add_attrs@%p"
		" before HOOK_HANDLE_ATTRIBUTE",
		(void*)pnode, (void*)*pnode, (void*)name, (void*)args, flags, (void*)pno_add_attrs);
   tree res =
     melthookproc_HOOK_HANDLE_ATTRIBUTE (*pnode, name, args, flags,
					 (long)(pno_add_attrs?(*pno_add_attrs):0),
                                         pnode, 
					 &out_no_add_attrs);
     debugeprintf("melt_attribute_handler_glue pnode@%p (*%p) res=%p after HOOK_HANDLE_ATTRIBUTE",
		  (void*)pnode, (void*)*pnode, (void*)res);
   if (pno_add_attrs) 
     *pno_add_attrs = out_no_add_attrs;
   return res;
} /* end melt_attribute_handler_glue */
}#)


(defvar gcc_attribute_dict)
(defvar gcc_attribute_installer_list)
(setq gcc_attribute_installer_list (make_list discr_list))

(defclass class_gcc_attribute 
  :super class_named
  :doc #{The $CLASS_GCC_ATTRIBUTE describes general GCC attributes
  known by MELT, in addition of the specially handled
  @code{__attribute__((melt(...)))}..}#
  :fields (gccattr_data
	   gccattr_handler
))
(export_class class_gcc_attribute)

(defhook hook_install_attributes
  ()
  ()
  :void
  :predef HOOK_INSTALL_ATTRIBUTES
  (debug "hook_install_attributes" " start gcc_attribute_dict=" 
	 gcc_attribute_dict)
  (if (null gcc_attribute_dict) 
      (return))
  (forever 
   atloop
   (unless (is_non_empty_list gcc_attribute_installer_list)
     (exit atloop))
   (let ( (clo1 (list_popfirst gcc_attribute_installer_list))
	  )
     (debug "hook_install_attributes" " loop clo1=" clo1)
     (assert_msg "check clo1" (is_closure clo1) clo1)
     (clo1)
     )
   )
  (debug "hook_install_attributes" " final gcc_attribute_installer_list=" gcc_attribute_installer_list)
  )

(defhook hook_handle_attribute    
  (:tree tr_in_node tr_name tr_args :long flags in_add_attrs)
  (:tree tr_out_node :long out_add_attrs)
  :tree
  :predef HOOK_HANDLE_ATTRIBUTE
  (debug "hook_handle_attribute" " tr_in_node=" tr_in_node
	 "; tr_name=" tr_name "; tr_args=" tr_args
	 "; flags=" flags "; in_add_attrs=" in_add_attrs)
  (let (
	(namev ())
	)
    (code_chunk getname_chk #{ /* hook_handle_attribute $GETNAME_CHK start */
		melt_assertmsg ("check good name",
				$TR_NAME
				&& TREE_CODE($TR_NAME) == IDENTIFIER_NODE) ;
		$NAMEV = meltgc_new_stringdup
		((meltobject_ptr_t)MELT_PREDEF(DISCR_STRING),
		 IDENTIFIER_POINTER($TR_NAME))	;
		/* hook_handle_attribute $GETNAME_CHK end */
		}#)
    (debug "hook_handle_attribute " "namev=" namev)
    (assert_msg "check namev" (is_string namev))
    (assert_msg "@$@unimplemented hook_handle_attribute")
    (return))
  )
  
  

(defmacro register_gcc_attribute (sexp env mexpander modctx)
  :doc #{The variadic macro $REGISTER_GCC_ATTRIBUTE is registering a
  GCC attribute $ATTR of $CLASS_GCC_ATTRIBUTE by expanding to a call to
  $MELT_REGISTER_GCC_ATTRIBUTE_AT internal function. Memory used by the
  attribute is never freed.  After it can occur variadically equivalents
  of @code{struct attribute_spec} fields: @code{:MIN_LENGTH}
  @var{minimal-length} (default 0).  @code{:MAX_LENGTH}
  @var{maximal-length} (default -1).  @code{:DECL_REQUIRED}
  @var{decl-required-flag}.  @code{:TYPE_REQUIRED}
  @var{type-required-flag}.  @code{:FUNCTION_TYPE_REQUIRED}
  @var{function-type-required-flag} @code{:AFFECTS_TYPE_IDENTITY}
  @var{affects-type-identity-flag}. Notice that checking of variadic arguments happen at run-time. }# 
  (debug "register_gcc_attribute macro sexp=" sexp "\n env=" debug_less env)
  (let (
	(sloc (get_field :loca_location sexp))
	(sexcont (get_field :sexp_contents sexp))
	(regatbnd (find_env env 'melt_register_gcc_attribute_at))
	)
    (unless regatbnd
      (error_at sloc "REGISTER_GCC_ATTRIBUTE used when MELT_REGISTER_GCC_ATTRIBUTE_AT is unbound")
      (return))
    (let ( (xarglist (expand_pairlist_as_list (pair_tail (list_first sexcont)) env mexpander modctx))
	   )
      (debug "register_gcc_attribute macro xarglist=" xarglist)
      (when (<i (list_length xarglist) 1)
	(error_at sloc "REGISTER_GCC_ATTRIBUTE needs at least one argument")
	(return))
      (list_prepend xarglist sloc)
      (debug "register_gcc_attribute macro prepended xarglist=" xarglist)
      (let ( (res (instance class_source_apply
			    :loca_location sloc
			    :sapp_fun 'melt_register_gcc_attribute_at
			    :sargop_args (list_to_multiple xarglist discr_multiple)))
	     )
	(debug "register_gcc_attribute macro returns res=" res)
	(return res)
      )
    )))
(export_macro register_gcc_attribute)

(defun melt_register_gcc_attribute_at (loc attr :rest)
  :doc #{The $MELT_REGISTER_GCC_ATTRIBUTE_AT is an internal variadic function,
  used by $REGISTER_GCC_ATTRIBUTE macro.}#
  (debug "melt_register_gcc_attribute_at" " start loc=" loc " attr=" attr)
  (unless (is_a attr class_gcc_attribute)
    (error_at loc "register_gcc_attribute got invalid attr $1" attr)
    (return ()))
  ;;
  (when (get_int attr)
    (error_at loc "register_gcc_attribute already registered #$1 attribute $2"
	      (get_int attr)
	      attr)
    (return ()))
  ;;
  (if (not (is_mapstring gcc_attribute_dict))
      (let ( (atdic (make_mapstring discr_map_strings 31)) )
	(setq gcc_attribute_dict atdic)
	(debug "melt_register_gcc_attribute_at" " atdic=" atdic)
	))
  (debug "melt_register_gcc_attribute_at" " gcc_attribute_dict=" gcc_attribute_dict)
  (assert_msg "check gcc_attribute_dict" (is_mapstring gcc_attribute_dict) gcc_attribute_dict)
  ;;
  (let ( 
        (name (get_field :named_name attr))
        (min_length 0)
	(max_length -1)
	(decl_required_flag 0)
	(type_required_flag 0)
	(function_type_required_flag 0)
	(affects_type_identity_flag 0)
	(:long attix (+i (mapstring_count gcc_attribute_dict) 1))	       
	)
    (debug "register_gcc_attribute " "gcc_attribute_dict=" gcc_attribute_dict ";\n attix=" attix)
    (unless (is_string name)
      (error_at loc "register_gcc_attribute got badly named attr $1" attr)
      (return))
    (when (mapstring_getstr gcc_attribute_dict name)
      (error_at loc "register_gcc_attribute got already named attr $1" name) 
      (return))
    ;; variadic parsing loop
    (forever 
     argsloop
     (variadic 
      ;; end of args
      (()
       (exit argsloop))
      ((:value key)
       (match 
	key
	;; :min_length <number>
	(:MIN_LENGTH
	 (variadic 
	  ((:long l)
	   (setq min_length l))
	  ((:value vl)
	   (cond 
	    ((is_integerbox vl)
	     (setq min_length (unbox :long vl))
	     (void))
	    (:else
	     (error_at loc "register_gcc_attribute for attr $1 got bad :MIN_LENGTH value" name)
	     (return))))
	  (:else
	   (error_at loc "register_gcc_attribute for attr $1 got bad :MIN_LENGTH" name)
	   (return))))
	;; :max_length <number>
	(:MAX_LENGTH
	 (variadic 
	  ((:long l)
	   (setq max_length l))
	  ((:value vl)
	   (cond 
	    ((is_integerbox vl)
	     (setq max_length (unbox :long vl))
	     (void))
	    (:else
	     (error_at loc "register_gcc_attribute for attr $1 got bad :MAX_LENGTH value" name)
	     (return))))
	  (:else
	   (error_at loc "register_gcc_attribute for attr $1 got bad :MAX_LENGTH" name)
	   (return))))
	;; :decl_required <flag>
	(:DECL_REQUIRED
	 (variadic 
	  ((:long l)
	   (setq decl_required_flag l))
	  ((:value vl)
	   (cond 
	    ((is_integerbox vl)
	     (setq decl_required_flag (unbox :long vl))
	     (void))
	    (:else
	     (setq decl_required_flag (non-null vl)))))
	  (:else
	   (error_at loc "register_gcc_attribute for attr $1 got bad :DECL_REQUIRED" name)
	   (return))))	 
	;; :type_required <flag>
	(:TYPE_REQUIRED
	 (variadic 
	  ((:long l)
	   (setq type_required_flag l))
	  ((:value vl)
	   (cond 
	    ((is_integerbox vl)
	     (setq type_required_flag (unbox :long vl))
	     (void))
	    (:else
	     (setq type_required_flag (non-null vl)))))
	  (:else
	   (error_at loc "register_gcc_attribute for attr $1 got bad :TYPE_REQUIRED" name)
	   (return))))	 	 
	;; :function_type_required <flag>
	(:FUNCTION_TYPE_REQUIRED
	 (variadic 
	  ((:long l)
	   (setq function_type_required_flag l))
	  ((:value vl)
	   (cond 
	    ((is_integerbox vl)
	     (setq function_type_required_flag (unbox :long vl))
	     (void)
	     )
	    (:else
	     (setq function_type_required_flag (non-null vl)))))
	  (:else
	   (error_at loc "register_gcc_attribute for attr $1 got bad :FUNCTION_TYPE_REQUIRED" name)
	   (return))))	 	 
	;; :affects_type_identity <flag>
	(:AFFECTS_TYPE_IDENTITY
	 (variadic 
	  ((:long l)
	   (setq affects_type_identity_flag l))
	  ((:value vl)
	   (cond 
	    ((is_integerbox vl)
	     (setq affects_type_identity_flag (unbox :long vl))
	     (void)
	     )
	    (:else
	     (setq affects_type_identity_flag (non-null vl)))))
	  (:else
	   (error_at loc "register_gcc_attribute for attr $1 got bad :AFFECTS_TYPE_IDENTITY" name)
	   (return))))	 
	;; unexpected key
	(?_
	 (error_at loc  "register_gcc_attribute for attr $1 got unexpected key $2" name key)
	 (return))
	)
       )
      (:else
       (error_at loc "register_gcc_attribute for $1 got invalid key" name)
       (return))
      )
     )					; end forever argloop
    (put_int attr attix)
    ;; add the installing closure to the installer list
    (list_append 
     gcc_attribute_installer_list
     ;; we are boxing all the parameters, since they are closed under lambda
     (let ( (vminlength (constant_box min_length))
	    (vmaxlength (constant_box max_length))
	    (vdeclrequired (if decl_required_flag :true))
	    (vtyperequired (if type_required_flag :true))
	    (vfunctiontyperequired (if function_type_required_flag :true))
	    (vaffectstypeidentity (if affects_type_identity_flag :true))
	    )
       (lambda ()
	 (debug "melt_register_gcc_attribute_at/lambda attr=" attr)
	 (let (
	       (:long iminlength (get_int vminlength))
	       (:long imaxlength (get_int vmaxlength))
	       )
	    (code_chunk
	     gccattr_chk
	     #{ /* ++ melt_register_gcc_attribute_at/lambda $GCCATTR_CHK start */
	     struct attribute_spec *atspec
	     /* will never be freed! */
	     = (struct attribute_spec*)xmalloc(sizeof(struct attribute_spec)) ;
	     if (!atspec)
	       melt_fatal_error("failed to allocate attribute_spec in melt_register_gcc_attribute_at (%s)",
	    		     xstrerror(errno)) ;
	     memset (atspec, 0, sizeof(struct attribute_spec)) ;
	     atspec->name = melt_intern_cstring (melt_string_str ($NAME)) ;
	     atspec->min_length = (int) $IMINLENGTH ;
	     atspec->max_length = (int) $IMAXLENGTH ;
	     atspec->decl_required = $VDECLREQUIRED != NULL ;
	     atspec->type_required = $VTYPEREQUIRED != NULL ;
	     atspec->function_type_required = $VFUNCTIONTYPEREQUIRED != NULL ;
	     atspec->affects_type_identity = $VAFFECTSTYPEIDENTITY != NULL ;
	     atspec->handler = melt_attribute_handler_glue ;
	     register_attribute (atspec) ;
	     debugeprintf ("melt_register_gcc_attribute_at/lambda registered atspec=%p", 
	    		(void*)atspec);
	     /* -- melt_register_gcc_attribute_at/lambda $GCCATTR_CHK end */
	     }#)
	 )
	 (debug "melt_register_gcc_attribute_at/lambda" " end, attr=" attr)
	 (return)
	 )
       )
     );end append gcc_attribute_installer_list
    (mapstring_putstr gcc_attribute_dict name attr)
    (debug "melt_register_gcc_attribute_at end attr=" attr 
	   ";\n gcc_attribute_dict=" gcc_attribute_dict)
    )
  )

(export_values melt_register_gcc_attribute_at)
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; private final exit queue
(definstance final_exit_delayed_queue class_delayed_queue
  :named_name '"final_exit_delayed_queue"
  :delqu_first (make_list discr_list)
  :delqu_last (make_list discr_list)
  )

;;; exit hook 
(defhook hook_exit_finalizer () () :void
  :predef HOOK_EXIT_FINALIZER
  (debug "hook_exit_finalizer final_exit_delayed_queue=" final_exit_delayed_queue)
  (let ( (firstlist (get_field :delqu_first final_exit_delayed_queue))
	 (lastlist (get_field :delqu_last final_exit_delayed_queue))
	 (revlastlist (make_list discr_list))
	 )
;;; call the first routines in natural order
    (foreach_pair_component_in_list
     (firstlist)
     (curpair firstproc)
     (firstproc ())
     )
;;; reverse the last list
    (foreach_pair_component_in_list
     (lastlist)
     (curpair lastproc)
     (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
    (foreach_pair_component_in_list
     (revlastlist)
     (curpair lastproc)
     (lastproc ())
     )))
    

(defun at_exit_first (fun)
  :doc #{Use $AT_EXIT_FIRST to register a function to be run at MELT
exit, in first place.}#
  (let ( (firstlist (unsafe_get_field :delqu_first final_exit_delayed_queue))
	 )
    (if (is_closure fun) (list_append firstlist fun)))
  )  

(defun at_exit_last (fun)
  :doc #{Use $AT_EXIT_LAST to register a function to be run at MELT
exit, in last place.}#
  (let ( (lastlist (unsafe_get_field :delqu_last final_exit_delayed_queue))
	 )
    (if (is_closure fun) (list_append lastlist fun)))
  )


;; pragma support is related to trees, so most of it is done in
;; libmelt-ana-tree.melt however, the hook is predefined so should
;; appear here. In fact, it calls a forward reference variable.


(defvar pragma_processor)

(defun register_pragma_processor (pfun)
  (debug "register_pragma_processor pfun=" pfun " pragma_processor=" pragma_processor)
  (assert_msg "check no pragma_processor" (null pragma_processor) pragma_processor)
  (shortbacktrace_dbg "register_pragma_processor" 12)
  (if (is_closure pfun)
      (setq pragma_processor pfun))
  (debug "register_pragma_processor now pragma_processor=" pragma_processor)
  )

(defvar pragma_handler_tuple)

(defhook hook_process_pragma (:long lix) () :void
  :predef HOOK_PROCESS_PRAGMA
  :doc #{$HOOK_PROCESS_PRAGMA is an internal hook to process a pragma.}#
  (debug "hook_process_pragma lix=" lix "; pragma_handler_tuple=" pragma_handler_tuple)
  (let ( (ph (multiple_nth pragma_handler_tuple lix))
	 )
    (shortbacktrace_dbg "hook_process_pragma" 12)
    (debug "hook_process_pragma lix=" lix " ph=" ph)
    (assert_msg "check ph" (is_a ph class_gcc_pragma))
    ((get_field :gccpragma_handler ph) ph)
    (debug "hook_process_pragma done ph=" ph)))


;; we define the hook_register_pragmas here so that it gets built by 'make upgrade-warmelt'
(defhook hook_register_pragmas () () :void
  :predef HOOK_REGISTER_PRAGMAS
  (debug "hook_register_pragmas start pragma_processor=" pragma_processor
	 "\n.. pragma_handler_tuple=" pragma_handler_tuple "\n")
  (shortbacktrace_dbg "hook_register_pragmas" 15)
  (cond 
   ( (is_closure pragma_processor)
     (debug "hook_register_pragmas before calling pragma_processor=" pragma_processor)
     (pragma_processor pragma_handler_tuple)
     (debug "hook_register_pragmas done with pragma_processor=" pragma_processor))
   (:else
    (debug "hook_register_pragmas bad pragma_processor=" pragma_processor)
    (warning_at () "hook_register_pragmas has been wrongly called")
    (assert_msg "@$@invalid call of hook_register_pragmas" () pragma_processor))
   )
  )

(defun add_pragma_handler (ph)
  :doc #{Internal utility to add a pragma handler $PH which should be
  a $CLASS_GCC_PRAGMA. See also $REGISTER_EXPANDED_PRAGMA and
  $REGISTER_PLAIN_PRAGMA from @file{libmelt-ana-tree.melt}.}#
  (debug "add_pragma_handler start ph=" ph
	 " pragma_handler_tuple=" pragma_handler_tuple)
  (shortbacktrace_dbg "add_pragma_handler" 12)
  (assert_msg "check ph" (is_a ph class_gcc_pragma))
  (if (null pragma_handler_tuple)
      (setq pragma_handler_tuple (make_multiple discr_multiple 16)))  
  (let ( (:long lix 0)
	 (:long nbph (multiple_length pragma_handler_tuple))
	 )
    (foreach_in_multiple
     (pragma_handler_tuple)
     (comp :long ix)
     (when ix
	 (unless comp
	   (setq lix ix)
	   (setq ix (+i nbph 1))
	   (void))))
    (unless lix
      (let ( (:long newnbph (+ nbph 16 (* 2 (/i nbph 8))))
	     (newtup (make_multiple discr_multiple newnbph))
	     )
	(foreach_in_multiple
	 (pragma_handler_tuple)
	 (comp :long ix)
	 (if ix (multiple_put_nth newtup ix comp)))
	(setq pragma_handler_tuple newtup)
	(setq lix nbph)
	(setq nbph newnbph)
	(void)
	))
    (put_int ph lix)
    (multiple_put_nth pragma_handler_tuple lix ph)
    (debug "add_pragma_handler ph=" ph " lix=" lix)
    (return ph)
    ))    


(defun remove_pragma_handler (ph)
  :doc #{Utility to remove a pragma handler $PH which should be a
  $CLASS_GCC_PRAGMA or a boxed integer.}#
  (debug "remove_pragma_handler ph=" ph)
  (shortbacktrace_dbg "remove_pragma_handler" 12)
  (if (is_integerbox ph)
      (setq ph (multiple_nth pragma_handler_tuple (get_int ph))))
  (if (is_a ph class_gcc_pragma)
      (let ( (:long phrk (get_int ph))
	     )
	(if (== (multiple_nth pragma_handler_tuple phrk) ph)
	    (multiple_put_nth pragma_handler_tuple phrk ()))))
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(export_values
 add_pragma_handler
 at_end_of_this_melt_pass_first
 at_end_of_this_melt_pass_last
 at_exit_first
 at_exit_last
 at_finish_unit_first
 at_finish_unit_last
 at_melt_attribute_first
 at_melt_attribute_last
 at_start_unit_first
 at_start_unit_last
 hook_low_debug_value_at
 hook_override_gate
 hook_process_pragma
 hook_register_pragmas
 register_all_ipa_passes_end_first
 register_all_ipa_passes_end_last
 register_all_ipa_passes_start_first
 register_all_ipa_passes_start_last
 register_all_passes_end_first
 register_all_passes_end_last
 register_all_passes_start_first
 register_all_passes_start_last
 register_early_gimple_passes_end_first
 register_early_gimple_passes_end_last
 register_early_gimple_passes_start_first
 register_early_gimple_passes_start_last
 register_finish_decl_first
 register_finish_decl_last
 register_finish_type_first
 register_finish_type_last
 register_override_gate_first
 register_override_gate_last
 register_pass_execution_first
 register_pass_execution_last
 register_pragma_processor
 register_pre_genericize_first
 register_pre_genericize_last
 remove_pragma_handler
 unregister_override_gate_first
 unregister_override_gate_last
 )



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



(cheader #{ /* header from warmelt-hooks.melt for poll etc... */
#include <poll.h>

#define MELT_BUFSIZE 8192
#define MELT_POLL_DELAY_MILLISEC 500
}#)



(defvar melt_inpchanbuck) ;;contain bucket of longs for input handling

(defclass class_paragraph_input_channel_handler
  :doc #{$CLASS_PARAGRAPH_INPUT_CHANNEL_HANDLER is for input channel
  handlers which are accepting paragraphs terminated by two
  newlines. See also $CLASS_RAW_INPUT_CHANNEL_HANDLER}#
  :super class_input_channel_handler
  :fields ())

(defclass class_raw_input_channel_handler
  :doc #{$CLASS_RAW_INPUT_CHANNEL_HANDLER is for input channel
  handlers which are accepting raw input data, without paragraph
  separation. See also $CLASS_PARAGRAPH_INPUT_CHANNEL_HANDLER.}#
  :super class_input_channel_handler
  :fields ())

(export_class class_raw_input_channel_handler class_paragraph_input_channel_handler)
  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; internal utility to read input and invoke the callbacks
(defun melt_invoke_input_callbacks (tupinch tupstate :long nbins)
  :doc #{$MELT_INVOKE_INPUT_CALLBACKS is an internal utility, useful
  for $REGISTER_RAW_INPUT_CHANNEL_HANDLER and
  $REGISTER_PARAGRAPH_INPUT_CHANNEL_HANDLER...}#
  (debug "melt_invoke_input_callbacks tupinch=" tupinch
	 "\n.. tupstate=" tupstate
	 "\n.. nbins=" nbins)
  (block_signals 
   () ()   
   (let ( (removelist (make_list discr_list))
	  (buck melt_inpchanbuck)
	  )
     (foreach_long_upto
      (0 (-i nbins 1))
      (:long ix)
      (let ( (curinch (multiple_nth tupinch ix))
	     (curstate (multiple_nth tupstate ix))
	     (curfd (get_int curinch))
	     (:long readcnt -2)
	     (sbuf (get_field :inch_sbuf curinch))
	     (clos (get_field :inch_clos curinch))
	     )
	(debug "melt_invoke_input_callbacks ix#" ix " curfd#" curfd
	       " curinch=" curinch "\n.. curstate=" curstate)
	(assert_msg "check curinch" (is_a curinch class_input_channel_handler) curinch)
	(assert_msg "check curfd" (>=i curfd 0) curfd)
	(if curstate
	    (progn ;; should read and callback if got entire message
	      (code_chunk 
	       read_chk
	       #{ /* melt_invoke_input_callbacks $READ_CHK */
	       static char rdbuf[MELT_BUFSIZE] ;
	       memset (&rdbuf, 0, sizeof (rdbuf)) ;
	       $READCNT = read ($CURFD, rdbuf, sizeof(rdbuf)) ;
	       if ($READCNT > 0)
	         meltgc_add_out_raw_len ((melt_ptr_t) $SBUF, rdbuf, $READCNT) ;
		 }#)
	      (debug "melt_invoke_input_callbacks" "after read curfd=" curfd ", readcnt=" readcnt
		     ", sbuf=" sbuf "\n")
	      (when (==i readcnt 0)
		(list_append removelist curinch)
		(setq curstate ()))
	      (void)
	      )
	  (progn ;; should callback for eof close and remove from bucks
	    (debug "melt_invoke_input_callbacks" " no curstate curinch=" curinch)
	    (list_append removelist curinch)
	    ))
	(debug "melt_invoke_input_callbacks" " readcnt=" readcnt
	       " sbuf=" sbuf ";\n curinch=" curinch)
	(cond ( (is_a curinch class_paragraph_input_channel_handler)
		;; loop to handle every 2-newline ended paragraph in the sbuf
		(forever 
		 scanloop
		 (let ( (:long stop 0)
			(seqv ())
			)
		   (code_chunk 
		    eat_chk
		    #{ /* melt_invoke_input_callbacks $EAT_CHK */
		    const char* bufdata = melt_strbuf_str ((melt_ptr_t) $SBUF) ;
		    char* buf2nl = bufdata
		        ? CONST_CAST (char*, strstr(bufdata,"\n\n")) 
		        : NULL ;
		    if (buf2nl)  {
		      int paralen = buf2nl - bufdata + 2 ;
		      ((char*) buf2nl)[1] = '\0' ;
		      $SEQV =  meltgc_read_from_rawstring (bufdata, NULL, 
		      						  UNKNOWN_LOCATION) ;
		      melt_strbuf_consume ((melt_ptr_t) $SBUF, paralen) ;
		    }
		    else   {
		      $STOP = 1;
		      if (!$CURSTATE && bufdata) {
		        int buflen = strlen (bufdata) ;
		        $SEQV = meltgc_read_from_rawstring (bufdata, NULL, 
		        				    UNKNOWN_LOCATION) ;
		        melt_strbuf_consume ((melt_ptr_t) $SBUF, buflen) ;
		      }
		    }
		    }#)
		   (when seqv
		     (debug "melt_invoke_input_callbacks paragraph seqv=" seqv "\n curinch=" curinch)
		     (clos curinch seqv))
		   (if stop (exit scanloop))
		   )
		 )			;end scanloop
		)
	      ( (is_a curinch class_raw_input_channel_handler)
		(debug "melt_invoke_input_callbacks" " raw sbuf=" sbuf ";\n curinch=" curinch)
		;; pass the sbuf to separate the EOF case
	       (clos curinch sbuf)
	       )
	      (:else
	       (assert_msg "melt_invoke_input_callbacks invalid curinch" () curinch))
	      )
	(when (null curstate)
	  (debug "melt_invoke_input_callbacks eof curinch=" curinch)
	  (clos curinch ())
	  )
	)
      )					;end for ix
     (debug "melt_invoke_input_callbacks removelist=" removelist)
     (foreach_pair_component_in_list
      (removelist)
      (curpair curemove)
      (debug "melt_invoke_input_callbacks curemove=" curemove)
      (setq buck (bucketlong_remove buck (get_int curemove)))
      )
     (setq melt_inpchanbuck buck)
     )
   )
  )				     ;end melt_invoke_input_callbacks 



(defhook hook_poll_inputs 
  (:long delayms)
  ()
  :void
  :predef HOOK_POLL_INPUTS
  :doc #{The $HOOK_POLL_INPUTS is making a multiplexing @code{poll(2)}
  syscall -with the milliseconds delay given by $DELAYMS- and then
  reading appropriate input file descriptors and running the callback
  registered with $REGISTER_PARAGRAPH_INPUT_CHANNEL_HANDLER or
  $REGISTER_RAW_INPUT_CHANNEL_HANDLER. It is usually called to service
  the SIGIO signal, but could be called elsewhere. For experts
  mostly.}#
  (let ( (inchbuck melt_inpchanbuck)
	 (:long nbinch (bucketlong_count inchbuck))
	 (:long respoll 0)
	)
    (debug "hook_poll_inputs inchbuck=" inchbuck " delayms=" delayms)
    (when (==i nbinch 0)
      (debug "hook_poll_inputs empty inchbuck")
      (code_chunk 
       pollsleep_chk 
       #{/* hook_poll_inputs $POLLSLEEP_CHK do the poll */
       $RESPOLL = poll (NULL, 0, $DELAYMS);
       }#)
      (return))
    (let (
	  (tupinch (make_multiple discr_multiple nbinch))
	  (:long nbfd 0)
	  )
      (code_chunk 
       pollin_chk 
       #{ /* hook_poll_inputs $POLLIN_CHK start */
       struct pollfd *fdtab
         = (struct pollfd *) xcalloc ($NBINCH+1, sizeof(struct pollfd));
       /* hook_poll_inputs $POLLIN_CHK iteration to fill fdtab */
       $(foreach_in_bucketlong
         (inchbuck)
         (:long curfd :value curinchd)
         (debug "hook_poll_inputs curfd#" curfd ", curinchd=" curinchd)
         (when (is_a curinchd class_input_channel_handler)
	   (assert_msg "check curinchd" (==i (get_int curinchd) curfd) curinchd curfd)
	   (code_chunk 
	    addfd_chk
	    #{ /* hook_poll_inputs $POLLIN_CHK with $ADDFD_CHK */
	    fdtab[$NBFD].fd = (int) $CURFD ;
	    fdtab[$NBFD].events = POLLIN ;
	    fdtab[$NBFD].revents = 0 ;
	    }#)
	   (multiple_put_nth tupinch nbfd curinchd)
	   (setq nbfd (+i nbfd 1))
	   )
         )
       $(progn (debug "hook_poll_inputs nbfd=" nbfd " tupinch=" tupinch) (void))
       /* hook_poll_inputs $POLLIN_CHK do the poll */
       $RESPOLL = poll (fdtab, $NBFD, $DELAYMS);
       debugeprintf ("hook_poll_inputs respoll=%ld", $RESPOLL);
       $(if (>i respoll 0)
	    (let ( 
		  (tupstate (make_multiple discr_multiple nbfd))
		  (badinchlist (make_list discr_list))
		  )
	  (foreach_long_upto
	   (0 (-i nbfd 1))
	   (:long ix)
	   (let ( (curinchd (multiple_nth tupinch ix))
		  )
	     (debug "hook_poll_inputs ix#" ix " curinchd=" curinchd)
	     (cond 
	      ( (expr_chunk testpollin_chk :long 
			   ##{/* hook_poll_inputs $TESTPOLLIN_CHK */ 
			   fdtab[$IX].revents & POLLIN}#)
		(debug "hook_poll_inputs POLLIN ix#" ix)
		(multiple_put_nth tupstate ix :true) 
		)
	      ;; POLLERR & POLLHUP cannot happen for input polling
	      ( (expr_chunk testpollnval_chk :long 
			   ##{/* hook_poll_inputs $TESTPOLLNVAL_CHK */ 
			   fdtab[$IX].revents & POLLNVAL}#)
		(debug "hook_poll_inputs POLLNVAL ix#" ix)
		(multiple_put_nth tupstate ix ())
		(list_append badinchlist curinchd)
		)
	      )
	   )) ;; end foreach_long_upto ix
	  (debug "hook_poll_inputs nbfd#" nbfd
		 "\n.. tupstate=" tupstate
		 "\n.. badinchlist=" badinchlist)
	  (foreach_pair_component_in_list
	   (badinchlist)
	   (curpair curinchb)
	   (debug "hook_poll_inputs bad curinchb=" curinchb)
	   (bucketlong_put inchbuck (get_int curinchb) :true)
	   )
	  (debug "hook_poll_inputs before melt_invoke_input_callbacks tupinch=" tupinch
		 "\n.. tupstate=" tupstate "\n.. nbfd=" nbfd)
	  (melt_invoke_input_callbacks tupinch tupstate nbfd)	
	  (debug "hook_poll_inputs after melt_invoke_input_callbacks nbfd=" nbfd)
	  (void)
	  ))
       /* hook_poll_inputs $POLLIN_CHK final */
       free (fdtab);
       /* hook_poll_inputs $POLLIN_CHK end */ }#))
      )
)


(defun is_polling_inputs ()
  :doc #{$IS_POLLING_INPUTS return :TRUE with secondarily the number of input channels 
  if some channels are polling, or nil otherwise}# 
  (let ( (inchbuck melt_inpchanbuck)
	 (:long nbinch (bucketlong_count inchbuck))
	 )
    (if nbinch (return :true nbinch)
      (return () 0))
))

(defun every_polling_input (f)
  :doc #{$EVERY_POLLING_INPUTS applies the given closure $F to every
  input channel. Iteration is stopped if that application returns nil.}# 
  (let ( (inchbuck melt_inpchanbuck)
	 (:long nbinch (bucketlong_count inchbuck))
	 (lischan (make_list discr_list))
	 )
    (when nbinch 
      (block_signals 
       () ()
       (foreach_in_bucketlong
	(inchbuck)
	(:long fd :value chv)
	(if (is_a chv class_input_channel_handler)
	    (list_append lischan chv))
	))
      (when (is_closure f)
	(foreach_pair_component_in_list 
	 (lischan)
	 (curpair curchan)
	 (debug "every_polling_input curchan=" curchan)
	 (if (null (f curchan))
	     (setq curpair ())))))))

(defun get_polling_input (bi)
  :doc #{The function $GET_POLLING_INPUT gets the polling input associated to integer in $BI.}#
  (let ( (inchbuck melt_inpchanbuck)
	 (:long nbinch (bucketlong_count inchbuck))
	 (:long i (get_int bi))
	 )
    (when nbinch 
      (block_signals 
       () ()
       (let ( (curb (bucketlong_get inchbuck i))
	      )
	 (if (is_a curb class_input_channel_handler)
	     (return curb)))))
    (return ())
  ))

;;;;;;;;;;;;;;;;
(defun register_paragraph_input_channel_handler (clos data :long inchfd)
  :doc #{$REGISTER_PARAGRAPH_INPUT_CHANNEL_HANDLER registers an asynchronous
  paragraph input channel handler, such as for the graphical user interface
  probe. $CLOS is the registered closure, $DATA is some client data,
  $INCHFD is the input Unix file descriptor. When an entire
  message (double-newline ended sequence of MELT values in MELT
  syntax) is recieved from the $INCHFD, the $CLOS is applied to the
  input channel handler -containing the data as its $INCH_DATA field-,
  a read-only instance of $CLASS_INPUT_CHANNEL_HANDLER, and to the
  read list. When end-of-file is obtained on $INCHFD, the closure is
  similarily applied with a null value instead of the read list.}#
  (debug "register_paragraph_input_channel_handler clos=" clos " data=" data 
	 " inchfd=" inchfd)
  (let ( (:long goodinchfd 0) )
    (if (and (is_closure clos)
	     (>=i inchfd 0))
	(code_chunk
	 statinchfdchk
	 #{ /*register_paragraph_input_channel_handler $STATINCHFDCHK */ {
         struct stat $STATINCHFDCHK#_stat;
	 memset (& $STATINCHFDCHK#_stat, 0, sizeof(struct stat));
	 if (fstat ($INCHFD, & $STATINCHFDCHK#_stat))
	 warning(0, "MELT bad registered paragraph input channel fd#%d - %s",
		    (int) $INCHFD, xstrerror (errno));
	 else
	 $GOODINCHFD = 1; 
	 } /* end $STATINCHFDCHK */ }#)
      )
    (if (not goodinchfd) (return)))
  (let ( (insbuf (make_strbuf discr_strbuf)) 
	 (inchdlr (instance class_paragraph_input_channel_handler 
			    :inch_sbuf insbuf
			    :inch_clos clos
			    :inch_data data))
	 (inbuck melt_inpchanbuck)
	 )
    (put_int inchdlr inchfd)
    (if (not (is_bucketlong inbuck))
	(let ( (newinbuck (make_bucketlong discr_bucket_longs 50))
	       )
	  (setq inbuck newinbuck)))
    (let ( (updatedinbuck (bucketlong_put inbuck inchfd inchdlr))
	   )
      (setq melt_inpchanbuck updatedinbuck)
      (code_chunk 
       fcntlinchfdchk
       #{ /* register_paragraph_input_channel_handler $FCNTLINCHFDCHK start */
	  if (fcntl ($INCHFD, F_SETOWN, getpid()))
	  melt_fatal_error("MELT failed to set ownership (F_SETOWN) fd #%d - %s",
			   (int) $INCHFD, xstrerror (errno));
          /* end  $FCNTLINCHFDCHK register_paragraph_input_channel_handler */
	  }#)
      )))

;;;;;;;;;;;;;;;;
(defun register_raw_input_channel_handler (clos data :long inchfd)
  :doc #{$REGISTER_RAW_INPUT_CHANNEL_HANDLER registers an asynchronous
  raw input channel handler, such as for some JSONRPC server (e.g. by
  $DO_BLOCKING_JSONRPC2_CALL). $CLOS is the registered closure, $DATA
  is some client data, $INCHFD is the input Unix file descriptor. When
  some bytes are recieved from the $INCHFD, the $CLOS is applied - by
  $MELT_INVOKE_INPUT_CALLBACKS utility - to the input channel handler
  -containing the data as its $INCH_DATA field-, a read-only instance
  of $CLASS_INPUT_CHANNEL_HANDLER and to the contained string buffer.
  When end-of-file is obtained on $INCHFD, the closure is similarily
  applied to the channel and a null value.}#
  (debug "register_raw_input_channel_handler clos=" clos " data=" data 
	 " inchfd=" inchfd)
  (let ( (:long goodinchfd 0) )
    (if (and (is_closure clos)
	     (>=i inchfd 0))
	(code_chunk
	 statinchfdchk
	 #{ /*register_raw_input_channel_handler $STATINCHFDCHK */ {
         struct stat $STATINCHFDCHK#_stat;
	 memset (& $STATINCHFDCHK#_stat, 0, sizeof(struct stat));
	 if (fstat ($INCHFD, & $STATINCHFDCHK#_stat))
	 warning(0, "MELT bad registered raw input channel fd#%d - %s",
		    (int) $INCHFD, xstrerror (errno));
	 else
	 $GOODINCHFD = 1; 
	 } /* end $STATINCHFDCHK */ }#)
      )
    (if (not goodinchfd) (return)))
  (let ( (insbuf (make_strbuf discr_strbuf)) 
	 (inchdlr (instance class_raw_input_channel_handler 
			    :inch_sbuf insbuf
			    :inch_clos clos
			    :inch_data data))
	 (inbuck melt_inpchanbuck)
	 )
    (put_int inchdlr inchfd)
    (if (not (is_bucketlong inbuck))
	(let ( (newinbuck (make_bucketlong discr_bucket_longs 50))
	       )
	  (setq inbuck newinbuck)))
    (let ( (updatedinbuck (bucketlong_put inbuck inchfd inchdlr))
	   )
      (setq melt_inpchanbuck updatedinbuck)
      (code_chunk 
       fcntlinchfdchk
       #{ /* register_raw_input_channel_handler $FCNTLINCHFDCHK start */
	  if (fcntl ($INCHFD, F_SETOWN, getpid()))
	  melt_fatal_error("MELT failed to set ownership (F_SETOWN) fd #%d - %s",
			   (int) $INCHFD, xstrerror (errno));
          /* end  $FCNTLINCHFDCHK register_raw_input_channel_handler */
	  }#)
      )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; connect to a server thru a socket
(cheader
 #{ /* headers before connect_to_server */
 #include <sys/socket.h>
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <sys/un.h>
 #include <netinet/in.h>
 #include <netinet/ip.h>
 #include <netinet/tcp.h>
 #include <netdb.h>
 #include <map>
 
 struct Melt_connect_info {
   std::string             mci_service;
   int             	   mci_family;
   int             	   mci_socktype;
   int             	   mci_protocol;
   socklen_t       	   mci_addrlen;
   struct sockaddr_storage mci_sockaddr;
   };
 typedef std::map<std::string,Melt_connect_info> melt_connect_info_map_t;
 /* end of headers for connect_to_server */
 }#)

(defun connect_to_server (service :long quiet)
  :doc #{the $CONNECT_TO_SERVER function connect thru a socket to a
  given $SERVICE. If $SERVICE is a boxed integer, it is an already
  connected socket file descriptor. If $SERVICE is a string containing
  a / it is understood as @code{AF_UNIX} socket name. Otherwise it
  should be a @var{hostname}@code{:}@var{portnumber} for TCP/IPv4 or
  IPv6, with @code{:1234} understood as @code{localhost:1234}. Returns
  a boxed integer to a connected socket file descriptor, or NIL on
  system error. Gives GCC warnings on system errors. If $QUIET is
  zero, gives GCC notice inform on success. Notice that for IP
  connections, the IP address is cached so would be requested once.}#
  (debug "connect_to_server start service=" service)
  (cond
   ;;; boxed integer, a connected socket
   ( (is_integerbox service)
     ;; already connected socket, use getpeername
     ;;
     (let ( (:long servicenumfd (get_int service))
	    )
       (code_chunk
        getpeer_chk #{ /* connect_to_server $GETPEER_CHK */
        struct sockaddr_storage sa ;
        char sahname[80] ;           
        memset ((void*)&sa, 0, sizeof(sa)) ;
        memset ((void*)sahname, 0, sizeof(sahname)) ;
        socklen_t salen = sizeof(sa) ;
        if (getpeername((int)$SERVICENUMFD, (struct sockaddr*)&sa, &salen)) {
          warning (0, "MELT connect_to_server: on file descriptor #%d failed getpeername: %s",
                   (int)$SERVICENUMFD, xstrerror(errno)) ;
          $(ignore (return ())) ;
	} ;	  
        if (!$QUIET) {
          if (getnameinfo((const struct sockaddr *)(&sa), salen,
                          sahname, sizeof(sahname),
                          NULL, 0, 0)) {
            warning (0, "MELT connect_to_server: on file descriptor #%d failed getnameinfo: %s",
                     (int)$SERVICENUMFD, xstrerror(errno)) ;
            $(ignore (return ())) ;
          } ;
          inform (UNKNOWN_LOCATION,
		  "MELT connect_to_server with file descriptor #%d of peer %s",
		  (int)$SERVICENUMFD, sahname) ;
	  }
        }#)
       (debug "connect_to_server service=" service " good peered file descriptor#" servicenumfd)
       (return (constant_box servicenumfd))
       )
     )
   ;; should be a string
   ( (not (is_string service))
     (warning_at () "connect_to_server invalid service $1" service)
     (return))
   ( (>i (string_length service) 100)
     (warning_at () "connect_to_server too long service $1, more than 100 chars" service)
     (return))
   ;; unix-like socket with /
   ( (expr_chunk unixsockslash_chk :long
		 #{/* connect_to_server $UNIXSOCKSLASH_CHK */ strchr (melt_string_str ($SERVICE), '/') != NULL}#)
     (let ( (:long unixsockfd -1)
	    )
       (code_chunk connectunix_chk
		 #{ /* connect_to_server $CONNECTUNIX_CHK */
		 /* UNIX_PATH_MAX might be defined, but usually not, see unix(7) man page */
#ifndef UNIX_PATH_MAX
#define UNIX_PATH_MAX 100
#endif /*UNIX_PATH_MAX */
		 struct sockaddr_un saun;
		 memset (&saun, 0, sizeof(saun));
		 debugeprintf("connect_to_server unix service %s",
			      melt_string_str($SERVICE));
		 if (strlen(melt_string_str($SERVICE))>=UNIX_PATH_MAX) {
		    warning (0, "MELT connect_to_server: AF_UNIX too long path %s", melt_string_str($SERVICE));
		    $(ignore (return ()));
		 };
		 saun.sun_family = AF_UNIX;
		 strncpy (saun.sun_path,  melt_string_str($SERVICE), UNIX_PATH_MAX);
		 $UNIXSOCKFD = socket (AF_UNIX, SOCK_STREAM, 0);
		 if ((int)$UNIXSOCKFD<0) {
		   warning (0, "MELT connect_to_server: AF_UNIX %s socket failure: %s",
			    saun.sun_path, xstrerror(errno));
		   $(ignore (return ()));
		 };
		 // read man page unix(7)
		 socklen_t saulen = offsetof(struct sockaddr_un, sun_path) + strlen(saun.sun_path) + 1;
		 debugeprintf ("connect_to_server: connect sun_path %s saulen=%d",
			       saun.sun_path, (int)saulen);
		 if (connect ((int)$UNIXSOCKFD, (const struct sockaddr*)&saun, saulen)) {
		   warning (0, "MELT connect_to_server: AF_UNIX %s connect failure: %s",
			       saun.sun_path, xstrerror(errno));
		   (void) close((int)$UNIXSOCKFD);
		   $(ignore (return ()));
		 };
		 if (!$QUIET)
		   inform (UNKNOWN_LOCATION,
			   "MELT connect_to_server: connected to Unix socket %s file descriptor #%d",
			   saun.sun_path, (int)$UNIXSOCKFD) ;		    
		 }#)
       (debug "connect_to_server service=" service " unixsockfd=" unixsockfd)
       (return (constant_box unixsockfd))
     ))
   ;; TCP-like socket with at least one colon <host>:<port>
   ( (expr_chunk unixsockslash_chk :long
		 #{/* connect_to_server $UNIXSOCKSLASH_CHK */ strchr (melt_string_str ($SERVICE), ':') != NULL}#)
     (let ( (:long tcpsockfd -1)
	    )
       (code_chunk
	connecttcp_chk
	#{ /* connect_to_server $CONNECTTCP_CHK */
	int locportnum = -1;
	int pos = -1;
	struct addrinfo hints = { 0 };
	char remservicename[24] = { 0 };
	char remhostname[80] = { 0 };
	struct addrinfo *adinf = NULL;
	int gstatus = -1;
	static melt_connect_info_map_t coninfmap;
	Melt_connect_info conninfo;
	bool gotconninfo = false;
	const char* servicestr = melt_string_str ($SERVICE);
	debugeprintf("connect_to_server TCPlike servicestr=%s", servicestr);
	if ((sscanf(servicestr, "localhost:%d", &locportnum)>0
	     || sscanf(servicestr, ":%d", &locportnum)>0)
	    && locportnum>0) {
	    debugeprintf("connect_to_server locportnum=%d", locportnum);
	    struct sockaddr_in sain;
	    memset (&sain, 0, sizeof (sain));
	    servicestr = NULL;
	    sain.sin_family = AF_INET;
	    sain.sin_port = htons ((int)locportnum);
	    sain.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
	    $TCPSOCKFD = (long) socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);
	    if ((int)$TCPSOCKFD<0) {
	      warning (0, "MELT connect_to_server: localhost:%d socket failure: %s",
		       locportnum, xstrerror(errno));
	      $(ignore (return ()));
	    }
	    if (connect ((int)$TCPSOCKFD, (const struct sockaddr*)&sain, (socklen_t)sizeof(sain))) {
	       warning (0, "MELT connect_to_server: localhost:%d connect failure: %s",
			locportnum, xstrerror(errno));
	       (void) close((int)$TCPSOCKFD);
	       $(ignore (return ()));
	       }
	     }
	     else { /* try IPv6 connection with getaddrinfo, <hostname>:<servicenameorport> */
                     memset (&hints, 0, sizeof (hints));
		     /// use the memoized connect info, if available
		     {
		       const char* servicestr = melt_string_str ($SERVICE);
		       gcc_assert (servicestr != NULL);
		       melt_connect_info_map_t::iterator iterconninfo = coninfmap.find(std::string(servicestr));
		       if (iterconninfo != coninfmap.end()) {
		         conninfo = iterconninfo->second;
		         gotconninfo = true;
		       }
		       debugeprintf("connect_to_server gotconninfo=%d",
				    (int) gotconninfo);
		       if (strlen(servicestr) >= sizeof(remhostname)) {
		          warning (0, "MELT connect_to_server: too long service name %s", servicestr);
			  $(ignore (return ()));
		       };
		       const char* lastcolon = strrchr(servicestr, ':');
		       gcc_assert (lastcolon != NULL && lastcolon > servicestr+1);
		       strncpy(remhostname, servicestr, MIN(lastcolon-servicestr, sizeof(remhostname)));
		       strncpy(remservicename, lastcolon+1, sizeof(remservicename)-1);
		       debugeprintf("connect_to_server remhostname=%s remservicename=%s", remhostname, remservicename);
		       if (gotconninfo) { // cached network info from previous call
		         gcc_assert (!strcmp(conninfo.mci_service.c_str(), melt_string_str($SERVICE)));
                         $TCPSOCKFD = (long) socket (conninfo.mci_family, conninfo.mci_socktype, conninfo.mci_protocol);
			 if ((int)$TCPSOCKFD<0) {
			   warning (0, "MELT connect_to_server: cached service %s socket failed: %s",
				       melt_string_str($SERVICE), xstrerror(errno));
			   $(ignore (return ()));
			 }
                         if (connect ((int)$TCPSOCKFD, (struct sockaddr *) &conninfo.mci_sockaddr,
				      conninfo.mci_addrlen) < 0) {
			   warning (0, "MELT connect_to_server: cached service %s connect failed: %s",
				       melt_string_str($SERVICE), xstrerror(errno));
			   $(ignore (return ()));
			 };			 
			 $(progn (debug "connect_to_server cached service=" service " tcpsockfd=" tcpsockfd)
				 (return (constant_box tcpsockfd))
				 (void))			 
		       };// end if gotconninfo
		     };  		       
                     hints.ai_family = AF_UNSPEC;
                     hints.ai_socktype = SOCK_STREAM;
                     hints.ai_flags = AI_PASSIVE | AI_CANONNAME;
                     if ((gstatus = getaddrinfo (remhostname, remservicename, &hints, &adinf)) != 0) {
		       warning (0, "MELT connect_to_server: getaddrinfo host %s service %s failed: %s",
                                remhostname, remservicename, gai_strerror(gstatus));
		       $(ignore (return ()));
                     };
                     for (struct addrinfo * curadinf = adinf; 
                          curadinf != NULL;
 	                  curadinf = curadinf->ai_next)
	               {
                         errno = 0;
                         $TCPSOCKFD = (long) socket (curadinf->ai_family, curadinf->ai_socktype,
		                                     curadinf->ai_protocol);
                         if ((int)$TCPSOCKFD<0 && curadinf->ai_next) 
                           continue;
                         if ((int)$TCPSOCKFD<0) {
                           int errnosocket = errno;
	                   struct protoent *protoent = getprotobynumber (curadinf->ai_protocol);
	                   char protonumbuf[8] = { 0 };
                           char* protoname = NULL;
	                   if (protoent) 
                              protoname = protoent->p_name;
                           else {
                              snprintf (protonumbuf, sizeof (protonumbuf), "%d",
		                        curadinf->ai_protocol);
                              protoname = protonumbuf;
                           };
		           warning (0, "MELT connect_to_server socket remote host %s service %s failed for protocol %s: %s",
                                    remhostname, remservicename, protoname,
                                    xstrerror(errnosocket));
                           freeaddrinfo (adinf);
                           $(ignore (return ()));
                         }; // end if (int)$TCPSOCKFD<0 
                         if (connect ((int)$TCPSOCKFD, (struct sockaddr *) curadinf->ai_addr,
	                     curadinf->ai_addrlen) < 0) {
                           int errnoconnect = errno;
	                   struct protoent *protoent = getprotobynumber (curadinf->ai_protocol);
	                   char protonumbuf[8] = { 0 };
                           char* protoname = NULL;
	                   if (protoent) 
                              protoname = protoent->p_name;
                           else {
                              snprintf (protonumbuf, sizeof (protonumbuf), "%d",
		                        curadinf->ai_protocol);
                              protoname = protonumbuf;
                           };
		           warning (0, "MELT connect_to_server connect remote host %s service %s failed for protocol %s: %s",
                                    remhostname, remservicename, protoname,
                                    xstrerror(errnoconnect));
                           freeaddrinfo (adinf);
                           $(ignore (return ()));
                         } // end if connect failed
                         else 
                           { // memoize and break the loop
                              Melt_connect_info newconninfo;
                              std::string strservice(melt_string_str($SERVICE));
                              newconninfo.mci_service = strservice;
                              newconninfo.mci_family = curadinf->ai_family;
                              newconninfo.mci_socktype = curadinf->ai_socktype;
                              newconninfo.mci_protocol = curadinf->ai_protocol;
                              newconninfo.mci_addrlen = curadinf->ai_addrlen;
                              memset (&newconninfo.mci_sockaddr, 0, sizeof(struct sockaddr_storage));
                              memcpy (&newconninfo.mci_sockaddr, curadinf->ai_addr, curadinf->ai_addrlen);
                              coninfmap[strservice] = newconninfo;
                              break;
                           };
                       }; /* end for curadinf */
                       freeaddrinfo(adinf), adinf = NULL;
                     } /* end IP with getaddrinfo */
                   /* end connect_to_server $CONNECTTCP_CHK */
		   }#)
       (debug "connect_to_server service=" service " tcpsockfd=" tcpsockfd)
       (return (constant_box tcpsockfd))
       ))
   (:else
    (warning_at () "connect_to_server: invalid service $1" service)
    (return)))
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; asynchronous JSON parsing
(defclass class_json_parser
  :super class_proped
  :doc #{The $CLASS_JSON_PARSER is the internal class for asynchronous JSON parsing}#
  :fields (jsonparse_jdata
	   jsonparse_stack
	   jsonparse_errorhandler
	   jsonparse_counter
	   )
  )
(export_class class_json_parser)

(defvar json_name_dict)
(let ( (jsondict (make_mapstring discr_map_strings 71))
       )
  (mapstring_putstr jsondict '"null" :json_nil)
  (mapstring_putstr jsondict '"true" :true)
  (mapstring_putstr jsondict '"false" :json_false)
  (setq json_name_dict jsondict)
  (void))


;; internal function to lex a json sbuf it is expected that the sbuf
;; contains a JSON composite object or array.  Passing an sbuf
;; containing exactly "null" would fail (because another letter could
;; be added after that....), you'll need to pass an sbuf like "null "
;; or "null," to get a successful :json_nil
(defun json_lexer (sbuf)
  (unless (is_strbuf sbuf) 
    (return))
  (forever
   lexloop
   (let ( (:long curch -1)
	  (:long nextch -1)
	  (:long bulen (strbuf_usedlength sbuf))
	  )
     (when (<=i bulen 0) 
       (debug "json_lexer eof")
       (return))
     (code_chunk getch2_chk 
		 #{/* json_lexer $GETCH2_CHK */
		 const char* pc = melt_strbuf_unsafe_byte_address($SBUF, 0);
		 if ($BULEN>0) $CURCH= pc[0];
		 if ($BULEN>1) $NEXTCH= pc[1];
		 }#)
     (debug "json_lexer loop sbuf=" sbuf " curch=" curch " nextch=" nextch
	    " bulen=" bulen)
     (cond
      ;; skip spaces
      ((expr_chunk testspace_chk :long #{ISSPACE($CURCH)}#)
       (strbuf_consume sbuf 1)
       (again lexloop))
      ;; various single-char delimiters
      ((==i curch #\[)
       (strbuf_consume sbuf 1)
       (debug "json_lexer leftbacket")
       (return :delim :left_bracket))
      ((==i curch #\])
       (strbuf_consume sbuf 1)
       (debug "json_lexer rightbracket")
       (return :delim :right_bracket))
      ((==i curch #\,)
       (strbuf_consume sbuf 1)
       (debug "json_lexer comma")
       (return :delim :comma))
      ((==i curch #\:)
       (strbuf_consume sbuf 1)
       (debug "json_lexer colon")
       (return :delim :colon))
      ((==i curch #\{)
       (strbuf_consume sbuf 1)
       (debug "json_lexer leftbrace")
       (return :delim :left_brace))
      ((==i curch #\})
       (strbuf_consume sbuf 1)
       (debug "json_lexer rightbrace")
       (return :delim :right_brace))
      ;;
      ;; numbers
      ((expr_chunk testdigitminus_chk :long
		   #{/* json_lexer $TESTDIGITMINUS_CHK */
		   (ISDIGIT($CURCH)
			   || ((char)$CURCH== '-'
			       && ISDIGIT((char)$NEXTCH)))}#)
       (debug "json_lexer number start")
       (let ( 
	     (:long eatlen 0)
	     (val ())
	     )
	 (code_chunk
	  parsejsonnum_chk
	  #{ /* json_lexer begin $PARSEJSONNUM_CHK */
	  long l = 0 ;
	  double x = 0.0 ;
	  int lnum = melt_strbuf_peek_long_number($SBUF,0,&l) ;
	  int ldbl = melt_strbuf_peek_double_number($SBUF,0,&x)	;
	  debugeprintf("json_lexer $PARSEJSONNUM_CHK lnum=%d ldbl=%d l=%ld x=%g bulen=%ld",
		       lnum, ldbl, l, x, $BULEN);
	  if (lnum>0 && lnum>=ldbl && (long)lnum<$BULEN) {
	    $EATLEN = (long)lnum ;
	    debugeprintf("json_lexer $PARSEJSONNUM_CHK long number l=%ld eatlen=%ld", l, $EATLEN);
	    $VAL = meltgc_new_int((meltobject_ptr_t)
				  MELT_PREDEF(DISCR_CONSTANT_INTEGER),
				  l) ;
	  }
	  else if (ldbl>0 && (long)ldbl<$BULEN) {
	    $EATLEN = (long)ldbl ;
	    debugeprintf("json_lexer $PARSEJSONNUM_CHK double number x=%g eatlen=%ld", x, $EATLEN);
	    $VAL = meltgc_new_double((meltobject_ptr_t)
				     MELT_PREDEF(DISCR_CONSTANT_DOUBLE),
				     x) ;
	  }
	  /* json_lexer end $PARSEJSONNUM_CHK */
	  }#)
	 (debug "json_lexer number eatlen=" eatlen " val=" val)
	 (when eatlen
	   (strbuf_consume sbuf eatlen)
	   (debug "json_lexer number val=" val)
	   (return :number val))
	 ))
      ;;
      ;; strings
      ((==i curch #\")
       (debug "json_lexer string start")
       ;; notice that this favors rather short strings. For very long
       ;; strings (e.g. megabyte-sized) which takes several calls to be
       ;; read, the meltgc_strbuf_json_string_peek function would be
       ;; called several times. Hopefully not a big deal in practice!
       (let ( (nstr ())
	      (:long endoff 0)
	      )
	 (code_chunk peekjsonstr_chk
		     #{ /* json_lexer $PEEKJSONSTR_CHK */
		     int iend = 0 ;
		     $NSTR = meltgc_strbuf_json_string_peek ($SBUF, 0, &iend) ;
		     if ($NSTR)
		        $ENDOFF = (long) iend ;
		     }#)
	 (debug "json_lexer string nstr=" nstr " endoff=" endoff)
	 (when nstr
	   (strbuf_consume sbuf endoff)
	   (return :string nstr))
	 )
       )
      ;;
      ;; special case for "null"
      ((and (==i curch #\n)
	    (==i nextch #\u)
	    (>i bulen 4)
	    (==i (strbuf_peek sbuf 2) #\l)
	    (==i (strbuf_peek sbuf 3) #\l)
	    (let ( (:long c4 (strbuf_peek sbuf 4)) )
	      (expr_chunk testc4null_chk :long
			  #{/* json_lexer $TESTC4NULL_CHK */
			  (!ISALNUM($C4) && $C4 != '_')}#)))
       (strbuf_consume sbuf 4)
       (debug "json_lexer null")
       (return :keyword :json_nil))
      ;;
      ;; special case for "true"
      ((and (==i curch #\t)
	    (==i nextch #\r)
	    (>i bulen 4)
	    (==i (strbuf_peek sbuf 2) #\u)
	    (==i (strbuf_peek sbuf 3) #\e)
	    (let ( (:long c4 (strbuf_peek sbuf 4)) )
	      (expr_chunk testc4true_chk :long
			  #{/* json_lexer $TESTC4TRUE_CHK */
			  (!ISALNUM($C4) && $C4 != '_')}#)))
       (strbuf_consume sbuf 4)
       (debug "json_lexer true")
       (return :keyword :true))
      ;;
      ;; special case for "false"
      ((and (==i curch #\f)
	    (==i nextch #\a)
	    (>i bulen 5)
	    (==i (strbuf_peek sbuf 2) #\l)
	    (==i (strbuf_peek sbuf 3) #\s)
	    (==i (strbuf_peek sbuf 4) #\e)
	    (let ( (:long c5 (strbuf_peek sbuf 5)) )
	      (expr_chunk testc5false_chk :long
			  #{/* json_lexer $TESTC5FALSE_CHK */
			  (!ISALNUM($C5) && $C5 != '_')}#)))
       (strbuf_consume sbuf 5)
       (debug "json_lexer false")
       (return :keyword :json_false))
      ;;
      ;; keywords case, which we accept as an extension
      ((expr_chunk testalpha_chk :long
		   #{/* json_lexer $TESTALPHA_CHK */
		   (ISALPHA((char)$CURCH) || ($CURCH== '_')) }#)
       (let ( (nambuf (make_strbuf discr_strbuf))
	      (:long ix 0)
	      )
	 (debug "json_lexer start keyword")
	 (forever getalnumloop
		  (if (>i ix bulen) (return))
		  (let ( (:long curc (strbuf_peek sbuf ix)) )
		    (if
			(expr_chunk
			 testnotalnumu_chk :long
			 #{/* json_lexer $TESTNOTALNUMU_CHK */
			 (!(ISALNUM((char)$CURCH) || ($CURCH== '_'))) }#)
			(exit getalnumloop))
		    (code_chunk addtoname_chk #{ /* json_lexer $ADDTONAME_CHK */
				char buf_$ADDTONAME_CHK[4] = {0,0,0,0} ;
				buf_$ADDTONAME_CHK[0] = (char) $CURCH ;
				meltgc_add_strbuf_raw_len($NAMBUF, buf_$ADDTONAME_CHK, 1) ;
				}#)
		    )
		  (setq ix (+i ix 1))
		  )
	 (let ( (namstr (strbuf2string discr_string nambuf))
		(namjson (mapstring_getstr json_name_dict namstr))
		(namsymb (get_symbolstr namstr))
		(namkeyw (get_keywordstr namstr))
		(name (or namjson namsymb namkeyw namstr))
		)
	   (debug "json_lexer keyword name=" name)
	   (return :keyword name)
	   )   
	 )
       )
      ;;
      ;; otherwise error
      (:else
       (debug "json_lexer error sbuf=" sbuf)
       (return :error sbuf))
      )
     (debug "json_lexer fail")
     (return)
     )
   )
  )


;;;; the JSON parser stack is a list of tuples whose first element is
;;;; a MELT keyword.
;;;;
;;;;  (:json_result <closure>) ;; to return a result via <closure>
;;;;
;;;;  (:json_array <list-comp>) ;; when parsing array elements
;;;;  (:json_array_next <list-comp>) ;; when parsing array comma or closing bracket

;;;;  (:json_object_attr <list-attr> <list-val>) ;; when parsing object attribute
;;;;  (:json_object_colon <list-attr> <list-val>) ;; when parsing object colon after attribute
;;;;  (:json_object_val <list-attr> <list-val>) ;; when parsing object value
;;;;  (:json_object_next <list-attr> <list-val>) ;; when parsing object comma or closing brace


(defun json_state_accepting_jvalue (jstate)
  (match jstate
	 (?(tuple :json_result ?_) (return :true))
	 (?(tuple :json_array ?_) (return :true))
	 (?(tuple :json_object_val ?_ ?_) (return :true))
	 (?_ (return ()))))

	 

(defun make_json_parser (resclos errclos data)
  :doc #{$MAKE_JSON_PARSER create an initialized instance of
  $CLASS_JSON_PARSER with the given $RESCLOS closure getting the parsed
  JSON, the given $ERRCLOS handling errors, and some additional $DATA.}#
  (let ( (jp (instance class_json_parser
		       :jsonparse_jdata data
		       :jsonparse_stack (list (tuple :json_result resclos))
		       :jsonparse_errorhandler errclos
		       :jsonparse_counter (box 0)
	     ))
	 )
    (debug "make_json_parser jp=" jp)
    (return jp)
    ))

;; this can be passed to register_raw_input_channel_handler
(defun json_parser_input_processor (inch arg)
  (debug "json_parser_input_processor inch=" inch " arg=" arg)
  (unless arg				;eof
    (return))
  (let ( (jparser (get_field :inch_data inch))
	 (sbuf (get_field :inch_sbuf inch))
	 (jstack (get_field :jsonparse_stack jparser))
	 (jerror (get_field :jsonparse_errorhandler jparser))
	 (jcountbox (get_field :jsonparse_counter jparser))
	 (:long count 0)
	 )
    (assert_msg "check jparser" (is_a jparser class_json_parser) jparser inch)
    (assert_msg "check inch" (is_a inch class_raw_input_channel_handler))
    (assert_msg "check sbuf" (is_strbuf sbuf))
    (assert_msg "check jstack" (is_list jstack))
    (assert_msg "check jcountbox" (is_integerbox jcountbox))
    (forever
     jsonparseloop
       (setq count (+i count 1))
       (debug "json_parser_input_processor parseloop start count=" count " sbuf=" sbuf
	      " jparser=" jparser)
     (let ( (jtopstate (list_first_element jstack))
	    )
       (multicall
	(kind detail)
	(json_lexer sbuf)
	(debug "json_parser_input_processor lexed kind=" kind
	       ", detail=" detail "; jtopstate=" jtopstate "\n")
	(put_int jcountbox count)
	(match
	 (tuple kind detail)
	 (?(tuple :delim :left_brace)
	   (debug "json_parser_input_processor got leftbrace")
	   (cond
	    ((json_state_accepting_jvalue jtopstate)
	     (let ( (jnewstate (tuple :json_object_attr (list) (list)))
		    )
	       (list_prepend jstack jnewstate)
	       (debug "json_parser_input_processor after leftbrace jnewstate=" jnewstate)
	     ))
	    (:else
	     (jerror '"unexpected left brace")
	     (return)))
	   )
	 (?(tuple :delim :right_brace)
	   (debug "json_parser_input_processor got rightbrace")
	   (match jtopstate
		  (?(tuple :json_object_next ?atlist ?valist)
		    (assert_msg "check atlist samelength valist"
				(==i (list_length atlist) (list_length valist)) jtopstate)
		    (list_popfirst jstack)
		    (debug "json_parser_input_processor rightbrace atlist=" atlist "; valist=" valist)
		    (let ( (jsob (make_jsonobject discr_jsonobject atlist valist))
			   (jprevstate (list_first_element jstack))
			   )
		      (debug "json_parser_input_processor made jsob=" jsob
			     ", popped " jprevstate)
		      (match jprevstate
			     (?(tuple :json_result ?clores)
			       (debug "json_parser_input_processor after jsob result clores=" clores)
			       (assert_msg "check clores" (is_closure clores))
			       (list_popfirst jstack)
			       (clores jsob inch)
			       (return)
			       )
			     (?(tuple :json_object_val ?atlist ?valist)
			       (list_append valist jsob)
			       (multiple_put_nth jprevstate 0 :json_object_next)
			       (debug "json_parser_input_processor after jsob now jprevstate=" jprevstate)
			       )
			     (?(tuple :json_array ?complist)
			       (list_append complist jsob)
			       (multiple_put_nth jprevstate 0 :json_array_next)
			       (debug "json_parser_input_processor after jsob now jprevstate=" jprevstate)
			       )  
			     (?_
			      (debug "json_parser_input_processor after jsob bad jprevstate=" jprevstate)
			      (jerror '"unexpected object at right brace")
			      (return))
			     )
		    ))
		  (?_
		   (debug  "json_parser_input_processor bad rightbrace jtopstate=" jtopstate)
		   (jerror '"unexpected right brace")
		   (return)))
	   )
	 (?(tuple :delim :left_bracket)
	   (debug "json_parser_input_processor got leftbracket")
	   (cond
	    ((json_state_accepting_jvalue jtopstate)
	     (let ( (jnewstate (tuple :json_array (list)))
		    )
	       (list_prepend jstack jnewstate)
	       (debug "json_parser_input_processor leftbracket pushed jnewstate=" jnewstate)
	     ))
	    (:else
	     (debug "json_parser_input_processor leftbracket unhappy with jtopstate=" jtopstate)
	     (jerror '"unexpected left bracket")
	     (return)))
	   )
	 (?(tuple :delim :right_bracket)
	   (debug "json_parser_input_processor got rightbracket")
	   (match jtopstate
		  (?(tuple :json_array_next ?complist)
		    (list_popfirst jstack)
		    (let ( (jsarray (list_to_multiple complist discr_jsonarray))
			   (jprevstate (list_first_element jstack))
			   )
		      (debug "json_parser_input_processor made jsarray=" jsarray
			     ", popped " jprevstate)
		      (match jprevstate
			     (?(tuple :json_result ?clores)
			       (debug "json_parser_input_processor after array result clores=" clores)
			       (assert_msg "check clores" (is_closure clores))
			       (list_popfirst jstack)
			       (clores jsarray inch)
			       (return)
			       )
			     (?(tuple :json_object_val ?atlist ?valist)
			       (list_append valist jsarray)
			       (multiple_put_nth jprevstate 0 :json_object_next)
			       (debug "json_parser_input_processor after array now jprevstate=" jprevstate)
			       )
			     (?(tuple :json_array ?complist)
			       (list_append complist jsarray)
			       (multiple_put_nth jprevstate 0 :json_array_next)
			       (debug "json_parser_input_processor after array now jprevstate=" jprevstate)
			       )  
			     (?_
			      (debug "json_parser_input_processor after array bad jprevstate=" jprevstate)
			      (jerror '"unexpected array at right bracket")
			      (return))
			     )
		      ))
		  (?_
		   (debug "json_parser_input_processor unexpected right bracket")
		   (jerror '"unexpected right bracket")
		   (return))
		  )
	   )
	 (?(tuple :delim :comma)
	   (debug "json_parser_input_processor got comma")
	   (match jtopstate
		  (?(tuple :json_array_next ?clist)
		    (multiple_put_nth jtopstate 0 :json_array)
		    (debug "json_parser_input_processor comma updated jtopstate=" jtopstate)
		    )
		  (?(tuple :json_object_next ?atlist ?valist)
		    (multiple_put_nth jtopstate 0 :json_object_attr)
		    (debug "json_parser_input_processor comma updated jtopstate=" jtopstate)
		    )
		  (?_
		   (debug "json_parser_input_processor unexpected comma jtopstate=" jtopstate
			  "\n.. jparser=" jparser)
		   (jerror '"unexpected comma")
		   (return))
		   )
	   )
	 (?(tuple :delim :colon)
	   (debug "json_parser_input_processor got colon")
	   (match jtopstate
		  (?(tuple :json_object_colon ?atlist ?valist)
		    (multiple_put_nth jtopstate 0 :json_object_val)
		    (debug "json_parser_input_processor colon updated jtopstate=" jtopstate)
		    )
		  (?_
		   (debug "json_parser_input_processor unexpected colon jtopstate=" jtopstate
			  "\n.. jparser=" jparser)
		   (jerror '"unexpected colon")
		   (return))		  
		  )
	   )
	 (?(tuple :string ?vstr)
	   (debug "json_parser_input_processor got string vstr=" vstr)
	   (match jtopstate
		  (?(tuple :json_object_attr ?atlist ?valist)
		    (list_append atlist vstr)
		    (multiple_put_nth jtopstate 0 :json_object_colon)
		    (debug "json_parser_input_processor after string now jtopstate=" jtopstate)
		    )
		  (?(tuple :json_object_val ?atlist ?valist)
		    (list_append valist vstr)
		    (multiple_put_nth jtopstate 0 :json_object_next)
		    (debug "json_parser_input_processor after string now jtopstate=" jtopstate)
		    )
		  (?(tuple :json_result ?clores)
		    (debug "json_parser_input_processor after string result clores=" clores)
		    (assert_msg "check clores" (is_closure clores))
		    (list_popfirst jstack)
		    (clores vstr inch)
		    (return)
		    )
		  (?(tuple :json_array ?complist)
		    (list_append complist vstr)
		    (multiple_put_nth jtopstate 0 :json_array_next)
		    (debug "json_parser_input_processor after string now jtopstate=" jtopstate))    
		  (?_
		   (debug "json_parser_input_processor after string bad jtopstate=" jtopstate)
		   (jerror '"unexpected string")
		   (return))
		   )
	   )
	 (?(tuple :number ?vnum)
	   (debug "json_parser_input_processor got number vnum=" vnum)
	   (match jtopstate
		  (?(tuple :json_result ?clores)
		    (debug "json_parser_input_processor after number result clores=" clores)
		    (assert_msg "check clores" (is_closure clores))
		    (list_popfirst jstack)
		    (clores vnum inch)
		    (return)
		    )
		  (?(tuple :json_object_val ?atlist ?valist)
		    (list_append valist vnum)
		    (multiple_put_nth jtopstate 0 :json_object_next)
		    (debug "json_parser_input_processor after number now jtopstate=" jtopstate)
		    )
		  (?(tuple :json_array ?complist)
		    (list_append complist vnum)
		    (multiple_put_nth jtopstate 0 :json_array_next)
		    (debug "json_parser_input_processor after number now jtopstate=" jtopstate)
		    )  
		  (?_
		   (debug "json_parser_input_processor after number bad jtopstate=" jtopstate)
		   (jerror '"unexpected number")
		   (return))
		   )
	   )
	 (?(tuple :keyword :json_nil)
	   (debug "json_parser_input_processor got keyword null")
	   (match jtopstate
		  (?(tuple :json_object_val ?atlist ?valist)
		    (list_append valist ())
		    (multiple_put_nth jtopstate 0 :json_object_next)
		    (debug "json_parser_input_processor after null now jtopstate=" jtopstate)
		    )
		  (?(tuple :json_array ?complist)
		    (list_append complist ())
		    (multiple_put_nth jtopstate 0 :json_array_next)
		    (debug "json_parser_input_processor after null now jtopstate=" jtopstate)
		    )  
		  (?_
		   (debug "json_parser_input_processor after null bad jtopstate=" jtopstate "; jstack=" jstack)
		   (jerror '"unexpected null")
		   (return))
		   )
	   )
	 (?(tuple :keyword :json_false)
	   (debug "json_parser_input_processor got keyword false")
	   (match jtopstate
		  (?(tuple :json_object_val ?atlist ?valist)
		    (list_append valist :json_false)
		    (multiple_put_nth jtopstate 0 :json_object_next)
		    (debug "json_parser_input_processor after false now jtopstate=" jtopstate)
		    )
		  (?(tuple :json_array ?complist)
		    (list_append complist :json_false)
		    (multiple_put_nth jtopstate 0 :json_array_next)
		    (debug "json_parser_input_processor after false now jtopstate=" jtopstate)
		    )  
		  (?_
		   (debug "json_parser_input_processor after false bad jtopstate=" jtopstate)
		   (jerror '"unexpected false")
		   (return))
		   )
	   )
	 (?(tuple :keyword :true)
	   (debug "json_parser_input_processor got keyword true")
	   (match jtopstate
		  (?(tuple :json_object_val ?atlist ?valist)
		    (list_append valist :true)
		    (multiple_put_nth jtopstate 0 :json_object_next)
		    (debug "json_parser_input_processor after true now jtopstate=" jtopstate)
		    )
		  (?(tuple :json_array ?complist)
		    (list_append complist :json_false)
		    (multiple_put_nth jtopstate 0 :json_array_next)
		    (debug "json_parser_input_processor after true now jtopstate=" jtopstate)
		    )  
		  (?_
		   (debug "json_parser_input_processor after true bad jtopstate=" jtopstate)
		   (jerror '"unexpected true")
		   (return))
		   )
	   )
	 (?(tuple :keyword ?kword)
	   (debug "json_parser_input_processor got keyword kword=" kword)
	   )
	 (?(tuple () ())
	   (debug "json_parser_input_processor got nothing")
	   (exit jsonparseloop))	 
	 (?_
	  (debug "json_parser_input_processor unexpected kind=" kind " detail=" detail)
	  (assert_msg "json_parser_input_processor unexpected kind" () kind detail))
	 )
	)
       )
     )					;end forever parseloop
    (debug "json_parser_input_processor ended")
    ))


;;;; make one single blocking JSONRPC2 call on TCP/IP transport, then
;;;; close the connection
(defun do_blocking_jsonrpc2_call (server methodname jparams :long timeoutms)
  :doc #{$DO_BLOCKING_JSONRPC2_CALL makes a single JSONRPC2 remote
  procedure call with TCP transport to given $SERVER with given
  $METHODNAME and given JSON parameters $JPARAMS with a timeout of
  $TIMEOUTMS milliseconds, at least 50 milliseconds, then close the
  connection.}#
  (debug "do_blocking_jsonrpc2_call server=" server 
	 " methodname=" methodname ", jparams=" jparams 
	 "\n.. timeoutms=" timeoutms)
  (when 
      (<i timeoutms 50) 
    (setq timeoutms 50)
    (debug "do_blocking_jsonrpc2_call forced timeoutms=" timeoutms)
    )
  (let  ( 
	 (randidstr 
	  ( let ( (idstr ()) 
		  )
	    (code_chunk 
	     makerandidstr_chk 
	     #{ /* do_blocking_jsonrpc2_call $MAKERANDIDSTR_CHK */
	     static long cumcallcount;	     
	     char buf[40];
	     cumcallcount++;
	     snprintf(buf, sizeof(buf), "C%lxP%dR%xT%ld", 
			   cumcallcount, (int)getpid(),
			   (int)(melt_lrand() % 65536), melt_relative_time_millisec());
	     $IDSTR =  meltgc_new_string((meltobject_ptr_t)MELT_PREDEF(DISCR_STRING), buf);	     
	     }#)
	    (debug "do_blocking_jsonrpc2_call randidstr=" idstr)
	    idstr))
	 (service (connect_to_server server))
	 (jreq (make_jsonobject discr_jsonobject 
				'jsonrpc '"2.0"
				'method methodname
				'id randidstr
				'params jparams))
	 )
    (debug "do_blocking_jsonrpc2_call service=" service " jreq=" jreq)
    (unless (is_integerbox service)
      (warning_at () "do_blocking_jsonrpc2_call failure server=$1 method=$2 connection failed" 
		  server methodname)
      (return))
    (let (
	  (:long servfd (get_int service))
	  (servout ())
	  )
      (code_chunk 
       makesockfile_chk
       #{ /* do_blocking_jsonrpc2_call $MAKESOCKFILE_CHK */
       FILE* sockfil = fdopen((int)$SERVFD, "w+");
       if (!sockfil) {
         warning(0, "MELT do_blocking_jsonrpc2_call failed to fdopen #%d",
		  (int)$SERVFD);
         (void) close((int)$SERVFD);
         $(ignore (return));
       }
       $SERVOUT = meltgc_new_file($DISCR_RAWFILE, sockfil); ;
       }#)
      (debug "do_blocking_jsonrpc2_call servout=" servout " jreq=" jreq
	     " outputtingjson=" 
	     (let ( (sbuf (make_strbuf discr_strbuf)) )
	       (output_json sbuf jreq)
	       (strbuf2string discr_string sbuf)))
      (output_json servout jreq)
      (code_chunk 
       flushsockfile_chk
       #{ /* do_blocking_jsonrpc2_call $FLUSHSOCKFILE_CHK */
       melt_newlineflush (melt_get_file($SERVOUT));
       $(debug "do_blocking_jsonrpc2_call flusshed servout=" servout)
       }#)
      (let (
	    (:long begtime (relative_time_millisec))
	    (:long loopcount 0)
	    (gotreply (reference ()))
	    (goterror (reference ()))
	    (replyref (reference ()))
	    (jreplyhandler 
	     (lambda (jrepl)
	       (debug "blockjsonrpcreply jrepl=" jrepl)
	       (set_ref replyref jrepl)
	       (set_ref gotreply :true)
	       ))
	    (jerrorhandler
	     (lambda (jerror)
	       (debug "blockjsonrpcerror jerror=" jerror)
	       (assert_msg "blockjsonrpcerror check jerror" jerror)
	       (set_ref goterror jerror)
	       ))
	    (jparser (make_json_parser jreplyhandler jerrorhandler 
				       (tuple servout (constant_box servfd))))
	    )
	(debug "do_blocking_jsonrpc2_call jparser=" jparser "; begtime=" begtime)
	(register_raw_input_channel_handler json_parser_input_processor
					    jparser
					    servfd)
	(forever pollingloop
		 (setq loopcount (+i loopcount 1))
		 (debug "do_blocking_jsonrpc2_call loopcount=" loopcount) 
		 (hook_poll_inputs timeoutms)
		 (debug "do_blocking_jsonrpc2_call after timeoutms=" timeoutms 
			" elapsed " (-i (relative_time_millisec) begtime)
			" ms; gotreply=" gotreply " goterror=" goterror)
		 (cond ( !gotreply
			 (debug "do_blocking_jsonrpc2_call gotreply replyref=" replyref)
			 (exit pollingloop)
			 )
		       ( !goterror
			 (debug "do_blocking_jsonrpc2_call goterror=" goterror)
			 (warning_at () "do_blocking_jsonrpc2_call error $1 on method $2 to server $3"
				     !goterror methodname server)
			 (exit pollingloop)
			 )
		       ( (>=i (-i (relative_time_millisec) begtime) timeoutms)
			 (debug "do_blocking_jsonrpc2_call timedout " timeoutms)
			 (warning_at () "do_blocking_jsonrpc2_call timedout $1 milliseconds on method $2 to server $3"
				     timeoutms methodname server)
			 (exit pollingloop)			 
			 )
		       (:else
			(debug "do_blocking_jsonrpc2_call again loopcount=" loopcount)
			(again pollingloop))))
	(debug "do_blocking_jsonrpc2_call after pollingloop loopcount=" loopcount " gotreply=" gotreply
	       " goterror=" goterror " replyref=" replyref)
	(code_chunk afterpoll_chk 
		    #{ /* do_blocking_jsonrpc2_call $AFTERPOLL_CHK */
		    if (shutdown ($SERVFD, SHUT_RDWR))
		       warning(0, "MELT do_blocking_jsonrpc2_call shutdown failed: %s",
				  xstrerror(errno));
		    melt_close_file($SERVOUT);
		    }#)
	(when !gotreply 
	  (let ( (jreply !replyref)
		 (jid (jsonobject_get_named jreply 'id))
		 (jres (jsonobject_get_named jreply 'result))
		 (jerr (jsonobject_get_named jreply 'error))
		 )
	  (debug "do_blocking_jsonrpc2_call got jreply=" jreply "; jid=" jid
		 " jres=" jres " jerr=" jerr)
	  (assert_msg "check jreply" (is_jsonobject jreply))
	  (cond
	   ( (!=s jid randidstr)
	     (warning_at () 
			 "do_blocking_jsonrpc2_call sent id $1 but got reply with id $2 for method $3 to server $4"
			 randidstr jid methodname server)
	     (return ()))
	   ( jerr
	     (warning_at ()
			 "do_blocking_jsonrpc2_call failed for method $1 to server $2 : got error $3"
			 methodname server jerr)
	     (return ()))
	   (:else
	    (debug "do_blocking_jsonrpc2_call gives jres=" jres)
	    (return jres))
	   )
	))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; the sigio handler, called from safe places
(defhook hook_handle_sigio
  () ()
  :void
  :predef HOOK_HANDLE_SIGIO
  (hook_poll_inputs 250)
)

(export_values
 connect_to_server
 do_blocking_jsonrpc2_call
 every_polling_input
 get_polling_input
 hook_handle_sigio 
 hook_poll_inputs 
 is_polling_inputs
 json_parser_input_processor
 make_json_parser
 melt_invoke_input_callbacks
)





;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defvar melt_alarmbucket)

;; the sigalarm handler, called from safe places
(defhook hook_handle_sigalrm
  () ()
  :void
  :predef HOOK_HANDLE_SIGALRM
  (let ( (alarmbuck melt_alarmbucket)
	 (:long cureltim (relative_time_millisec))
	 )
    (debug "hook_handle_sigalrm start alarmbuck=" alarmbuck " cureltim=" cureltim)
    (unless alarmbuck (return))
    ;;
    (forever
     handleloop
     (assert_msg "check alarmbuck" (is_bucketlong alarmbuck) alarmbuck)
     (unless (bucketlong_count alarmbuck) (exit handleloop))
     (let ( (:long nextim (bucketlong_nth_key alarmbuck 0))
	    (nextalhd (bucketlong_nth_val alarmbuck 0))
	    )
       (debug "hook_handle_sigalrm nextim=" nextim " nextalhd=" nextalhd)
       (unless nextim (exit handleloop))
       (unless (>i nextim cureltim) (exit handleloop))
       (assert_msg "check mextalhd" (is_a nextalhd class_alarm_handler) nextalhd)
       (setq alarmbuck (bucketlong_remove alarmbuck nextim))
       (block_signals
	() ()
       (let ( (clos (get_field :alarmh_clos nextalhd))
	      )
	 (if (is_closure clos)
	     (let ( (res (clos nextalhd))
		    )
	       (if res
		   (let ( (:long newperiod (get_int (get_field :alarmh_period nextalhd)))
			  )
		     (if (>i newperiod 10)
			 (setq alarmbuck 
			       (bucketlong_put alarmbuck 
					       (+i newperiod cureltim) nextalhd)))))))))
       ))				;end handleloop
    ;;
    (setq melt_alarmbucket alarmbuck)
    (let ( (:long nowtim (relative_time_millisec))
	   (:long nextalarm (bucketlong_nth_key alarmbuck 0))
	   )
      (cond ( (>i nextalarm nowtim)
	      ;; set alarm to next time
	      (set_real_timer_millisec (-i nextalarm nowtim)))
	    ( (>i nextalarm 0)
	      ;; missed time, set a quick alarm
	      (set_real_timer_millisec 30))
	    ( :else
	      ;; no more alarm
	      (set_real_timer_millisec 0))
	    )
      )))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; alarm processing need a sorted bucket of timeouts -> alarm-handlers

(defun register_alarm_timer (clos :long periodms :value data)
  :doc #{$REGISTER_ALARM_TIMER is the low level function to register
  the closure $CLOS to be called periodically with a period of $PERIODMS
  -at least 50- milliseconds and some client $DATA. The closure should
  return non-nil for the alarm to be repeated. $REGISTER_ALARM_TIMER
  returns a timer object, usable for $UNREGISTER_ALARM_TIMER.}#
  (debug "register_alarm_timer clos=" clos " periodms=" periodms)
  (if (is_closure clos)
      (if (>=i periodms 50)
	  (let ( (res ())
		 )
	    (block_signals 
	     () ()
	     (let ( (periodbox (make_integerbox discr_constant_integer periodms))
		    (oldbuck (or melt_alarmbucket (make_bucketlong discr_bucket_longs 31)))
		    (alhd (instance class_alarm_handler
				    :alarmh_period periodbox
				    :alarmh_clos clos
				    :alarmh_data data))
		    (:long cureltim (relative_time_millisec))
		    (:long nextim (+i cureltim periodms))
		    (newbuck (bucketlong_put oldbuck nextim alhd))
		    (:long firstkey (bucketlong_nth_key newbuck 0))
		    (:long firstdelay (if firstkey (-i firstkey cureltim)))
		    )
	       (setq melt_alarmbucket newbuck)
	       (set_real_timer_millisec firstdelay)
	       (setq res alhd)))
	    (return res)
	    ))))


(defun unregister_alarm_timer (tim)
  :doc #{Unregister a timer obtained by $REGISTER_ALARM_TIMER.}#
  (debug "unregister_alarm_timer tim=" tim)
  (unless tim (return))
  (unless (is_not_a tim class_alarm_handler)
    (assert_msg "check tim" (is_a tim class_alarm_handler) tim)
    (return))
  (block_signals
   () ()
   (let ( (oldbuck melt_alarmbucket)
	  (:long oldbucklen (bucketlong_count oldbuck))
	  (newbuck (make_bucketlong discr_bucket_longs oldbucklen))
	  )
     (unless oldbucklen 
       ;; no more alarms
       (setq melt_alarmbucket ())
       (set_real_timer_millisec 0)
       (return))
     (foreach_in_bucketlong
      (oldbuck)
      (:long oldkey :value oldala)
      (assert_msg "check oldala" (is_a oldala class_alarm_handler) oldala)
      (unless (== oldala tim)
	(setq newbuck (bucketlong_put newbuck oldkey oldala))
	))
     (setq melt_alarmbucket newbuck)
     )
   ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defvar melt_childbuck) ;; contain the bucket from childpid to handlers
;; the sigchld handler, called from safe places
(defhook hook_handle_sigchld
  () ()
  :void
  :predef HOOK_HANDLE_SIGCHLD
  (debug "hook_handle_sigchld melt_childbuck=" melt_childbuck)
  (let ( (lischph (make_list discr_list))
	 (liswstat (make_list discr_list))
	 (buck melt_childbuck)
	 )
    (unless (is_bucketlong buck) (return))
    (block_signals 
     () ()
     (let ( (:long waitfail 0)
	    (:long pidstat 0)
	    )
       (code_chunk 
	waitprobchk
	#{ /* hook_handle_sigchld $WAITPROBCHK */
	$WAITFAIL = melt_wait_for_probe (WNOHANG) ;
	}#)
       (unless waitfail
	 (debug "hook_handle_sigchld waited for probe")
	 (return))
       (foreach_in_bucketlong
	(buck)
	(:long keypid :value chph)
	(assert_msg "check chph" (is_a chph class_child_process_handler) chph)
	(assert_msg "check pid" 
		    (==i keypid (get_int (get_field  :chilproh_pid chph))) keypid chph)
	(code_chunk 
	 waitpidchk
         #{ /* hook_handle_sigchld $WAITPIDCHK */ {
         pid_t wpid = 0 ;
         int pstatus = 0 ;
         $WAITFAIL = 0L ;
         $PIDSTAT = 0L ;
         wpid = waitpid ((pid_t) $KEYPID, &pstatus, WNOHANG) ;
         $WAITFAIL = (wpid != (pid_t) $KEYPID) ;
         if (!$WAITFAIL)
	   $PIDSTAT = pstatus ;
         } /* hook_handle_sigchld end $WAITPIDCHK */ }#)
	(unless waitfail
	  (list_append lischph chph)
	  (list_append liswstat (make_integerbox discr_constant_integer pidstat)))
	)
       )
     )
    (let ( (tupchph (list_to_multiple lischph discr_multiple))
	   (tupwstat (list_to_multiple liswstat discr_multiple))
	   )
      (foreach_in_multiple
       (tupchph)
       (curchph :long ix)
       (let ( (:long curwstat (get_int (multiple_nth tupwstat ix)))
	      (:long curpid (get_int (get_field :chilproh_pid curchph)))
	      (curclos (get_field :chilproh_clos curchph))
	      (:long exited 0)
	      (:long exitstat 0)
	      (:long signaled 0)
	      (:long termsig 0)
	      (:value termsigname ())
	      )
	 (debug "hook_handle_sigchld curchph=" curchph
		" curwstat=" curwstat " ix=" ix)
	 (block_signals
	  () ()
	  (let ( (cbuck melt_childbuck)
		 )
	    (setq cbuck (bucketlong_remove cbuck curpid))
	    (setq melt_childbuck cbuck)
	    ))
	 (code_chunk 
	  lookwstatchk
          #{ /* hook_handle_sigchld $LOOKWSTATCHK */ {
          int wstat = (int) $CURWSTAT ;
          if (WIFEXITED(wstat)) {
	    $EXITED = 1	;
	    $EXITSTAT = WEXITSTATUS (wstat) ;
          } 
          else if (WIFSIGNALED(wstat)) {
            $SIGNALED = 1 ;
            $TERMSIG = WTERMSIG (wstat)	;
            $TERMSIGNAME = meltgc_new_string
	         ((meltobject_ptr_t) MELT_PREDEF(DISCR_STRING),
	           strsignal($TERMSIG))	;
          }
          } /* end hook_handle_sigchld $LOOKWSTATCHK */  }#)
	 ;;
	 (block_signals
	  () ()
	  (cond
	   (exited 
	    (cond 
	     ( (==i exitstat 0)
	       ;; successful exit
	       (debug "hook_handle_sigchld successful curchph=" 
		      curchph)
	       (curclos curchph ())
	       )
	     ( :else
	       ;; failed exit
	       (debug "hook_handle_sigchld failed curchph=" 
		      curchph " exitstat=" exitstat)
	       (curclos curchph 
			(make_integerbox discr_constant_integer exitstat))
	       )
	     ))
	   (signaled
	    (debug "hook_handle_sigchld signaled curchph="
		   curchph " termsigname=" termsigname)
	    (curclos curchph termsigname))
	   )))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun register_child_process_handler (clos :long pid :value data)
  :doc #{$REGISTER_CHILD_PROCESS_HANDLER is the low level function to
  register a handler of closure $CLOS for termination of process $PID
  with extra $DATA. The $CLOS would be applied to the returned child}#
  (debug "register_child_process_handler clos=" clos " pid=" pid " data=" data)
  (if (is_closure clos)
      (if (>i pid 0)
	  (let ( (:long pidisbad 0)
		 )
	    (code_chunk 
	     trykillchk
	     #{/* register_child_process_handler $TRYKILLCHK */
	     if (kill ((pid_t) $PID, 0))
	     $PIDISBAD = -1L		;
	     }#)
	    (debug "register_child_process_handler pidisbad=" pidisbad)
	    (if pidisbad (return))
	    (let ( (chph (instance 
			  class_child_process_handler
			  :chilproh_pid (make_integerbox discr_constant_integer pid)
			  :chilproh_clos clos
			  :chilproh_data data))
		   )
	      (debug "register_child_process_handler chph=" chph)
	      (block_signals 
	       () ()
	       (let ( (buck (or melt_childbuck
				(make_bucketlong discr_bucket_longs 13)))
		     )
		 (assert_msg "check buck" (is_bucketlong buck) buck)
		 (setq buck (bucketlong_put buck pid chph))
		 (setq melt_childbuck buck)
		 )
	       )
	      (return chph)
	    )))))



(defun unregister_child_process_handler (chd)
  :doc #{Unregister a child process handler obtained by $REGISTER_CHILD_PROCESS_HANDLER @b{**unimplemented**}}#
  (debug "unregister_child_process_handler chd=" chd)
  (assert_msg "@$@unimplemented unregister_child_process_handler")
)

(export_values 
 register_alarm_timer
 register_child_process_handler
 register_paragraph_input_channel_handler
 register_raw_input_channel_handler 
 unregister_alarm_timer 
 unregister_child_process_handler
 )

(export_synonym register_input_channel_handler register_paragraph_input_channel_handler)

;; eof warmelt-hooks.melt
