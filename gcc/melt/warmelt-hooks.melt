; -*- Lisp -*-
;; file warmelt-hooks.melt
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(comment "***
    Copyright 2012 - 2013 Free Software Foundation, Inc.
    Contributed by Basile Starynkevitch <basile@starynkevitch.net>

    This file is part of GCC.

    GCC is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.

    GCC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.
***")

;; the copyright notice above apply both to warmelt-hooks.melt and 
;; to the generated files  warmelt-hooks*.c


;;;====================================================================
;;;******************* low level debug at routine *********************
;;;see the melt_low_debug_value macro in melt-runtime.h
(defhook hook_low_debug_value_at (:value val 
				  :cstring filename :long lineno
				  :cstring msg :long count) () :void
  :predef HOOK_LOW_DEBUG_VALUE_AT
  :doc #{$HOOK_LOW_DEBUG_VALUE_AT is an internal hook for the
  melt_low_debug_value macro in @file{melt-runtime.h}.}#
  (melt_debug_fun () count filename lineno msg val)
)

;;;====================================================================
;;;******************* OVERRIDE_GATE plugin event *********************
(definstance override_gate_delayed_queue class_delayed_queue
  :named_name '"override_gate_delayed_queue"
  :delqu_first (make_list discr_list)
  :delqu_last (make_list discr_list)
)

(defhook hook_override_gate (:long beforegate) (:long aftergate) :void
  :predef HOOK_OVERRIDE_GATE
  :doc #{The internal $HOOK_OVERRIDE_GATE handles
  @t{PLUGIN_OVERRIDE_GATE} events. See $REGISTER_OVERRIDE_GATE_FIRST
  etc...}#
  (debug "hook_override_gate beforegate=" beforegate)
  (let ( 
	(gateflag (if beforegate :true ()))
	(passname ())
	(:long passnum 0)
	(memref (reference ()))
	(revlastlist (make_list discr_list))
	(qufirst (get_field :delqu_first override_gate_delayed_queue))
	(qulast (get_field :delqu_last override_gate_delayed_queue))
	)
    ;; retrieve the passname and pass number
    (code_chunk 
     getpassname_chk 
     #{ /* hook_override_gate $GETPASSNAME_CHK */
     gcc_assert (current_pass != NULL);
     $PASSNAME =  meltgc_new_stringdup
	((meltobject_ptr_t) MELT_PREDEF(DISCR_STRING), current_pass->name);
     $PASSNUM = current_pass->static_pass_number;
     }#)
    ;; call the first closures in natural order
    (debug "hook_override_gate memref=" memref 
	   "\n gateflag=" gateflag
	   "\n override_gate_delayed_queue=" override_gate_delayed_queue
	   "\n passname=" passname " passnum=" passnum)
    ;; apply the first closures in order
    (foreach_in_list
     (qufirst)
     (curpair curclo)
     (debug "hook_override_gate first curclo=" curclo " memref=" memref)
     (if (is_closure curclo)
	 (let ( (clores (curclo gateflag memref passname passnum))
		)
	   (debug "hook_override_gate first clores=" clores)
	   (setq gateflag clores)
	 )))
    ;; reverse the last closures list
    (foreach_in_list
     (qulast)
     (curlpair curlclo)
     (if (is_closure curlclo)
	 (list_append revlastlist curlclo)))
    ;; apply the last closures in reverse order
    (foreach_in_list
     (revlastlist)
     (curlpair curlclo)
     (debug "hook_override_gate last curlclo=" curlclo " memref=" memref)
     (assert_msg "check curlclo" (is_closure curlclo))
     (let ( (clores (curlclo gateflag memref passname passnum))
	    )
       (debug "hook_override_gate last clores=" clores)
       (setq gateflag clores)))
    ;;
    (debug "hook_override_gate final gateflag=" gateflag
	   "\n passname=" passname " passnum=" passnum)
    (if gateflag
	(setq aftergate 1)
      (setq aftergate 0))
  )
)

(cheader 
 #{
   static void 
   melt_override_gate_callback (void* gccdata, 
				void* userdata ATTRIBUTE_UNUSED)
   {
     bool *pgatestatus = (bool*) gccdata;
     bool gatsta = false;
     long oldgatstalng = 0, newgatstalng = 0;
     gcc_assert (pgatestatus != NULL);
     gatsta = *pgatestatus;
     oldgatstalng = newgatstalng = (long)gatsta;
     melthookproc_HOOK_OVERRIDE_GATE (oldgatstalng, &newgatstalng);
     gatsta = (newgatstalng != 0L);
     *pgatestatus = gatsta;
   } /* end of  melt_override_gate_callback */
 }#)


;; internal flag set when PLUGIN_OVERRIDE_GATE registered

(cheader #{/* flag for PLUGIN_OVERRIDE_GATE */
MELT_EXTERN bool MELT_MODULE_VISIBILITY  melthk_override_gate_registered_flag;
}#)

(cimplement #{/* flag for PLUGIN_OVERRIDE_GATE */
bool  melthk_override_gate_registered_flag;
}#)

;; internal function to enable the plugin hook
(defun enable_override_gate ()
    (code_chunk 
     regpluginoverride_gate_chk
     #{ /* enable_override_gate $REGPLUGINOVERRIDE_GATE_CHK */
     if (!melthk_override_gate_registered_flag) 
       {
         melthk_override_gate_registered_flag = true;
         register_callback (melt_plugin_name, PLUGIN_OVERRIDE_GATE,
			    melt_override_gate_callback,
			    NULL);
       }
     }#)
)

;; internal function to disable the plugin hook
(defun maybe_disable_override_gate ()
  (when (and 
	     (null (list_first (get_field :delqu_first override_gate_delayed_queue)))
	     (null (list_first (get_field :delqu_last override_gate_delayed_queue))))
    (code_chunk
     unregpluginoverride_gate_chk
     #{ /* disable_override_gate $UNREGPLUGINOVERRIDE_GATE_CHK */
     if (melthk_override_gate_registered_flag)
       {
         melthk_override_gate_registered_flag = false;
         unregister_callback (melt_plugin_name, PLUGIN_OVERRIDE_GATE);
       }
     }#)
))

;; public functions to register
(defun register_override_gate_first (clo)
  :doc #{Register a function $CLO for @code{PLUGIN_OVERRIDE_GATE} at first place. 
See also $UNREGISTER_OVERRIDE_GATE_FIRST, $REGISTER_OVERRIDE_GATE_LAST, etc..}#
  (debug "register_override_gate_first clo=" clo)
  (when (is_closure clo)
    (list_append (get_field :delqu_first override_gate_delayed_queue) clo)
    (enable_override_gate)))

(defun register_override_gate_last (clo)
  :doc #{Register a function $CLO for @code{PLUGIN_OVERRIDE_GATE} at last place. 
See also $UNREGISTER_OVERRIDE_GATE_LAST, $REGISTER_OVERRIDE_GATE_FIRST, etc...}#
  (debug "register_override_gate_last clo=" clo)
  (when (is_closure clo)
    (list_append (get_field :delqu_last override_gate_delayed_queue) clo)
    (enable_override_gate)))

(defun unregister_override_gate_first (clo)
  :doc #{Unregister a function $CLO previously registered with
  $REGISTER_OVERRIDE_GATE_FIRST for @code{PLUGIN_OVERRIDE_GATE},
  return the boxed count of removed closures or null on failure.}#
  (debug "unregister_override_gate_first clo=" clo)
  (let ( (oldlis (get_field :delqu_first override_gate_delayed_queue))
	 (newlis (make_list discr_list))
	 (:long count 0)
	 )
    (foreach_in_list
     (oldlis)
     (curpair curclo)
     (if (== curclo clo) 
	 (setq count (+i count 1))
       (list_append newlis curclo)))
    (when count
      (put_fields override_gate_delayed_queue :delqu_first newlis)
      (maybe_disable_override_gate)
      (debug "unregister_override_gate_first count=" count)
      (return (constant_box count)))
    (debug "unregister_override_gate_first fail")
    (return ())))

(defun unregister_override_gate_last (clo)
  :doc #{Unregister a function $CLO previously registered with
  $REGISTER_OVERRIDE_GATE_LAST for @code{PLUGIN_OVERRIDE_GATE}, 
  return the boxed count of removed closures or null on failure.}#
  (debug "unregister_override_gate_last clo=" clo)
  (let ( (oldlis (get_field :delqu_last override_gate_delayed_queue))
	 (newlis (make_list discr_list))
	 (:long count 0)
	 )
    (foreach_in_list
     (oldlis)
     (curpair curclo)
     (if (== curclo clo) 
	 (setq count (+i count 1))
       (list_append newlis curclo)))
    (when count
      (put_fields override_gate_delayed_queue :delqu_last newlis)
      (maybe_disable_override_gate)
      (debug "unregister_override_gate_last count=" count)
      (return (constant_box count)))
    (debug "unregister_override_gate_last fail")
    (return ())))

;;;====================================================================
;;;******************* START_UNIT plugin event *********************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(cheader #{/* flag for PLUGIN_START_UNIT */
MELT_EXTERN bool MELT_MODULE_VISIBILITY  melthk_start_unit_registered_flag;
}#)

(cimplement #{/* flag for for PLUGIN_START_UNIT */
bool  melthk_start_unit_registered_flag;
}#)

;;;;;; private queue for start of compilation unit
(definstance start_unit_delayed_queue class_delayed_queue
  :named_name '"start_unit_delayed_queue"
  :delqu_first (make_list discr_list)
  :delqu_last (make_list discr_list)
  )

;; this internal hook needs to be predefined, or static variable
;; [which are not yet implemented in MELT 0.9.9] to remain alive for
;; the MELT & Ggc garbage collectors...
(defhook hook_start_unit () () :void
  :predef HOOK_START_UNIT
  (let ( (firstlist (unsafe_get_field :delqu_first start_unit_delayed_queue))
	 (lastlist (unsafe_get_field :delqu_last start_unit_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (rescont (instance class_reference))
	 )
;;; call the first routines in natural order
    (list_every 
     firstlist
     (lambda (firstproc)
       (let ( (prevres (unsafe_get_field :referenced_value rescont)) 
	      (nextres (firstproc prevres start_unit_delayed_queue))
	      )
	 (unsafe_put_fields rescont :referenced_value nextres)
	 )))
;;; reverse the last list
    (list_every 
     lastlist 
     (lambda (lastproc)
       (if (is_closure lastproc) (list_prepend revlastlist lastproc))))
;;; call the last routines in reverse order
    (list_every
     revlastlist
     (lambda (lastproc)
       (let ( (prevres (unsafe_get_field :referenced_value rescont)) 
	      (nextres (lastproc prevres start_unit_delayed_queue))
	      )
	 (unsafe_put_fields rescont :referenced_value nextres)
	 )))
    ))

;; internal function to enable the plugin hook
(defun enable_start_unit ()
  (code_chunk 
   enabstartunit_chk
   #{
   melthk_start_unit_registered_flag = true ;
   #warning enable_start_unit $ENABSTARTUNIT_CHK should register PLUGIN_START_UNIT
   }#)
  )


(defun at_start_unit_first (fun)
  :doc #{Use $AT_START_UNIT_FIRST to register a function to be run at start of translation unit, in first place.}#
  (let ( (firstlist (unsafe_get_field :delqu_first start_unit_delayed_queue))
	 )
    (when (is_closure fun) 
      (enable_start_unit)
      (list_append firstlist fun)))
  )  

(defun at_start_unit_last (fun)
  :doc #{Use $AT_START_UNIT_LAST to register a function to be run at start of translation unit, in first place.}#
  (let ( (lastlist (unsafe_get_field :delqu_last start_unit_delayed_queue))
	 )
    (when (is_closure fun) 
      (enable_start_unit)
      (list_append lastlist fun)))
  )

  
;;;====================================================================
;;;******************* FINISH_UNIT plugin event *********************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;; the private queue for compilation unit finish
(definstance finish_unit_delayed_queue class_delayed_queue
  :named_name '"finish_unit_delayed_queue"
  :delqu_first (make_list discr_list)
  :delqu_last (make_list discr_list)
  )

(cheader #{/* flag for PLUGIN_FINISH_UNIT */
MELT_EXTERN bool MELT_MODULE_VISIBILITY  melthk_finish_unit_registered_flag;
}#)

(cimplement #{/* flag for PLUGIN_FINISH_UNIT */
bool MELT_MODULE_VISIBILITY  melthk_finish_unit_registered_flag;
}#)

(defhook hook_finish_unit () () :void
  :predef HOOK_FINISH_UNIT
  (let ( (firstlist (unsafe_get_field :delqu_first finish_unit_delayed_queue))
	 (lastlist (unsafe_get_field :delqu_last finish_unit_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (rescont (instance class_reference))
	 )
;;; call the first routines in natural order
    (list_every 
     firstlist
     (lambda (firstproc)
       (let ( (prevres (unsafe_get_field :referenced_value rescont)) 
	      (nextres (firstproc prevres finish_unit_delayed_queue))
	      )
	 (unsafe_put_fields rescont :referenced_value nextres)
	 )))
;;; reverse the last list
    (list_every 
     lastlist 
     (lambda (lastproc)
       (if (is_closure lastproc) (list_prepend revlastlist lastproc))))
;;; call the last routines in reverse order
    (list_every
     revlastlist
     (lambda (lastproc)
       (let ( (prevres (unsafe_get_field :referenced_value rescont)) 
	      (nextres (lastproc prevres finish_unit_delayed_queue))
	      )
	 (unsafe_put_fields rescont :referenced_value nextres)
	 )))
    ))


(defun enable_finish_unit ()
  (code_chunk 
   enfinishunit_chk
   #{ /* enable_finish_unit $ENFINISHUNIT_CHK */
   if (!melthk_finish_unit_registered_flag) 
     {
        melthk_finish_unit_registered_flag = true;
#warning enable_finish_unit  $ENFINISHUNIT_CHK should register PLUGIN_FINISH_UNIT
     }
   }#)
)

(defun at_finish_unit_first (fun)
  :doc #{Use $AT_FINISH_UNIT_FIRST to register a function to be run at
end of compilation unit in first place}#
  (let ( (firstlist (unsafe_get_field :delqu_first finish_unit_delayed_queue))
	 )
    (when (is_closure fun) 
      (enable_finish_unit)
      (list_append firstlist fun)))
  )  

(defun at_finish_unit_last (fun)
  :doc #{Use $AT_FINISH_UNIT_LAST to register a function to be run at
end of compilation unit in last place}#
  (let ( (lastlist (unsafe_get_field :delqu_last finish_unit_delayed_queue))
	 )
    (when (is_closure fun) 
      (enable_finish_unit)
      (list_append lastlist fun)))
  )




  
;;;====================================================================
;;;****************** ALL_PASSES_START plugin event *******************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; handling PLUGIN_ALL_PASSES_START
;; private all_passes_start handling queue
(definstance all_passes_start_delayed_queue class_delayed_queue
  :named_name '"all_passes_start_delayed_queue"
  :delqu_first ()
  :delqu_last ()
  )

(cheader #{/* flag for PLUGIN_ALL_PASSES_START declare */
MELT_EXTERN bool MELT_MODULE_VISIBILITY  melthk_all_passes_start_registered_flag;
}#)
(cimplement  #{/* flag for PLUGIN_ALL_PASSES_START define */
 bool melthk_all_passes_start_registered_flag;
}#)

;; internal hook for PLUGIN_ALL_PASSES_START 
(defhook hook_all_passes_start () () :void
  :predef HOOK_ALL_PASSES_START
  (let ( (firstlist (get_field :delqu_first all_passes_start_delayed_queue))
	 (lastlist (get_field :delqu_last all_passes_start_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (res ())
	 )
;;; call the first routines in natural order
    (foreach_in_list
     (firstlist)
     (firstpair firstproc)
     (setq res (firstproc res))
     )
;;; reverse the last list
    (foreach_in_list
     (lastlist)
     (lastpair lastproc)
     (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
    (if lastlist 
	(foreach_in_list
	 (revlastlist)
	 (revlastpair revlastproc)
	 (setq res (revlastproc res))
    ))))

(defun enable_all_passes_start ()
  (code_chunk 
   enallpassesstart_chk
   #{ /* enable_all_passes_start $ENALLPASSESSTART_CHK */
     if (!melthk_all_passes_start_registered_flag) {
       melthk_all_passes_start_registered_flag = true;
#warning enable_all_passes_start $ENALLPASSESSTART_CHK should register the PLUGIN_ALL_PASSES_START
     }
   }#
  ))

(defun register_all_passes_start_first (fun)
  :doc #{Use $REGISTER_ALL_PASSES_START_FIRST to register a function $FUN to
  be run at PLUGIN_ALL_PASSES_START, in first place.  $FUN must be a closure
  which takes no arguments and whose result is ignored.}#
  (if (is_closure fun)
      (let ( (firstlist (get_field :delqu_first all_passes_start_delayed_queue))
	    )
	(enable_all_passes_start)
	(if (null firstlist)
	    (progn
	      (setq firstlist (make_list discr_list))
	      (put_fields
	        all_passes_start_delayed_queue
	        :delqu_first firstlist
	        :delqu_last (make_list discr_list))
	      ))
	(list_append firstlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_all_passes_start_hook_first")
    ))

(defun register_all_passes_start_last (fun)
  :doc #{Use $REGISTER_ALL_PASSES_START_LAST to register a function $FUN to
  be run at PLUGIN_ALL_PASSES_START, in last place.  $FUN must be a closure
  which takes no argument and whose result is ignored.}#
  (if (is_closure fun)
      (let ( (lastlist (get_field :delqu_last all_passes_start_delayed_queue))
	    )
	(enable_all_passes_start)
	(if (null lastlist)
	    (progn
	      (setq lastlist (make_list discr_list))
	      (put_fields
	        all_passes_start_delayed_queue
	        :delqu_first (make_list discr_list)
	        :delqu_last lastlist)
	      ))
	(list_append lastlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_all_passes_start_hook_last")
    ))


;;;====================================================================
;;;****************** ALL_PASSES_END plugin event *******************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



(cheader #{/* flag for PLUGIN_ALL_PASSES_END declare */
MELT_EXTERN bool MELT_MODULE_VISIBILITY  melthk_all_passes_end_registered_flag;
}#)
(cimplement #{/* flag for PLUGIN_ALL_PASSES_END define */
bool  melthk_all_passes_end_registered_flag;
}#)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; handling PLUGIN_ALL_PASSES_END
;; private all_passes_end handling queue
(definstance all_passes_end_delayed_queue class_delayed_queue
  :named_name '"all_passes_end_delayed_queue"
  :delqu_first ()
  :delqu_last ()
  )

;; internal private hook for PLUGIN_ALL_PASSES_END 
(defhook hook_all_passes_end () () :void
  :predef HOOK_ALL_PASSES_END
  (let ( (firstlist (get_field :delqu_first all_passes_end_delayed_queue))
	 (lastlist (get_field :delqu_last all_passes_end_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (res ())
	 )
;;; call the first routines in natural order
    (foreach_in_list
     (firstlist)
     (firstpair firstproc)
     (setq res (firstproc res))
     )
;;; reverse the last list
    (foreach_in_list
     (lastlist)
     (lastpair lastproc)
     (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
    (foreach_in_list
     (revlastlist)
     (revlastpair revlastproc)
     (setq res (revlastproc res))
    )))

(defun enable_all_passes_end ()
  (code_chunk 
   enallpassesend_chk
   #{ /* enable_all_passes_end $ENALLPASSESEND_CHK */
     if (!melthk_all_passes_end_registered_flag) {
       melthk_all_passes_end_registered_flag = true;
#warning enable_all_passes_end $ENALLPASSESEND_CHK should register the PLUGIN_ALL_PASSES_END
     }
   }#
  ))

(defun register_all_passes_end_first (fun)
  :doc #{Use $REGISTER_ALL_PASSES_END_FIRST to register a function $FUN to
  be run at PLUGIN_ALL_PASSES_END, in first place.  $FUN must be a closure
  which takes no argument and whose result is ignored.}#
  (if (is_closure fun)
      (let ( (firstlist (get_field :delqu_first all_passes_end_delayed_queue))
	    )
	(enable_all_passes_end)
	(if (null firstlist)
	    (progn
	      (setq firstlist (make_list discr_list))
	      (put_fields
	        all_passes_end_delayed_queue
	        :delqu_first firstlist
	        :delqu_last (make_list discr_list))
	      ))
	(list_append firstlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_all_passes_end_first")
    ))

(defun register_all_passes_end_last (fun)
  :doc #{Use $REGISTER_ALL_PASSES_END_LAST to register a function $FUN to
  be run at PLUGIN_ALL_PASSES_END, in last place.  $FUN must be a closure
  which takes no arguments and whose result is ignored.}#
  (if (is_closure fun)
      (let ( (lastlist (get_field :delqu_last all_passes_end_delayed_queue))
	    )
	(enable_all_passes_end)
	(if (null lastlist)
	    (progn
	      (setq lastlist (make_list discr_list))
	      (put_fields
	        all_passes_end_delayed_queue
	        :delqu_first (make_list discr_list)
	        :delqu_last lastlist)
	      ))
	(list_append lastlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_all_passes_end_hook_last")
    ))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(export_values
  at_finish_unit_first
  at_finish_unit_last
  at_start_unit_first
  at_start_unit_last
  hook_override_gate
  hook_low_debug_value_at
  register_override_gate_first
  register_override_gate_last
  register_all_passes_end_first
  register_all_passes_end_last
  register_all_passes_start_first
  register_all_passes_start_last
  unregister_override_gate_first
  unregister_override_gate_last
)
;; eof warmelt-hooks.melt
