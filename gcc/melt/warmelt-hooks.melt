; -*- Lisp -*-
;; file warmelt-hooks.melt
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(comment "***
    Copyright 2012 - 2013 Free Software Foundation, Inc.
    Contributed by Basile Starynkevitch <basile@starynkevitch.net>

    This file is part of GCC.

    GCC is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.

    GCC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.
***")

;; the copyright notice above apply both to warmelt-hooks.melt and 
;; to the generated files  warmelt-hooks*.c


;;;====================================================================
;;;******************* low level debug at routine *********************
;;;see the melt_low_debug_value macro in melt-runtime.h
(defhook hook_low_debug_value_at (:value val 
				  :cstring filename :long lineno
				  :cstring msg :long count) () :void
  :predef HOOK_LOW_DEBUG_VALUE_AT
  :doc #{$HOOK_LOW_DEBUG_VALUE_AT is an internal hook for the
  melt_low_debug_value macro in @file{melt-runtime.h}.}#
  (melt_debug_fun () count filename lineno msg val)
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Nota Bene: environment management hooks are so crucial that they
;;; have to be in warmelt-first.melt,
;;; i.e. hook_fresh_environment_reference_maker, hook_value_importer,
;;; hook_value_exporter, hook_macro_exporter, hook_patmacro_exporter...


;;;====================================================================
;;;******************* OVERRIDE_GATE plugin event *********************
(definstance override_gate_delayed_queue class_delayed_queue
  :named_name '"override_gate_delayed_queue"
  :delqu_first (make_list discr_list)
  :delqu_last (make_list discr_list)
)

(defhook hook_override_gate (:long beforegate) (:long aftergate) :void
  :predef HOOK_OVERRIDE_GATE
  :doc #{The internal $HOOK_OVERRIDE_GATE handles
  @t{PLUGIN_OVERRIDE_GATE} events. See $REGISTER_OVERRIDE_GATE_FIRST
  etc...}#
  (debug "hook_override_gate beforegate=" beforegate)
  (let ( 
	(gateflag (if beforegate :true ()))
	(passname ())
	(:long passnum 0)
	(memref (reference ()))
	(revlastlist (make_list discr_list))
	(qufirst (get_field :delqu_first override_gate_delayed_queue))
	(qulast (get_field :delqu_last override_gate_delayed_queue))
	)
    ;; retrieve the passname and pass number
    (code_chunk 
     getpassname_chk 
     #{ /* hook_override_gate $GETPASSNAME_CHK */
     gcc_assert (current_pass != NULL);
     $PASSNAME =  meltgc_new_stringdup
	((meltobject_ptr_t) MELT_PREDEF(DISCR_STRING), current_pass->name);
     $PASSNUM = current_pass->static_pass_number;
     }#)
    ;; call the first closures in natural order
    (debug "hook_override_gate memref=" memref 
	   "\n gateflag=" gateflag
	   "\n override_gate_delayed_queue=" override_gate_delayed_queue
	   "\n passname=" passname " passnum=" passnum)
    ;; apply the first closures in order
    (foreach_in_list
     (qufirst)
     (curpair curclo)
     (debug "hook_override_gate first curclo=" curclo " memref=" memref)
     (if (is_closure curclo)
	 (let ( (clores (curclo gateflag memref passname passnum))
		)
	   (debug "hook_override_gate first clores=" clores)
	   (setq gateflag clores)
	 )))
    ;; reverse the last closures list
    (foreach_in_list
     (qulast)
     (curlpair curlclo)
     (if (is_closure curlclo)
	 (list_append revlastlist curlclo)))
    ;; apply the last closures in reverse order
    (foreach_in_list
     (revlastlist)
     (curlpair curlclo)
     (debug "hook_override_gate last curlclo=" curlclo " memref=" memref)
     (assert_msg "check curlclo" (is_closure curlclo))
     (let ( (clores (curlclo gateflag memref passname passnum))
	    )
       (debug "hook_override_gate last clores=" clores)
       (setq gateflag clores)))
    ;;
    (debug "hook_override_gate final gateflag=" gateflag
	   "\n passname=" passname " passnum=" passnum)
    (if gateflag
	(setq aftergate 1)
      (setq aftergate 0))
  )
)

(cheader 
 #{
   static void 
   melt_override_gate_callback (void* gccdata, 
				void* userdata ATTRIBUTE_UNUSED)
   {
     bool *pgatestatus = (bool*) gccdata;
     bool gatsta = false;
     long oldgatstalng = 0, newgatstalng = 0;
     gcc_assert (pgatestatus != NULL);
     gatsta = *pgatestatus;
     oldgatstalng = newgatstalng = (long)gatsta;
     melthookproc_HOOK_OVERRIDE_GATE (oldgatstalng, &newgatstalng);
     gatsta = (newgatstalng != 0L);
     *pgatestatus = gatsta;
   } /* end of  melt_override_gate_callback */
 }#)


;; internal flag set when PLUGIN_OVERRIDE_GATE registered

(cheader #{/* flag for PLUGIN_OVERRIDE_GATE */
MELT_EXTERN bool MELT_MODULE_VISIBILITY  melthk_override_gate_registered_flag;
}#)

(cimplement #{/* flag for PLUGIN_OVERRIDE_GATE */
bool  melthk_override_gate_registered_flag;
}#)

;; internal function to enable the plugin hook
(defun enable_override_gate ()
    (code_chunk 
     regpluginoverride_gate_chk
     #{ /* enable_override_gate $REGPLUGINOVERRIDE_GATE_CHK */
     if (!melthk_override_gate_registered_flag) 
       {
         melthk_override_gate_registered_flag = true;
         register_callback (melt_plugin_name, PLUGIN_OVERRIDE_GATE,
			    melt_override_gate_callback,
			    NULL);
       }
     }#)
)

;; internal function to disable the plugin hook
(defun maybe_disable_override_gate ()
  (when (and 
	     (null (list_first (get_field :delqu_first override_gate_delayed_queue)))
	     (null (list_first (get_field :delqu_last override_gate_delayed_queue))))
    (code_chunk
     unregpluginoverride_gate_chk
     #{ /* disable_override_gate $UNREGPLUGINOVERRIDE_GATE_CHK */
     if (melthk_override_gate_registered_flag)
       {
         melthk_override_gate_registered_flag = false;
         unregister_callback (melt_plugin_name, PLUGIN_OVERRIDE_GATE);
       }
     }#)
))

;; public functions to register
(defun register_override_gate_first (clo)
  :doc #{Register a function $CLO for @code{PLUGIN_OVERRIDE_GATE} at first place. 
See also $UNREGISTER_OVERRIDE_GATE_FIRST, $REGISTER_OVERRIDE_GATE_LAST, etc..}#
  (debug "register_override_gate_first clo=" clo)
  (when (is_closure clo)
    (list_append (get_field :delqu_first override_gate_delayed_queue) clo)
    (enable_override_gate)))

(defun register_override_gate_last (clo)
  :doc #{Register a function $CLO for @code{PLUGIN_OVERRIDE_GATE} at last place. 
See also $UNREGISTER_OVERRIDE_GATE_LAST, $REGISTER_OVERRIDE_GATE_FIRST, etc...}#
  (debug "register_override_gate_last clo=" clo)
  (when (is_closure clo)
    (list_append (get_field :delqu_last override_gate_delayed_queue) clo)
    (enable_override_gate)))

(defun unregister_override_gate_first (clo)
  :doc #{Unregister a function $CLO previously registered with
  $REGISTER_OVERRIDE_GATE_FIRST for @code{PLUGIN_OVERRIDE_GATE},
  return the boxed count of removed closures or null on failure.}#
  (debug "unregister_override_gate_first clo=" clo)
  (let ( (oldlis (get_field :delqu_first override_gate_delayed_queue))
	 (newlis (make_list discr_list))
	 (:long count 0)
	 )
    (foreach_in_list
     (oldlis)
     (curpair curclo)
     (if (== curclo clo) 
	 (setq count (+i count 1))
       (list_append newlis curclo)))
    (when count
      (put_fields override_gate_delayed_queue :delqu_first newlis)
      (maybe_disable_override_gate)
      (debug "unregister_override_gate_first count=" count)
      (return (constant_box count)))
    (debug "unregister_override_gate_first fail")
    (return ())))

(defun unregister_override_gate_last (clo)
  :doc #{Unregister a function $CLO previously registered with
  $REGISTER_OVERRIDE_GATE_LAST for @code{PLUGIN_OVERRIDE_GATE}, 
  return the boxed count of removed closures or null on failure.}#
  (debug "unregister_override_gate_last clo=" clo)
  (let ( (oldlis (get_field :delqu_last override_gate_delayed_queue))
	 (newlis (make_list discr_list))
	 (:long count 0)
	 )
    (foreach_in_list
     (oldlis)
     (curpair curclo)
     (if (== curclo clo) 
	 (setq count (+i count 1))
       (list_append newlis curclo)))
    (when count
      (put_fields override_gate_delayed_queue :delqu_last newlis)
      (maybe_disable_override_gate)
      (debug "unregister_override_gate_last count=" count)
      (return (constant_box count)))
    (debug "unregister_override_gate_last fail")
    (return ())))

;;;====================================================================
;;;******************* START_UNIT plugin event *********************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(cheader #{/* flag for PLUGIN_START_UNIT */
MELT_EXTERN bool MELT_MODULE_VISIBILITY  melthk_start_unit_registered_flag;
}#)

(cimplement #{/* flag for for PLUGIN_START_UNIT */
bool  melthk_start_unit_registered_flag;
}#)

;;;;;; private queue for start of compilation unit
(definstance start_unit_delayed_queue class_delayed_queue
  :named_name '"start_unit_delayed_queue"
  :delqu_first (make_list discr_list)
  :delqu_last (make_list discr_list)
  )

;; this internal hook needs to be predefined to remain alive for the
;; MELT & Ggc garbage collectors...
(defhook hook_start_unit () () :void
  :predef HOOK_START_UNIT
  (let ( (firstlist (unsafe_get_field :delqu_first start_unit_delayed_queue))
	 (lastlist (unsafe_get_field :delqu_last start_unit_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (rescont (instance class_reference))
	 )
;;; call the first routines in natural order
    (list_every 
     firstlist
     (lambda (firstproc)
       (let ( (prevres (unsafe_get_field :referenced_value rescont)) 
	      (nextres (firstproc prevres start_unit_delayed_queue))
	      )
	 (unsafe_put_fields rescont :referenced_value nextres)
	 )))
;;; reverse the last list
    (list_every 
     lastlist 
     (lambda (lastproc)
       (if (is_closure lastproc) (list_prepend revlastlist lastproc))))
;;; call the last routines in reverse order
    (list_every
     revlastlist
     (lambda (lastproc)
       (let ( (prevres (unsafe_get_field :referenced_value rescont)) 
	      (nextres (lastproc prevres start_unit_delayed_queue))
	      )
	 (unsafe_put_fields rescont :referenced_value nextres)
	 )))
    ))

(cheader #{ 
 void MELT_MODULE_VISIBILITY 
    melt_startunithook_callback (void* gcc_data ATTRIBUTE_UNUSED,
				 void* user_data ATTRIBUTE_UNUSED);
 }#)

(cimplement #{
 void 
 melt_startunithook_callback (void* gcc_data ATTRIBUTE_UNUSED,
			      void* user_data ATTRIBUTE_UNUSED)
 {
    melthookproc_HOOK_START_UNIT ();
 }
 }#)

;; internal function to enable the plugin hook
(defun enable_start_unit ()
  (code_chunk 
   enabstartunit_chk
   #{
   if (!melthk_start_unit_registered_flag) 
     {
       melthk_start_unit_registered_flag = true;
       register_callback (melt_plugin_name, PLUGIN_START_UNIT,
			  melt_startunithook_callback,
			  NULL);
     }
   }#)
  )


(defun at_start_unit_first (fun)
  :doc #{Use $AT_START_UNIT_FIRST to register a function to be run at start of translation unit, in first place.}#
  (let ( (firstlist (unsafe_get_field :delqu_first start_unit_delayed_queue))
	 )
    (when (is_closure fun) 
      (enable_start_unit)
      (list_append firstlist fun)))
  )  

(defun at_start_unit_last (fun)
  :doc #{Use $AT_START_UNIT_LAST to register a function to be run at start of translation unit, in first place.}#
  (let ( (lastlist (unsafe_get_field :delqu_last start_unit_delayed_queue))
	 )
    (when (is_closure fun) 
      (enable_start_unit)
      (list_append lastlist fun)))
  )

  
;;;====================================================================
;;;******************* FINISH_UNIT plugin event *********************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;; the private queue for compilation unit finish
(definstance finish_unit_delayed_queue class_delayed_queue
  :named_name '"finish_unit_delayed_queue"
  :delqu_first (make_list discr_list)
  :delqu_last (make_list discr_list)
  )

(cheader #{/* flag for PLUGIN_FINISH_UNIT */
MELT_EXTERN bool MELT_MODULE_VISIBILITY  melthk_finish_unit_registered_flag;
}#)

(cimplement #{/* flag for PLUGIN_FINISH_UNIT */
bool MELT_MODULE_VISIBILITY  melthk_finish_unit_registered_flag;
}#)

(defhook hook_finish_unit () () :void
  :predef HOOK_FINISH_UNIT
  (let ( (firstlist (unsafe_get_field :delqu_first finish_unit_delayed_queue))
	 (lastlist (unsafe_get_field :delqu_last finish_unit_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (rescont (instance class_reference))
	 )
;;; call the first routines in natural order
    (list_every 
     firstlist
     (lambda (firstproc)
       (let ( (prevres (unsafe_get_field :referenced_value rescont)) 
	      (nextres (firstproc prevres finish_unit_delayed_queue))
	      )
	 (unsafe_put_fields rescont :referenced_value nextres)
	 )))
;;; reverse the last list
    (list_every 
     lastlist 
     (lambda (lastproc)
       (if (is_closure lastproc) (list_prepend revlastlist lastproc))))
;;; call the last routines in reverse order
    (list_every
     revlastlist
     (lambda (lastproc)
       (let ( (prevres (unsafe_get_field :referenced_value rescont)) 
	      (nextres (lastproc prevres finish_unit_delayed_queue))
	      )
	 (unsafe_put_fields rescont :referenced_value nextres)
	 )))
;;; force a minor GC to ensure nothing stays in the young region
    (code_chunk finishunitminorgc_chk 
		#{/*hook_finish_unit $FINISHUNITMINORGC_CHK*/ melt_garbcoll (0, MELT_ONLY_MINOR)}#)
    ))


(cheader 
 #{ 
 void MELT_MODULE_VISIBILITY 
    melt_finishunithook_callback (void* gcc_data ATTRIBUTE_UNUSED,
				 void* user_data ATTRIBUTE_UNUSED);
 }#)

(cimplement
 #{
 void 
 melt_finishunithook_callback (void* gcc_data ATTRIBUTE_UNUSED,
			      void* user_data ATTRIBUTE_UNUSED)
 {
    melthookproc_HOOK_FINISH_UNIT ();
 }
 }#)
(defun enable_finish_unit ()
  (code_chunk 
   enfinishunit_chk
   #{ /* enable_finish_unit $ENFINISHUNIT_CHK */
   if (!melthk_finish_unit_registered_flag) 
     {
        melthk_finish_unit_registered_flag = true;
       register_callback (melt_plugin_name, PLUGIN_FINISH_UNIT,
			  melt_finishunithook_callback,
			  NULL);
     }
   }#)
)

(defun at_finish_unit_first (fun)
  :doc #{Use $AT_FINISH_UNIT_FIRST to register a function to be run at
end of compilation unit in first place}#
  (let ( (firstlist (unsafe_get_field :delqu_first finish_unit_delayed_queue))
	 )
    (when (is_closure fun) 
      (enable_finish_unit)
      (list_append firstlist fun)))
  )  

(defun at_finish_unit_last (fun)
  :doc #{Use $AT_FINISH_UNIT_LAST to register a function to be run at
end of compilation unit in last place}#
  (let ( (lastlist (unsafe_get_field :delqu_last finish_unit_delayed_queue))
	 )
    (when (is_closure fun) 
      (enable_finish_unit)
      (list_append lastlist fun)))
  )




  
;;;====================================================================
;;;****************** ALL_PASSES_START plugin event *******************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; handling PLUGIN_ALL_PASSES_START
;; private all_passes_start handling queue
(definstance all_passes_start_delayed_queue class_delayed_queue
  :named_name '"all_passes_start_delayed_queue"
  :delqu_first ()
  :delqu_last ()
  )

(cheader #{/* flag for PLUGIN_ALL_PASSES_START declare */
MELT_EXTERN bool MELT_MODULE_VISIBILITY  melthk_all_passes_start_registered_flag;
}#)
(cimplement  #{/* flag for PLUGIN_ALL_PASSES_START define */
 bool melthk_all_passes_start_registered_flag;
}#)

;; internal hook for PLUGIN_ALL_PASSES_START 
(defhook hook_all_passes_start () () :void
  :predef HOOK_ALL_PASSES_START
  (let ( (firstlist (get_field :delqu_first all_passes_start_delayed_queue))
	 (lastlist (get_field :delqu_last all_passes_start_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (res ())
	 )
;;; call the first routines in natural order
    (foreach_in_list
     (firstlist)
     (firstpair firstproc)
     (setq res (firstproc res))
     )
;;; reverse the last list
    (foreach_in_list
     (lastlist)
     (lastpair lastproc)
     (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
    (if lastlist 
	(foreach_in_list
	 (revlastlist)
	 (revlastpair revlastproc)
	 (setq res (revlastproc res))
    ))))

(cheader #{ 
 void MELT_MODULE_VISIBILITY 
    melt_all_passes_start_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
				 void* user_data ATTRIBUTE_UNUSED);
 }#)

(cimplement #{
 void 
 melt_all_passes_start_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
			      void* user_data ATTRIBUTE_UNUSED)
 {
    melthookproc_HOOK_ALL_PASSES_START ();
 }
 }#)

(defun enable_all_passes_start ()
  (code_chunk 
   enallpassesstart_chk
   #{ /* enable_all_passes_start $ENALLPASSESSTART_CHK */
     if (!melthk_all_passes_start_registered_flag) {
       melthk_all_passes_start_registered_flag = true;
       register_callback (melt_plugin_name, PLUGIN_ALL_PASSES_START,
			  melt_all_passes_start_hook_callback,
			  NULL);
     }
   }#
  ))

(defun register_all_passes_start_first (fun)
  :doc #{Use $REGISTER_ALL_PASSES_START_FIRST to register a function $FUN to
  be run at PLUGIN_ALL_PASSES_START, in first place.  $FUN must be a closure
  which takes no arguments and whose result is ignored.}#
  (if (is_closure fun)
      (let ( (firstlist (get_field :delqu_first all_passes_start_delayed_queue))
	    )
	(enable_all_passes_start)
	(if (null firstlist)
	    (progn
	      (setq firstlist (make_list discr_list))
	      (put_fields
	        all_passes_start_delayed_queue
	        :delqu_first firstlist
	        :delqu_last (make_list discr_list))
	      ))
	(list_append firstlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_all_passes_start_hook_first")
    ))

(defun register_all_passes_start_last (fun)
  :doc #{Use $REGISTER_ALL_PASSES_START_LAST to register a function $FUN to
  be run at PLUGIN_ALL_PASSES_START, in last place.  $FUN must be a closure
  which takes no argument and whose result is ignored.}#
  (if (is_closure fun)
      (let ( (lastlist (get_field :delqu_last all_passes_start_delayed_queue))
	    )
	(enable_all_passes_start)
	(if (null lastlist)
	    (progn
	      (setq lastlist (make_list discr_list))
	      (put_fields
	        all_passes_start_delayed_queue
	        :delqu_first (make_list discr_list)
	        :delqu_last lastlist)
	      ))
	(list_append lastlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_all_passes_start_hook_last")
    ))


;;;====================================================================
;;;****************** ALL_PASSES_END plugin event *******************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



(cheader #{/* flag for PLUGIN_ALL_PASSES_END declare */
MELT_EXTERN bool MELT_MODULE_VISIBILITY  melthk_all_passes_end_registered_flag;
}#)
(cimplement #{/* flag for PLUGIN_ALL_PASSES_END define */
bool  melthk_all_passes_end_registered_flag;
}#)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; handling PLUGIN_ALL_PASSES_END
;; private all_passes_end handling queue
(definstance all_passes_end_delayed_queue class_delayed_queue
  :named_name '"all_passes_end_delayed_queue"
  :delqu_first ()
  :delqu_last ()
  )

;; internal private hook for PLUGIN_ALL_PASSES_END 
(defhook hook_all_passes_end () () :void
  :predef HOOK_ALL_PASSES_END
  (let ( (firstlist (get_field :delqu_first all_passes_end_delayed_queue))
	 (lastlist (get_field :delqu_last all_passes_end_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (res ())
	 )
;;; call the first routines in natural order
    (foreach_in_list
     (firstlist)
     (firstpair firstproc)
     (setq res (firstproc res))
     )
;;; reverse the last list
    (foreach_in_list
     (lastlist)
     (lastpair lastproc)
     (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
    (foreach_in_list
     (revlastlist)
     (revlastpair revlastproc)
     (setq res (revlastproc res))
    )))

(cheader #{ 
 void MELT_MODULE_VISIBILITY 
    melt_all_passes_end_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
				 void* user_data ATTRIBUTE_UNUSED);
 }#)

(cimplement #{
 void 
 melt_all_passes_end_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
			      void* user_data ATTRIBUTE_UNUSED)
 {
    melthookproc_HOOK_ALL_PASSES_END ();
 }
 }#)

(defun enable_all_passes_end ()
  (code_chunk 
   enallpassesend_chk
   #{ /* enable_all_passes_end $ENALLPASSESEND_CHK */
     if (!melthk_all_passes_end_registered_flag) {
       melthk_all_passes_end_registered_flag = true; 
       register_callback (melt_plugin_name, PLUGIN_ALL_PASSES_END,
			  melt_all_passes_end_hook_callback,
                          NULL);
     } 
   }#
  ))

(defun register_all_passes_end_first (fun)
  :doc #{Use $REGISTER_ALL_PASSES_END_FIRST to register a function $FUN to
  be run at PLUGIN_ALL_PASSES_END, in first place.  $FUN must be a closure
  which takes no argument and whose result is ignored.}#
  (if (is_closure fun)
      (let ( (firstlist (get_field :delqu_first all_passes_end_delayed_queue))
	    )
	(enable_all_passes_end)
	(if (null firstlist)
	    (progn
	      (setq firstlist (make_list discr_list))
	      (put_fields
	        all_passes_end_delayed_queue
	        :delqu_first firstlist
	        :delqu_last (make_list discr_list))
	      ))
	(list_append firstlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_all_passes_end_first")
    ))

(defun register_all_passes_end_last (fun)
  :doc #{Use $REGISTER_ALL_PASSES_END_LAST to register a function $FUN to
  be run at PLUGIN_ALL_PASSES_END, in last place.  $FUN must be a closure
  which takes no arguments and whose result is ignored.}#
  (if (is_closure fun)
      (let ( (lastlist (get_field :delqu_last all_passes_end_delayed_queue))
	    )
	(enable_all_passes_end)
	(if (null lastlist)
	    (progn
	      (setq lastlist (make_list discr_list))
	      (put_fields
	        all_passes_end_delayed_queue
	        :delqu_first (make_list discr_list)
	        :delqu_last lastlist)
	      ))
	(list_append lastlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_all_passes_end_last")
    ))


;;;====================================================================
;;;****************** ALL_IPA_PASSES_START plugin event *******************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; handling PLUGIN_ALL_IPA_PASSES_START
;; private all_ipa_passes_start handling queue
(definstance all_ipa_passes_start_delayed_queue class_delayed_queue
  :named_name '"all_ipa_passes_start_delayed_queue"
  :delqu_first ()
  :delqu_last ()
  )

(cheader #{/* flag for PLUGIN_ALL_IPA_PASSES_START declare */
MELT_EXTERN bool MELT_MODULE_VISIBILITY  melthk_all_ipa_passes_start_registered_flag;
}#)
(cimplement  #{/* flag for PLUGIN_ALL_IPA_PASSES_START define */
 bool melthk_all_ipa_passes_start_registered_flag;
}#)

;; internal hook for PLUGIN_ALL_IPA_PASSES_START 
(defhook hook_all_ipa_passes_start () () :void
  :predef HOOK_ALL_IPA_PASSES_START
  (let ( (firstlist (get_field :delqu_first all_ipa_passes_start_delayed_queue))
	 (lastlist (get_field :delqu_last all_ipa_passes_start_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (res ())
	 )
;;; call the first routines in natural order
    (foreach_in_list
     (firstlist)
     (firstpair firstproc)
     (setq res (firstproc res))
     )
;;; reverse the last list
    (foreach_in_list
     (lastlist)
     (lastpair lastproc)
     (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
    (if lastlist 
	(foreach_in_list
	 (revlastlist)
	 (revlastpair revlastproc)
	 (setq res (revlastproc res))
    ))))

(cheader #{ 
 void MELT_MODULE_VISIBILITY 
    melt_all_ipa_passes_start_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
				 void* user_data ATTRIBUTE_UNUSED);
 }#)

(cimplement #{
 void 
 melt_all_ipa_passes_start_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
			      void* user_data ATTRIBUTE_UNUSED)
 {
   melthookproc_HOOK_ALL_IPA_PASSES_START ();
 }
 }#)

(defun enable_all_ipa_passes_start ()
  (code_chunk 
   enallpassesstart_chk
   #{ /* enable_all_ipa_passes_start $ENALLPASSESSTART_CHK */
     if (!melthk_all_ipa_passes_start_registered_flag) {
       melthk_all_ipa_passes_start_registered_flag = true;
       register_callback (melt_plugin_name, PLUGIN_ALL_IPA_PASSES_START,
			  melt_all_ipa_passes_start_hook_callback,
			  NULL);
     }
   }#
  ))

(defun register_all_ipa_passes_start_first (fun)
  :doc #{Use $REGISTER_ALL_IPA_PASSES_START_FIRST to register a function $FUN to
  be run at PLUGIN_ALL_IPA_PASSES_START, in first place.  $FUN must be a closure
  which takes no arguments and whose result is ignored.}#
  (if (is_closure fun)
      (let ( (firstlist (get_field :delqu_first all_ipa_passes_start_delayed_queue))
	    )
	(enable_all_ipa_passes_start)
	(if (null firstlist)
	    (progn
	      (setq firstlist (make_list discr_list))
	      (put_fields
	        all_ipa_passes_start_delayed_queue
	        :delqu_first firstlist
	        :delqu_last (make_list discr_list))
	      ))
	(list_append firstlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_all_ipa_passes_start_hook_first")
    ))

(defun register_all_ipa_passes_start_last (fun)
  :doc #{Use $REGISTER_ALL_IPA_PASSES_START_LAST to register a function $FUN to
  be run at PLUGIN_ALL_IPA_PASSES_START, in last place.  $FUN must be a closure
  which takes no argument and whose result is ignored.}#
  (if (is_closure fun)
      (let ( (lastlist (get_field :delqu_last all_ipa_passes_start_delayed_queue))
	    )
	(enable_all_ipa_passes_start)
	(if (null lastlist)
	    (progn
	      (setq lastlist (make_list discr_list))
	      (put_fields
	        all_ipa_passes_start_delayed_queue
	        :delqu_first (make_list discr_list)
	        :delqu_last lastlist)
	      ))
	(list_append lastlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_all_ipa_passes_start_hook_last")
    ))


;;;====================================================================
;;;****************** ALL_IPA_PASSES_END plugin event *******************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



(cheader #{/* flag for PLUGIN_ALL_IPA_PASSES_END declare */
MELT_EXTERN bool MELT_MODULE_VISIBILITY  melthk_all_ipa_passes_end_registered_flag;
}#)
(cimplement #{/* flag for PLUGIN_ALL_IPA_PASSES_END define */
bool  melthk_all_ipa_passes_end_registered_flag;
}#)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; handling PLUGIN_ALL_IPA_PASSES_END
;; private all_ipa_passes_end handling queue
(definstance all_ipa_passes_end_delayed_queue class_delayed_queue
  :named_name '"all_ipa_passes_end_delayed_queue"
  :delqu_first ()
  :delqu_last ()
  )

;; internal private hook for PLUGIN_ALL_IPA_PASSES_END 
(defhook hook_all_ipa_passes_end () () :void
  :predef HOOK_ALL_IPA_PASSES_END
  (let ( (firstlist (get_field :delqu_first all_ipa_passes_end_delayed_queue))
	 (lastlist (get_field :delqu_last all_ipa_passes_end_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (res ())
	 )
;;; call the first routines in natural order
    (foreach_in_list
     (firstlist)
     (firstpair firstproc)
     (setq res (firstproc res))
     )
;;; reverse the last list
    (foreach_in_list
     (lastlist)
     (lastpair lastproc)
     (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
    (foreach_in_list
     (revlastlist)
     (revlastpair revlastproc)
     (setq res (revlastproc res))
    )))

(cheader #{ 
 void MELT_MODULE_VISIBILITY 
    melt_all_ipa_passes_end_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
				 void* user_data ATTRIBUTE_UNUSED);
 }#)

(cimplement #{
 void 
 melt_all_ipa_passes_end_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
			      void* user_data ATTRIBUTE_UNUSED)
 {
    melthookproc_HOOK_ALL_IPA_PASSES_END ();
 }
 }#)

(defun enable_all_ipa_passes_end ()
  (code_chunk 
   enallpassesend_chk
   #{ /* enable_all_ipa_passes_end $ENALLPASSESEND_CHK */
     if (!melthk_all_ipa_passes_end_registered_flag) {
       melthk_all_ipa_passes_end_registered_flag = true; 
       register_callback (melt_plugin_name, PLUGIN_ALL_IPA_PASSES_END,
			  melt_all_ipa_passes_end_hook_callback,
                          NULL);
     } 
   }#
  ))

(defun register_all_ipa_passes_end_first (fun)
  :doc #{Use $REGISTER_ALL_IPA_PASSES_END_FIRST to register a function $FUN to
  be run at PLUGIN_ALL_IPA_PASSES_END, in first place.  $FUN must be a closure
  which takes no argument and whose result is ignored.}#
  (if (is_closure fun)
      (let ( (firstlist (get_field :delqu_first all_ipa_passes_end_delayed_queue))
	    )
	(enable_all_ipa_passes_end)
	(if (null firstlist)
	    (progn
	      (setq firstlist (make_list discr_list))
	      (put_fields
	        all_ipa_passes_end_delayed_queue
	        :delqu_first firstlist
	        :delqu_last (make_list discr_list))
	      ))
	(list_append firstlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_all_ipa_passes_end_first")
    ))

(defun register_all_ipa_passes_end_last (fun)
  :doc #{Use $REGISTER_ALL_IPA_PASSES_END_LAST to register a function $FUN to
  be run at PLUGIN_ALL_IPA_PASSES_END, in last place.  $FUN must be a closure
  which takes no arguments and whose result is ignored.}#
  (if (is_closure fun)
      (let ( (lastlist (get_field :delqu_last all_ipa_passes_end_delayed_queue))
	    )
	(enable_all_ipa_passes_end)
	(if (null lastlist)
	    (progn
	      (setq lastlist (make_list discr_list))
	      (put_fields
	        all_ipa_passes_end_delayed_queue
	        :delqu_first (make_list discr_list)
	        :delqu_last lastlist)
	      ))
	(list_append lastlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_all_ipa_passes_end_last")
    ))



;;;====================================================================
;;;************** EARLY_GIMPLE_PASSES_START plugin event **************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; handling PLUGIN_EARLY_GIMPLE_PASSES_START
;; private early_gimple_passes_start handling queue
(definstance early_gimple_passes_start_delayed_queue class_delayed_queue
  :named_name '"early_gimple_passes_start_delayed_queue"
  :delqu_first ()
  :delqu_last ()
  )

(cheader #{/* flag for PLUGIN_EARLY_GIMPLE_PASSES_START declare */
MELT_EXTERN bool MELT_MODULE_VISIBILITY  melthk_early_gimple_passes_start_registered_flag;
}#)
(cimplement  #{/* flag for PLUGIN_EARLY_GIMPLE_PASSES_START define */
 bool melthk_early_gimple_passes_start_registered_flag;
}#)

;; internal hook for PLUGIN_EARLY_GIMPLE_PASSES_START 
(defhook hook_early_gimple_passes_start () () :void
  :predef HOOK_EARLY_GIMPLE_PASSES_START
  (let ( (firstlist (get_field :delqu_first early_gimple_passes_start_delayed_queue))
	 (lastlist (get_field :delqu_last early_gimple_passes_start_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (res ())
	 )
;;; call the first routines in natural order
    (foreach_in_list
     (firstlist)
     (firstpair firstproc)
     (setq res (firstproc res))
     )
;;; reverse the last list
    (foreach_in_list
     (lastlist)
     (lastpair lastproc)
     (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
    (if lastlist 
	(foreach_in_list
	 (revlastlist)
	 (revlastpair revlastproc)
	 (setq res (revlastproc res))
    ))))

(cheader #{ 
 void MELT_MODULE_VISIBILITY 
    melt_early_gimple_passes_start_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
				 void* user_data ATTRIBUTE_UNUSED);
 }#)

(cimplement #{
 void 
 melt_early_gimple_passes_start_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
			      void* user_data ATTRIBUTE_UNUSED)
 {
   melthookproc_HOOK_EARLY_GIMPLE_PASSES_START ();
 }
 }#)

(defun enable_early_gimple_passes_start ()
  (code_chunk 
   enallpassesstart_chk
   #{ /* enable_early_gimple_passes_start $ENALLPASSESSTART_CHK */
     if (!melthk_early_gimple_passes_start_registered_flag) {
       melthk_early_gimple_passes_start_registered_flag = true;
       register_callback (melt_plugin_name, PLUGIN_EARLY_GIMPLE_PASSES_START,
			  melt_early_gimple_passes_start_hook_callback,
			  NULL);
     }
   }#
  ))

(defun register_early_gimple_passes_start_first (fun)
  :doc #{Use $REGISTER_EARLY_GIMPLE_PASSES_START_FIRST to register a function $FUN to
  be run at PLUGIN_EARLY_GIMPLE_PASSES_START, in first place.  $FUN must be a closure
  which takes no arguments and whose result is ignored.}#
  (if (is_closure fun)
      (let ( (firstlist (get_field :delqu_first early_gimple_passes_start_delayed_queue))
	    )
	(enable_early_gimple_passes_start)
	(if (null firstlist)
	    (progn
	      (setq firstlist (make_list discr_list))
	      (put_fields
	        early_gimple_passes_start_delayed_queue
	        :delqu_first firstlist
	        :delqu_last (make_list discr_list))
	      ))
	(list_append firstlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_early_gimple_passes_start_hook_first")
    ))

(defun register_early_gimple_passes_start_last (fun)
  :doc #{Use $REGISTER_EARLY_GIMPLE_PASSES_START_LAST to register a function $FUN to
  be run at PLUGIN_EARLY_GIMPLE_PASSES_START, in last place.  $FUN must be a closure
  which takes no argument and whose result is ignored.}#
  (if (is_closure fun)
      (let ( (lastlist (get_field :delqu_last early_gimple_passes_start_delayed_queue))
	    )
	(enable_early_gimple_passes_start)
	(if (null lastlist)
	    (progn
	      (setq lastlist (make_list discr_list))
	      (put_fields
	        early_gimple_passes_start_delayed_queue
	        :delqu_first (make_list discr_list)
	        :delqu_last lastlist)
	      ))
	(list_append lastlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_early_gimple_passes_start_hook_last")
    ))


;;;=====================================================================
;;;*************** EARLY_GIMPLE_PASSES_END plugin event ****************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



(cheader #{/* flag for PLUGIN_EARLY_GIMPLE_PASSES_END declare */
MELT_EXTERN bool MELT_MODULE_VISIBILITY  melthk_early_gimple_passes_end_registered_flag;
}#)
(cimplement #{/* flag for PLUGIN_EARLY_GIMPLE_PASSES_END define */
bool  melthk_early_gimple_passes_end_registered_flag;
}#)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; handling PLUGIN_EARLY_GIMPLE_PASSES_END
;; private early_gimple_passes_end handling queue
(definstance early_gimple_passes_end_delayed_queue class_delayed_queue
  :named_name '"early_gimple_passes_end_delayed_queue"
  :delqu_first ()
  :delqu_last ()
  )

;; internal private hook for PLUGIN_EARLY_GIMPLE_PASSES_END 
(defhook hook_early_gimple_passes_end () () :void
  :predef HOOK_EARLY_GIMPLE_PASSES_END
  (let ( (firstlist (get_field :delqu_first early_gimple_passes_end_delayed_queue))
	 (lastlist (get_field :delqu_last early_gimple_passes_end_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (res ())
	 )
;;; call the first routines in natural order
    (foreach_in_list
     (firstlist)
     (firstpair firstproc)
     (setq res (firstproc res))
     )
;;; reverse the last list
    (foreach_in_list
     (lastlist)
     (lastpair lastproc)
     (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
    (foreach_in_list
     (revlastlist)
     (revlastpair revlastproc)
     (setq res (revlastproc res))
    )))

(cheader #{ 
 void MELT_MODULE_VISIBILITY 
    melt_early_gimple_passes_end_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
				 void* user_data ATTRIBUTE_UNUSED);
 }#)

(cimplement #{
 void 
 melt_early_gimple_passes_end_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
			      void* user_data ATTRIBUTE_UNUSED)
 {
   melthookproc_HOOK_EARLY_GIMPLE_PASSES_END ();
 }
 }#)

(defun enable_early_gimple_passes_end ()
  (code_chunk 
   enallpassesend_chk
   #{ /* enable_early_gimple_passes_end $ENALLPASSESEND_CHK */
     if (!melthk_early_gimple_passes_end_registered_flag) {
       melthk_early_gimple_passes_end_registered_flag = true; 
       register_callback (melt_plugin_name, PLUGIN_EARLY_GIMPLE_PASSES_END,
			  melt_early_gimple_passes_end_hook_callback,
                          NULL);
     } 
   }#
  ))

(defun register_early_gimple_passes_end_first (fun)
  :doc #{Use $REGISTER_EARLY_GIMPLE_PASSES_END_FIRST to register a function $FUN to
  be run at PLUGIN_EARLY_GIMPLE_PASSES_END, in first place.  $FUN must be a closure
  which takes no argument and whose result is ignored.}#
  (if (is_closure fun)
      (let ( (firstlist (get_field :delqu_first early_gimple_passes_end_delayed_queue))
	    )
	(enable_early_gimple_passes_end)
	(if (null firstlist)
	    (progn
	      (setq firstlist (make_list discr_list))
	      (put_fields
	        early_gimple_passes_end_delayed_queue
	        :delqu_first firstlist
	        :delqu_last (make_list discr_list))
	      ))
	(list_append firstlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_early_gimple_passes_end_first")
    ))

(defun register_early_gimple_passes_end_last (fun)
  :doc #{Use $REGISTER_EARLY_GIMPLE_PASSES_END_LAST to register a function $FUN to
  be run at PLUGIN_EARLY_GIMPLE_PASSES_END, in last place.  $FUN must be a closure
  which takes no arguments and whose result is ignored.}#
  (if (is_closure fun)
      (let ( (lastlist (get_field :delqu_last early_gimple_passes_end_delayed_queue))
	    )
	(enable_early_gimple_passes_end)
	(if (null lastlist)
	    (progn
	      (setq lastlist (make_list discr_list))
	      (put_fields
	        early_gimple_passes_end_delayed_queue
	        :delqu_first (make_list discr_list)
	        :delqu_last lastlist)
	      ))
	(list_append lastlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_early_gimple_passes_end_last")
    ))



;;;=====================================================================
;;;******************* PRE_GENERICIZE plugin event *********************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; private pregenericize queue
(definstance pregenericize_delayed_queue class_delayed_queue
  :named_name '"pregenericize_delayed_queue"
  :delqu_first ()
  :delqu_last ()
  )


(cheader #{/* flag for PLUGIN_PRE_GENERICIZE declare */
MELT_EXTERN bool MELT_MODULE_VISIBILITY  melthk_pre_genericize_registered_flag;
}#)

(cimplement #{/* flag for PLUGIN_PRE_GENERICIZE define */
bool  melthk_pre_genericize_registered_flag;
}#)

(cheader #{ 
 void MELT_MODULE_VISIBILITY 
    melt_pre_genericize_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
				 void* user_data ATTRIBUTE_UNUSED);
 }#)

(cimplement #{
 void 
 melt_pre_genericize_hook_callback (void* gcc_data,
			      void* user_data ATTRIBUTE_UNUSED)
 {
   melthookproc_HOOK_PRE_GENERICIZE ((tree)gcc_data);
 }
 }#)

(defun enable_pre_genericize ()
  (code_chunk 
   enablepregen_chk
   #{ /* enable_pre_genericize $enablepregen_chk */
   if (!melthk_pre_genericize_registered_flag) {
     melthk_pre_genericize_registered_flag = true;
/*
  register_callback (melt_plugin_name, PLUGIN_PRE_GENERICIZE,
                     melt_pre_genericize_hook_callback, NULL);
*/
   }
   }#)
)

(defhook hook_pre_genericize (:tree tfndecl) () :void
  :predef HOOK_PRE_GENERICIZE
  (let ( (firstlist (get_field :delqu_first pregenericize_delayed_queue))
	 (lastlist (get_field :delqu_last pregenericize_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (res ())
	 )
    (let ( (cfndeclv (constant_box tfndecl))
	   )
;;; call the first routines in natural order
      (foreach_in_list
       (firstlist)
       (firstpair firstproc)
       (setq res (firstproc cfndeclv res))
       )
;;; reverse the last list
      (foreach_in_list
       (lastlist)
       (lastpair lastproc)
       (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
      (foreach_in_list
       (revlastlist)
       (revlastpair revlastproc)
       (setq res (revlastproc cfndeclv res))
       )
      )
    )
  )					;end hook_pre_genericize 


(defun register_pre_genericize_first (fun)
  :doc #{Use $REGISTER_PRE_GENERICIZE_FIRST to register a function $FUN to
  be run at PLUGIN_PRE_GENERICIZE hook, in first place.  $FUN must be a closure
  which take 1 argument (the boxed tree of function declaration being parsed).}#
  (let ( (firstlist (get_field :delqu_first pregenericize_delayed_queue))
	     )
    (if (null firstlist)
	    (progn
	      (setq firstlist (make_list discr_list))
	      (put_fields
	        pregenericize_delayed_queue
	        :delqu_first firstlist
	        :delqu_last (make_list discr_list))
	      ))
    (if (is_closure fun)
      (progn 
	(list_append firstlist fun)
	(enable_pre_genericize))
      (errormsg_plain
        "Bad hook passed to register_pre_genericize_hook")
    ))
)

(defun register_pre_genericize_last (fun)
  :doc #{Use $REGISTER_PRE_GENERICIZE_LAST to register a function $FUN to
  be run at PLUGIN_PRE_GENERICIZE hook, in last place.  $FUN must be a closure
  which take 1 argument (the boxed tree of function declaration being parsed).}#
  (let ( (lastlist (get_field :delqu_first pregenericize_delayed_queue))
	     )
    (if (null lastlist)
	    (progn
	      (setq lastlist (make_list discr_list))
	      (put_fields
	        pregenericize_delayed_queue
	        :delqu_first lastlist
	        :delqu_last (make_list discr_list))
	      ))
    (if (is_closure fun)
	(progn
	  (list_append lastlist fun)
	  (enable_pre_genericize))
      (errormsg_plain
        "Bad hook passed to register_pre_genericize_hook")
    ))
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



;;;=====================================================================
;;;******************* FINISH_TYPE plugin event *********************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; private finishtype queue
(definstance finishtype_delayed_queue class_delayed_queue
  :named_name '"finishtype_delayed_queue"
  :delqu_first ()
  :delqu_last ()
  )


(cheader #{/* flag for PLUGIN_FINISH_TYPE declare */
MELT_EXTERN bool MELT_MODULE_VISIBILITY  melthk_finish_type_registered_flag;
}#)

(cimplement #{/* flag for PLUGIN_FINISH_TYPE define */
bool  melthk_finish_type_registered_flag;
}#)

(cheader #{ 
 void MELT_MODULE_VISIBILITY 
    melt_finish_type_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
				 void* user_data ATTRIBUTE_UNUSED);
 }#)

(cimplement #{
 void 
 melt_finish_type_hook_callback (void* gcc_data,
			      void* user_data ATTRIBUTE_UNUSED)
 {
   melthookproc_HOOK_FINISH_TYPE ((tree)gcc_data);
 }
 }#)

(defun enable_finish_type ()
  (code_chunk 
   enablepregen_chk
   #{ /* enable_finish_type $enablepregen_chk */
   if (!melthk_finish_type_registered_flag) {
     melthk_finish_type_registered_flag = true;
     register_callback (melt_plugin_name, PLUGIN_FINISH_TYPE,
			melt_finish_type_hook_callback, NULL);
   }
   }#)
)

(defhook hook_finish_type (:tree tfndecl) () :void
  :predef HOOK_FINISH_TYPE
  (let ( (firstlist (get_field :delqu_first finishtype_delayed_queue))
	 (lastlist (get_field :delqu_last finishtype_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (res ())
	 )
    (let ( (cfndeclv (constant_box tfndecl))
	   )
;;; call the first routines in natural order
      (foreach_in_list
       (firstlist)
       (firstpair firstproc)
       (setq res (firstproc cfndeclv res))
       )
;;; reverse the last list
      (foreach_in_list
       (lastlist)
       (lastpair lastproc)
       (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
      (foreach_in_list
       (revlastlist)
       (revlastpair revlastproc)
       (setq res (revlastproc cfndeclv res))
       )
      )
    )
  )					;end hook_finish_type 


(defun register_finish_type_first (fun)
  :doc #{Use $REGISTER_FINISH_TYPE_FIRST to register a function $FUN to
  be run at PLUGIN_FINISH_TYPE hook, in first place.  $FUN must be a closure
  which take 1 argument (the boxed tree of function declaration being parsed).}#
  (let ( (firstlist (get_field :delqu_first finishtype_delayed_queue))
	     )
    (if (null firstlist)
	    (progn
	      (setq firstlist (make_list discr_list))
	      (put_fields
	        finishtype_delayed_queue
	        :delqu_first firstlist
	        :delqu_last (make_list discr_list))
	      ))
    (if (is_closure fun)
      (progn 
	(list_append firstlist fun)
	(enable_finish_type))
      (errormsg_plain
        "Bad hook passed to register_finish_type_first")
    ))
)

(defun register_finish_type_last (fun)
  :doc #{Use $REGISTER_FINISH_TYPE_LAST to register a function $FUN to
  be run at PLUGIN_FINISH_TYPE hook, in last place.  $FUN must be a closure
  which take 1 argument (the boxed tree of function declaration being parsed).}#
  (let ( (lastlist (get_field :delqu_first finishtype_delayed_queue))
	     )
    (if (null lastlist)
	    (progn
	      (setq lastlist (make_list discr_list))
	      (put_fields
	        finishtype_delayed_queue
	        :delqu_first lastlist
	        :delqu_last (make_list discr_list))
	      ))
    (if (is_closure fun)
	(progn
	  (list_append lastlist fun)
	  (enable_finish_type))
      (errormsg_plain
        "Bad hook passed to register_finish_type_last")
    ))
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; private endmeltpass queue

(definstance endmeltpass_delayed_queue class_delayed_queue
  :named_name '"endmeltpass_delayed_queue"
  :delqu_first ()
  :delqu_last ()
  )

(defun run_endmeltpass_functions ()
  (let ( (firstlist (get_field :delqu_first endmeltpass_delayed_queue))
	 (lastlist (get_field :delqu_last endmeltpass_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (res (instance class_container))
	 )
    (put_fields endmeltpass_delayed_queue
		:delqu_first ()
		:delqu_last ())
;;; call the first routines in natural order
    (foreach_in_list
     (firstlist)
     (firstpair firstproc)
     (if (is_closure firstproc) 
	 (firstproc res))
     )
;;; reverse the last list
    (foreach_in_list
     (lastlist)
     (lastpair lastproc)
     (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
    (foreach_in_list
     (revlastlist)
     (revlastpair revlastproc)
     (revlastproc res)
     )
    )
  )

(defun at_end_of_this_melt_pass_first (fun)
  :doc #{Use $AT_END_OF_THIS_MELT_PASS_FIRST to register a function to be called at the end of the current MELT provided GCC pass, in first place.}#
  (let ( (firstlist (unsafe_get_field :delqu_first endmeltpass_delayed_queue))
	 )
    (when (null firstlist)
      (setq firstlist (make_list discr_list))
      (put_fields endmeltpass_delayed_queue :delqu_first firstlist))
    (if (is_closure fun)
	(list_append firstlist fun))))

		   
(defun at_end_of_this_melt_pass_last (fun)
  :doc #{Use $AT_END_OF_THIS_MELT_PASS_LAST to register a function to be called 
at the end of the current MELT provided GCC pass, in last place.}#
  (let ( (lastlist (unsafe_get_field :delqu_last endmeltpass_delayed_queue))
	 )
    (when (null lastlist)
      (setq lastlist (make_list discr_list))
      (put_fields endmeltpass_delayed_queue :delqu_last lastlist))
    (if (is_closure fun)
	(list_append lastlist fun))))

		   

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;=====================================================================
;;;******************* FINISH_DECL plugin event *********************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; private finishdecl queue
(definstance finishdecl_delayed_queue class_delayed_queue
  :named_name '"finishdecl_delayed_queue"
  :delqu_first ()
  :delqu_last ()
  )


(cheader #{/* flag for PLUGIN_FINISH_DECL declare */
MELT_EXTERN bool MELT_MODULE_VISIBILITY  melthk_finish_decl_registered_flag;
}#)

(cimplement #{/* flag for PLUGIN_FINISH_DECL define */
bool  melthk_finish_decl_registered_flag;
}#)

(cheader #{ 
 void MELT_MODULE_VISIBILITY 
    melt_finish_decl_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
				 void* user_data ATTRIBUTE_UNUSED);
 }#)

(cimplement #{
 void 
 melt_finish_decl_hook_callback (void* gcc_data,
			      void* user_data ATTRIBUTE_UNUSED)
 {
 melthookproc_HOOK_FINISH_DECL ((tree)gcc_data);
 }
 }#)

(defun enable_finish_decl ()
  (code_chunk 
   enablepregen_chk
   #{ /* enable_finish_decl $enablepregen_chk */
   if (!melthk_finish_decl_registered_flag) {
     melthk_finish_decl_registered_flag = true;
#if MELT_GCC_VERSION < 4007
   melt_fatal_error ("PLUGIN_FINISH_DECL does not exist in GCC 4.6");
#else
  register_callback (melt_plugin_name, PLUGIN_FINISH_DECL,
                     melt_finish_decl_hook_callback, NULL);
#endif 
   }
   }#)
)

(defhook hook_finish_decl (:tree tfndecl) () :void
  :predef HOOK_FINISH_DECL
  (let ( (firstlist (get_field :delqu_first finishdecl_delayed_queue))
	 (lastlist (get_field :delqu_last finishdecl_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (res ())
	 )
    (let ( (cfndeclv (constant_box tfndecl))
	   )
;;; call the first routines in natural order
      (foreach_in_list
       (firstlist)
       (firstpair firstproc)
       (setq res (firstproc cfndeclv res))
       )
;;; reverse the last list
      (foreach_in_list
       (lastlist)
       (lastpair lastproc)
       (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
      (foreach_in_list
       (revlastlist)
       (revlastpair revlastproc)
       (setq res (revlastproc cfndeclv res))
       )
      )
    )
  )					;end hook_finish_decl 


(defun register_finish_decl_first (fun)
  :doc #{Use $REGISTER_FINISH_DECL_FIRST to register a function $FUN to
  be run at PLUGIN_FINISH_DECL hook, in first place.  $FUN must be a closure
  which take 1 argument (the boxed tree of function declaration being parsed).}#
  (let ( (firstlist (get_field :delqu_first finishdecl_delayed_queue))
	     )
    (if (null firstlist)
	    (progn
	      (setq firstlist (make_list discr_list))
	      (put_fields
	        finishdecl_delayed_queue
	        :delqu_first firstlist
	        :delqu_last (make_list discr_list))
	      ))
    (if (is_closure fun)
      (progn 
	(list_append firstlist fun)
	(enable_finish_decl))
      (errormsg_plain
        "Bad hook passed to register_finish_decl_first")
    ))
)

(defun register_finish_decl_last (fun)
  :doc #{Use $REGISTER_FINISH_DECL_LAST to register a function $FUN to
  be run at PLUGIN_FINISH_DECL hook, in last place.  $FUN must be a closure
  which take 1 argument (the boxed tree of function declaration being parsed).}#
  (let ( (lastlist (get_field :delqu_first finishdecl_delayed_queue))
	     )
    (if (null lastlist)
	    (progn
	      (setq lastlist (make_list discr_list))
	      (put_fields
	        finishdecl_delayed_queue
	        :delqu_first lastlist
	        :delqu_last (make_list discr_list))
	      ))
    (if (is_closure fun)
	(progn
	  (list_append lastlist fun)
	  (enable_finish_decl))
      (errormsg_plain
        "Bad hook passed to register_finish_decl_last")
    ))
)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



;;;=====================================================================
;;;******************* PASS_EXECUTION plugin event *********************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; private pass_execution queue
(definstance pass_execution_delayed_queue class_delayed_queue
  :named_name '"pass_execution_delayed_queue"
  :delqu_first ()
  :delqu_last ()
  )

(cheader #{/* flag for PLUGIN_PASS_EXECUTION declare */
MELT_EXTERN bool MELT_MODULE_VISIBILITY  melthk_pass_execution_registered_flag;
}#)
(cimplement #{/* flag for PLUGIN_PASS_EXECUTION define */
bool  melthk_pass_execution_registered_flag;
}#)

(cheader #{ 
 void MELT_MODULE_VISIBILITY 
    melt_pass_execution_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
				 void* user_data ATTRIBUTE_UNUSED);
 }#)

(cimplement #{
 void 
 melt_pass_execution_hook_callback (void* gcc_data ATTRIBUTE_UNUSED,
			      void* user_data ATTRIBUTE_UNUSED)
 {
   struct opt_pass* pass = (struct opt_pass*) gcc_data;
   melthookproc_HOOK_PASS_EXECUTION (pass->name, (long) pass->static_pass_number);
 }
 }#)


;; we always register the pass_execution hook, because we want the GC
;; to run there
(code_chunk 
 register_pass_execution_hook_chk
 #{ /* we always $register_pass_execution_hook_chk */
    register_callback (melt_plugin_name, PLUGIN_PASS_EXECUTION,
		       melt_pass_execution_hook_callback, NULL);
 }#)

(defhook hook_pass_execution (:cstring passname :long passnum) () :void
  :predef HOOK_PASS_EXECUTION
  (let (
	(passnameval (expr_chunk
		      makepassname_chk  
		      :value
		      #{/*hook_pass_execution $MAKEPASSNAME_CHK*/
		      meltgc_new_stringdup 
		      ((meltobject_ptr_t) MELT_PREDEF(DISCR_STRING),
		       $PASSNAME)
		      }#))
	(firstlist (get_field :delqu_first pass_execution_delayed_queue))
	(lastlist (get_field :delqu_last  pass_execution_delayed_queue))
	(revlastlist (make_list discr_list))
	(res ())
	)
;;; call the first routines in natural order
    (foreach_in_list
     (firstlist)
     (firstpair firstproc)
     (setq res (firstproc passnameval passnum res))
     )
;;; reverse the last list
    (foreach_in_list
     (lastlist)
     (lastpair lastproc)
     (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
    (foreach_in_list
     (revlastlist)
     (revlastpair revlastproc)
     (setq res (revlastproc passnameval passnum res))
     )
    )
  ;; always force a minor garbage collection, otherwise other GCC
  ;; passes could break havoc
  (minor_garbcoll 1024)
  )					;end hook_pass_execution 


(defun register_pass_execution_first (fun)
  :doc #{Use $REGISTER_PASS_EXECUTION_FIRST to register a function $FUN to
  be run at PLUGIN_PASS_EXECUTION hook, in first place.  $FUN must be a closure
  which take 1 argument (the boxed tree of function declaration being parsed).}#
  (let ( (firstlist (get_field :delqu_first pass_execution_delayed_queue))
	     )
    (if (null firstlist)
	    (progn
	      (setq firstlist (make_list discr_list))
	      (put_fields
	        pass_execution_delayed_queue
	        :delqu_first firstlist
	        :delqu_last (make_list discr_list))
	      ))
    (if (is_closure fun)
      (list_append firstlist fun)
      (errormsg_plain
        "Bad hook passed to register_pass_execution_hook")
    ))
)

(defun register_pass_execution_last (fun)
  :doc #{Use $REGISTER_PASS_EXECUTION_LAST to register a function $FUN to
  be run at PLUGIN_PASS_EXECUTION hook, in last place.  $FUN must be a closure
  which take 1 argument (the boxed tree of function declaration being parsed).}#
  (let ( (lastlist (get_field :delqu_first pass_execution_delayed_queue))
	     )
    (if (null lastlist)
	    (progn
	      (setq lastlist (make_list discr_list))
	      (put_fields
 	        pass_execution_delayed_queue
	        :delqu_first lastlist
	        :delqu_last (make_list discr_list))
	      ))
    (if (is_closure fun)
      (list_append lastlist fun)
      (errormsg_plain
        "Bad hook passed to register_pass_execution_last_hook")
    ))
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; gate hook for gimple passes
(defhook hook_gimple_gate
  () () :long
  :predef HOOK_GIMPLE_GATE
  (let ( (:long hasmodeflag 0)
	 (:long okres 0)
	 (passdict (get_field :sysdata_pass_dict initial_system_data))
	 (mypass ())
	 )
    (code_chunk gethasmode_chk 
		#{ /* hook_gimple_gate $GETHASMODE_CHK */
		static const char* $GETHASMODE_CHK#modstr ;
		if (!$GETHASMODE_CHK#modstr) 
		$GETHASMODE_CHK#modstr = melt_argument("mode") ;
		$HASMODEFLAG = $GETHASMODE_CHK#modstr != NULL && $GETHASMODE_CHK#modstr[0] ;
		}#)
    (if (not hasmodeflag)
	(return 0))
    (code_chunk 
     getmypass_chk
     #{ /* hook_gimple_gate $GETMYPASS_CHK */		
     gcc_assert(current_pass != NULL) ;
     gcc_assert(current_pass->name != NULL) ;
     gcc_assert(current_pass->type == GIMPLE_PASS) ;
     $MYPASS = melt_get_mapstrings ((struct meltmapstrings_st*) $PASSDICT, 
				    current_pass->name)	;
     }#)
    (if (is_a mypass class_gcc_gimple_pass)
	(let ( (gatefun (get_field :gccpass_gate mypass))
	       (:cstring curpassname (the_null_cstring))
	       )
	  (if (is_closure gatefun)
	      (code_chunk 
	       dogatefun_chk
	       #{ /* hook_gimple_gate $DOGATEFUN_CHK */
	       FILE* oldf = meltgc_set_dump_file (dump_file) ;
	       $CURPASSNAME = current_pass->name ;
	       $(progn
		  (debug "hook_gimple_gate curpassname=" curpassname " mypass=" mypass)
		  (if (gatefun mypass)
		      (setq okres 1))
		  (debug "hook_gimple_gate after call okres=" okres)
		  (void)
		  )
	       meltgc_restore_dump_file (oldf) ;
	       oldf = NULL ;
	       }#)
	    (setq okres 1)		;no closure
	    )))
    (return okres)
    ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; execute hook for gimple passes
(defhook hook_gimple_execute
  () () :long
  :predef HOOK_GIMPLE_EXECUTE
  (let ( (:long hasmodeflag 0)
	 (:long okres 0)
	 (:long passnum 0)
	 (passdict (get_field :sysdata_pass_dict initial_system_data))
	 (mypass ())
	 )
    (code_chunk gethasmode_chk 
		#{ /* hook_gimple_execute $GETHASMODE_CHK */
		static const char* $GETHASMODE_CHK#modstr ;
		if (!$GETHASMODE_CHK#modstr) 
		$GETHASMODE_CHK#modstr = melt_argument("mode") ;
		$HASMODEFLAG = $GETHASMODE_CHK#modstr != NULL && $GETHASMODE_CHK#modstr[0] ;
		}#)
    (if (not hasmodeflag)
	(return 0))
    (code_chunk 
     getmypass_chk
     #{ /* hook_gimple_execute $GETMYPASS_CHK */		
     gcc_assert(current_pass != NULL)		   ;
     gcc_assert(current_pass->name != NULL)	   ;
     gcc_assert(current_pass->type == GIMPLE_PASS) ;
     $MYPASS = melt_get_mapstrings ((struct meltmapstrings_st*) $PASSDICT, 
				    current_pass->name)	;
     $PASSNUM = current_pass->static_pass_number	;
     }#)
    (if (is_a mypass class_gcc_gimple_pass)
	(let ( (execfun (get_field :gccpass_exec mypass))
	       (:cstring curpassname (the_null_cstring))
	       )
	  (when (is_closure execfun)
	    (code_chunk 
	     doexecfun_chk
	     #{ /* hook_gimple_execute $DOEXECFUN_CHK */
	     FILE* oldf = meltgc_set_dump_file (dump_file) ;
	     $CURPASSNAME = current_pass->name		   ;
	     $(progn
		(debug "hook_gimple_execute curpassname=" curpassname " mypass=" mypass
		       " passnum=" passnum)
		(multicall
		 (resexec :long flagexec)
		 (execfun mypass passnum)
		 (debug "hook_gimple_execute after call resexec=" resexec 
			" flagexec=" flagexec)
		 (if (null resexec)
		     (setq okres flagexec)
		   (setq okres 1))
		 )
		(void)
		)
	     meltgc_restore_dump_file (oldf) ;
	     oldf = NULL		     ;
	     }#)
	    (run_endmeltpass_functions)
	    )))
    (return okres)
    ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; gate hook for rtl passes
(defhook hook_rtl_gate
  () () :long
  :predef HOOK_RTL_GATE
  (let ( (:long hasmodeflag 0)
	 (:long okres 0)
	 (passdict (get_field :sysdata_pass_dict initial_system_data))
	 (mypass ())
	 (:long passnum 0)
	 )
    (code_chunk gethasmode_chk 
		#{ /* hook_rtl_gate $GETHASMODE_CHK */
		static const char* $GETHASMODE_CHK#modstr ;
		if (!$GETHASMODE_CHK#modstr) 
		$GETHASMODE_CHK#modstr = melt_argument("mode") ;
		$HASMODEFLAG = $GETHASMODE_CHK#modstr != NULL && $GETHASMODE_CHK#modstr[0] ;
		}#)
    (if (not hasmodeflag)
	(return 0))
    (code_chunk 
     getmypass_chk
     #{ /* hook_rtl_gate $GETMYPASS_CHK */		
     gcc_assert(current_pass != NULL) ;
     gcc_assert(current_pass->name != NULL) ;
     gcc_assert(current_pass->type == RTL_PASS) ;
     $MYPASS = melt_get_mapstrings ((struct meltmapstrings_st*) $PASSDICT, 
				    current_pass->name)	;
     }#)
    (if (is_a mypass class_gcc_rtl_pass)
	(let ( (gatefun (get_field :gccpass_gate mypass))
	       (:cstring curpassname (the_null_cstring))
	       )
	  (if (is_closure gatefun)
	      (code_chunk 
	       dogatefun_chk
	       #{ /* hook_rtl_gate $DOGATEFUN_CHK */
	       FILE* oldf = meltgc_set_dump_file (dump_file) ;
	       $CURPASSNAME = current_pass->name;
	       $PASSNUM = current_pass->static_pass_number;
	       $(progn
		  (debug "hook_rtl_gate curpassname=" curpassname " mypass=" mypass)
		  (if (gatefun mypass passnum)
		      (setq okres 1))
		  (debug "hook_rtl_gate after call okres=" okres)
		  (void)
		  )
	       meltgc_restore_dump_file (oldf) ;
	       oldf = NULL ;
	       }#)
	    (setq okres 1)		;no closure
	    )))
    (return okres)
))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; execute hook for rtl passes
(defhook hook_rtl_execute
  () () :long
  :predef HOOK_RTL_EXECUTE
  (let ( (:long hasmodeflag 0)
	 (:long okres 0)
	 (passdict (get_field :sysdata_pass_dict initial_system_data))
	 (mypass ())
	 (:long passnum 0)
	 )
    (code_chunk gethasmode_chk 
		#{ /* hook_rtl_execute $GETHASMODE_CHK */
		static const char* $GETHASMODE_CHK#modstr ;
		if (!$GETHASMODE_CHK#modstr) 
		$GETHASMODE_CHK#modstr = melt_argument("mode") ;
		$HASMODEFLAG = $GETHASMODE_CHK#modstr != NULL && $GETHASMODE_CHK#modstr[0] ;
		}#)
    (if (not hasmodeflag)
	(return 0))
    (code_chunk 
     getmypass_chk
     #{ /* hook_rtl_execute $GETMYPASS_CHK */		
     gcc_assert(current_pass != NULL) ;
     gcc_assert(current_pass->name != NULL) ;
     gcc_assert(current_pass->type == RTL_PASS) ;
     $MYPASS = melt_get_mapstrings ((struct meltmapstrings_st*) $PASSDICT, 
				    current_pass->name)	;
     }#)
    (if (is_a mypass class_gcc_rtl_pass)
	(let ( (execfun (get_field :gccpass_exec mypass))
	       (:cstring curpassname (the_null_cstring))
	       )
	  (when (is_closure execfun)
	      (code_chunk 
	       doexecfun_chk
	       #{ /* hook_rtl_execute $DOEXECFUN_CHK */
	       $PASSNUM = current_pass->static_pass_number;
	       FILE* oldf = meltgc_set_dump_file (dump_file) ;
	       $CURPASSNAME = current_pass->name ;
	       $(progn
		 (debug "hook_rtl_execute curpassname=" curpassname " mypass=" mypass
			" passnum=" passnum)
		 (multicall
		  (resexec :long flagexec)
		  (execfun mypass passnum)
		  (debug "hook_rtl_execute after call resexec=" resexec 
			 " flagexec=" flagexec)
		  (if (null resexec)
		      (setq okres flagexec)
		    (setq okres 1))
		  )
		 (void)
		 )
	       meltgc_restore_dump_file (oldf) ;
	       oldf = NULL ;
	       }#)
	      (run_endmeltpass_functions)
	    )))
    (return okres)
))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; gate hook for simple_ipa passes
(defhook hook_simple_ipa_gate
  () () :long
  :predef HOOK_SIMPLE_IPA_GATE
  (let ( (:long hasmodeflag 0)
	 (:long okres 0)
	 (passdict (get_field :sysdata_pass_dict initial_system_data))
	 (mypass ())
	 (:long passnum 0)
	 )
    (code_chunk gethasmode_chk 
		#{ /* hook_simple_ipa_gate $GETHASMODE_CHK */
		static const char* $GETHASMODE_CHK#modstr ;
		if (!$GETHASMODE_CHK#modstr) 
		$GETHASMODE_CHK#modstr = melt_argument("mode") ;
		$HASMODEFLAG = $GETHASMODE_CHK#modstr != NULL && $GETHASMODE_CHK#modstr[0] ;
		}#)
    (if (not hasmodeflag)
	(return 0))
    (code_chunk 
     getmypass_chk
     #{ /* hook_simple_ipa_gate $GETMYPASS_CHK */		
     gcc_assert(current_pass != NULL) ;
     gcc_assert(current_pass->name != NULL) ;
     gcc_assert(current_pass->type == SIMPLE_IPA_PASS) ;
     $MYPASS = melt_get_mapstrings ((struct meltmapstrings_st*) $PASSDICT, 
				    current_pass->name)	;
     }#)
    (if (is_a mypass class_gcc_simple_ipa_pass)
	(let ( (gatefun (get_field :gccpass_gate mypass))
	       (:cstring curpassname (the_null_cstring))
	       )
	  (if (is_closure gatefun)
	      (code_chunk 
	       dogatefun_chk
	       #{ /* hook_simple_ipa_gate $DOGATEFUN_CHK */
	       FILE* oldf = meltgc_set_dump_file (dump_file) ;
	       $CURPASSNAME = current_pass->name;
	       $PASSNUM = current_pass->static_pass_number;
	       $(progn
		  (debug "hook_simple_ipa_gate curpassname=" curpassname " mypass=" mypass)
		  (if (gatefun mypass passnum)
		      (setq okres 1))
		  (debug "hook_simple_ipa_gate after call okres=" okres)
		  (void)
		  )
	       meltgc_restore_dump_file (oldf) ;
	       oldf = NULL ;
	       }#)
	    (setq okres 1)		;no closure
	    )))
    (return okres)
))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; execute hook for simple_ipa passes
(defhook hook_simple_ipa_execute
  () () :long
  :predef HOOK_SIMPLE_IPA_EXECUTE
  (let ( (:long hasmodeflag 0)
	 (:long okres 0)
	 (passdict (get_field :sysdata_pass_dict initial_system_data))
	 (mypass ())
	 (:long passnum 0)
	 )
    (code_chunk gethasmode_chk 
		#{ /* hook_simple_ipa_execute $GETHASMODE_CHK */
		static const char* $GETHASMODE_CHK#modstr ;
		if (!$GETHASMODE_CHK#modstr) 
		$GETHASMODE_CHK#modstr = melt_argument("mode") ;
		$HASMODEFLAG = $GETHASMODE_CHK#modstr != NULL && $GETHASMODE_CHK#modstr[0] ;
		}#)
    (if (not hasmodeflag)
	(return 0))
    (code_chunk 
     getmypass_chk
     #{ /* hook_simple_ipa_execute $GETMYPASS_CHK */		
     gcc_assert(current_pass != NULL) ;
     gcc_assert(current_pass->name != NULL) ;
     gcc_assert(current_pass->type == SIMPLE_IPA_PASS) ;
     $MYPASS = melt_get_mapstrings ((struct meltmapstrings_st*) $PASSDICT, 
				    current_pass->name)	;
     }#)
    (if (is_a mypass class_gcc_simple_ipa_pass)
	(let ( (execfun (get_field :gccpass_exec mypass))
	       (:cstring curpassname (the_null_cstring))
	       )
	  (when (is_closure execfun)
	      (code_chunk 
	       doexecfun_chk
	       #{ /* hook_simple_ipa_execute $DOEXECFUN_CHK */
	       $PASSNUM = current_pass->static_pass_number;
	       FILE* oldf = meltgc_set_dump_file (dump_file) ;
	       $CURPASSNAME = current_pass->name ;
	       $(progn
		 (debug "hook_simple_ipa_execute curpassname=" curpassname " mypass=" mypass
			" passnum=" passnum)
		 (multicall
		  (resexec :long flagexec)
		  (execfun mypass passnum)
		  (debug "hook_simple_ipa_execute after call resexec=" resexec 
			 " flagexec=" flagexec)
		  (if (null resexec)
		      (setq okres flagexec)
		    (setq okres 1))
		  )
		 (void)
		 )
	       meltgc_restore_dump_file (oldf) ;
	       oldf = NULL ;
	       }#)
	      (run_endmeltpass_functions)
	    )))
    (return okres)
))




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; attribute definer hook
;; private hook definer queue

(definstance attribute_definer_delayed_queue class_delayed_queue
  :named_name '"attribute_definer_delayed_queue"
  :delqu_first (make_list discr_list)
  :delqu_last (make_list discr_list)
  )

(defhook hook_melt_attribute_definer 
  (:tree decl :tree name :value attrseq
	 :cstring fileloc :long lineno)      
  ()
  :void
  :predef HOOK_MELT_ATTRIBUTE_DEFINER
  (let ( (firstlist (get_field :delqu_first attribute_definer_delayed_queue))
	 (lastlist (get_field :delqu_last attribute_definer_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (rescont (instance class_reference))
	 )
;;; call the first routines in natural order
    (foreach_in_list
     (firstlist)
     (curpair firstproc)
     (if (is_closure firstproc)
	 (firstproc attrseq rescont decl name fileloc lineno))
     )
;;; reverse the last list
    (foreach_in_list
     (lastlist)
     (curpair lastproc)
     (if (is_closure lastproc) (list_prepend revlastlist lastproc))
     )
    (foreach_in_list
     (revlastlist)
     (curpair lastproc)
     (lastproc attrseq rescont decl name fileloc lineno)
     )
    ))

(defun at_melt_attribute_first (fun)
  :doc #{Use $AT_MELT_ATTRIBUTE_FIRST to register a function to be run at MELT
attribute definition, in first place.}#
  (let ( (firstlist (unsafe_get_field :delqu_first attribute_definer_delayed_queue))
	 )
    (if (is_closure fun) (list_append firstlist fun)))
  ) 


(defun at_melt_attribute_last (fun)
  :doc #{Use $AT_MELT_ATTRIBUTE_FIRST to register a function to be run at MELT
attribute definition, in last place.}#
  (let ( (lastlist (unsafe_get_field :delqu_last attribute_definer_delayed_queue))
	 )
    (if (is_closure fun) (list_append lastlist fun)))
  ) 

;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; private final exit queue
(definstance final_exit_delayed_queue class_delayed_queue
  :named_name '"final_exit_delayed_queue"
  :delqu_first (make_list discr_list)
  :delqu_last (make_list discr_list)
  )

;;; exit hook 
(defhook hook_exit_finalizer () () :void
  :predef HOOK_EXIT_FINALIZER
  (let ( (firstlist (get_field :delqu_first final_exit_delayed_queue))
	 (lastlist (get_field :delqu_last final_exit_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (rescont (instance class_reference))
	 )
;;; call the first routines in natural order
    (foreach_in_list
     (firstlist)
     (curpair firstproc)
     (let ( (prevres (unsafe_get_field :referenced_value rescont)) 
	    (nextres (firstproc prevres final_exit_delayed_queue))
	    )
       (unsafe_put_fields rescont :referenced_value nextres)
       ))
;;; reverse the last list
    (foreach_in_list
     (lastlist)
     (curpair lastproc)
     (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
    (foreach_in_list
     (revlastlist)
     (curpair lastproc)
     (let ( (prevres (unsafe_get_field :referenced_value rescont)) 
	    (nextres (lastproc prevres final_exit_delayed_queue))
	    )
       (unsafe_put_fields rescont :referenced_value nextres)
       ))
    ))

(defun at_exit_first (fun)
  :doc #{Use $AT_EXIT_FIRST to register a function to be run at MELT
exit, in first place.}#
  (let ( (firstlist (unsafe_get_field :delqu_first final_exit_delayed_queue))
	 )
    (if (is_closure fun) (list_append firstlist fun)))
  )  

(defun at_exit_last (fun)
  :doc #{Use $AT_EXIT_LAST to register a function to be run at MELT
exit, in last place.}#
  (let ( (lastlist (unsafe_get_field :delqu_last final_exit_delayed_queue))
	 )
    (if (is_closure fun) (list_append lastlist fun)))
  )




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(export_values
 at_end_of_this_melt_pass_first
 at_end_of_this_melt_pass_last
 at_exit_first
 at_exit_last
 at_finish_unit_first
 at_finish_unit_last
 at_melt_attribute_first
 at_melt_attribute_last
 at_start_unit_first
 at_start_unit_last
 hook_low_debug_value_at
 hook_override_gate
 register_all_ipa_passes_end_first
 register_all_ipa_passes_end_last
 register_all_ipa_passes_start_first
 register_all_ipa_passes_start_last
 register_all_passes_end_first
 register_all_passes_end_last
 register_all_passes_start_first
 register_all_passes_start_last
 register_early_gimple_passes_end_first
 register_early_gimple_passes_end_last
 register_early_gimple_passes_start_first
 register_early_gimple_passes_start_last
 register_finish_decl_first
 register_finish_decl_last
 register_finish_type_first
 register_finish_type_last
 register_override_gate_first
 register_override_gate_last
 register_pass_execution_first
 register_pass_execution_last
 register_pre_genericize_first
 register_pre_genericize_last
 unregister_override_gate_first
 unregister_override_gate_last
 )



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(definstance melt_input_channels_buckets_ref class_reference)

(cheader #{
#include <poll.h>

#define MELT_BUFSIZE 8192

}#)

(defhook hook_poll_inputs
  (:long delayms)
  ()
  :long
  :predef HOOK_POLL_INPUTS
  (let ( (bucks !melt_input_channels_buckets_ref)
	 (:long nbbucks (bucketlong_count bucks))
	 (listbadinch (make_list discr_list))
	 (:long pollres 0)
	 )
#|
    (if (<=i nbbucks 0)
	(return 0))
    (code_chunk 
     hookpollinputs_chk
     #{ /* hook_poll_inputs $HOOKPOLLINPUTS_CHK start */
     struct pollfd *fdtab
        = (struct pollfd *) xcalloc ($NBBUCKS+1, sizeof(struct pollfd));
     int nbfd = 0;
     if (!fdtab)
       melt_fatal_error ("hook_poll_inputs cannot allocate %d polling slots - %m",
                      ($NBBUCKS+1));
     $(foreach_in_bucketlong
       (bucks)
       (:long curfd :value valbu)
       (when (and (>=i curfd 0)
		  (is_a valbu class_input_channel_handler))
	 (code_chunk 
	  addfdtab_chk
	  #{ /* hook_poll_inputs $ADDFDTAB_CHK */
	  fdtab[nbfd].fd = (int) $CURFD;
	  fdtab[nbfd].events = POLLIN;
	  fdtab[nbfd].revents = 0;
	  nbfd++;
	  }#)
	 )
       )     
     /* even when nbfd is null, we do call poll to sleep delayms */
     $POLLRES = poll (fdtab, nbfd, $DELAYMS);
     if ($POLLRES > 0) {
       int ixfd = 0;
       for (ixfd = 0; 
	   ixfd < nbfd; 
           ixfd++) {
         int rfd = fdtab[ixfd].fd;
         bool eaten = false;
	 static char rbuf[MELT_BUFSIZE];
         if (!fdtab[ixfd].revents & POLLIN)
	   continue;
	 $(let ( (curihd (bucketlong_get bucks 
					 (expr_chunk rfd_chk :long #{rfd}#)))
		 (:long rdcnt 0)
		 (:long goterr (expr_chunk 
				goterr_chk :long
				#{ (fdtab[ixfd].revents & POLLERR) != 0
				   || (fdtab[ixfd].revents & POLLNVAL) != 0
				}#))
	      )
	    (cond 
	      ( (is_a curihd class_input_channel_handler)
		(let ( (sbuf (get_field :inch_sbuf curihd))
		       (clos (get_field :inch_clos curihd))
		       (seqv ())
		       (:long eaten 0)
		      )
		  (code_chunk 
		    read_chk
		    #{ /* hook_poll_inputs $READ_CHK */
		    memset (&rbuf, 0, sizeof(rbuf));
		    $RDCNT = read (rfd, rbuf, sizeof(rbuf));
		    if ($RDCNT > 0)
		       meltgc_add_out_raw_len ((melt_ptr_t) $SBUF, 
					       rbuf, $RDCNT);
		    }#)
		  (when (or goterr (==i rdcnt 0))
		    ;; got eof or error
		    (debug "hook_poll_inputs got error or eof for curihd=" 
			   curihd)
		    ;; notify end of input with a null argument to the closure
		    (clos curihd ())
		    (list_append listbadinch curihd)
		    )
		  (forever eat_loop
		    (setq eaten 0)
		    (when (>i rdcnt 0)
		       (code_chunk 
		        eat_chk
		        #{ /* hook_poll_inputs $EAT_CHK */
		        const char* bufdata
                           = melt_strbuf_str ((melt_ptr_t) $SBUF);
		        char* buf2nl = bufdata
		          ? CONST_CAST (char*, strstr(bufdata,"\n\n")) 
		          : NULL;
		        if (buf2nl) {
		          int nbread = buf2nl - bufdata + 2;
		          ((char*) buf2nl)[1] = '\0';
		          $SEQV = 
		            meltgc_read_from_rawstring (bufdata, NULL, 
		     			  	     UNKNOWN_LOCATION);
		          melt_strbuf_consume ((melt_ptr_t) $SBUF, nbread);
			  $(ignore (progn 
				     (debug "hook_poll_inputs doing curihd=" curihd
					    " seqv=" seqv)
				     (clos curihd seqv)))
			  $EATEN = true;
			  $RDCNT -= nbread;
		        }
		        }#)
		     )
		     (if (not eaten) (exit eat_loop))
		     ))
		)
	      (:else
	       (code_chunk close_chk 
			   #{ /* hook_poll_inputs $CLOSE_CHK */
			   warning (0, "MELT polling, closing fd#%d without handler", rfd);
			   (void) close(rfd);
			   }#)
	       )
	      )
	    (void)
          )	  
       }
     }
     /* hook_poll_inputs $HOOKPOLLINPUTS_CHK end */
     free (fdtab);
     }#)
    (foreach_in_list
     (listbadinch)
     (curpair curbadinch)
     (bucketlong_replace bucks (get_int curbadinch) :true)
     )
|#
    (return pollres)
 ))

(defhook hook_handle_sigalrm
  () ()
  :void
  :predef HOOK_HANDLE_SIGALRM
  (assert_msg "hook_handle_sigalrm unimplemented")
)


(defhook hook_handle_sigchld
  () ()
  :void
  :predef HOOK_HANDLE_SIGCHLD
  (assert_msg "hook_handle_sigchld unimplemented")
)


;; eof warmelt-hooks.melt
