;; -*- Lisp -*-
;; file xtramelt-ana-tree.melt
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(comment "***
    Copyright 2008 - 2014  Free Software Foundation, Inc.
    Contributed by Basile Starynkevitch <basile@starynkevitch.net>
                and Jeremie Salvucci  <jeremie.salvucci@free.fr>
                and Pierre Vittet  <piervit@pvittet.com>
                and Romain Geissler  <romain.geissler@gmail.com>

    This file xtramelt-ana-tree.{melt,c} is part of GCC.

    GCC is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.

    GCC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.
***")

;; the copyright notice above apply both to xtramelt-ana-tree.melt and 
;; to the generated file  xtramelt-ana-tree*.c

;; This MELT module is GPL compatible since it is GPLv3+ licensed.
(module_is_gpl_compatible "GPLv3+")


(defprimitive walk_use_def_chain_depth_first (:value clos val :tree trvar) :void
  :doc #{Walk in a depth first order the use-def chaine of SSA
variable $TRVAR; apply the $CLOS closure to the $VAL value and to the
current :tree and :gimple. Stop walking if the closure gives null.}#
  #{ /* walk_use_def_chain_depth_first */  meltgc_walk_use_def_chain (((melt_ptr_t)($CLOS)),
     ((melt_ptr_t)($VAL)), $TRVAR, /*depth first*/TRUE); }#
)

(defprimitive walk_use_def_chain_breadth_first (:value clos val :tree trvar) :void
  :doc #{Walk in a breadth first order the use-def chaine of SSA
variable $TRVAR; apply the $CLOS closure to the $VAL value and to the
current :tree and :gimple. Stop walking if the closure gives null.}#
  #{ /* walk_use_def_chain_breadth_first */ meltgc_walk_use_def_chain (((melt_ptr_t)($CLOS)), 
    ((melt_ptr_t)($VAL)), $TRVAR, /*depth first*/FALSE); }#
)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defprimitive is_tree (v) :long
  :doc #{$IS_TREE test if value $V is a boxed tree}#
  #{(melt_magic_discr((melt_ptr_t)($v)) == MELTOBMAG_TREE)}# )

(defprimitive isnull_tree (:tree tr) :long
  :doc #{$ISNULL_TREE test if raw tree $TR is null}#
  #{$tr == NULL_TREE}#
)

(defprimitive make_tree (discr :tree tr) :value
  :doc #{$MAKE_TREE build a boxed tree of given $DISCR and tree $TR}#
  #{(meltgc_new_tree((meltobject_ptr_t)($DISCR),($TR)))}# )

(defprimitive tree_content (v) :tree
  :doc #{$TREE_CONTENT safely retrieve the tree inside boxed value $V}#
  #{(melt_tree_content((melt_ptr_t)($V)))}# )

(defprimitive ==t (:tree t1 t2) :long
  :doc #{==T safely compare tree $T1 and $T2 for identity}#
  #{(($t1) == ($t2))}# )

(defprimitive null_tree () :tree 
  :doc #{$NULL_TREE gives the null tree}#
#{(NULL_TREE)}#)

(defprimitive inform_at_tree (:tree tr :cstring msg) :void
  ;; if DECL_P(tr) use DECL_SOURCE_LOCATION(tr)
  ;; if EXPR_P(tr) use EXPR_LOCATION(tr)
  ;; otherwise no location
  :doc #{$INFORM_AT_TREE give a notice at location of tree $TR with message $MSG}#
  #{ /*inform_at_tree: */ inform ((($tr && DECL_P($tr))? DECL_SOURCE_LOCATION($tr)
	    : ($tr && EXPR_P($tr)) ? EXPR_LOCATION($tr) : UNKNOWN_LOCATION), 
  $msg );
  }# )

(defprimitive warning_at_tree (:tree tr :cstring msg) :void
  ;; if DECL_P(tr) use DECL_SOURCE_LOCATION(tr)
  ;; if EXPR_P(tr) use EXPR_LOCATION(tr)
  ;; otherwise no location
  :doc #{$WARNING_AT_TREE give a warning at location of tree $TR with message $MSG}#
  #{ /*warning_at_tree: */ warning_at((($tr && DECL_P($tr))? DECL_SOURCE_LOCATION($tr)
		 : ($tr && EXPR_P($tr)) ? EXPR_LOCATION($tr) : UNKNOWN_LOCATION), 
		 0, 
		 "MELT WARNING @Tree: %s", 
		 $msg);
  }# )


(defprimitive error_at_tree (:tree tr :cstring msg) :void
  ;; if DECL_P(tr) use DECL_SOURCE_LOCATION(tr)
  ;; if EXPR_P(tr) use EXPR_LOCATION(tr)
  ;; otherwise no location
  :doc #{$ERROR_AT_TREE give a warning at location of tree $TR with message $MSG}#
  #{ /*error_at_tree: */ error_at ((($tr && DECL_P($tr))? DECL_SOURCE_LOCATION($tr)
		 : ($tr && EXPR_P($tr)) ? EXPR_LOCATION($tr) : UNKNOWN_LOCATION), 
				   "MELT ERROR @Tree: %s",
				   $msg);
  }#)

(defprimitive warning_at_tree_decl_with_number
  (:tree trdecl :cstring msg :long num) :void
  :doc #{$WARNING_AT_TREE_DECL_WITH_NUMBER give a warning with declaration of tree $TRDECL message $MSG number $NUM}#
  #{ warning (0, "MELT warning %s at %q+D - #%ld", $MSG, ($TRDECL), ($NUM));
  }# )

(defprimitive tree_type (:tree tr) :tree
  :doc #{$TREE_TYPE gives the type of tree $TR}#
  #{(($TR) ? TREE_TYPE($TR) : (tree) NULL)}#)

(defprimitive tree_type_addr_space (:tree tr) :long
  :doc #{$TREE_TYPE_ADDR_SPACE gives the address space of type tree $TR}#
  #{(($TR && TYPE_P($TR))  ? TYPE_ADDR_SPACE($TR) : 0L)}#)

(defprimitive tree_uid (:tree tr) :long
  :doc #{$TREE_UID gives the uid of tree $TR}#
  #{(($TR) ? (long) DECL_UID($TR) : 0L)}#)

(defprimitive tree_useless_type_conversion_p (:tree tr1 tr2) :long
  :doc #{$TREE_USELESS_TYPE_CONVERSION_P checks that $TR1 and $TR2 are non-null and are type convertible using the @code{useless_type_conversion_p} function of GCC.}#
  #{/*tree_useless_type_conversion_p*/ ($TR1) && ($TR2)
  && useless_type_conversion_p(($TR1),($TR2))}#)

(defprimitive tree_types_compatible_p (:tree tr1 tr2) :long
  :doc #{$TREE_TYPES_COMPATIBLE_P checks that $TR1 and $TR2 are non-null and are type convertible using the @code{types_compatible_p} function of GCC.}#
  #{/*tree_types_compatible_p*/ ($TR1) && ($TR2)
  && types_compatible_p(($TR1),($TR2))}#)

(defprimitive tree_chain_prepend (:tree purpose value chain) :tree
	:doc #{Create a new TREE_LIST node with $PURPOSE and $VALUE trees
	and chain it at the begining of $CHAIN. Returns the newly created
	chain.}#
	#{ /* tree_chain_prepend */
		tree_cons ($PURPOSE, $VALUE, $CHAIN)
	}#)

(defprimitive tree_chain_append (:tree purpose value chain) :tree
	:doc #{Create a new TREE_LIST node with $PURPOSE and $VALUE trees
	and chain it at the end of $CHAIN. Returns the newly created
	chain (different from $CHAIN if $CHAIN is NULL_TREE).}#
	#{ /* tree_chain_append */
		chainon ($CHAIN, tree_cons ($PURPOSE, $VALUE, NULL_TREE))
	}#)

(defprimitive tree_chain_join (:tree chain1 chain2) :tree
	:doc #{Append $CHAIN2 to $CHAIN1 and returns the newly created
	chain (different from $CHAIN1 if $CHAIN1 is NULL_TREE).}#
	#{ /* tree_chain_join */
		chainon ($CHAIN1, $CHAIN2)
	}#)

(defprimitive build_identifier_tree (name) :tree
	:doc #{Create and returns a new IDENTIFIER_NODE tree whose
	name is $NAME.}#
	#{ /* build_identifier_tree */
		get_identifier (melt_string_str ((melt_ptr_t) $NAME))
	}#)

(defprimitive build_string_tree (string_value) :tree
	:doc #{Create and returns a new STRING_CST tree whose
	value is $STRING_VALUE.}#
	#{ /* build_string_tree */
		build_string (strlen (melt_string_str ((melt_ptr_t) $STRING_VALUE)),
				     melt_string_str ((melt_ptr_t) $STRING_VALUE))
	}#)


(defprimitive build_int_tree (int_value) :tree
	:doc #{Create and returns a new INTEGER_CST tree whose
	value is $INT_VALUE and type is the default language
	integer type.}#
	#{
		build_int_cst (integer_type_node, (int)melt_get_int ($INT_VALUE))
	}#
)


;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;; pattern (tree_function_decl_named <funame> <initialtree>) match a tree for a function
;; declaration
(defcmatcher tree_function_decl_named 
  (:tree tr) 				;matched
  ;; output 
  (:cstring funame
   :tree trresult
   )
  treefunam				;state symbol
  :doc #{$TREE_FUNCTION_DECL_NAMED match a function declaration extracting its name $FUNAME and result tree decl $TRRESULT}#
  ;; test expansion
  #{ /*  tree_function_decl_named $TREEFUNAM ? */ (($TR) && TREE_CODE($TR) == FUNCTION_DECL) }#
  ;; fill expansion
  #{/*  tree_function_decl_named $TREEFUNAM ! */ 
   $FUNAME = NULL; 
   $TRRESULT = NULL; 
   if (DECL_NAME($tr))
     $FUNAME = IDENTIFIER_POINTER(DECL_NAME($TR)); 
   $TRRESULT = DECL_RESULT($TR); 
  }#
)

;; match a function decl of a given name
(defcmatcher tree_function_decl_of_name 
  (:tree tr :cstring fname) 				;matched
  ;; output 
  (:tree tfunname
   :tree ttrresult
   )
  treefunofnam				;state symbol
  :doc #{$TREE_FUNCTION_DECL_OF_NAME match a function declaration tree $TR for function named $FNAME extracting the tree name $TFUNAME and result tree $TTRRESULT}#
  ;; test expansion
  #{ /* tree_function_decl_of_name $TREEFUNOFNAM ?*/ (($TR) && TREE_CODE($TR) == FUNCTION_DECL && DECL_NAME($TR) 
     && !strcmp($fname, IDENTIFIER_POINTER(DECL_NAME($TR)))) }#
  ;; fill expansion
  #{ /* tree_function_decl_of_name  $TREEFUNOFNAM ! */
   $TFUNNAME = DECL_NAME($TR);
   $TTRRESULT = DECL_RESULT($TR); 
  }#
)


(defcmatcher tree_function_decl 
  (:tree tr) 				;matched
  ;; output 
  (:tree tfuname
   :tree tresult
   )
  treefun				;state symbol
  :doc #{$TREE_FUNCTION_DECL match a function declaration tree, extracting the tree name $TFUNAME and the tree result $TRESULT.}#
  ;; test expansion
  #{ /* tree_function_decl $TREEFUN ?*/ (($TR) && TREE_CODE($TR) == FUNCTION_DECL) }#
  ;; fill expansion
  #{ /* tree_function_decl  $TREEFUN ! */
   $TFUNAME = DECL_NAME($TR);
   $TRESULT = DECL_RESULT($TR); 
  }#
)

;; pattern (tree_function_type <return type>) match a tree function type.
(defcmatcher tree_function_type
  (:tree tr)
  (:tree trtyp)
  tfunt
  :doc #{$TREE_FUNCTION_TYPE match a function type tree $TR extracting the result type tree $TRTYP}#
  ;; test expansion
  #{ /* tree_function_type $tfunt ? */ (($TR) && TREE_CODE($TR) == FUNCTION_TYPE) }#
  ;; fill expansion
  #{ /* tree_function_type $tfunt ! */
      $TRTYP = TREE_TYPE($TR);
  }#)

;; pattern (tree_method_type <return type>) match a tree method type.
(defcmatcher tree_method_type
  (:tree tr)
  (:tree trtyp)
  tmethoty
  :doc #{$TREE_FUNCTION_TYPE match a method type tree $TR extracting the result type tree $TRTYP}#
  ;; test expansion
  #{ /*  tree_method_type $TMETHOTY ? */ (($tr) && TREE_CODE($tr) == METHOD_TYPE) }#
  ;; fill expansion
  #{ /*  tree_method_type $TMETHOTY ! */
      $TRTYP = TREE_TYPE($tr);
  }#)

;;;;;;;;;;;;;;;;
(defcmatcher tree_of_type 
  (:tree tr)
  (:tree trtyp)
  treeoftype
  :doc #{$TREE_FUNCTION_TYPE match any non-null tree $TR extracting the type tree $TRTYP}#
  ;; test expansion
  #{ /* tree_of_type $treeoftype ?*/ ($TR) != NULL }#
  ;; fill expansion
  #{ /* tree_of_type $treeoftype !*/ $TRTYP = TREE_TYPE($tr); }#
)


;;;;;;;;;;;;;;;;
;; pattern for variables (tree_var_decl <type> <name> <uid>)
(defcmatcher tree_var_decl_named 
  (:tree tr)
  (:tree type :cstring varname :long uid)
  treevardnam				;statesym
  :doc #{$TREE_VAR_DECL_NAMED match a variable declartion tree $TR extracting its type tree $TYPE, its $VARNAME and its $UID}#
  ;; test expansion
  #{/* tree_var_decl_named $TREEVARDNAM ?*/ (($TR) && TREE_CODE($TR) == VAR_DECL) }#
  ;; fill expansion
  #{/* tree_var_decl_named $TREEVARDNAM !*/
   $VARNAME =NULL;
   $TYPE = TREE_TYPE($TR);
   $UID = DECL_UID($TR);
   if (DECL_NAME($TR))
     $VARNAME = IDENTIFIER_POINTER(DECL_NAME($TR));
   }# )

;; pattern for variables (tree_var_decl <type> <name> <uid>)
(defcmatcher tree_var_decl 
  (:tree tr)
  (:tree ttype tname :long uid)
  treevard				;statesym
  :doc #{$TREE_VAR_DECL match a variable declaration tree $TR extracting its type tree $TTYPE, its name tree $TNAME and its $UID}#
  ;; test expansion
  #{/* tree_var_decl $TREEVARD ?*/ (($TR) && TREE_CODE($TR) == VAR_DECL) }#
  ;; fill expansion
  #{/* tree_var_decl $TREEVARD !*/
   $TTYPE = TREE_TYPE($TR);
   $UID = DECL_UID($TR);
   $TNAME = DECL_NAME($TR);
   }# )

;;;;;;;;
;; pattern for a var_decl of given name
	   
(defcmatcher tree_var_decl_of_name 
  (:tree tr :cstring varname)
  (:tree ttype)
  treevarn				;statesym
  :doc #{$TREE_VAR_DECL match a variable declaration tree $TR of name $VARNAME extracting its type tree $TTYPE}#
  ;; test expansion
  #{ /* tree_var_decl_of_name $TREEVARN ?*/ (($TR) && TREE_CODE($TR) == VAR_DECL && DECL_NAME($TR) 
      && !strcmp($varname, IDENTIFIER_POINTER(DECL_NAME($TR)))) }#
  ;; fill expansion
  #{ /* tree_var_decl_of_name $TREEVARN !*/ 
   $TTYPE = TREE_TYPE($TR);
  }# )

;;;;;;;;;;;;;;;;
;; pattern for constants (tree_const_decl <type> <name> <uid>)
(defcmatcher tree_const_decl 
  (:tree tr)
  (:tree ttype :cstring constname :long uid)
  treeconstd				;statesym
  :doc #{$TREE_CONST_DECL match a const declaration tree $TR extracting its type tree $TTYPE, its name $CONSTNAME, its $UID}#
  ;; test expansion
  #{/* tree_const_decl $TREECONSTD ?*/ (($TR) && TREE_CODE($TR) == CONST_DECL) }#
  ;; fill expansion
  #{/* tree_const_decl $TREECONSTD !*/
   $CONSTNAME =NULL;
   $TTYPE = TREE_TYPE($TR);
   $UID = DECL_UID($TR);
   if (DECL_NAME($TR))
     $CONSTNAME = IDENTIFIER_POINTER(DECL_NAME($TR));
   }# )

;;;;;;;;
;; pattern for a const_decl of given name
	   
(defcmatcher tree_const_decl_of_name 
  (:tree tr :cstring constname)
  (:tree ttype)
  treeconstn				;statesym
  :doc #{$TREE_CONST_DECL_OF_NAME match a const declaration tree $TR of name $CONSTNAME extracting its type tree $TTYPE}#
  ;; test expansion
  #{ /* tree_const_decl_of_name $TREECONSTN ?*/ (($TR) && TREE_CODE($TR) == CONST_DECL && DECL_NAME($TR) 
      && !strcmp($constname, IDENTIFIER_POINTER(DECL_NAME($TR)))) }#
  ;; fill expansion
  #{ /* tree_const_decl_of_name $TREECONSTN !*/
   $TTYPE = TREE_TYPE($TR); }# )

;; pattern for constant declaration  (tree_const_decl_named <type> <name> <uid>)
(defcmatcher tree_const_decl_named 
  (:tree tr)
  (:tree ttype :cstring constname :long uid)
  treeconstnam				;statesym
  :doc #{$TREE_CONST_DECL_NAMED match a const declaration tree $TR extracting its type $TTYPE, its name $CONSTNAME its $UID}#
  ;; test expansion
  #{/* tree_const_decl_named $TREECONSTNAM ?*/ (($TR) && TREE_CODE($TR) == CONST_DECL) }#
  ;; fill expansion
  #{/* tree_const_decl_named $TREECONSTNAM !*/
   $CONSTNAME = NULL;
   $TTYPE = TREE_TYPE($TR);
   $UID = DECL_UID($TR);
   if (DECL_NAME($TR))
     $CONSTNAME = IDENTIFIER_POINTER(DECL_NAME($TR));
   }# )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; pattern for label
(defcmatcher tree_label_decl 
  (:tree tr)
  (:tree trlabel
   :long uidlabel)
  treelabel
  :doc #{$TREE_LABEL_DECL match a label declaration tree 
  $TR extracting its label tree $TRLABEL and uid $UIDLABEL}#
  ;;; test expansion
  #{ /* tree_label_decl $TREELABEL ?*/ (($TR) && 
					TREE_CODE($TR) == LABEL_DECL) }#
  ;;; test fill
  #{ /* tree_label_decl $TREELABEL !*/ 
     $TRLABEL = LABEL_EXPR_LABEL ($TR);
     $UIDLABEL = LABEL_DECL_UID ($TR);
  }#
)

(defprimitive tree_create_artificial_label ()
  :tree
  :doc #{Create an artifical label tree, without source location.}#
  #{ /* tree_create_artificial_label */ create_artificial_label (UNKNOWN_LOCATION) }#)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; pattern for parameters (tree_parm_decl <type> <name> <uid>)
(defcmatcher tree_parm_decl_named 
  (:tree tr)
  (:tree type :cstring parmname :long uid)
  treeparmdcnam				;statesym
  :doc #{$TREE_PARM_DECL_NAMED match a parm declaration tree $TR extracting its type $TTYPE, its name $PARMNAME its $UID}#
  ;; test expansion
  #{/* tree_parm_decl_named $TREEPARMDCNAM ?*/ (($TR) && TREE_CODE($TR) == PARM_DECL) }#
  ;; fill expansion
  #{/* tree_parm_decl_named $TREEPARMDCNAM !*/
   $PARMNAME =NULL;
   $TYPE = DECL_ARG_TYPE($TR);
   $UID = DECL_UID($TR);
   if (DECL_NAME($TR))
     $PARMNAME = IDENTIFIER_POINTER(DECL_NAME($TR));
   }# )

;; pattern for a parm_decl of given name
(defcmatcher tree_parm_decl_of_name 
  (:tree tr :cstring parmname)
  (:tree type)
  treeparmofnam				;statesym
  :doc #{$TREE_PARM_DECL_OF_NAME match a parm declaration tree $TR named $PARMNAME extracting its $TYPE}#
  ;; test expansion
  #{ /* tree_parm_decl_of_name $TREEPARMOFNAM ?*/ (($TR) && TREE_CODE($TR) == PARM_DECL && DECL_NAME($TR) 
      && !strcmp($PARMNAME, IDENTIFIER_POINTER(DECL_NAME($TR)))) }#
  ;; fill expansion
  #{ /* tree_parm_decl_of_name $TREEPARMOFNAM !*/ 
   $TYPE = DECL_ARG_TYPE($TR); }# )


;; pattern for a parm_decl
(defcmatcher tree_parm_decl
  (:tree tr)
  (:tree trargtype trdeclnam)
  treeparmde				;statesym
  :doc #{$TREE_PARM_DECL_OF_NAME match a parm declaration tree $TR extracting its $TRARGTYPE and decl name tree $TRDECLNAME}#
  ;; test expansion
  #{ /* tree_parm_decl $TREEPARMDE ?*/ (($TR) && TREE_CODE($TR) == PARM_DECL) }#
  ;; fill expansion
  #{ /* tree_parm_decl $TREEPARMDE !*/ 
   $TRARGTYPE = DECL_ARG_TYPE($TR);
   $TRDECLNAM = DECL_NAME($TR); }# )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; pattern for results (tree_result_decl <type> <name> <uid>)
(defcmatcher tree_result_decl_named
  (:tree tr)
  (:tree type :cstring name :long uid)
  treeparmd				;statesym
  :doc #{$TREE_RESULT_DECL_NAMED match a result declaration tree $TR extracting its $TYPE, $NAME, $UID}#
  ;; test expansion
  #{/* tree_result_decl_named $TREEPARMD ?*/ (($TR) && TREE_CODE($TR) == RESULT_DECL) }#
  ;; fill expansion
  #{/* tree_result_decl_named $TREEPARMD !*/
   $NAME =NULL;
   $TYPE = TREE_TYPE($TR);
   $UID = DECL_UID($TR);
   if (DECL_NAME($TR))
     $NAME = IDENTIFIER_POINTER(DECL_NAME($TR));
   }# )


(defcmatcher tree_result_decl
  (:tree tr)
  (:tree tnam ttyp)
  treeresd				;statesym
  :doc #{$TREE_RESULT_DECL match a result declaration $TR extracting its tree $TNAM and $TTYP}#
  ;; test expansion
  #{ /* tree_result_decl $TREERESD ?*/ (($TR) && TREE_CODE($TR) == RESULT_DECL) }#
  ;; fill expansion
  #{ /* tree_result_decl $TREERESD !*/ 
   $TNAM = DECL_NAME($TR);
   $TTYP = TREE_TYPE($TR); 
  }# )

;; pattern for a parm_decl of given name
(defcmatcher tree_result_decl_of_name 
  (:tree tr :cstring name)
  (:tree ttyp)
  treeparmn				;statesym
  :doc #{$TREE_RESULT_DECL_OF_NAME match a result declaration $TR named $NAME extracting its $TTYP}#
  ;; test expansion
  #{ /* tree_result_decl_of_name $TREEPARMN ?*/ (($TR) && TREE_CODE($TR) == RESULT_DECL && DECL_NAME($TR) 
      && !strcmp($NAME, IDENTIFIER_POINTER(DECL_NAME($TR)))) }#
  ;; fill expansion
  #{ /* tree_result_decl_of_name $TREEPARMN !*/ 
   $TTYP = TREE_TYPE($TR); }# )



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; pattern for defined types (tree_type_decl <type> <name> <uid>)
(defcmatcher tree_type_decl 
  (:tree tr)
  (:tree type :cstring name :long uid)
  treeparmd				;statesym
  :doc #{$TREE_TYPE_DECL match a tree type decl $TR extracting its $TYPE, $NAME, $UID}#
  ;; test expansion
  #{/* tree_type_decl $TREEPARMD ?*/ (($TR) && TREE_CODE($TR) == TYPE_DECL) }#
  ;; fill expansion
  #{/* tree_type_decl $TREEPARMD !*/
   $NAME =NULL;
   $TYPE = TREE_TYPE($TR);
   $UID = DECL_UID($TR);
   if (DECL_NAME($TR))
     $NAME = IDENTIFIER_POINTER(DECL_NAME($TR));
   }# )

;; pattern for a typr_decl of given name
(defcmatcher tree_type_decl_named 
  (:tree tr :cstring name)
  (:tree type)
  treetypn				;statesym
  :doc #{$TREE_TYPE_DECL match a tree type decl $TR for a type named $NAME extracting its $TYPE}#
  ;; test expansion
  #{ /* tree_type_decl_named $TREETYPN ?*/ (($TR) && TREE_CODE($TR) == TYPE_DECL && DECL_NAME($TR) 
      && !strcmp($NAME, IDENTIFIER_POINTER(DECL_NAME($TR)))) }#
  ;; fill expansion
  #{ /* tree_type_decl_named $TREETYPN !*/ 
   $TYPE = TREE_TYPE($TR);
  }# )



;;;;;;;;;;;;;;;;
;; pattern tree_array_ref matches an array reference with array and index
(defcmatcher tree_array_ref
  (:tree tr)				;input
  (:tree trarr trindex)
  treearrayref			 ;statesym
  :doc #{$TREE_ARRAY_REF match a tree array reference extracting array $TRARR and index $TRINDEX}#
  ;; test
  #{ /* tree_array_ref $TREEARRAYREF ?*/ (($TR) && TREE_CODE($TR) == ARRAY_REF) }#
  ;; fill
  #{ /* tree_array_ref $TREEARRAYREF !*/ 
    $TRARR = TREE_OPERAND ($TR, 0);
    $TRINDEX = TREE_OPERAND ($TR, 1);
  }#)

;; pattern tree_array_ref_full
(defcmatcher  tree_array_ref_full
  (:tree tr)				;input
  (:tree trarr trindex trmin trsize)
  treearrayreffull			 ;statesym
  :doc #{$TREE_ARRAY_REF_FULL match a tree array reference extracting array $TRARR and index $TRINDEX minimum $TRMIN and size $TRSIZE}#
  ;; test
  #{ /* tree_array_ref_full $TREEARRAYREFFULL ?*/ (($TR) && TREE_CODE($TR) == ARRAY_REF) }#
  ;; fill
  #{ /* tree_array_ref_full $TREEARRAYREFFULL !*/ 
    int $TREEARRAYREFFULL#_len = TREE_OPERAND_LENGTH($TR);
    $TRARR = TREE_OPERAND ($TR, 0);
    $TRINDEX = TREE_OPERAND ($TR, 1);
    $TRMIN = ($TREEARRAYREFFULL#_len >= 3) ? TREE_OPERAND ($TR, 2) : (NULL_TREE);
    $TRSIZE = ($TREEARRAYREFFULL#_len >= 4) ? TREE_OPERAND ($TR, 3) : (NULL_TREE);
  }#)

;;;;;;;;;;;;;;;;
;; pattern tree_component_ref matches an component reference with component and index
(defcmatcher tree_component_ref
  (:tree tr)				;input
  ;; traggr is the aggregate (ie a struct or union)
  (:tree traggr trfield)		;output
  treecomponentref			 ;statesym
  :doc #{$TREE_COMPONENT_REF match a component reference tree $TR extracting aggregate $TRAGGR and field $TRFIELD}#
  ;; test
  #{ /* tree_component_ref $TREECOMPONENTREF ?*/ (($TR) && TREE_CODE($TR) == COMPONENT_REF) }#
  ;; fill
  #{ /* tree_component_ref $TREECOMPONENTREF !*/ 
    $TRAGGR = TREE_OPERAND ($TR, 0);
    $TRFIELD = TREE_OPERAND ($TR, 1);
  }#)

(defcmatcher tree_component_ref_full
  (:tree tr)				;input
  ;; traggr is the aggregate (ie a struct or union)
  (:tree traggr trfield troff)
  treecomponentreffull			 ;statesym
  :doc #{$TREE_COMPONENT_REF_FULL match a component reference tree $TR extracting aggregate $TRAGGR and field $TRFIELD and offset $TROFF}#
  ;; test
  #{ /* tree_component_ref_full $TREECOMPONENTREFFULL ?*/ (($TR) && TREE_CODE($TR) == COMPONENT_REF) }#
  ;; fill
  #{ /* tree_component_ref_full $TREECOMPONENTREFFULL !*/ 
    int $TREECOMPONENTREFFULL#_len = TREE_OPERAND_LENGTH($TR);
    $TRAGGR = TREE_OPERAND ($TR, 0);
    $TRFIELD = TREE_OPERAND ($TR, 1);
    $TROFF = ($TREECOMPONENTREFFULL#_len > 2) ? TREE_OPERAND ($TR, 2) : NULL_TREE;
  }#)

(defcmatcher tree_component_ref_typed
  (:tree tr)
  (:tree type
   :tree traggr
   :tree trfield)
  treecr
  :doc #{$TREE_COMPONENT_REF_TYPED match a component reference tree $TR extracting the $TYPE, aggregate $TRAGGR, field $TRFIELD }#

  #{ /*  tree_component_ref_typed $TREECR ? */
       (($tr) && TREE_CODE ($tr) == COMPONENT_REF)
  }#

  #{/*  tree_component_ref_typed $TREECR ! */
       $TYPE = TREE_TYPE ($tr);
       $TRAGGR = TREE_OPERAND ($tr, 0);
       $TRFIELD = TREE_OPERAND ($tr, 1);
  }#)

;; pattern tree_mem_ref matches a memory reference with pointer and offset
(defcmatcher tree_mem_ref
  (:tree tr)				;input
  (:tree trptr troff)
  treememref			 ;statesym
  :doc #{$TREE_MEM_REF match a memory reference tree extracing pointer $TRPTR and offset $TROFF}#
  ;; test
  #{ /* tree_mem_ref $TREEMEMREF ?*/ (($TR) && TREE_CODE($TR) == MEM_REF) }#
  ;; fill
  #{ /* tree_mem_ref $TREEMEMREF !*/ 
    $TRPTR = TREE_OPERAND ($TR, 0);
    $TROFF = TREE_OPERAND ($TR, 1);
  }#)

;;;;;;;;;;;;;;;;
;; pattern tree_block matches a block
(defcmatcher tree_block 
  (:tree tr)
  (					;output
   :tree trvars  trsubblocks 	 
   )
  treeblock				;statesym
  :doc #{$TREE_BLOCK match a tree block extracting tree variables $TRVARS and subblocks $TRSUBBLOCKS}#
  ;; test expander
   #{/*tree_block $TREEBLOCK ?*/ (($TR) && TREE_CODE($TR) == BLOCK)}#
  ;; fill expander
   #{ /*tree_block $TREEBLOCK !*/
   $TRVARS = BLOCK_VARS($TR);
   $TRSUBBLOCKS = BLOCK_SUBBLOCKS($TR);
   }# )

;;;;;;;;;;;;;;;;
;; pattern tree_offset_type is for pointers relative to object
(defcmatcher tree_offset_type
 (:tree tr)
 (:tree trtype trbasetype)
 treeoffsettype				;statesym
  :doc #{$TREE_OFFSET_TYPE match offset type tree $TR extracting type $TRTYPE and basetype $TRBASETYPE}#
 ;; expander
 #{/*tree_offset_type $TREEOFFSETTYPE ?*/ (($TR) && TREE_CODE($TR) == OFFSET_TYPE) }#
 ;; filler
 #{/*tree_offset_type $TREEOFFSETTYPE !*/ $TRTYPE = TREE_TYPE($TR);
   $TRBASETYPE = TYPE_OFFSET_BASETYPE ($TR);
 }#)


;;;;;;;;
;;; pattern tree_identifier matches any identifier node
(defcmatcher tree_identifier
  (:tree tr)
  (:cstring name)
  treeident			;statesym
  :doc #{$TREE_IDENTIFIER match an identifier tree $TR extracting its $NAME}#
  #{ /*tree_identifier  $TREEIDENT ?*/ $TR 
         && TREE_CODE ($TR) == IDENTIFIER_NODE }#
  #{ /*tree_identifier $TREEIDENT !*/ $NAME = (const char*) IDENTIFIER_POINTER ($TR); 
}#
)

;;; pattern tree_list matches any tree list node
(defcmatcher tree_list
  (:tree tr)
  (:tree trvalue trpurpose trchain)
  treelist
  :doc #{$TREE_LIST match a tree list node extracting $TRVALUE $TRPURPOSE $TRCHAIN}#
  #{ /* tree_list $TREELIST ?*/ $TR && TREE_CODE ($TR) == TREE_LIST }#
  #{ /* tree_list $TREELIST !*/ 
    $TRVALUE = TREE_VALUE ($TR);
    $TRPURPOSE = TREE_PURPOSE ($TR);
    $TRCHAIN = TREE_CHAIN ($TR);
  }#
)

;;; pattern tree_vec matches any tree vector node
(defcmatcher tree_vec
  (:tree tr)
  (:long len :tree trchain)
  treevec
  :doc #{$TREE_VEC match a tree vector node extracting $LEN and $TRCHAIN}#
  #{ /* tree_vec $TREEVEC ?*/ $TR && TREE_CODE ($TR) == TREE_VEC }#
  #{ /* tree_vec $TREEVEC !*/ 
  $LEN = TREE_VEC_LENGTH ($TR);
  $TRCHAIN = TREE_CHAIN ($TR);
  }#
)

;;;;;;;;;;;;;;;;
;;; pattern tree_decl matches any declaration
(defcmatcher tree_decl 
  (:tree tr)
  (					;output
   :tree trname
   :cstring name
   :long uid
   )
  treedecl				;statesym
  :doc #{$TREE_DECL match any declaration extracting $TRANME $NAME $UID}#
  ;; test expander
  #{/* tree_decl $TREEDECL ? */ (($tr) && DECL_P($tr))}#
  ;; fill expander
  #{/* tree_decl $TREEDECL ! */ 
   tree  $treedecl#_name = DECL_NAME($tr);
   $TRNAME = $treedecl#_name;
   $NAME = ($treedecl#_name) ? IDENTIFIER_POINTER($treedecl#_name) : NULL;
   $UID = DECL_UID($tr);
   }# )

;; pattern tree_decl_at_source_location matches a declaration tree with a
;; known location
(defcmatcher tree_decl_at_source_location 
  (:tree tr)
  (:value filepathv
   :long line
   :long col)
  treedeclatloc				;statesym
  :doc #{$TREE_DECL_AT_SOURCE_LOCATION match any declaration with some
  known source location, extracting the cached $FILEPATHV string value and the
  $LINE and $COL info.}#
   ;; test expander
  #{/* tree_decl_at_source_location $TREEDECLATLOC ? */ (($TR)
      && DECL_P($TR) && DECL_SOURCE_LOCATION($TR) != UNKNOWN_LOCATION)}#
   ;; test filler
  #{/* tree_decl_at_source_location $TREEDECLATLOC ! */ {
     source_location $TREEDECLATLOC#_sloc = DECL_SOURCE_LOCATION($tr);
     $FILEPATHV =
         meltgc_cached_string_path_of_source_location ($TREEDECLATLOC#_sloc);
     $LINE = LOCATION_LINE ($TREEDECLATLOC#_sloc);
     $COL = LOCATION_COLUMN ($TREEDECLATLOC#_sloc);
   } /* end tree_decl_at_source_location $TREEDECLATLOC */ }#)


;; pattern tree_decl_at_source_location matches a declaration tree with a
;; known location
(defcmatcher tree_expr_at_source_location 
  (:tree tr)
  (:value filepathv
   :long line
   :long col)
  treeexpratloc				;statesym
  :doc #{$TREE_EXPR_AT_SOURCE_LOCATION match any expression with some
  known source location, extracting the cached $FILEPATHV string value and the
  $LINE and $COL info.}#
   ;; test expander
  #{/* tree_expr_at_source_location $TREEEXPRATLOC ? */ (($TR)
      && EXPR_P($TR) && EXPR_LOCATION($TR) != UNKNOWN_LOCATION)}#
   ;; test filler
  #{/* tree_expr_at_source_location $TREEEXPRATLOC ! */ {
     source_location $TREEEXPRATLOC#_sloc = EXPR_LOCATION($tr);
     $FILEPATHV =
         meltgc_cached_string_path_of_source_location ($TREEEXPRATLOC#_sloc);
     $LINE = LOCATION_LINE ($TREEEXPRATLOC#_sloc);
     $COL = LOCATION_COLUMN ($TREEEXPRATLOC#_sloc);
   } /* end tree_expr_at_source_location $TREEEXPRATLOC */ }#)



;; pattern tree_void_type
(defcmatcher tree_void_type
  (:tree tr)
  (:tree type)
  treevt
  :doc #{$TREE_VOID_TYPE match a void type $TR extracting its type $TYPE}#

  #{ /* tree_void_type $TREEVT ? */
       (($tr) && TREE_CODE ($tr) == VOID_TYPE)
  }#

  #{/* tree_void_type $TREEVT ! */
       $type = TYPE_NAME ($tr);
  }#)

;;;;;;;;;;;;;;;;
;;; pattern tree_integer_type
(defcmatcher tree_integer_type 
  (:tree tr)
  (					;output
   :tree type
   :value minbig maxbig 
   :tree size
   )
  treeinty				;statesym
  :doc #{$TREE_INTEGER_TYPE match an integer type tree $TR extracting its $TYPE and big minimal $MINBIG and maximal $MAXBIG values and tree size $SIZE}#
  ;; test expander
   #{ /* tree_integer_type $treeinty ?*/ (($tr) && TREE_CODE($tr) == INTEGER_TYPE) }#
  ;; fill expander
   #{ /* tree_integer_type $treeinty !*/
      mpz_t $treeinty#_minz;
      mpz_t $treeinty#_maxz;

      $type = TYPE_NAME($tr);
      $size = TYPE_SIZE($tr);

      mpz_init ($treeinty#_minz);
      mpz_init ($treeinty#_maxz);
      get_type_static_bounds($tr, $treeinty#_minz, $treeinty#_maxz);
      $minbig = meltgc_new_mixbigint_mpz((meltobject_ptr_t) MELT_PREDEF (DISCR_MIXED_BIGINT), 
					 NULL, 
					 $treeinty#_minz);
      $maxbig =  meltgc_new_mixbigint_mpz((meltobject_ptr_t) MELT_PREDEF (DISCR_MIXED_BIGINT), 
					 NULL, 
					 $treeinty#_maxz);
      mpz_clear ($treeinty#_minz);
      mpz_clear ($treeinty#_maxz);
    }#)

;;;;;;;;;;;;;;;;
(defcmatcher tree_enumeral_type
  (:tree tr)
  (:tree ttype
   :tree tmin tmax
   :tree tsize
   :tree tvalues)
  treeenumtype
  :doc #{$TREE_ENUMERAL_TYPE match a tree $TR enumeral extracting $TTYPE $TMIN $TMAX $TSIZE $TVALUES}#
  ;; test
  #{/* tree_enumeral_type $TREEENUMTYPE ?*/ (($TR) && TREE_CODE($TR) == ENUMERAL_TYPE) }#
  ;; fill
  #{/* tree_enumeral_type $TREEENUMTYPE !*/
      $TTYPE = TYPE_NAME($TR);
      $TSIZE = TYPE_SIZE($TR);
      $TMIN = TYPE_MIN_VALUE ($TR);
      $TMAX = TYPE_MAX_VALUE ($TR);
      $TVALUES = TYPE_VALUES ($TR); }#
)

;;;;;;;;;;;;;;;;;
(defcmatcher tree_boolean_type
  (:tree tr)
  (:tree ttype
   :tree tmin tmax
   :tree tsize
  )
  treebooltype
  :doc #{$TREE_BOOLEAN_TYPE match a boolean type tree $TR extracting $TTYPE $TMIN $TMAX $TSIZE}#
  ;; test
  #{/* tree_boolean_type $TREEBOOLTYPE ?*/ (($TR) && TREE_CODE($TR) == BOOLEAN_TYPE) }#
  ;; fill
  #{/* tree_boolean_type $TREEBOOLTYPE !*/
      $TTYPE = TYPE_NAME($TR);
      $TSIZE = TYPE_SIZE($TR);
      $TMIN = TYPE_MIN_VALUE ($TR);
      $TMAX = TYPE_MAX_VALUE ($TR);}#
)


;;;;;;;;;;;;;;;;
;;; pattern tree_integer_type_bounded, the bounds are trees
(defcmatcher tree_integer_type_bounded
  (:tree tr)
  (					;output
   :tree ttype
   :tree tmin tmax
   :tree tsize
   )
  treeintybnd				;statesym
  :doc #{$TREE_INTEGER_TYPE_BOUNDED match an integer type tree $TR  extracting $TTYPE $TMIN $TMAX $TSIZE}#
  ;; test expander
   #{ /* tree_integer_type_bounded $TREEINTYBND ?*/ (($TR) && TREE_CODE($TR) == INTEGER_TYPE) }#
  ;; fill expander
   #{ /* tree_integer_type_bounded $TREEINTYBND !*/
      $TTYPE = TYPE_NAME($TR);
      $TSIZE = TYPE_SIZE($TR);
      $TMIN = TYPE_MIN_VALUE ($TR);
      $TMAX = TYPE_MAX_VALUE ($TR);
    }#)


;;;; pattern for fixed point type

(defcmatcher tree_fixed_point_type
  (:tree tr)
  (					;output
   :tree ttype
   :tree tmin tmax
   :tree tsize
   )
  treefixpt				;statesym
  :doc #{$TREE_FIXED_POINT_TYPE match an fixed point type tree $TR  extracting $TTYPE $TMIN $TMAX $TSIZE}#
  ;; test expander
   #{ /* tree_fixed_point_type $TREEFIXPT ?*/ (($TR) && TREE_CODE($TR) == FIXED_POINT_TYPE) }#
  ;; fill expander
   #{ /* tree_fixed_point_type $TREEFIXPT !*/
      $TTYPE = TYPE_NAME($TR);
      $TSIZE = TYPE_SIZE($TR);
      $TMIN = TYPE_MIN_VALUE ($TR);
      $TMAX = TYPE_MAX_VALUE ($TR);
    }#)

;;;; pattern for the type of nullptr
(defcmatcher tree_nullptr_type 
  (:tree tr)
  ()
  treenullptr
  :doc #{$TREE_NULLPTR_TYPE match an nullptr type tree $TR }#
  #{ /* tree_nullptr_type $TREENULLPTR ?*/ (($TR) && TREE_CODE($TR) == NULLPTR_TYPE) }#
  #{ /* tree_nullptr_type $TREENULLPTR !*/ }#
)


;; Pattern tree_type_declaration. 
(defcmatcher tree_type_declaration
  (:tree tr)
  (:tree name)
  titd
  :doc #{$TREE_TYPE_DECLARATION match a type decl tree $TR extracting the declared name tree $NAME}#
  #{ /* tree_type_declaration $TITD ? */
      (($TR) && TREE_CODE($TR) == TYPE_DECL)
  }#

  #{ /* tree_type_declaration $TITD ! */
      $NAME = DECL_NAME($TR);
  }#)

;;; pattern tree_real_type. It matches any real type.
;;; asked by Marie Krumpe.
(defcmatcher tree_real_type 
  (:tree tr)
  (					;output
   :tree name
   :tree size
  )
  tranyfloaty
  :doc #{$TREE_REAL_TYPE match any real type tree $TR extracting its $NAME & $SIZE trees }#

  #{ /*  tree_real_type $tranyfloaty ? */ 
      (($tr) && TREE_CODE($tr) == REAL_TYPE)
  }#

  #{ /*  tree_real_type $tranyfloaty ! */
      $NAME = TYPE_NAME($tr);
      $SIZE = TYPE_SIZE($tr);
  }#
)

;;; pattern tree_complex_type. It matches any complex type.
(defcmatcher tree_complex_type 
  (:tree tr)
  (					;output
   :tree name
   :tree size
  )
  tranycplxy
  :doc #{$TREE_COMPLEX_TYPE match any complex type tree $TR extracting its $NAME & $SIZE trees }#

  #{ /* tree_complex_type $TRANYCPLXY ? */ 
      (($tr) && TREE_CODE($tr) == COMPLEX_TYPE)
  }#

  #{ /* tree_complex_type $TRANYCPLXY ! */
      $NAME = TYPE_NAME($tr);
      $SIZE = TYPE_SIZE($tr);
  }#
)

;;; pattern tree_integer_cst
(defcmatcher tree_integer_cst
  (:tree tr)
  (					;output
   :long n )
  treeintk
  :doc #{ $TREE_INTEGER_CST match a constant integer tree $TR extracting the constant $N. Might behave strangely if the constant don't fit in a long.}#
  ;; test expander
  #{ /*tree_integer_cst $TREEINTK ?*/
#if  MELT_GCC_VERSION >= 4009 /* GCC 4.9 or later */
  (($TR) && TREE_CODE($TR) == INTEGER_CST 
         && tree_fits_shwi_p ($TR))
#else /* GCC 4.8*/
  (($TR) && TREE_CODE($TR) == INTEGER_CST 
         && host_integerp($TR, 0))
#endif /* GCC 4.8 */
  }#
  ;; fill expander
  #{ /*tree_integer_cst $TREEINTK !*/
#if  MELT_GCC_VERSION >= 4009 /* GCC 4.9 or later */
    $N = tree_to_shwi(($TR));    
#else  /* GCC 4.8 */
    $N  = tree_low_cst(($TR), 0);
#endif /* GCC 4.9 */
  }#  )


;;; pattern tree_real_cst
(defcmatcher tree_real_cst
  (:tree tr)
  (:value v)
  treerealc
  :doc #{ $TREE_REAL_CST match a constant real tree $TR extracting the constant into a value $V}#
  ;; test expander 
  #{ /* tree_real_cst $treerealc ?*/ (($tr) && TREE_CODE($tr) == REAL_CST) }#
  ;; fill expander
  #{ /* tree_real_cst treerealc! */
  $v = meltgc_new_real ((meltobject_ptr_t) MELT_PREDEF (DISCR_REAL), 
                       TREE_REAL_CST(($tr))); }#
)

(defcmatcher tree_string_cst
  (:tree tr)
  (:value v)
  treestringc
  :doc #{ $TREE_STRING_CST match a constant string tree $TR extracting its string into value $V}#
  ;; test expander
  #{   /* tree_string_cst $treestringc ? */
       (($tr) && TREE_CODE ($tr) == STRING_CST)
  }#
  ;; fill expander
  #{   /* tree_string_cst $treestringc ! */
       $v = meltgc_new_string_raw_len ((meltobject_ptr_t) MELT_PREDEF (DISCR_STRING),
				       TREE_STRING_POINTER ($tr),
				       TREE_STRING_LENGTH ($tr));
  }#)
       
;;; pattern for  types
(defcmatcher tree_type_p
  (:tree tr)
  (:tree typetr)
  treetypet
  :doc #{$TREE_TYPE_P match a type tree $TR and extract the inside type $TYPETR}#
  ;; test
  #{ /*tree_type_p $TREETYPET ?*/ (($TR) && TYPE_P(($tr))) }#
  ;; fill
  #{ /*tree_type_p $TREETYPET !*/ $TYPETR = TREE_TYPE($tr); }#
)

;;; pattern for pointer types (or reference type)
(defcmatcher tree_pointer_type_p
  (:tree tr)
  (:tree typetr)
  treeisptrt
  :doc #{$TREE_POINTER_TYPE_P match a pointer type tree $TR and extract the pointed type $TYPETR}#
  ;; test
  #{ /*tree_pointer_type_p $treeisptrt ?*/ (($tr) && POINTER_TYPE_P(($tr))) }#
  ;; fill
  #{ /*tree_pointer_type_p $treeisptrt !*/ $typetr = TREE_TYPE($tr); }#
)

(defcmatcher tree_pointer_type
  (:tree tr)
  (:tree typetr)
  treeptrty
  :doc #{$TREE_POINTER_TYPE_P match or build a POINTER_TYPE tree $TR and extract the pointed type $TYPETR}#
  ;; test
  #{ /*  tree_pointer_type $TREEPTRTY ?*/ (($TR) && TREE_CODE($TR) == POINTER_TYPE) }#
  ;; fill
  #{ /* tree_pointer_type $TREEPTRTY !*/ $TYPETR = TREE_TYPE($TR); }#
  ;; operator
  #{ /* tree_pointer_type: */ build_pointer_type(($TYPETR)) }#
)

(defcmatcher tree_reference_type
  (:tree tr)
  (:tree typetr)
  treerefty
  :doc #{$TREE_REFERENCE_TYPE match a REFERENCE_TYPE tree $TR extracting the $TYPETR}#
  ;; test
  #{ /* tree_reference_type $TREEREFTY ?*/ (($TR) && TREE_CODE($TR) == REFERENCE_TYPE) }#
  ;; fill
  #{ /* tree_reference_type $TREEREFTY !*/ $TYPETR = TREE_TYPE($TR); }#
  ;; operator
  #{ /* tree_reference_type: */ build_reference_type(($TYPETR)) }#
)


;;; pattern for indirect references
(defcmatcher tree_indirect_reference
  (:tree tr)
  (:tree type
   :tree reference)
  treeir
  :doc #{$TREE_INDIRECT_REFERENCE match an indirect ref tree $TR extracting the $TYPE and $REFERENCE subtrees}#
  #{ /* tree_indirect_reference $TREEIR ? */
       (($tr) && INDIRECT_REF_P ($tr))
  }#

  #{ /* tree_indirect_reference $TREEIR ! */
       $type = TREE_TYPE ($tr);
       $reference = TREE_OPERAND ($tr, 0);
  }#)

(defcmatcher tree_addr_expr
  (:tree tr)
  (:tree type
   :tree expr)
  treeae
  :doc #{$TREE_ADDR_EXPR match an ADDR_EXPR tree $TR extracting the $TYPE and $EXPR subtrees}#

  #{ /*  tree_addr_expr $TREEAE ?*/
       (($tr) && TREE_CODE ($tr) == ADDR_EXPR)
  }#

  #{ /*  tree_addr_expr $TREEAE !*/
       $TYPE = TREE_TYPE ($tr);
       $EXPR = TREE_OPERAND ($tr, 0);
  }#

  #{ /* tree_addr_expr: */ (($TYPE != NULL && $EXPR != NULL)
			    ? build_fold_addr_expr_with_type((tree)$EXPR, (tree)$TYPE)
			    : (tree)NULL) 
  }#
)

;;;;;;;;;;;;;;;;
(defcmatcher tree_va_arg_expr
  (:tree tr)
  (:tree trva trtype)
  treeva
  :doc #{$TREE_VA_ARG_EPXR is used for @code{va_arg} in variadic functions.}#
  #{ /* tree_va_arg_expr $TREEVA ?*/
  (($TR) && TREE_CODE ($TR) == VA_ARG_EXPR)
  }#
  #{ /* tree_va_arg_expr $TREEVA !*/
     $TRVA = TREE_OPERAND ($TR, 0);
     $TRTYPE = TREE_TYPE ($TR);
  }#
)
;;;;;;;;
(defcmatcher tree_record_type
  (:tree tr)
  (:tree name)
  treerectyp

  :doc #{$TREE_RECORD_TYPE match a record type tree $TR extracting its $NAME }#
  #{ /*  tree_record_type $TREERECTYP ? */
       (($TR) && TREE_CODE ($TR) == RECORD_TYPE)
  }#
  #{ /*  tree_record_type $TREERECTYP ! */
       $NAME = TYPE_NAME ($TR);
  }#)

(defcmatcher tree_record_type_with_fields
  (:tree tr)
  (:tree tname tfields)
  trectyfld
  :doc #{$TREE_RECORD_TYPE_WITH_FIELDS match a record type tree $TR extracting its $TNAME & $TFIELDS}#
  #{  /*  tree_record_type_with_fields $TRECTYFLD ? */
       (($TR) && TREE_CODE ($TR) == RECORD_TYPE)
  }#
  #{ /*  tree_record_type_with_fields $TRECTYFLD ! */
       $TNAME = TYPE_NAME ($TR);
       $TFIELDS = TYPE_FIELDS ($TR);
  }#)


;; qualified union
(defcmatcher tree_qual_union_type
  (:tree tr)
  (:tree type)
  treequunityp
  :doc #{$TREE_QUAL_UNION_TYPE match a qualified union type tree $TR extracting its $TYPE}#

  #{ /* tree_qual_union_type $TREEQUUNITYP ? */
       (($TR) && TREE_CODE ($TR) == QUAL_UNION_TYPE)
  }#
  #{ /* tree_qual_union_type  $TREEQUUNITYP ! */
       $TYPE = TYPE_NAME ($TR);
  }#)

(defcmatcher tree_qual_union_type_with_fields
  (:tree tr)
  (:tree type tfields)
  tquunityfld
  :doc #{$TREE_QUAL_UNION_TYPE_WITH_FIELDS match a qualified union type tree $TR extracting its $TYPE & $TFIELDS}#

  #{  /* tree_qual_union_type_with_fields $TQUUNITYFLD ? */
       (($TR) && TREE_CODE ($TR) == QUAL_UNION_TYPE)
  }#
  #{ /* tree_qual_union_type_with_fields $TQUUNITYFLD ! */
       $TYPE = TYPE_NAME ($TR);
       $TFIELDS = TYPE_FIELDS ($TR);
  }#)


(defcmatcher tree_array_type
  (:tree tr)
  (:tree telemtype tdomaintype)
  treearrtyp
  :doc #{$TREE_ARRAY_TYPE match an array type tree $TR extracting the elements tpe $TELEMTYPE and the domain type $TDOMAINTYPE}#
  #{ /* tree_array_type $TREEARRTYP ? */
  (($TR) && TREE_CODE ($TR) == ARRAY_TYPE)
  }#
  #{ /* tree_array_type $TREEARRTYP ! */
  $TELEMTYPE = TREE_TYPE ($TR);
  $TDOMAINTYPE = TYPE_DOMAIN ($TR);
  }#
  #{ /* tree_array_type: */
  build_array_type ($TELEMTYPE, $TDOMAINTYPE)
  }#
  )


(defcmatcher tree_field_decl
  (:tree tr)
  (:tree name type)
  treefield
  :doc #{$TREE_FIELD_DECL match a field declaration tree $TR extracting $NAME & $TYPE}#
  #{ /*  tree_field_decl $TREEFIELD ? */
       (($TR) && TREE_CODE ($TR) == FIELD_DECL)
  }#
  #{ /*  tree_field_decl $TREEFIELD ! */
       $NAME = DECL_NAME ($TR);
       $TYPE = TREE_TYPE ($TR);
  }#)

;;;; matcher for pattern ssa_name
(defcmatcher tree_ssa_name 
  (:tree tr)
  (:tree tvar tvalu :long vers :gimple defstmt)
  treessa
  :doc #{$TREE_SSA_NAME match an SSA name tree $TR extracting the $TVAR $TVALUE $VERS and $DEFSTMT}#
  ;; test expander
  #{ /*  tree_ssa_name $TREESSA ? */ (($tr) && TREE_CODE($tr) == SSA_NAME) }#
  ;; fill expander
  #{ /*  tree_ssa_name $TREESSA ! */
   $tvar = SSA_NAME_VAR($tr);
   $tvalu = SSA_NAME_VALUE($tr);
   $vers = SSA_NAME_VERSION($tr);
   $defstmt = SSA_NAME_DEF_STMT($tr);
  }# )

;;;; simpler matcher for pattern ssa_name
(defcmatcher tree_simple_ssa_name 
  (:tree tr)
  (:tree tvar :long vers)
  treesssa
  :doc #{$TREE_SIMPLE_SSA_NAME match an SSA name tree $TR extracting the $TVAR and $VERS}#
  ;; test expander
  #{ /* tree_simple_ssa_name  $TREESSSA ? */ (($TR) && TREE_CODE($TR) == SSA_NAME) }#
  ;; fill expander
  #{ /* tree_simple_ssa_name  $TREESSSA ! */
   $tvar = SSA_NAME_VAR($tr);
   $vers = SSA_NAME_VERSION($tr);
  }# )



;; Iterator on function argument 
(defciterator foreach_argument_in_function_tree
  (:tree tr_fun)
  eachtrfun
  (:tree trarg)
  #{
      /* foreach_argument_in_function_tree $EACHTRFUN start */
      tree $EACHTRFUN#_tr = NULL;

      $TRARG = (tree) NULL;
      if ($TR_FUN && TREE_CODE($TR_FUN) == FUNCTION_TYPE)
      {
          function_args_iterator $EACHTRFUN#_args_iter;
          FOREACH_FUNCTION_ARGS($TR_FUN, $EACHTRFUN#_tr, $EACHTRFUN#_args_iter)
          {
              $TRARG = $EACHTRFUN#_tr;
   }#
              
   #{ /* ending  foreach_argument_in_function_tree $EACHTRFUN */
              $TRARG = (tree) NULL;
          } 
      }
      /* end foreach_argument_in_function_tree $EACHTRFUN */
   }#)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; constant c-matchers for predefined tree nodes

;;; "char"
(defcmatcher tree_char_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_CHAR_TYPE_NODE matches or gives the constant char integer 
type node.}#
 #{ /* tree_char_type_node $NODETR ? */ $TR == char_type_node }#
 ()
 #{ /* tree_char_type_node : */ char_type_node }#)

;;; "signed char"
(defcmatcher tree_signed_char_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_SIGNED_CHAR_TYPE_NODE matches or gives the constant signed 
char integer type node.}#
 #{ /* tree_signed_char_type_node $NODETR ? */ $TR == signed_char_type_node }#
 ()
 #{ /* tree_signed_char_type_node : */ signed_char_type_node }#)

;;; "unsigned char"
(defcmatcher tree_unsigned_char_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_UNSIGNED_CHAR_TYPE_NODE matches or gives the constant unsigned 
char integer type node.}#
 #{ /* tree_unsigned_char_type_node $NODETR ? */ $TR == unsigned_char_type_node }#
 ()
 #{ /* tree_unsigned_char_type_node : */ unsigned_char_type_node }#)

;;; "short"
(defcmatcher tree_short_integer_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_SHORT_INTEGER_TYPE_NODE matches or gives the constant short integer 
type node.}#
 #{ /* tree_short_integer_type_node $NODETR ? */ $TR == short_integer_type_node }#
 ()
 #{ /* tree_short_integer_type_node : */ short_integer_type_node }#)

;;; "unsigned short"
(defcmatcher tree_short_unsigned_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_SHORT_UNSIGNED_TYPE_NODE matches or gives the constant short integer 
type node.}#
 #{ /* tree_short_unsigned_type_node $NODETR ? */ $TR == short_unsigned_type_node }#
 ()
 #{ /* tree_short_unsigned_type_node : */ short_unsigned_type_node }#)

;;; "int"
(defcmatcher tree_integer_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_INTEGER_TYPE_NODE matches or gives the constant  integer 
type node.}#
 #{ /* tree_integer_type_node $NODETR ? */ $TR == integer_type_node }#
 ()
 #{ /* tree_integer_type_node : */ integer_type_node }#)

;;; "unsigned"
(defcmatcher tree_unsigned_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_UNSIGNED_TYPE_NODE matches or gives the constant unsigned integer 
type node.}#
 #{ /* tree_unsigned_type_node $NODETR ? */ $TR == unsigned_type_node }#
 ()
 #{ /* tree_unsigned_type_node : */ unsigned_type_node }#)

;;; "long"
(defcmatcher tree_long_integer_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_LONG_INTEGER_TYPE_NODE matches or gives the constant long integer 
type node.}#
 #{ /* tree_long_integer_type_node $NODETR ? */ $TR == long_integer_type_node }#
 ()
 #{ /* tree_long_integer_type_node : */ long_integer_type_node }#)

;;; "size_t"
(defcmatcher tree_size_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_SIZE_TYPE_NODE matches or gives the constant size_t integer 
type node.}#
 #{ /* tree_size_type_node $NODETR ? */ $TR == size_type_node }#
 ()
 #{ /* tree_size_type_node : */ size_type_node }#)

;;; "unsigned long"
(defcmatcher tree_long_unsigned_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_LONG_UNSIGNED_TYPE_NODE matches or gives the constant unsigned long integer 
type node.}#
 #{ /* tree_long_unsigned_type_node $NODETR ? */ $TR == long_unsigned_type_node }#
 ()
 #{ /* tree_long_unsigned_type_node : */ long_unsigned_type_node }#)

;;; "long long"
(defcmatcher tree_long_long_integer_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_LONG_LONG_INTEGER_TYPE_NODE matches or gives the constant long long integer 
type node.}#
 #{ /* tree_long_long_integer_type_node $NODETR ? */ $TR == long_long_integer_type_node }#
 ()
 #{ /* tree_long_long_integer_type_node : */ long_long_integer_type_node }#)

;;; "unsigned long long"
(defcmatcher tree_long_long_unsigned_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_LONG_LONG_UNSIGNED_TYPE_NODE matches or gives the constant unsigned long long integer 
type node.}#
 #{ /* tree_long_long_unsigned_type_node $NODETR ? */ $TR == long_long_unsigned_type_node }#
 ()
 #{ /* tree_long_long_unsigned_type_node : */ long_long_unsigned_type_node }#)

;;; "int128"
(defcmatcher tree_int128_integer_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_INT128_INTEGER_TYPE_NODE matches or gives the constant 128 bits integer 
type node.}#
 #{ /* tree_int128_integer_type_node $NODETR ? */ $TR == int128_integer_type_node }#
 ()
 #{ /* tree_int128_integer_type_node : */ int128_integer_type_node }#)

;;; "unsigned int128"
(defcmatcher tree_int128_unsigned_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_INT128_UNSIGNED_TYPE_NODE matches or gives the constant 128 bits unsigned integer 
type node.}#
 #{ /* tree_int128_unsigned_type_node $NODETR ? */ $TR == int128_unsigned_type_node }#
 ()
 #{ /* tree_int128_unsigned_type_node : */ int128_unsigned_type_node }#)

;;; "float"
(defcmatcher tree_float_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_FLOAT_TYPE_NODE matches or gives the constant float
type node.}#
 #{ /* tree_float_type_node $NODETR ? */ $TR == float_type_node }#
 ()
 #{ /* tree_float_type_node : */ float_type_node }#)

;;; "double"
(defcmatcher tree_double_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_DOUBLE_TYPE_NODE matches or gives the constant double
type node.}#
 #{ /* tree_double_type_node $NODETR ? */ $TR == double_type_node }#
 ()
 #{ /* tree_double_type_node : */ double_type_node }#)

;;; "long double"
(defcmatcher tree_long_double_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_LONG_DOUBLE_TYPE_NODE matches or gives the constant long double
type node.}#
 #{ /* tree_long_double_type_node $NODETR ? */ $TR == long_double_type_node }#
 ()
 #{ /* tree_long_double_type_node : */ long_double_type_node }#)

;;; "void"
(defcmatcher tree_void_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_VOID_TYPE_NODE matches or gives the constant void
type node.}#
 #{ /* tree_void_type_node $NODETR ? */ $TR == void_type_node }#
 ()
 #{ /* tree_void_type_node : */ void_type_node }#)

;;; "void*"
(defcmatcher tree_ptr_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_PTR_TYPE_NODE matches or gives the constant void*
pointer type node.}#
 #{ /* tree_ptr_type_node $NODETR ? */ $TR == ptr_type_node }#
 ()
 #{ /* tree_ptr_type_node : */ ptr_type_node }#)

;;; "const void*"
(defcmatcher tree_const_ptr_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_CONST_PTR_TYPE_NODE matches or gives the constant const void*
pointer type node.}#
 #{ /* tree_const_ptr_type_node $NODETR ? */ $TR == const_ptr_type_node }#
 ()
 #{ /* tree_const_ptr_type_node : */ const_ptr_type_node }#)

;;; "bool"
(defcmatcher tree_boolean_type_node (:tree tr) ()
 nodetr
 :doc #{$TREE_BOOLEAN_TYPE_NODE matches or gives the constant bool
 type node.}#
 #{ /* tree_boolean_type_node $NODETR ? */ $TR == boolean_type_node }#
 ()
 #{ /* tree_boolean_type_node : */ boolean_type_node }#)

;;; "true"
(defcmatcher tree_boolean_true_node (:tree tr) ()
 nodetr
 :doc #{$TREE_BOOLEAN_TRUE_NODE matches or gives the constant true node.}#
 #{ /* tree_boolean_true_node $NODETR ? */ $TR == boolean_true_node }#
 ()
 #{ /* tree_boolean_true_node : */ boolean_true_node }#)

;;; "false"
(defcmatcher tree_boolean_false_node (:tree tr) ()
 nodetr
 :doc #{$TREE_BOOLEAN_FALSE_NODE matches or gives the constant false node.}#
 #{ /* tree_boolean_false_node $NODETR ? */ $TR == boolean_false_node }#
 ()
 #{ /* tree_boolean_false_node : */ boolean_false_node }#)


;;; "0"
(defcmatcher tree_integer_zero_node (:tree tr) ()
 nodetr
 :doc #{$TREE_INTEGER_ZERO_NODE matches or gives the constant integer 0 node.}#
 #{ /* tree_integer_zero_node $NODETR ? */ $TR == integer_zero_node }#
 ()
 #{ /* tree_integer_zero_node : */ integer_zero_node }#)

;;; "NULL"
(defcmatcher tree_null_pointer_node (:tree tr) ()
 nodetr
 :doc #{$TREE_NULL_POINTER_NODE matches or gives the constant NULL pointer node.}#
 #{ /* tree_null_pointer_node $NODETR ? */ $TR == null_pointer_node }#
 ()
 #{ /* tree_null_pointer_node : */ null_pointer_node }#)


;;; "1"
(defcmatcher tree_integer_one_node (:tree tr) ()
 nodetr
 :doc #{$TREE_INTEGER_ONE_NODE matches or gives the constant integer 1 node.}#
 #{ /* tree_integer_one_node $NODETR ? */ $TR == integer_one_node }#
 ()
 #{ /* tree_integer_one_node : */ integer_one_node }#)

;;; "-1"
(defcmatcher tree_integer_minus_one_node (:tree tr) ()
 nodetr
 :doc #{$TREE_INTEGER_MINUS_ONE_NODE matches or gives the constant integer -1 node.}#
 #{ /* tree_integer_minus_one_node $NODETR ? */ $TR == integer_minus_one_node }#
 ()
 #{ /* tree_integer_minus_one_node : */ integer_minus_one_node }#)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;; map keyed by raw trees
(defprimitive is_maptree (map) :long
  :doc #{Test if $MAP is a map of trees.}#
  #{ (melt_magic_discr((melt_ptr_t)($map)) == MELTOBMAG_MAPTREES) }#)
(defprimitive maptree_size (map) :long
  :doc #{Safely retrieve allocated size of map of trees $MAP.}#
 #{ (melt_size_maptrees((struct meltmaptrees_st*)($map))) }#)
;; primitive to get the attribute count of a maptree
(defprimitive maptree_count (map) :long
  :doc #{Safely retrieve used count of map of trees $MAP.}#
  #{ (melt_count_maptrees((struct meltmaptrees_st*)($map))) }# )
;; get an entry in a maptree from a C tree
(defprimitive maptree_get (map :tree tr) :value
  :doc #{Safely get in map of trees $MAP value associated to tree $TR.}#
  #{(melt_get_maptrees((melt_ptr_t) ($MAP), ($TR)))}#)
;; primitive for making a new map of trees
(defprimitive make_maptree (discr :long len) :value
  :doc #{Make a map of trees with discriminant $DISCR and initial size $LEN.}#
 #{(meltgc_new_maptrees((meltobject_ptr_t) ($DISCR), ($LEN)))}#)
;; primitive for putting into a map of trees
(defprimitive maptree_put (map :tree trkey :value val) :void
  :doc #{Safely put in map of trees $MAP associated to tree $TRKEY the non-nil value $VAL.}#
  #{melt_put_maptrees((melt_ptr_t) ($MAP),  ($TRKEY), 
		      (melt_ptr_t) ($VAL))}#)
;; primitive for removing from a map of trees
(defprimitive maptree_remove (map :tree trkey) :void
  :doc #{Safely remove in map of trees $MAP entry for tree $TRKEY.}#
  #{melt_remove_maptrees((melt_ptr_t) ($MAP), ($TRKEY))}#)
;; primitive to retrieve the auxiliary data of a map of trees
(defprimitive maptree_aux (map) :value
  :doc #{Safely retrieve in map of trees $MAP the auxiliary data.}#
  #{melt_auxdata_maptrees ((melt_ptr_t)$MAP)}#)
;; primitive to put the auxiliary data of a map of trees
(defprimitive maptree_auxput (map aux) :void
  :doc #{Safely put in map of trees $MAP the auxiliary data to $AUX.}#
  #{melt_auxput_maptrees ((melt_ptr_t)$MAP, (melt_ptr_t)$AUX)}#)

;; primitive to get the nth tree of a maptree
(defprimitive maptree_nth_attr (map :long n) :tree
  #{(melt_nthattr_maptrees((struct meltmaptrees_st*)($map), (int)($n)))}#)
;; primitive to get the nth value of a mapobject
(defprimitive maptree_nth_val (map :long n) :value
  #{(melt_nthval_maptrees((struct meltmaptrees_st*)($map), (int)($n)))}# )
;; iterator inside maptree
(defciterator foreach_maptree 
  (trmap)				; startformals
  eachmaptr 				;state symbol
  (:tree tratt :value trval)	;local formals
  ;; before expansion
  #{
   /*$EACHMAPTR*/ int $EACHMAPTR#_rk=0;
   for ($EACHMAPTR#_rk=0;
        $EACHMAPTR#_rk < (int) melt_size_maptrees((struct meltmaptrees_st*)($TRMAP));
	$EACHMAPTR#_rk++) {
   tree $EACHMAPTR#_tr = ((struct meltmaptrees_st*)($TRMAP))->entab[$EACHMAPTR#_rk].e_at;
   $TRATT = (tree) NULL;
   $TRVAL = (melt_ptr_t) NULL;
   if (!$EACHMAPTR#_tr 
       || (void*) $EACHMAPTR#_tr == (void*) HTAB_DELETED_ENTRY) 
     continue;
   $TRATT = $EACHMAPTR#_tr;
   $TRVAL = ((struct meltmaptrees_st*)($TRMAP))->entab[$EACHMAPTR#_rk].e_va;
   }#
  ;;after expansion
   #{
   } /*end $EACHMAPTR*/
   $TRATT = (tree) NULL;
   $TRVAL = (melt_ptr_t) NULL;
   }#
  )


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; TREE DEBUG OUTPUT 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; boxed tree debug
(defun dbgout_boxtree_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debug_information))
  (let ( (dis (discrim self)) 
	 (out  (unsafe_get_field :dbgi_out dbgi)) ) 
    (add2out_strconst out " ?/")
    (if (is_a dis class_named) (add2out_string out (unsafe_get_field :named_name dis)))
    (add2out_strconst out "/{")
    (output_tree_briefly out (tree_content self))
    (add2out_strconst out "}/")
    (add2out_indentnl out depth)
    )
  )
(install_method discr_tree dbg_output dbgout_boxtree_method)


;;;; treemap debug
(defun dbgout_maptree_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debug_information))
  (assert_msg "check self" (is_maptree self))
  (let ( (dis (discrim self)) 
	 (:long mapcount (maptree_count self))
	 (aux (maptree_aux self))
	 (out  (unsafe_get_field :dbgi_out dbgi)) ) 
    (add2out_strconst out " !treemap.")
    (if (is_a dis class_named) (add2out_string out (unsafe_get_field :named_name dis)))
    (add2out_strconst out "/")
    (add2out_longdec out mapcount)
    (add2out_strconst out "!{ ")
    (if (and (<=i depth 1)
	     aux)
	(progn
	  (add2out out " aux:")
	  (dbg_out aux dbgi (+i depth 3))
	  ))
    (foreach_maptree
     (self)
     (:tree tratt :value trval)
     (add2out_indentnl out (+i depth 1))
     (add2out_strconst out "*")
     (output_tree_briefly out tratt)
     (add2out_strconst out " == ")
     (dbg_out trval dbgi (+i depth 2))
     )
    (add2out_strconst out " }!")
    (add2out_indentnl out depth)
    ))
(install_method discr_map_trees dbg_output dbgout_maptree_method)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;           P R A G M A S
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(cheader
 #{ /* cheader for pragmas in warmelt-hooks.melt */
 #include "cpplib.h"
 #include "c-family/c-pragma.h"
/*** 
     We declare weak functions because they cannot be linked when we
     use lto (it loses langage specific informations).  If you use one
     of those functions you must check them to be not NULL.
***/
// Function pragma_lex is declared in c-family/c-pragma.h
extern enum cpp_ttype pragma_lex (tree *) MELT_WEAK_ON_HOST;

// Function c_register_pragma_with_expansion_and_data from c-family/c-pragma.h
extern void
c_register_pragma_with_expansion_and_data (const char *space,
					   const char *name,
					   pragma_handler_2arg handler,
					   void *data) MELT_WEAK_ON_HOST;
// Function c_register_pragma_with_data from c-family/c-pragma.h
extern void
c_register_pragma_with_data (const char *space, const char *name,
			     pragma_handler_2arg handler,
			     void *data) MELT_WEAK_ON_HOST;

 static void
 melt_register_pragmas_callback (void* gccdata ATTRIBUTE_UNUSED,
			        void* userdata ATTRIBUTE_UNUSED)
 {
   melthookproc_HOOK_REGISTER_PRAGMAS ();
   } /* end of melt_register_pragmas_callback */

static void
melt_pragma_process_callback(struct cpp_reader* ATTRIBUTE_UNUSED, void* data)
{
   long ix = (long) data;
   melthookproc_HOOK_PROCESS_PRAGMA(ix);
}

 }#)


(defun check_c_frontend (nam :cstring msg)
  :doc #{utility function to check that we are indeed within a C or
  C++ compiler, outside of @code{lto1} but inside @code{cc1} or
  @code{cc1plus}.}#
  (assert_msg "check nam" (is_a nam class_named))
  (let ( (:long good 0)
	 )
    (code_chunk
     checkc_havepragmas_chk
     #{ /* start check_c_frontend $CHECKC_HAVEPRAGMAS_CHK */
#ifdef MELT_WEAK_ON_HOST
     $GOOD = pragma_lex
           && c_register_pragma_with_expansion_and_data
           && c_register_pragma_with_data;
#else
#error check_c_frontend need MELT_WEAK_ON_HOST
#endif
     /* end check_c_frontend $CHECKC_HAVEPRAGMAS_CHK */
     }#)
    (debug "check_c_frontend good=" good " nam=" nam " msg=" msg)
    (unless good
      (error_at () "Can't use $1 ($2) outside of a C [cc1] or C++ [cc1plus] compiler -e.g. inside [lto1]"
		nam msg)
      (let ( (namstr (get_field :named_name nam))
	     )
	(assert_msg "check namstr" (is_string namstr) namstr nam)
	(code_chunk
	 checkc_fatalerror_chk
	 #{ /* check_c_frontend $CHECKC_FATALERROR_CHK */
	 melt_fatal_error("C or C++ frontend expected in %s (%s)",
			  melt_string_str($NAMSTR),
			  $MSG);
	 }#)))
    ))


;; a variable to hold lazily the tuple of symbols for our pragma_lexer
(defvar cpp_ttype_tuple)

(defhook register_cpp_ttype (:long ix :cstring name) () :void
  (assert_msg "check cpp_ttype_tuple" (is_multiple cpp_ttype_tuple) cpp_ttype_tuple)
  (multiple_put_nth cpp_ttype_tuple ix
		    (hook_named_symbol
		     name
		     (expr_chunk chk_meltcreate :long
				 #{/*register_cpp_ttype*/ (long)MELT_CREATE}#)))
  )

(defun ensure_cpp_ttype_tuple ()
  (if cpp_ttype_tuple (return))
  (let ( (:long nbttype (expr_chunk chk_nbttype :long
				    #{/*ensure_cpp_ttype_tuple*/ (long) N_TTYPES}#))
	 (newcpptytuple (make_multiple discr_multiple nbttype))
	 )
    (setq cpp_ttype_tuple newcpptytuple)
    (code_chunk
     cpptypetuple_chk
     #{ /* ensure_cpp_ttype_tuple $CPPTYPETUPLE_CHK */
#define MELT_DO_REGISTER_CPP_TTYPE(CppNam) \
   melthook_REGISTER_CPP_TTYPE($REGISTER_CPP_TTYPE, \
			       CppNam, #CppNam);
// macros used by TTYPE_TABLE from cpplib.h
#ifndef TTYPE_TABLE
#error TTYPE_TABLE not defined but expected
#endif
#define OP(Nam,Str) /*oper*/  MELT_DO_REGISTER_CPP_TTYPE(CPP_##Nam)
#define TK(Nam,Typ) /*token*/ MELT_DO_REGISTER_CPP_TTYPE(CPP_##Nam)
// the TTYPE_TABLE below is a long macro
     TTYPE_TABLE
#undef MELT_DO_REGISTER_CPP_TTYPE
     }#)
    )
  )

(defun pragma_lex ()
  :doc #{Thin wrapper around @code{pragma_lex} from
  @code{c-family/c-pragma.h}, to be called from pragma handling. Returns
  the type, as a symbol, and secondarily the tree.}#
  (let ( (:long trtyperank -1)
	 (:tree tr (null_tree))
	 )
    (code_chunk
     pragmalex_chk
     #{ /* pragma_lex $PRAGMALEX_CHK */
     if (!pragma_lex)
       melt_fatal_error ("pragma_lex @%p called outside of C [cc1] or C++ compiler [cc1plus] e.g. from [lto1]",
			 (void*) pragma_lex);
     $TRTYPERANK = (long) pragma_lex (& ($TR));
     }#)
    (if trtyperank
	(let ( (trtype (multiple_nth cpp_ttype_tuple trtyperank))
	       )
	  (debug "pragma_lex trtype=" trtype " tr=" tr)
	  (return trtype tr)
	  )
      (return () tr)
      )
  ))


(defclass class_gcc_expanded_pragma
  :doc #{The $CLASS_GCC_EXPANDED_PRAGMA is for registered pragma
  handlers with expansion, see
  @code{c_register_pragma_with_expansion_and_data} in
  @file{c-family/c-pragma.h} and also $CLASS_GCC_PLAIN_PRAGMA.}#
  :super class_gcc_pragma
  :fields ())


(defclass class_gcc_plain_pragma
  :doc #{The $CLASS_GCC_PLAIN_PRAGMA is for registered pragma handlers
  without expansion, see @code{c_register_pragma_with_data} in
  @file{c-family/c-pragma.h} and also $CLASS_GCC_EXPANDED_PRAGMA.}#
  :super class_gcc_pragma
  :fields ())


(defun register_expanded_pragma (space name fun data)
  :doc #{Register an expanded pragma using
  @code{c_register_pragma_with_expansion_and_data} in given
  $SPACE (default is :melt) with a given $NAME and closure $FUN and
  $DATA. Return a newly added instance of
  $CLASS_GCC_EXPANDED_PRAGMA. See also $REGISTER_PLAIN_PRAGMA.}#
  (debug "register_expanded_pragma start space=" space " name=" name " fun=" fun " data=" data)
  (check_c_frontend 'register_expanded_pragma "start")
  (ensure_cpp_ttype_tuple)
  (unless (is_a space class_symbol)
    (setq space :melt))
  (when (is_not_a space class_named)
    (error_at () "register_expanded_pragma bad space for name $1"
	      name)
    (return))
  (when (is_not_a name class_named)
    (error_at () "register_expanded_pragma bad name $1"
	      name)
    (return))
  (unless (is_closure fun)
    (error_at () "register_expanded_pragma fail in space $1 name $2 - non closure fun"
	      space name)
    (return))
  (let ( (ph (instance class_gcc_expanded_pragma
		       :named_name name
		       :gccpragma_handler fun
		       :gccpragma_space space
		       :gccpragma_data data))
	 )
    (add_pragma_handler ph)
    )
  )

(defun register_plain_pragma (space name fun data)
  :doc #{Register a plain (unexpanded) pragma using
  @code{c_register_pragma_with_expansion_and_data} in given
  $SPACE (default is :melt) with a given $NAME and closure $FUN and
  $DATA. Return a newly added instance of
  $CLASS_GCC_PLAIN_PRAGMA. See also $REGISTER_EXPANDED_PRAGMA.}#
  (debug "register_plain_pragma start space=" space " name=" name " fun=" fun " data=" data)
  (check_c_frontend 'register_plain_pragma "start")
  (ensure_cpp_ttype_tuple)
  (unless (is_a space class_symbol)
    (setq space 'meltpragma))
  (when (is_not_a space class_named)
    (error_at () "register_plain_pragma bad space for name $1"
	      name)
    (return))
  (when (is_not_a name class_named)
    (error_at () "register_plain_pragma bad name $1"
	      name)
    (return))
  (unless (is_closure fun)
    (error_at () "register_plain_pragma fail in space $1 name $2 - non closure fun"
	      space name)
    (return))
  (let ( (ph (instance class_gcc_plain_pragma
		       :named_name name
		       :gccpragma_handler fun
		       :gccpragma_space space
		       :gccpragma_data data))
	 )
    (add_pragma_handler ph)
    )
  )


(defun real_pragma_processor (pragmatup)
  (debug "real_pragma_processor start pragmatup=" pragmatup)
  (foreach_in_multiple
   (pragmatup)
   (curpragma :long ix)
   (cond
    ( (null curpragma)
      (void))
    ( (is_a curpragma class_gcc_plain_pragma)
      (let ( (:long lix (get_int curpragma) )
	     (name (get_field :named_name curpragma))
	     (space (get_field :gccpragma_space curpragma))
	     (spacestr (get_field :named_name space))
	     (namestr (get_field :named_name name))
	     )
	(assert_msg "check lix" (==i lix ix) lix ix curpragma)
	(assert_msg "check spacestr" (is_string spacestr) space curpragma)
	(assert_msg "check namestr" (is_string namestr) name curpragma)
	(code_chunk
	 plainpragma_chk
	 #{ /* real_pragma_processor $PLAINPRAGMA_CHK */
	 c_register_pragma_with_data
	   (melt_string_str ($SPACESTR),
	    melt_string_str ($NAMESTR),
	    melt_pragma_process_callback,
	    (void*) $LIX);
	 }#)
	)
      )
    ( (is_a curpragma class_gcc_expanded_pragma)
      (let ( (:long lix (get_int curpragma))
	     (name (get_field :named_name curpragma))
	     (space (get_field :gccpragma_space curpragma))
	     (spacestr (get_field :named_name space))
	     (namestr (get_field :named_name name))
	     )
	(assert_msg "check lix" (==i lix ix) lix ix curpragma)
	(assert_msg "check spacestr" (is_string spacestr) space curpragma)
	(assert_msg "check namestr" (is_string namestr) name curpragma)
	(code_chunk
	 expandedpragma_chk
	 #{ /* real_pragma_processor $EXPANDEDPRAGMA_CHK */
	 c_register_pragma_with_expansion_and_data
           (melt_string_str ($SPACESTR),
            melt_string_str ($NAMESTR),
            melt_pragma_process_callback,
            (void*) $LIX) ;
	 }#)
	)
      )
    (:else
     (assert_msg "bad curpragma" curpragma curpragma))
    )
   )
  )

;; see warmelt-hooks.melt and its hook_register_pragmas
(register_pragma_processor real_pragma_processor)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; TREE DIAGNOSTIC OUTPUT 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun diag_tree (diagstate :tree tr)
  (debug "diag_tree start diagstate=" diagstate " tr=" tr)
  (assert_msg "check diagstate" (is_a diagstate class_diagnostic_state))
  (let ( (outbuf (make_strbuf discr_strbuf))
	 )
    (output_tree_briefly outbuf tr)
    (strbuf2string discr_string outbuf)))
(register_diag_tree diag_tree)

;;;;;;;;;;;;;;;;
;;; primitive to push the cfun asociated with a function declaration
;;; this is required otherwise dump of gimple crashes
(defprimitive push_cfun_decl (:tree fundecl) :void
#{ push_cfun(DECL_STRUCT_FUNCTION($fundecl)) }#) 
(defprimitive pop_cfun () :void
"pop_cfun()")


(export_class class_gcc_expanded_pragma)
(export_class class_gcc_plain_pragma)

(export_values
 ;;in alphanumerical order
 ==t
 build_identifier_tree
 build_int_tree
 build_string_tree
 foreach_argument_in_function_tree
 foreach_maptree
 inform_at_tree
 is_maptree
 is_tree
 isnull_tree
 make_maptree
 make_tree  
 maptree_aux
 maptree_auxput
 maptree_count
 maptree_get
 maptree_nth_attr
 maptree_nth_val
 maptree_put
 maptree_remove
 maptree_size
 null_tree
 pop_cfun
 pragma_lex
 push_cfun_decl
 register_expanded_pragma
 register_plain_pragma
 tree_addr_expr
 tree_array_ref
 tree_array_ref_full
 tree_array_type
 tree_block
 tree_boolean_false_node 
 tree_boolean_true_node 
 tree_boolean_type
 tree_boolean_type_node 
 tree_chain_append
 tree_chain_join
 tree_chain_prepend
 tree_char_type_node 
 tree_complex_type
 tree_component_ref
 tree_component_ref_full
 tree_component_ref_typed
 tree_const_decl
 tree_const_decl_named
 tree_const_decl_of_name
 tree_const_ptr_type_node 
 tree_content 
 tree_create_artificial_label
 tree_decl
 tree_decl_at_source_location
 tree_double_type_node 
 tree_enumeral_type
 tree_expr_at_source_location
 tree_field_decl
 tree_fixed_point_type
 tree_float_type_node 
 tree_function_decl 
 tree_function_decl_named
 tree_function_decl_of_name
 tree_function_type
 tree_identifier
 tree_indirect_reference
 tree_int128_integer_type_node 
 tree_int128_unsigned_type_node 
 tree_integer_cst
 tree_integer_minus_one_node 
 tree_integer_one_node 
 tree_integer_type
 tree_integer_type_bounded
 tree_integer_type_node 
 tree_integer_zero_node 
 tree_label_decl
 tree_list
 tree_long_double_type_node 
 tree_long_integer_type_node 
 tree_long_long_integer_type_node 
 tree_long_long_unsigned_type_node 
 tree_long_unsigned_type_node 
 tree_mem_ref
 tree_null_pointer_node 
 tree_nullptr_type
 tree_of_type
 tree_offset_type
 tree_parm_decl
 tree_parm_decl_named
 tree_parm_decl_of_name
 tree_pointer_type
 tree_pointer_type_p
 tree_ptr_type_node 
 tree_real_cst
 tree_real_type
 tree_record_type
 tree_record_type_with_fields
 tree_reference_type
 tree_result_decl
 tree_result_decl_named
 tree_result_decl_of_name
 tree_short_integer_type_node 
 tree_short_unsigned_type_node 
 tree_signed_char_type_node 
 tree_simple_ssa_name 
 tree_size_type_node 
 tree_ssa_name 
 tree_string_cst
 tree_type   
 tree_type_addr_space 
 tree_type_decl
 tree_type_decl_named
 tree_type_declaration
 tree_type_p
 tree_types_compatible_p
 tree_uid
 tree_unsigned_char_type_node 
 tree_unsigned_type_node
 tree_useless_type_conversion_p 
 tree_va_arg_expr
 tree_var_decl
 tree_var_decl_named
 tree_var_decl_of_name
 tree_vec
 tree_void_type
 tree_void_type_node 
 walk_use_def_chain_breadth_first 
 walk_use_def_chain_depth_first 
 warning_at_tree
 warning_at_tree_decl_with_number
)


;; eof xtramelt-ana-tree.melt
