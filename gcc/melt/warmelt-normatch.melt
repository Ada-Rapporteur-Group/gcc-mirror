;; file warmelt-normatch.melt -*- Lisp -*-
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(comment "***
    Copyright 2008, 2009, 2010 Free Software Foundation, Inc.
    Contributed by Basile Starynkevitch <basile@starynkevitch.net>

    This file is part of GCC.

    GCC is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.

    GCC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.
***")

;; the copyright notice above apply both to warmelt-normatch.melt and 
;; to the generated file  warmelt-normatch*.c
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Permission is granted to copy, distribute and/or modify this document
;; under the terms of the GNU Free Documentation License, Version 1.3 or
;; any later version published by the Free Software Foundation.  
;; A copy of the license is included in the section 
;; entitled ``GNU Free Documentation License''.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Explanatory Notice:

;; The copyright notice with GPLv3+ above apply both to
;; warmelt-normatch.melt and to the generated files
;; warmelt-normatch*.c. The GPLv3+ license is useful to use, distribute,
;; modify (and do anything permitted by the GPLv3+) GCC MELT as a
;; software.

;; This source file is dual-licensed as GPLv3+ & GFDL1.3+ because
;; parts of it [the :doc annotations] are used to generate a GFDL1.3+
;; documentation.  The GFDL1.3+ license permits the generation of
;; GFDL1.3+ documentation chunks from this file.

;; Dual licensed with explicit permission from FSF, after a question
;; to licensing@fsf.org positively replied by Karl Berry on May 31st
;; 2010, [gnu.org #579118]. See also
;; http://gcc.gnu.org/ml/gcc/2010-05/msg00674.html
;; http://gcc.gnu.org/ml/gcc/2010-05/msg00125.html
;; http://gcc.gnu.org/ml/gcc/2010-05/msg00749.html 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;    This file is part of a bootstrapping compiler for the MELT lisp
;;    dialect, compiler which should be able to compile itself (into
;;    generated C file[s])


;;; class for the context of normalization of patterns
(defclass class_pattern_context
  :super class_root
  :doc #{The $CLASS_PATTERN_CONTEXT is for context of patterns'
normalization. $PCTN_NORMCTXT is the
$CLASS_NORMALIZATION_CONTEXT. $PCTN_SRC is the source match
expression. $PCTN_MAPATVAR is the mapping from symbols to pattern
variables. $PCTN_MAPATCNST is the mapping from constant objects to
pattern constants. $PCTN_MAPOR is the mapping from or source patterns
to their map of symbols to pattern variables. $PCTN_BINDLIST is the
binding list for input arguments in matcher. $PCTN_STUFFMAP is the
mapping from a matched stuff to the list of normaltesters matching
it. $PCTN_PVARLOCMAP maps pattern variable symbols to local
occurrences. $PCTN_TESTS is the list of normal
testers. $PCTN_VARHANDERS is a list of pattern variable handler when
scanning variables.}#
  :fields (pctn_normctxt		;the class_normalization_context
	   pctn_src			;the source match expressioon
	   pctn_env			;the current environment
	   ;; mapping symbols to patternvars
	   pctn_mapatvar		;objmap of patternvars
	   ;; mapping constant objects to their patternconsts
	   pctn_mapatcst		;objmap of patternconst
	   ;; mapping or source patterns to their map of symbols to patternvars
	   pctn_mapor
	   ;; binding list for input arguments in matcher
	   pctn_bindlist		;binding list 
	   ;; mapping matched stuff with list of normtesters
	   pctn_stuffmap
	   ;; mapping pattern variable symbols to local occurrences 
	   pctn_pvarlocmap
	   ;; list of tests
	   pctn_tests
	   ;; list of pattern variables handlers when scanning
	   pctn_varhandlers
	   ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; selector to scan a pattern
;;; invoked with :
;;; * the source pattern as reciever
;;; * a parent source location
;;; * a ctype
;;; * a normpatcontext
(defselector scan_pattern class_selector
  )



;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;;; catch-all for scanning any reciever (by failing)
(defun scanpat_anyrecv (recv psloc ctyp pcn)
  (debug_msg recv "scanpat_anypattern recv")
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (let ( (myclass (discrim recv))
	 (myclassname (get_field :named_name myclass)) )
    (error_strv psloc 
		"unimplemented scan_pattern for any " myclassname)
    (assert_msg "catchall scan_pattern unimplemented for any reciever" ())
    ))
(install_method discr_any_receiver scan_pattern scanpat_anyrecv)


;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;;; catch-all for scanning any pattern (by failing)
(defun scanpat_anypattern (recv psloc ctyp pcn)
  (debug_msg recv "scanpat_anypattern recv")
  (assert_msg "check recv" (is_a recv class_source_pattern))
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (let ( (myclass (discrim recv))
	 (myclassname (get_field :named_name myclass)) )
    (debug_msg myclass "scanpat_anypattern myclass [discrim of recv]")
    (error_strv psloc 
		"unimplemented scan_pattern for pattern " myclassname)
    (assert_msg "catchall scan_pattern unimplemented for pattern" ())
    ))
(install_method class_source_pattern scan_pattern scanpat_anypattern)

;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;; scanning pattern variable
(defun scanpat_srcpatvar (recv psloc ctyp pcn)
  (debug_msg recv "scanpat_srcpatvar recv")
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (assert_msg "check recv" (is_a recv class_source_pattern_variable))
  (let ( (sloc (unsafe_get_field :loca_location recv))
	 (svar (unsafe_get_field :spatvar_symb recv))
	 (mapvar (unsafe_get_field :pctn_mapatvar pcn))
	 (varhdlerlist (unsafe_get_field :pctn_varhandlers pcn))
	 (mvar (mapobject_get mapvar svar))
	 )
    (cond ( (null mvar)
	    (mapobject_put mapvar svar recv)
	    (debug_msg svar "scanpat_srcpatvar return new svar")
	    (setq mvar recv)
	    )
	  (:else
	   (debug_msg mvar "scanpat_srcpatvar return found mvar")
	   ))
    (assert_msg "check mvar" (is_a mvar class_source_pattern_variable))
    (let ( (nboccbox (unsafe_get_field :spatvar_nbocc mvar)) 
	   (:long nbocc (get_int nboccbox))
	   )
      (put_int nboccbox (+i nbocc 1)))
    (foreach_in_list
     (varhdlerlist)
     (curpair curhdler)
     (if (is_closure curhdler)
	 (curhdler mvar pcn recv)))
    ))
(install_method class_source_pattern_variable scan_pattern scanpat_srcpatvar)

;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;; scanning pattern joker
(defun scanpat_srcpatjoker (recv psloc ctyp pcn)
  (debug_msg recv "scanpat_srcpatjoker recv")
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (assert_msg "check recv" (is_a recv class_source_pattern_joker_variable))
  ;; just return
  (return)
  )
(install_method class_source_pattern_joker_variable scan_pattern scanpat_srcpatjoker)



;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;; scanning a pattern constant
(defun scanpat_srcpatconst (recv psloc ctyp pcn)
  (debug_msg recv "scanpat_srcpatconst recv")
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (assert_msg "check recv" (is_a recv class_source_pattern_constant))
  (let ( (sconst (unsafe_get_field :spat_constx recv))
	 (sloc (unsafe_get_field :loca_location recv))
	 (ncx (unsafe_get_field :pctn_normctxt pcn))
	 (mapcst (unsafe_get_field :pctn_mapatcst pcn))
	 (mcst (if (is_object sconst) (mapobject_get mapcst sconst)))
	 (ncst mcst)
	 (bindlist (unsafe_get_field :pctn_bindlist pcn))
	 (env (unsafe_get_field :pctn_env pcn))
	 )
    (assert_msg "check bindlist" (is_list bindlist))
    (cond 
     ( (not (is_object sconst))
       (debug_msg sconst "scanpat_srcpatconst nonobj literal const")
	(setq ncst sconst)
       )
     ( (null mcst)
       (multicall
	(nconst nbindconst)
	(normal_exp sconst env ncx sloc)
	(debug_msg nconst "scanpat_srcpatconst nconst")
	(mapobject_put mapcst sconst nconst)
	(if nbindconst (list_append2list bindlist nbindconst))
	(setq ncst nconst)
	))
     (:else
      (debug_msg mcst "scanpat_srcpatconst got mcst")
      ))
    (debug_msg ncst "scanpat_srcpatconst ncst")
    (let ( (rectyp (get_ctype ncst env)) )
      (debug_msg rectyp "scanpat_srcpatconst rectyp")
      (assert_msg "check rectyp" (is_a rectyp class_ctype))
      (cond ((!= rectyp ctyp)
	     (error_strv sloc "invalid ctype in constant pattern - expecting"
			 (unsafe_get_field :named_name rectyp))
	     (warning_strv sloc "got ctype"
			   (unsafe_get_field :named_name ctyp))
	     ))
      )))
(install_method class_source_pattern_constant scan_pattern scanpat_srcpatconst)

;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;; scanning a pattern object or instance
(defun scanpat_srcpatobject (recv psloc ctyp pcn)
  (debug_msg recv "scanpat_srcpatobject recv")
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (assert_msg "check recv" (is_a recv class_source_pattern_object))
  (let ( (sloc (unsafe_get_field :loca_location recv))
	 (scla (unsafe_get_field :spat_class recv))
	 (sfields (unsafe_get_field :spat_fields recv))
	 )
    (assert_msg "check scla" (is_a scla class_class))
    (assert_msg "check sfields" (is_multiple sfields))
    (foreach_in_multiple
     (sfields)
     (fldpa :long ix)
     (assert_msg "check fldp" (is_a fldpa class_source_field_pattern))
     (let ( (fld (let ( ( f (get_field :spaf_field fldpa)) )
		   (assert_msg "check fld" (is_a f class_field))
		   f))
	    (flcla (get_field :fld_ownclass fld))
	    (fpat (unsafe_get_field :spaf_pattern fldpa))
	    )
       (cond ( (not (subclass_or_eq scla flcla))
	       (error_strv sloc "bad field in object pattern"
			   (unsafe_get_field :named_name fld))
	       (inform_strv sloc "class in pattern is" (get_field :named_name scla))
	       (inform_strv sloc "class of field is" (get_field :named_name flcla))
	       (return)))
       (scan_pattern fpat sloc ctype_value pcn)
       )
     )
    (debug_msg recv "scanpat_srcpatobject end recv")
    )
  )
(install_method class_source_pattern_object scan_pattern scanpat_srcpatobject)


;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;; scanning a composite pattern 
(defun scanpat_srcpatcomposite (recv psloc ctyp pcn)
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (debug_msg recv "scanpat_srcpatcomposite start recv")
  (debug_msg ctyp "scanpat_srcpatcomposite start ctyp")
  (assert_msg "check ctyp" (is_a ctyp class_ctype))
  (assert_msg "check recv" (is_a recv class_source_pattern_composite))
  (let ( (sloc (unsafe_get_field :loca_location recv))
	 (soper (let ((sop (unsafe_get_field :spac_operator recv)))
		  (debug_msg sop "scanpat_srcpatcomposite soper")
		  (assert_msg "check soper" (is_a sop class_any_matcher))
		  sop))
	 (sins (unsafe_get_field :spac_inargs recv)) 
	 (souts (unsafe_get_field :spac_outargs recv)) 
	 (matmb (let ( (mb (unsafe_get_field :amatch_matchbind soper)) )
		  (debug_msg mb "scanpat_srcpatcomposite matmb")
		  (assert_msg "check matmb" (is_a mb class_formal_binding))
		  mb))
	 (matin (unsafe_get_field :amatch_in soper))
	 (matout (unsafe_get_field :amatch_out soper))
	 (opnam (unsafe_get_field :named_name soper))
	 (matctyp (unsafe_get_field :fbind_type matmb))
	 (env (unsafe_get_field :pctn_env pcn))
	 (ncx (unsafe_get_field :pctn_normctxt pcn))
	 (bindlist (unsafe_get_field :pctn_bindlist pcn))
	 )
    (assert_msg "check matctyp" (is_a matctyp class_ctype))
    (debug_msg matout "scanpat_srcpatcomposite matout")
    (cond ((!= ctyp matctyp)
	   (error_strv sloc "invalid ctype in composite pattern - expecting"
		       (unsafe_get_field :named_name matctyp))
	   (warning_strv sloc "got ctype"
			 (unsafe_get_field :named_name ctyp))
	   (debug_msg ctyp "scanpat_srcpatcomposite mismatched ctyp")
	   (debug_msg matctyp "scanpat_srcpatcomposite mismatched matctyp")
	   (debug_msg recv "scanpat_srcpatcomposite mismatched recv")
	   ;;
	   (return)))
    (multicall 
     (nins bindins)
     (normalize_tuple sins env ncx sloc)
     (debug_msg nins "scanpat_srcpatcomposite nins")
     (if bindins (list_append2list bindlist bindins))
     (debug_msg souts "scanpat_srcpatcomposite souts")
     (debug_msg matout "scanpat_srcpatcomposite matout")
     (foreach_in_multiple
      (souts)
      (pout :long ix)
      (debug_msg pout "scanpat_srcpatcomposite before scan_pattern pout")
      (let ( (curobind (multiple_nth matout ix)) 
	     (curctype (get_field :fbind_type curobind))
	     )
	(debug_msg curobind "scanpat_srcpatcomposite curobind")
	(debug_msg curctype "scanpat_srcpatcomposite curctype")
	(assert_msg "check curctype" (is_a curctype class_ctype))
	(scan_pattern pout sloc curctype pcn)
	(debug_msg pout "scanpat_srcpatcomposite after scan_pattern pout")
	))
     (debug_msg recv "scanpat_srcpatcomposite end recv")
     )))
(install_method class_source_pattern_composite scan_pattern scanpat_srcpatcomposite)


;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;; scanning or pattern
(defun scanpat_srcpator (recv psloc ctyp pcn)
  (debug_msg recv "scanpat_srcpator recv")
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (assert_msg "check recv" (is_a recv class_source_pattern_or))
  (debug_msg pcn "scanpat_srcpator pcn start")
  (let ( (sloc (unsafe_get_field :loca_location recv))
	 (sdisj (unsafe_get_field :orpat_disj recv))
	 (pvarmap (unsafe_get_field :pctn_mapatvar pcn))
	 (:long cntpvarmap (mapobject_count pvarmap))
	 (ownvarmap (make_mapobject discr_map_objects (+i 4 (*i cntpvarmap 2))))
	 (varhdlerlist (unsafe_get_field :pctn_varhandlers pcn))
	 (ownvarhandler
	  (lambda (mvar mypcn pvar)
	    (debug_msg mvar "scanpat_srcpator.ownvarhandler mvar")
	    (assert_msg "check mvar" (is_a mvar class_source_pattern_variable))
	    (assert_msg "check mypcn" (== mypcn pcn))
	    (let ( (msymb (unsafe_get_field :spatvar_symb mvar)) )
	      (mapobject_put ownvarmap msymb mvar))
	    ))
	 (inipvarmap 
	  (let ( 
		(inimap (make_mapobject discr_map_objects
					(+i 3 (/i (*i cntpvarmap 5) 4))))
		)
	    (foreach_in_mapobject 
	     (pvarmap)
	     (cursym curpatvar)
	     (mapobject_put inimap cursym curpatvar))
	    inimap))
	 )
    (debug_msg sdisj "scanpat_srcpator sdisj")
    (assert_msg "check sdisj" (is_multiple sdisj))
    (list_prepend varhdlerlist ownvarhandler)
    (foreach_in_multiple
     (sdisj)
     (dis :long ix)
     (debug_msg dis "scanpat_srcpator dis")
     (scan_pattern dis sloc ctyp pcn)
     )
    (let ( (:long incrpvarmap 
		  (-i (mapobject_count pvarmap)
		      cntpvarmap))
	   (pmapor (get_field :pctn_mapor pcn))
	   (orvarmap (make_mapobject discr_map_objects
				     (+i 3 (/i (*i incrpvarmap 5) 4))))
	   (oldvarhdler (list_popfirst varhdlerlist))
	   )
      (assert_msg "check pmapor" (is_mapobject pmapor))
      (assert_msg "check oldvarhdler" (== oldvarhdler ownvarhandler))
      ;; scan the updated pvarmap for new entries w.r.t. inipvarmap
      (foreach_in_mapobject 
       (pvarmap)
       (cursym curpatvar)
       (assert_msg "check cursym" (is_a cursym class_symbol))
       (assert_msg "check curpatvar" 
		   (is_a curpatvar class_source_pattern_variable))
       (assert_msg "good curpatvar"
		   (== (get_field :spatvar_symb curpatvar) cursym))
       (if (null (mapobject_get inipvarmap cursym))
	   (mapobject_put orvarmap cursym curpatvar))
       )
      (debug_msg orvarmap "scanpat_srcpator orvarmap")
      (mapobject_put pmapor recv orvarmap)
      )
    (debug_msg pcn "scanpat_srcpator pcn end")
    (debug_msg recv "scanpat_srcpator recv end")
    ))
(install_method class_source_pattern_or scan_pattern scanpat_srcpator)




;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;; scanning and pattern
(defun scanpat_srcpatand (recv psloc ctyp pcn)
  (debug_msg recv "scanpat_srcpatand recv")
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (assert_msg "check recv" (is_a recv class_source_pattern_and))
  (let ( (sloc (unsafe_get_field :loca_location recv))
	 (sconj (unsafe_get_field :andpat_conj recv))
	 )
    (assert_msg "check sconj" (is_multiple sconj))
    (foreach_in_multiple
     (sconj)
     (dis :long ix)
     (scan_pattern dis sloc ctyp pcn)
     )
    (debug_msg recv "scanpat_srcpatand end recv")
    ))
(install_method class_source_pattern_and scan_pattern scanpat_srcpatand)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; selector to normalize a pattern
;;; reciever is the pattern to normalize
;;; arguments are
;;; the normal matched stuff
;;; the closure (if any) to handle the newly created stuff -e.g. tester
;;; the pattern context


(defselector normal_pattern class_selector)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defclass class_normal_or_variable
  :super class_root
  :fields (
	   norvar_norexp
	   norvar_locsym 
	   norvar_patvar		
	   norvar_nrepor
	   )
  :doc #{The $CLASS_NORMAL_OR_VARIABLE is an internal class for
  normalization of variables under an $OR pattern. Field
  $NORVAR_PATVAR gives the associated pattern variable, field
  $NORVAR_NREPOR gives the normalized or pattern, and field
  $NORVAR_LOCSYM gives the local symbol occurrence if any.
  $NORVAR_NOREXP gives the normalized matched expression.}#
  )
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; all the testers share a common superclass
(defclass class_normtester_any 
  :super class_nrep_expression	;inherit fields: nrep_loc
  :fields (ntest_matched       	;normal matched thing
	   ntest_then		;tester to run if successful
	   ntest_else		;tester to run if failed
	   ntest_normatch	;the containing normalized match
	   ;; a list of class_nrep_locsymocc 
	   ntest_locclist	;the local occurence list inside the test
	   ;; list of tests going into this one
	   ntest_comefrom
	   ))



;; final successful tester (always succeed) just evaluate the expression
(defclass class_normtester_success
  :super class_normtester_any
  :fields (ntsuccess_do		;single expression (usually a normlet)
	   ))
 
;; quasi-tester used at failing end of disjuncts to clear a list of variables
(defclass class_normtester_or_clear
  :super class_normtester_any
  :fields (ntorclear_locsym    ;tuple of symbol occurrences to clear
	   ))

;; quasi-tester used at start of or to initialize & clear a list of variables
(defclass class_normtester_or_initial_clear
  :super class_normtester_or_clear
  :fields (
	   ))

;; quasi-tester used at succeeding end of disjuncts to transmit a list of variables
(defclass class_normtester_or_transmit
  :super class_normtester_any
  :fields (ntortransmit_dst		;tuple of locsymocc destinations
	   ntortransmit_src		;tuple of [normal] sources
))


;; all real tests share this superclass
(defclass class_normtester_anytester
  :super class_normtester_any
  :fields (
	   ))

;;; the tester wrapping or.  Needed to share the same ntest_then
;;; between disjuncts
(compile_warning "we probably need to compute the ntdisj_setorvar field somewhere")
(defclass class_normtester_disjunction
  :super class_normtester_anytester
  :fields (ntdisjuncts			;the tuple of disjunct tests
	   ntdisj_freshorvar		;the tuple of fresh or variables
	   ntdisj_setorvar		;the tuple of already set or variables
	   )
)
;; test for same (ie identical) stuff
(defclass class_normtester_same
  :super class_normtester_anytester
  :fields (ntsame_identical		;checked normal stuff
	   ))

;; test for matcher
(defclass class_normtester_matcher
    :super class_normtester_anytester
    :fields (
	     ntmatch_matcher		;the matcher
	     ntmatch_matndata		;the marcher's normal data
	     ;; both inargs & outlocs are normalized
	     ntmatch_inargs		;its input arguments tuple
	     ntmatch_outlocs		;its output locals
	     ))


;; test for instance
(defclass class_normtester_instance
    :super class_normtester_anytester
    :fields (ntinst_class		;the class 
	     ;; a tuple similar to the class's fields
	     ntinst_fieldlocs		;the tuple of field locals or nil
	     ))

;;;;;;;;;;;;;;;;
(defclass class_nrep_match
  :super class_nrep_typed_expression
  :fields (nmatch_tests			;sequence of tests
	   nmatch_stuffmap		;mapping matched stuff with
					;list or normal tests
	   nmatch_matched		;the normal matched stuff
	   ))

;;;;;; utility function to register a new normtester
(defun register_new_normtester (ntest pcn)
  (debug_msg ntest "register_new_normtester ntest")
  (debug_msg pcn "register_new_normtester pcn")
  (assert_msg "check ntest" (is_a ntest class_normtester_any))
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (let ( (nmatched (unsafe_get_field :ntest_matched ntest))
	 (stuffmap (unsafe_get_field :pctn_stuffmap pcn))
	 )
    (assert_msg "check nmatched" (is_object nmatched))
    (assert_msg "check stuffmap" (is_mapobject stuffmap))
    (let (
	  (ntlist
	   (let ( (ntl (mapobject_get stuffmap nmatched)) )
	     (if (is_list ntl) 
		 ntl
	       (let ( (newntl (make_list discr_list)) )
		 (mapobject_put stuffmap nmatched newntl)
		 newntl)
	       )))
	  )
      (assert_msg "check ntlist" (is_list ntlist))
      (list_append ntlist ntest)
      (debug_msg stuffmap "register_new_normtester updated stuffmap")
      (return)
      )))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; utility to set the then of a last test; also handle the case of
;; disjunctions by propagating into them
(defun put_tester_then (curtester thentester)
  (debug_msg curtester "put_tester_then curtester")
  (debug_msg thentester "put_tester_then thentester")
  (assert_msg "check curtester" (is_a curtester class_normtester_any))
  (assert_msg "check thentester" (is_a thentester class_normtester_any))
  (assert_msg "check curtester has no then" 
	     (null (unsafe_get_field :ntest_then curtester)))
  (let ( (thencome (unsafe_get_field :ntest_comefrom thentester)) )
    (assert_msg "check thencome" (is_list thencome))
    (list_append thencome curtester))
  (assert_msg "check curtester not a normtester success"
	      (is_not_a curtester class_normtester_success))
  (unsafe_put_fields curtester :ntest_then thentester)
  ;;; propagate into disjunctions
  (if (is_a curtester class_normtester_disjunction)
      (let ( (curdisjtuple (unsafe_get_field :ntdisjuncts curtester)) )
	(debug_msg curdisjtuple "put_tester_then curdisjtuple")
	(foreach_in_multiple 
	 (curdisjtuple)
	 (curdisj :long disjix)
	 (debug_msg curdisj "put_tester_then curdisj")
	 (let ( (curcont (instance class_container :container_value curdisj)) )
	 (debug_msg curcont "put_tester_then curcont start")
	 (set_new_tester_last_then thentester curcont)
	 (debug_msg curcont "put_tester_then curcont done")
	 ))
      ))
  (debug_msg curtester "put_tester_then curtester done")
)

;; utility to set the newtester to the last of a ntest_then linked list
(defun set_new_tester_last_then (newtester testercont)
  (debug_msg newtester "set_new_tester_last_then newtester")
  (debug_msg testercont "set_new_tester_last_then testercont")
  (shortbacktrace_dbg "set_new_tester_last_then start" 15)
  (assert_msg "check newtester" (is_a newtester class_normtester_any))
  (assert_msg "check testercont" (is_a testercont class_container))
  (let ( (curtester (get_field :container_value testercont)) )
    (forever 
     lastesterloop
     (debug_msg curtester "set_new_tester_last_then loop curtester")
     ;; indeed a safe get_field to handle the nil case!
     (let ( (nextester (get_field :ntest_then curtester)) )
       (if (is_a nextester class_normtester_any)
	   (setq curtester nextester)
	 (exit lastesterloop))))
    (debug_msg curtester "set_new_tester_last_then final curtester")
    (assert_msg "check curtester set_new_tester_last_then" curtester)
    (put_fields testercont :container_value curtester)
    (put_tester_then curtester newtester)
    (debug_msg testercont "set_new_tester_last_then end testercont")
    ))


;; recursive utility to set a newtester as all the unset else branches
;; of a given partester return the list of updated testers, ie the
;; updatlist - which should be null initially
(defun set_new_tester_all_elses (newtester partester updatlist)
  (debug_msg newtester "set_new_tester_all_elses newtester")
  (debug_msg partester "set_new_tester_all_elses partester")
  (shortbacktrace_dbg "set_new_tester_all_elses start" 15)
  (assert_msg "check newtester" (is_a newtester class_normtester_any))
  (assert_msg "check partester" (is_a partester class_normtester_any))
  (if (null updatlist) 
      (setq updatlist (make_list discr_list)))
  (assert_msg "check updatlist" (is_list updatlist))
  (forever
   allelseloop
   (debug_msg partester "set_new_tester_all_elses allelseloop partester")
   (cond
    ((null partester) 
     (exit allelseloop))
    ((is_a partester class_normtester_anytester)
     (let ( (eltest (unsafe_get_field :ntest_else partester)) 
	    (thtest (unsafe_get_field :ntest_then partester))
	    )
       (cond
	((null eltest)
	 (put_fields partester :ntest_else newtester)
	 (debug_msg partester "set_new_tester_all_elses updated partester")
	 (list_append updatlist partester)
	 )
	(:else
	 (foreach_in_list
	  (updatlist)
	  (curpair curtest)
	  (if (== curtest partester) 
	      (exit allelseloop))
	  (if (== curtest newtester)
	      (exit allelseloop))
	  )
	 (setq partester eltest))
	)
       (cond ( (is_a thtest class_normtester_anytester)
	 (foreach_in_list
	  (updatlist)
	  (curpair curtest)
	  (if (== curtest thtest) 
	      (exit allelseloop))
	  (if (== curtest newtester)
	      (exit allelseloop))
	  )
	 (debug_msg thtest "set_new_tester_all_elses before recursion")
	 (set_new_tester_all_elses newtester thtest updatlist)
	 (debug_msg thtest "set_new_tester_all_elses after recursion")
	 )))
     )
    (:else
     (exit allelseloop)))
   ) ;;;; end forever allelseloop
  (debug_msg updatlist "set_new_tester_all_elses return updatlist")
  (return updatlist)
  )
  


;;; expansion of tuples in cmatcher should be done in warmelt-genobj

;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;;; catch-all for normpat any reciever (by failing)
(defun normpat_anyrecv (recv nmatch hdler pcn)
  (debug_msg recv "normpat_anyrecv recv")
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (let ( (myclass (discrim recv))
	 (myclassname (get_field :named_name myclass)) 
	 (psloc (get_field :loca_location (get_field :pctn_src pcn)))
	 )
    (error_strv psloc 
		"unimplemented normal_pattern for any " myclassname)
    (assert_msg "catchall normal_pattern unimplemented" ())
    ))
(install_method discr_any_receiver normal_pattern normpat_anyrecv)

;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;;; catch-all for normpat any pattern (by failing)
(defun normpat_anypat (recv nmatch hdler  pcn)
  (debug_msg recv "normpat_anyrecv recv")
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (assert_msg "check recv" (is_a recv class_source_pattern))
  (let ( (myclass (discrim recv))
	 (myclassname (get_field :named_name myclass)) 
	 (psloc (get_field :loca_location (get_field :pctn_src pcn)))
	 )
    (error_strv psloc 
		"unimplemented NORMAL_PATTERN for pattern of " myclassname)
    (assert_msg "catchall normal_pattern unimplemented on pattern" ())
    ))
(install_method class_source_pattern normal_pattern normpat_anypat)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; internal function when normalizing a variable pattern to generate
;;; or reuse a test
(defun normvarpat_genreusetest (sloc nmatch lococc testlist tstuff hdler pcn)
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (assert_msg "check lococc" (is_a lococc class_nrep_locsymocc))
  (let (
	(tester ())
	(curhdler hdler)
	)
    (forever 
     loopstuff
     (debug_msg tstuff "normvarpat_genreusetest tstuff")
     (cond 
      ( (== (get_field :ntsame_identical tstuff) lococc)
	(setq tester tstuff)
	(exit loopstuff)
	)
      ( (is_a tstuff class_normtester_any)
	(setq tstuff (get_field :ntest_else tstuff))
	(setq curhdler 
	      (lambda (tester)
		(shortbacktrace_dbg "normvarpat_genreusetest lambda curhdler" 15)
		(put_fields tstuff :ntest_else tester)
		(debug_msg tstuff "normvarpat_genreusetest lambda curhdler updatelse of tstuff")
		(list_append (get_field :ntest_comefrom tester) tstuff)
		))
	)
      (:else
       (let ( (newtester (instance class_normtester_same
				   :nrep_loc sloc
				   :ntest_matched nmatch
				   :ntest_then ()
				   :ntest_else ()
				   :ntest_locclist ()
				   :ntest_comefrom (make_list discr_list)
				   :ntsame_identical lococc))
	      )
	 (shortbacktrace_dbg "normvarpat_genreusetest making same newtester" 15)
	 (register_new_normtester newtester pcn)
	 (debug_msg newtester "normvarpat_genreusetest newtester same")
	 (setq tester newtester)
	 (list_append testlist newtester)
	 (curhdler newtester)
	 (exit loopstuff)
	 )
       )
      )
     )
    )
  )

;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;;; normalize variable pattern
(defun normpat_variablepat (recv nmatch hdler pcn)
  (debug_msg recv "normpat_variablepat recv")
  (debug_msg nmatch "normpat_variablepat nmatch")
  (assert_msg "check recv" (is_a recv class_source_pattern_variable))
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (shortbacktrace_dbg "normpat_variablepat begin" 15) 
  (let ( (stuffmap (get_field :pctn_stuffmap pcn))
	 (pvarlocmap (get_field :pctn_pvarlocmap pcn)) 
	 (psloc (get_field :loca_location (get_field :pctn_src pcn)))
	 (sloc (get_field :loca_location recv))
	 (patvar (get_field :spatvar_symb recv))
	 (tstuff (mapobject_get stuffmap nmatch))
	 (lococc (mapobject_get pvarlocmap patvar))
	 (env (get_field :pctn_env pcn))
	 (ncx (get_field :pctn_normctxt pcn))
	 (testlist (get_field :pctn_tests pcn))
	 )
    (debug_msg tstuff "normpat_variablepat tstuff")
    (debug_msg lococc "normpat_variablepat lococc")
    (debug_msg patvar "normpat_variablepat patvar")
    (compile_warning "we need to generate the clear of all or-variables")
    (cond 
     ( (is_a lococc class_nrep_locsymocc)
       ;; patvar already bound, generate or reuse a same test
       (debug_msg lococc "normpat_variablepat alreadybound lococc")
       (normvarpat_genreusetest sloc nmatch lococc testlist tstuff hdler pcn)
       )
     ;; process specially or variables
     ((is_a lococc class_normal_or_variable)
      (debug_msg lococc "normpat_variablepat lococc orvariable")
      (compile_warning "normpat_variablepat unhandled orvariable")
      (let ( (realococc (unsafe_get_field :norvar_locsym lococc)) 
	     (npatvar (unsafe_get_field :norvar_patvar lococc))
	     (patsym (get_field :spatvar_symb npatvar))
	     )
	(debug_msg npatvar "normpat_variablepat orvariable npatvar")
	(assert_msg "check patsym == patvar" (== patsym patvar))
	(debug_msg realococc "normpat_variablepat orvariable realococc")
	(cond ( (null realococc)
		;; the or-variable was not bound at all
		(let ( 
		      (ctyp (get_ctype nmatch env))
		      (cbind (instance class_normal_let_binding
				       :letbind_loc sloc
				       :binder patsym
				       :letbind_type ctyp
				       :letbind_expr nmatch
				       ))
		      (clocc (instance class_nrep_locsymocc
				       :nrep_loc sloc
				       :nocc_ctyp ctyp
				       :nocc_symb patsym
				       :nocc_bind cbind))
		      )
		  (debug_msg clocc "normpat_variablepat fresh orvariable clocc")
		  (put_fields lococc 
			      :norvar_locsym clocc
			      :norvar_norexp nmatch)
		  (debug_msg lococc "normpat_variablepat updated fresh orvariable lococc")
		  (shortbacktrace_dbg "normpat_variablepat updated fresh orvar" 15)
		  ;; put the clocc in the symbol cache map
		  (mapobject_put (get_field :nctx_symbcachemap ncx) patvar clocc)
		  (mapobject_put pvarlocmap patvar clocc)
		  (debug_msg pvarlocmap "normpat_variablepat updated fresh orvariable pvarlocmap")
		  )
		)
	      ;;
	      ;; the or-variable was already bound within the same
	      ;; disjunct, so generate or reuse a same test
	      ( (is_a realococc class_nrep_locsymocc)
		(debug_msg realococc "normpat_variablepat bound orvariable realococccc")
		(normvarpat_genreusetest sloc nmatch realococc testlist tstuff hdler pcn)
		)
	      ;; the or-variable was already bound in a previous
	      ;; disjunction
	      ( (is_box realococc)
		(let ( 
		      (ctyp (get_ctype nmatch env))
		      (bxclocc (box_content realococc))
		      )
		  (debug_msg bxclocc "normpat_variablepat bxclocc")
		  (assert_msg "check bxclocc" (is_a bxclocc class_nrep_locsymocc))
		  ;; check ctype compatibility with former occurence
		  (let (
			 (prevctyp (unsafe_get_field :nocc_ctyp bxclocc))
			 )
		    (if (!= ctyp prevctyp)
			(let ( (prevsloc (unsafe_get_field :nrep_loc bxclocc)) 
			       )
			  (error_strv sloc "incompatible type for pattern variable inside OR pattern"
				      (get_field :named_name (unsafe_get_field :nocc_symb bxclocc)))
			  (inform_strv sloc "disjunct pattern variable occurs here with type"
				       (get_field :named_name (get_field :ctype_keyword ctyp)))
			  (inform_strv prevsloc "disjunct pattern variable occurs previously with type"
				       (get_field :named_name (get_field :ctype_keyword prevctyp)))
			  )))
		  (put_fields lococc 
			      :norvar_locsym bxclocc
			      :norvar_norexp nmatch)
		  (debug_msg lococc "normpat_variablepat updated reusing orvariable lococc")
		  (shortbacktrace_dbg "normpat_variablepat updated reused orvar" 15)
		))
	      ;; unexpected case
	      (:else
	       (assert_msg "normpat_variablepat corruption" ())
	       )
	      )
	)
      )
     ;; else patvar unbound, so bind it 
     ((null lococc)
      (let ( (ctyp (get_ctype nmatch env))
	     (cbind (instance class_normal_let_binding
			      :letbind_loc sloc
			      :binder patvar
			      :letbind_type ctyp
			      :letbind_expr nmatch
			      ))
	     (clocc (instance class_nrep_locsymocc
			      :nrep_loc sloc
			      :nocc_ctyp ctyp
			      :nocc_symb patvar
			      :nocc_bind cbind))
	     )
	(debug_msg ctyp "normpat_variablepat ctyp")
	(debug_msg clocc "normpat_variablepat new clocc")
	(shortbacktrace_dbg "normpat_variablepat:: new clocc" 12)
	;; put the clocc in the symbol cache map
	(mapobject_put (get_field :nctx_symbcachemap ncx) patvar clocc)
	(mapobject_put pvarlocmap patvar clocc)
	(debug_msg patvar "normpat_variablepat updated patvar")
	(debug_msg clocc "normpat_variablepat updated clocc")
	(debug_msg pvarlocmap "normpat_variablepat updated pvarlocmap")
	)
      )
     (:else
      (assert_msg "normpat_variablepat unexpected lococc" ())
      )
     )
    )
  )
(install_method class_source_pattern_variable normal_pattern normpat_variablepat)
;;;;;;;;;;;;;;;;





;;; normalize joker pattern
(defun normpat_jokerpat (recv nmatch hdler pcn)
  (debug_msg recv "normpat_jokerpat recv")
  (debug_msg nmatch "normpat_jokerpat nmatch")
  (assert_msg "check recv" (is_a recv class_source_pattern_joker_variable))
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  ;; we need nothing more, a joker pattern is essentially a black hole..
)
(install_method class_source_pattern_joker_variable normal_pattern normpat_jokerpat)




;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;;; normalize instance pattern
(defun normpat_instancepat (recv nmatch hdler pcn)
  (debug_msg recv "normpat_instancepat recv start")
  (debug_msg nmatch "normpat_instancepat nmatch")
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (assert_msg "check recv" (is_a recv class_source_pattern_instance))
  (let ( (psloc (get_field :loca_location (get_field :pctn_src pcn)))
	 (sloc (get_field :loca_location recv))
	 (env (unsafe_get_field :pctn_env pcn))
	 (patcla (get_field :spat_class recv))
	 (patfields (get_field :spat_fields recv))
	 (oldenv env)
	 (ncx (get_field :pctn_normctxt pcn))
	 (stuffmap (get_field :pctn_stuffmap pcn))
	 (tstuff (mapobject_get stuffmap nmatch))
	 (tester ())
	 (curhdler hdler)
	 (testlist (get_field :pctn_tests pcn))
	 ;; we know for sure that patcla is a class_class
	 ;; hence its normalization does not make any bindings!
	 (npatcla (normal_exp patcla env ncx sloc))
	 )
    (assert_msg "check patcla" (is_a patcla class_class))
    ;; find the tester in the stuff
    (forever
     loopstuff
     (debug_msg tstuff "normpat_instancepat loop tstuff")
     ;; check if tstuff is a class_normtester_instance with good :ntinst_class
     (cond
      ( (== (get_field :ntinst_class tstuff) patcla)
	(setq tester tstuff)
	(exit loopstuff)
	)
      ((is_a tstuff class_normtester_any)
       (setq tstuff (get_field :ntest_else tstuff))
       (setq curhdler
	     (lambda (tester)
	       (shortbacktrace_dbg "normpat_instancepat lambda" 15)
	       (put_fields tstuff :ntest_else tester)
	       (debug_msg tstuff "normpat_instancepat lambda updatelse of tstuff")
	       (list_append (get_field :ntest_comefrom tester) tstuff)
	       ))
       )
      (:else
       (let ( 
	     (newfieldlocs
	      (make_multiple 
	       discr_multiple
	       (multiple_length (get_field :class_fields patcla))
	       ))
	     (newtester 
	      (instance class_normtester_instance
			:nrep_loc sloc
			:ntest_matched nmatch
			:ntest_then ()
			:ntest_else ()
			:ntest_locclist (make_list discr_list)
			:ntest_comefrom (make_list discr_list)
			:ntinst_class npatcla
			:ntinst_fieldlocs newfieldlocs
			))
	     )
	 (debug_msg newtester "normpat_instancepat newtester")
	 (register_new_normtester newtester pcn)
	 (setq tester newtester)
	 (list_append testlist newtester)
	 (debug_msg curhdler "normpat_instancepat before calling curhdler")
	 (curhdler tester)
	 (debug_msg curhdler "normpat_instancepat after calling curhdler")
	 (exit loopstuff)
	 )
       ))
     )
    (debug_msg tester "normpat_instancepat tester")
    (debug_msg recv "normpat_instancepat recv after tester")
    (debug_msg patcla "normpat_instancepat patcla")
    (let ( (testloccl (get_field :ntest_locclist tester)) 
	   (testercont (instance class_container
				 :container_value tester
				 ))
	   )
      (debug_msg testercont "normpat_instancepat testercont before loop")
      (assert_msg "check testbindl" (is_list testloccl))
      (foreach_in_multiple
       (patfields)
       (curpatf :long patix)
       (debug_msg curpatf "normpat_instancepat curpatf in loop")
       (debug_msg testercont "normpat_instancepat testercont in loop")
       (assert_msg "check curpatf" (is_a curpatf class_source_field_pattern))
       (let ( (floc (get_field :loca_location curpatf))
	      (curfld (get_field :spaf_field curpatf))
	      (cursubpat (get_field :spaf_pattern curpatf))
	      (curfldcla (get_field :fld_ownclass curfld))
	      (subhdler 
	       (lambda (newsubtester)
		 (debug_msg newsubtester "normpat_instancepat.subhdler newsubtester")
		 (debug_msg testercont "normpat_instancepat.subhdler testercont")
		 (shortbacktrace_dbg "normpat_instancepat.subhdler" 16)
		 (let ( (prevtester (get_field :container_value testercont)) )
		   (debug_msg prevtester "normpat_instancepat.subhdler prevtester")
		   (assert_msg "check prevtester" (is_a prevtester class_normtester_anytester))
		   (set_new_tester_last_then newsubtester testercont)
		   )
		 (debug_msg newsubtester "normpat_instancepat.subhdler end newsubtester")
		 ))
	      )
	 (debug_msg curfld "normpat_instancepat curfld")
	 (cond  ( (== curfldcla patcla) ())
		( (subclass_of patcla curfldcla) ())
		(:else (error_strv floc "bad field in instance pattern" (get_field :named_name curfld))))
	 (debug_msg cursubpat "normpat_instancepat before normal_pattern cursubpat")
	 (let ( (curloccl ())
		)
	   (debug_msg testloccl "normpat_instancepat scanning testloccl")
	   ;; try to find an existing local occurrence for the field
	   (foreach_in_list 
	    (testloccl)
	    (testpair testlocsy)
	    (assert_msg "check testlocsy" (is_a testlocsy class_nrep_locsymocc))
	    (if (== curfld
		    (get_field :nuget_field (get_field :letbind_expr (get_field :nocc_bind testlocsy))))
		(progn
		  (setq testpair ())	;to exist from foreach
		  (setq curloccl testlocsy)))
	    )
	   (debug_msg curloccl "normpat_instancepat got curloccl")
	   ;; if no local occurrence found, add a new one
	   (if (null curloccl)
	       (let ( 
		     (newsym (clone_symbol (get_field :named_name curfld))) 
		     (nflexp (instance class_nrep_unsafe_get_field
				       :nrep_loc floc
				       :nuget_obj nmatch
				       :nuget_field curfld))
		     (newbind (instance class_normal_let_binding
					:binder newsym
					:letbind_type ctype_value
					:letbind_expr nflexp
					:letbind_loc floc))
		     (newlocc (instance class_nrep_locsymocc
					:nrep_loc floc
					:nocc_ctyp ctype_value
					:nocc_symb newsym
					:nocc_bind newbind
					))
		     )
		 (multiple_put_nth 
		  (get_field :ntinst_fieldlocs tester) 
		  (get_int curfld)
		  newlocc)
		 ;; put the newlocc in the symbol cache map
		 (mapobject_put (get_field :nctx_symbcachemap ncx) newsym newlocc)
		 (debug_msg tester "normpat_instancepat updated fieldlocs tester")
		 (list_append testloccl newlocc)
		 (debug_msg newlocc "normpat_instancepat made newlocc")
		 (setq curloccl newlocc)
		 ))
	   (debug_msg cursubpat "normpat_instancepat before normal_pattern cursubpat")
	   (normal_pattern cursubpat curloccl subhdler pcn)
	   (debug_msg cursubpat "normpat_instancepat after normal_pattern cursubpat")
	   (debug_msg curpatf "normpat_instancepat did curpatf")
	   )
	 )))
    (debug_msg tester "normpat_instancepat final tester")
    )
  (debug_msg recv "normpat_instancepat recv end")
  )
(install_method class_source_pattern_instance normal_pattern normpat_instancepat)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;;; normalize a conjonction [and of subpatterns]
(defun normpat_andpat (recv nmatch hdler pcn)
  (debug_msg recv "normpat_andpat recv")
  (debug_msg nmatch "normpat_andpat nmatch")
  (debug_msg pcn "normpat_andpat pcn")
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (assert_msg "check recv" (is_a recv class_source_pattern_and))
  (let (
	(sloc (get_field :loca_location recv))
	(conjpats (get_field :andpat_conj recv))
	(testercont (instance class_container))
	(subhdler
	 (lambda (newtester) 
	   (debug_msg newtester "normpat_andpat.subhdler newtester")
	   (debug_msg testercont "normpat_andpat.subhdler testercont")
	   (let ( (prevtester (get_field :container_value testercont)) )
	     (cond
	      ((is_a prevtester class_normtester_any)
	       (debug_msg prevtester "normpat_andpat.subhdler prevtester")
	       (set_new_tester_last_then newtester testercont)
	       )
	      (:else
	       (debug_msg newtester "normpat_andpat.subhdler before calling hdler")
	       (hdler newtester)
	       (put_fields testercont :container_value newtester)
	       (debug_msg newtester "normpat_andpat.subhdler after calling hdler")
	       ))
	     (debug_msg testercont "normpat_andpat.subhdler done testercont")
	     )))
	)
    (foreach_in_multiple 
     (conjpats)
     (subpat :long subix)
     (debug_msg testercont "normpat_andpat testercont")
     (debug_msg subpat "normpat_andpat subpat before normal_pattern")
     (normal_pattern subpat nmatch subhdler pcn)
     (debug_msg subpat "normpat_andpat subpat after normal_pattern")
     (debug_msg testercont "normpat_andpat subpat testercont")
     )
    (debug_msg recv "normpat_andpat recv end")
    ))
(install_method class_source_pattern_and normal_pattern normpat_andpat)




;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;;; normalize a disjunction [or of subpatterns]

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun normpat_orpat (recv nmatch hdler pcn)
  (debug_msg recv "normpat_orpat recv")
  (shortbacktrace_dbg "normpat_orpat called" 16)
  (debug_msg nmatch "normpat_orpat nmatch")
  (debug_msg pcn "normpat_orpat pcn")
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (assert_msg "check recv" (is_a recv class_source_pattern_or))
  (let (
	(sloc (get_field :loca_location recv))
	(disjpats (get_field :orpat_disj recv))
	(testlist (get_field :pctn_tests pcn))
	(subtestlist (make_list discr_list)) ;; the list of subtests
	(stuffmap (get_field :pctn_stuffmap pcn))
	(pvarlocmap (get_field :pctn_pvarlocmap pcn)) 
	(mapor (get_field :pctn_mapor pcn))
	(ncx (get_field :pctn_normctxt pcn))
	(orvarmap (mapobject_get mapor recv)) 
	(sortedorsymbs (mapobject_sorted_attribute_tuple orvarmap))
	(disjtester (instance class_normtester_disjunction 
			      :nrep_loc sloc
			      :ntest_matched nmatch
			      :ntest_then ()
			      :ntest_else ()
			      :ntest_comefrom (make_list discr_list)
			      :ntdisjuncts ()
			      :ntdisj_freshorvar ()
			      :ntdisj_setorvar ()
			      )) 
	(sortorvars 
	 (multiple_map 
	  sortedorsymbs
	  (lambda (orsymb :long orix)
	    (let (
		  (curvarpat (mapobject_get orvarmap orsymb))
		  (curorvar (instance class_normal_or_variable
				      :norvar_patvar curvarpat
				      :norvar_nrepor disjtester
				      :norvar_norexp ()
				      :norvar_locsym ())
			    )
		  )
	      (assert_msg "check curvarpat"
			  (is_a curvarpat class_source_pattern_variable))
	      (put_int curorvar orix)
	      (debug_msg curorvar "normpat_orpat/sortlambda curorvar")
	      (debug_msg curvarpat "normpat_orpat/sortlambda curvarpat")
	      (debug_msg orsymb "normpat_orpat/sortlambda orsymb")
	      (mapobject_put pvarlocmap orsymb curorvar)
	      (debug_msg pvarlocmap "normpat_orpat/sortlambda updated pvarlocmap")
	      (return curorvar)
	      ))
	  ))
	(prevcont (instance class_container
			    :container_value disjtester))
	)
    (debug_msg stuffmap "normpat_orpat orig stuffmap")
    (debug_msg pvarlocmap "normpat_orpat orig pvarlocmap")
    (debug_msg orvarmap "normpat_orpat orvarmap")
    (assert_msg "check orvarmap" (is_mapobject orvarmap))
    (debug_msg sortedorsymbs "normpat_orpat sortedorsymbs")
    (debug_msg sortorvars "normpat_orpat sortorvars")
    ;; first register and handle the empty disjtester
    (debug_msg disjtester "normpat_orpat disjtester")
    (register_new_normtester disjtester pcn)
    (hdler disjtester)
    (list_append testlist disjtester)
    (debug_msg disjtester "normpat_orpat handled disjtester")
;;;;;;;;;;;;;;;;
;;;; foreach disjunctive subpattern
    (foreach_in_multiple
     (disjpats)
     (curdisj :long disjix)
     (let ( (clearloclist (make_list discr_list))
	    )
       (foreach_in_multiple
	(sortorvars)
	(curorvar :long orvix)
	(assert_msg "check curorvar" (is_a curorvar class_normal_or_variable))
	(let ( (orvarlocc (unsafe_get_field :norvar_locsym curorvar))
	       )
	  (if (is_a orvarlocc class_nrep_locsymocc)
	      (let ( (orvarbox (make_box discr_box orvarlocc)) )
		(put_fields curorvar :norvar_locsym orvarbox)
		(list_append clearloclist orvarlocc)
		))
	  ))
       (let (
	     (norclear (instance class_normtester_or_clear
				 :nrep_loc sloc
				 :ntest_matched nmatch
				 :ntest_then ()
				 :ntest_else ()
				 :ntest_comefrom (make_list discr_list)
				 :ntorclear_locsym (list_to_multiple clearloclist discr_multiple)
				 ))
	     )
;;;;;;;;;;;;;;;;
	 ;; normalize the current disjunct
	 (debug_msg curdisj "normpat_orpat curdisj before normalization")
	 ;; add the norclear
	 (let (
	       (prevtest (get_field :container_value prevcont))
	       (prevloc (get_field :nrep_loc prevtest))
	       )
	   (debug_msg prevtest "normpat_orpat prevtest")
	   (debug_msg norclear "normpat_orpat norclear")
	   (list_append testlist norclear)
	   (debug_msg norclear "normpat_orclear setallelses norclear")
	   (debug_msg prevtest "normpat_orclear setallelses prevtest")
	   (set_new_tester_all_elses norclear prevtest)
	   (put_fields prevcont :container_value norclear)
	   (debug_msg prevcont "normpat_orpat prevcont with norclear")
	   ;;
	   (let (
		 (subdisjbox (make_box discr_box ()))
		 (subdisjhandler 
		  (lambda (subtester)
		    (debug_msg subtester "normpat_orpat.lambda subtester")
		    (box_put subdisjbox subtester)
		    (let (
			  (prevtestsub (unsafe_get_field :container_value prevcont))
			  )
		      (list_append subtestlist subtester)
		      (debug_msg subtester "normpat_orpat.lambda setlastthen subtester")
		      (debug_msg prevcont "normpat_orpat.lambda setlastthen subtester")
		      (set_new_tester_last_then subtester prevcont)
		      (debug_msg subtester "normpat_orpat.lambda done subtester")
		      (put_fields prevcont :container_value subtester)
		      (debug_msg prevcont "normpat_orpat prevcont with subtester")
		      ))
		  )
		 )
	     (normal_pattern curdisj nmatch 
			     subdisjhandler pcn)       
	     (debug_msg curdisj "normpat_orpat curdisj after normalization")
	     (let (
		   (lastdisj (box_content subdisjbox))
		   (prevtestrans (unsafe_get_field :container_value prevcont))
		   (nortransm (instance class_normtester_or_transmit
					:nrep_loc sloc
					:ntest_matched nmatch
					:ntest_then ()
					:ntest_else ()
					:ntest_comefrom (make_list discr_list)
					:ntortransmit_dst ()
					:ntortransmit_src ()
					))
		   )
	       (debug_msg prevtestrans "normpat_orpat prevtestrans")
	       (list_append testlist nortransm)
	       (debug_msg nortransm "normpat_orpat setlasthen nortransm")
	       (debug_msg prevcont "normpat_orpat setlasthen prevcont")
	       (set_new_tester_last_then nortransm prevcont)
	       ;; if no proper disjunct test was generated, add the
	       ;; ortransmit to the list of tests, so that distributing
	       ;; the then thru the disjunct still works!
	       (if (null lastdisj)
		   (list_append subtestlist nortransm))
	       )
	     )
	   )
	 (debug_msg curdisj "normpat_orpat done curdisj")
	 )
       )
     )
    ;;
    (debug_msg pvarlocmap "normpat_orpat pvarlocmap before freshorvar")
    (debug_msg subtestlist "normpat_orpat final subtestlist")
    (let ( (freshorvar
	    (multiple_map
	     sortorvars
	     (lambda (curorvar :long orix)
	       (assert_msg "check curorvar" (is_a curorvar class_normal_or_variable))
	       (let ( (orlocsy (unsafe_get_field :norvar_locsym curorvar))
		      (patvar (unsafe_get_field :norvar_patvar curorvar))
		      (orsymb (get_field :spatvar_symb patvar))
		      )
		 (if (is_box orlocsy)
		     (setq orlocsy (box_content orlocsy)))
		 ;; the pvarlocmap should already have orsymb bound to orlocsy
		 (debug_msg orsymb "normpat_orpat/finalambda orsymb")
		 (debug_msg orlocsy "normpat_orpat/finalambda orlocsy")
		 (return orlocsy))
	       ))
	    )
	   )
      (debug_msg freshorvar "normpat_orpat final freshorvar")
      (put_fields disjtester 
		  :ntdisjuncts (list_to_multiple subtestlist discr_multiple)
		  :ntdisj_freshorvar freshorvar
		  )
      (debug_msg disjtester "normpat_orpat final disjtester")
      )
    ;;
    (compile_warning "@$@unimplemented normpat_orpat")
    (debug_msg recv "enf normpat_orpat recv")
    ))

(install_method class_source_pattern_or normal_pattern normpat_orpat)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;;; normalize anymatcher pattern
(defun normpat_anymatchpat (recv nmatch hdler pcn)
  (debug_msg recv "normpat_anymatchpat recv")
  (debug_msg nmatch "normpat_anymatchpat nmatch")
  (debug_msg pcn "normpat_anymatchpat pcn")
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (assert_msg "check recv" (is_a recv class_source_pattern_matcher))
  (shortbacktrace_dbg "normpat_anymatchpat start" 14)
  (let (
	(sloc (get_field :loca_location recv))
	(mat (get_field :spac_operator recv))
	(matopbind (get_field :spac_operbind recv))
	(inargs (get_field :spac_inargs recv))
	(outargs (get_field :spac_outargs recv))
	(env (unsafe_get_field :pctn_env pcn))
	(oldenv env)
	(ncx (unsafe_get_field :pctn_normctxt pcn))
	(bindlist (unsafe_get_field :pctn_bindlist pcn))
	(stuffmap (unsafe_get_field :pctn_stuffmap pcn))
	(matchctype (get_ctype nmatch env))
	(testlist (get_field :pctn_tests pcn))
	)
    (assert_msg "check mat" (is_a mat class_any_matcher))
    (assert_msg "check matopbind" (is_a matopbind class_any_binding))
    (debug_msg inargs "normpat_anymatchpat inargs")
    (debug_msg mat "normpat_anymatchpat mat")
    (debug_msg matopbind "normpat_anymatchpat matopbind")
    (let ( 
	  (matvar (let ( (mv (get_field :binder matopbind)) )
		    (debug_msg mv "normpat_anymatchpat matvar")
		    (assert_msg "check matvar's binding"
				(== (find_env env mv) matopbind))
		    mv
		    ))
	  ;; we know that matvar is a symbol so its normalization
	  ;; returns a single value
	  (matndata (normal_exp matvar env ncx sloc))
	  )
      (debug_msg matndata "normpat_anymatchpat matndata")
      (multicall
       (nins bindins)
       (normalize_tuple inargs env ncx sloc)
       (debug_msg nins "normpat_anymatchpat nins")
       (debug_msg bindins "normpat_anymatchpat bindins")
       (if bindins (list_append2list bindlist bindins))
       (let (
	     (inmatchs (get_field :amatch_in mat))
	     (outmatchs (get_field :amatch_out mat))
	     (matbind (get_field :amatch_matchbind mat))
	     (outbinds ())
	     (tester ())
	     )
	 ;; check compatibility of ctype
	 (if (!= matchctype (get_field :fbind_type matbind))
	     (progn
	       (error_strv sloc "unexpected matched type" (get_field :named_name matchctype))
	       (inform_strv sloc "expecting type in matcher" (get_field :named_name (get_field :fbind_type matbind)))))
	 ;; input args
	 (debug_msg inargs "normpat_anymatchpat inargs")
	 (debug_msg inmatchs "normpat_anymatchpat inmatchs")
	 (let ( (:long nbinargs  (multiple_length inargs)) )
	   (if (!=i nbinargs (multiple_length inmatchs))
	       (error_strv 
		sloc 
		"formal and actual number of input matching arguments differ for anymatch"
		(get_field :named_name mat)))
	   (if (>i nbinargs 0)
	       (let ( (newenv (fresh_env env)) )
		 (foreach_in_multiple
		  (nins)
		  (ncurin :long ix)
		  (debug_msg ncurin "normpat_anymatchpat ncurin")
		  (let ( (curmatch (multiple_nth inmatchs ix)) 
			 (curctype (get_ctype ncurin env))
			 (matchtype (get_field :fbind_type curmatch))
			 )
		    (debug_msg curmatch "normpat_anymatchpat curmatch")
		    (assert_msg "check curmatch" 
				(is_a curmatch class_formal_binding))
		    (debug_msg curctype "normpat_anymatchpat curctype")
		    (debug_msg matchtype "normpat_anymatchpat matchtype")
		    (if (!= curctype matchtype)
			(progn
			  (error_strv sloc
				      "type mismatch for match argument in matcher"
				      (get_field :named_name mat))
			  (inform_strv sloc
				       "mismatched formal name in matcher is"
				       (get_field :named_name (get_field :binder curmatch)))
			  (inform_strv sloc
				       "mismatched input type is"
				       (get_field :named_name curctype))
			  (inform_strv sloc
				       "expected match type is"
				       (get_field :named_name matchtype))
			  )
		      (let ( (newb (instance class_normal_let_binding
					     :letbind_loc sloc
					     :binder (get_field :binder curmatch)
					     :letbind_type curctype
					     :letbind_expr ncurin)
				   )
			     )
			(debug_msg newb "normpat_anymatchpat newb")
			(put_env newenv newb)
			))))
		 (setq env newenv)
		 (put_fields pcn :pctn_env newenv)
		 )))
	 ;; output args
	 (debug_msg outargs "normpat_anymatchpat outargs")
	 (debug_msg outmatchs "normpat_anymatchpat outmatchs")
	 (let ( (:long nboutargs (multiple_length outargs)) ) 
	   (if (!=i nboutargs (multiple_length outmatchs))
	       (error_strv 
		sloc 
		"formal and actual number of output matched arguments differ for anymatch"
		(get_field :named_name mat)))
	   (let ( (tstuff (mapobject_get stuffmap nmatch)) 
		  (curhdler hdler)
		  )
	     (forever 
	      loopstuff
	      (debug_msg tstuff "normpat_anymatchpat tstuff")
	      (cond 
	       ((and (is_a tstuff class_normtester_matcher)
		     (== (get_field :ntmatch_matcher tstuff) mat))
		(let ((tinargs (get_field :ntmatch_inargs tstuff)) 
		      (:long good 1)
		      )
		  (foreach_in_multiple
		   (tinargs)
		   (curinarg :long ix)
		   (let ( (nthins (multiple_nth nins ix)) )
		     (if (!= curinarg nthins)
			 (setq good 0)))
		   )
		  (if good 
		      (progn 
			(debug_msg tstuff "normpat_anymatchpat good tstuff")
			(setq tester tstuff)
			(exit loopstuff))
		    (progn
		      (setq tstuff (get_field :ntest_else tstuff))
		      (setq curhdler
			    (lambda (tester)
			      (shortbacktrace_dbg "normpat_anymatchpat lambda updating else" 15)
			      (put_fields tstuff :ntest_else tester)
			      (debug_msg tstuff "normpat_anymatchpat lambda updatelse of tstuff")
			      (list_append (get_field :ntest_comefrom tester) tstuff)
			      ))
		      ))
		  )
		(assert_msg "normpat_anymatchpat incomplete found tstuff" ())
		)
	       ((is_a tstuff class_normtester_any)
		(setq tstuff (get_field :ntest_else tstuff))
		(setq curhdler
		      (lambda (tester)
			(put_fields tstuff :ntest_else tester)
			(shortbacktrace_dbg "normpat_anymatchpat updatelse" 15)
			(debug_msg tstuff "normpat_anymatchpat updatelse tsuff")
			(list_append (get_field :ntest_comefrom tester) tstuff)
			))
		)
	       (:else
		(let
		    ( (outlocs
		       (multiple_map 
			outmatchs
			(lambda (curoutmatch :long ix)
			  (debug_msg curoutmatch "normpat_anymatchpat curoutmatch")
			  (assert_msg "check curoutmatch" (is_a curoutmatch class_formal_binding))
			  (let ( (csym (clone_symbol (get_field :binder curoutmatch)))
				 (curtyp (get_field :fbind_type curoutmatch))
				 (cbind (instance class_normal_let_binding
						  :letbind_loc sloc
						  :binder csym
						  :letbind_type curtyp
						  ;; this is really nil,
						  ;; the binding should
						  ;; be cleared
						  :letbind_expr ()
						  ))
				 (clocc (instance class_nrep_locsymocc
						  :nrep_loc sloc
						  :nocc_ctyp curtyp
						  :nocc_symb csym
						  :nocc_bind cbind))
				 )
			    ;; put the clocc in the symbol cache map
			    (mapobject_put (get_field :nctx_symbcachemap ncx) csym clocc)
			    clocc
			    ))))
		      (newtester 
		       (instance class_normtester_matcher
				 :nrep_loc sloc
				 :ntest_matched nmatch
				 :ntest_then ()
				 :ntest_else ()
;;;; one could imagine having some
;;;; subclass of cmatcher which add
;;;; additional local stuff...
				 :ntest_locclist (multiple_to_list outlocs)
				 :ntest_comefrom (make_list discr_list)
				 :ntmatch_matcher mat
				 :ntmatch_matndata matndata
				 :ntmatch_inargs nins
				 :ntmatch_outlocs outlocs
				 ))
		      )
		  (debug_msg newtester "normpat_anymatchpat newtester")
		  (register_new_normtester newtester pcn)
		  (setq tester newtester)
		  (list_append testlist newtester)
		  (shortbacktrace_dbg "normpat_anymatchpat before curhdler" 12)
		  (curhdler newtester)
		  (exit loopstuff)
		  ))
	       ))
	     )
	   )
	 (debug_msg tester "normpat_anymatchpat got tester")
	 (assert_msg "check tester" (is_a tester class_normtester_matcher))
	 ;;	
	 (let ( (outlocs (get_field :ntmatch_outlocs tester)) )
	   (debug_msg outlocs "normpat_anymatchpat outlocs from tester")
	   (debug_msg outargs "normpat_anymatchpat outargs before foreach")
	   (debug_msg outmatchs "normpat_anymatchpat outmatchs before foreach")
	   (foreach_in_multiple
	    (outmatchs)
	    (curmatch :long ixm)
	    (messagenum_dbg "normpat_anymatchpat ixm in outmatchs" ixm)
	    (debug_msg curmatch "normpat_anymatchpat curmatch in foreach")
	    (let ( (clocc (multiple_nth outlocs ixm)) 
		   (curout (multiple_nth outargs ixm))
		   (testercont (instance class_container
					 :container_value tester))
		   (subhdler 
		    ;; put the new tester as the last element of its
		    ;; ntest_then chain
		    (lambda (newtester)
		      (debug_msg newtester "normpat_anymatchpat subhdler newtester")
		      (shortbacktrace_dbg "normpat_anymatchpat subhdler" 14)
		      (set_new_tester_last_then newtester testercont)
		      ))
		   )
	      (debug_msg curout "normpat_anymatchpat curout before normal_pattern")
	      (debug_msg clocc "normpat_anymatchpat clocc before normal_pattern")
	      (shortbacktrace_dbg "normpat_anymatchpat before normal_pattern curout" 14)
	      (normal_pattern curout clocc subhdler pcn)
	      (debug_msg curmatch "normpat_anymatchpat curout after normal_pattern")
	      )
	    )
	   )
	 (debug_msg outbinds "normpat_anymatchpat outbinds")
	 )
       )
      )
    (if (!= env oldenv)
	(put_fields pcn :pctn_env oldenv))
    )
  )
(install_method class_source_pattern_matcher normal_pattern normpat_anymatchpat)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;; 
;;;; normalize a constant pattern
(defun normpat_constpat (recv nmatch hdler pcn)
  (debug_msg recv "normpat_constpat recv")
  (debug_msg nmatch "normpat_constpat nmatch")
  (debug_msg pcn "normpat_constpat pcn")
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (assert_msg "check recv" (is_a recv class_source_pattern_constant))
  (let (
	(sloc (get_field :loca_location recv))
	(sconst (get_field :spat_constx recv))
	(stuffmap (get_field :pctn_stuffmap pcn))
	(pvarlocmap (get_field :pctn_pvarlocmap pcn)) 
	(psloc (get_field :loca_location (get_field :pctn_src pcn)))
	(tstuff (mapobject_get stuffmap nmatch))
	(env (get_field :pctn_env pcn))
	(ncx (get_field :pctn_normctxt pcn))
	(testlist (get_field :pctn_tests pcn))
	(mapcst (get_field :pctn_mapatcst pcn))
	)
;;; the constant has already been normalized in scanpat_srcpatconst
    (debug_msg tstuff "normpat_constpat tstuff")
    (let (
	  (tester ())
	  (curhdler hdler)
	  (nconst (if (is_object sconst) (mapobject_get mapcst sconst) sconst))
	  )
      (debug_msg nconst "normpat_constpat nconst")
      (forever 
       loopstuff
       (debug_msg tstuff "normpat_constpat tstuff")
       (cond
	( (== (get_field :ntsame_identical tstuff) nconst)
	  (setq tester tstuff)
	  (exit loopstuff))
	( (is_a tstuff class_normtester_any)
	  (setq tstuff (get_field :ntest_else tstuff))
	  (setq curhdler 
		(lambda (tester)
		  (put_fields tstuff :ntest_else tester)
		  (shortbacktrace_dbg "normpat_constpat lambda updatelse" 15)
		  (debug_msg tstuff "normpat_constpat lambda updatelse tstuff")
		  (list_append (get_field :ntest_comefrom tester) tstuff)
		  ))
	  )
	(:else
	 (let ( (newtester (instance class_normtester_same
				     :nrep_loc psloc
				     :ntest_matched nmatch
				     :ntest_then ()
				     :ntest_else ()
				     :ntest_locclist ()
				     :ntest_comefrom (make_list discr_list)
				     :ntsame_identical nconst))
		)
	   (shortbacktrace_dbg "normpat_constpat making newtester same" 15)
	   (register_new_normtester newtester pcn)
	   (debug_msg newtester "normpat_constpat newtester same")
	   (setq tester newtester)
	   (list_append testlist newtester)
	   (curhdler newtester)
	   (exit loopstuff)
	   )
	 )
	)
       )				;end forever
      (debug_msg tester "normpat_constpat got tester")
      )
    )
  )
(install_method class_source_pattern_constant normal_pattern normpat_constpat)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; to ease debugging, we offer the option to generate .dot files
;;;;; for graphviz (see http://www.graphviz.org/ for more)

;;  the instance containing the string value prefix of the generated
;;  .dot file, should be something like /tmp/mygr to generated
;;  /tmp/mygr1.dot /tmp/mygr2.dot etc...
(definstance match_graphic_dot_prefix class_container
  :container_value ())

(defun match_graphic_optset (optsymb :cstring prefixs)
  (debug_msg optsymb "match_graphic_optset optsumb")
  (let ( (prefstr (make_stringconst discr_string prefixs)) )
    (put_fields match_graphic_dot_prefix :container_value prefstr)
    (debug_msg match_graphic_dot_prefix
	       "match_graphic_optset match_graphic_dot_prefix")
    (return match_graphic_dot_prefix)
    ))

(register_option
 'match_graphic
 '"Prefix for Graphviz .dot files generated about match normalization when debugging" 
 match_graphic_optset)
		 

;;; a private class to help generate dot graphics
(defclass class_match_graphic
  :doc #{$CLASS_MATCH_GRAPHIC is a private class to generate graphviz
  .dot graphics files to debug the MELT translation of matching. Don't
  use it yourself.}#
  :super class_proped
  :fields (
	   mchgx_filename		;the filename
	   mchgx_nodout			;the output strbuf for nodes
	   mchgx_edgout			;the output strbuf for edges
	   mchgx_datanamemap		;the objmap for name of datas
	   mchgx_stepnamemap		;the objmap for name of steps
	   ))

;; internal function to out the node name for the match graphic
(defun mg_out_node_name (out ntest)
  (assert_msg "check out" (is_out out))
  (assert_msg "check ntest" (is_a ntest class_normtester_any))
  (let ( (cla (discrim ntest))
	 (clanam (get_field :named_name cla))
	 (:long clanamlen (string_length clanam))
	 (:long ix (get_int ntest))
	)
    ;; the classname starts with CLASS_ which has six characters, we
    ;; skip them for the node name
    (assert_msg "check clanamlen" (>i clanamlen 6))
    (code_chunk outchunk
		#{ /* mg_node_name $OUTCHUNK */
		meltgc_add_out ((melt_ptr_t) $OUT,
				melt_string_str ((melt_ptr_t) $CLANAM) +6);
		meltgc_out_printf ((melt_ptr_t) $OUT, "_%d",
				   (int) $IX);
		}#
		)
    ))

;; internal selector to output the label of a test in "HTML-like"
;; graphiz format
(defselector matchgraphic_label class_selector
)

(defun mglabel_any_test (ntest mg)
  (debug_msg ntest "mglabel_any_test start ntest")
  (assert_msg "check ntest" (is_a ntest class_normtester_any))
  (assert_msg "check mg" (is_a mg class_match_graphic))
  (let ( (nloc (unsafe_get_field :nrep_loc ntest))
	 (nmatched (unsafe_get_field :ntest_matched ntest))
	 (nodout (unsafe_get_field :mchgx_nodout mg))
	 (edgout (unsafe_get_field :mchgx_edgout mg))
	 )
    (debug_msg nloc "mglabel_any_test nloc")
    (debug_msg nmatched "mglabel_any_test nmatched")
    (assert_msg "check nodout" (is_out nodout))
    (assert_msg "check edgout" (is_out edgout))
    ;; first table row: output the node name in blue bold and the hashcode
    (add2out_strconst nodout "<tr><td>")
    (add2out_strconst nodout 
		      "<font color=\"blue\" face=\"Times-Roman Bold\" point-size=\"10\">")
    (mg_out_node_name nodout ntest)
    (add2out_strconst nodout "</font></td>")
    (add2out_strconst nodout "<td><font face=\"Courier\" point-size=\"8\">#")
    (add2out_longhex nodout (obj_hash ntest))
    (add2out_strconst nodout "</font></td>")
    (add2out_strconst nodout "</tr>")
    (add2out_indentnl nodout 2)
    ;; if we have a location, it makes a row
    (cond
     ( (is_mixloc nloc)
       (add2out_strconst nodout "<tr><td rowspan=\"2\">")
       (add2out_strconst nodout "<font face=\"Courier Italic\" point-size=\"8\">")
       (add2out_mixloc nodout nloc)
       (add2out_strconst nodout "</font></td></tr>")
       (add2out_indentnl nodout 2)
       )
     )
    ;; if the matched is a locsymocc [it usually should] display it,
    ;; that is its symbol and the hashcode of the locsymocc
    (if (is_a nmatched class_nrep_locsymocc)
	(let ( (nmaloc (unsafe_get_field :nrep_loc nmatched))
	       (nmasymb (unsafe_get_field :nocc_symb nmatched))
	       (:long nmarank
		      (get_int (get_field :csym_urank nmasymb)))
	       )
	  (add2out_strconst nodout "<tr><td>")
	  (add2out_strconst nodout "<font face=\"Courier Bold\" point-size=\"8\">")
	  (add2out_string nodout (get_field :named_name nmasymb))
	  (if (>i nmarank 0)
	      (progn
		(add2out_strconst nodout " #")
		(add2out_longhex nodout nmarank)
		(add2out_strconst nodout " ")
		))
	  (add2out_strconst nodout "</font></td> <td><font point-size=\"8\">##")
	  (add2out_longhex nodout (obj_hash nmatched))
	  (add2out_strconst nodout "</font></td></tr>")
	  (add2out_indentnl nodout 2)
	  ))
    (debug_msg ntest "mglabel_any_test end ntest")
    ))
(install_method class_normtester_any matchgraphic_label mglabel_any_test)

;; output an instance test
(defun mglabel_instance_test (ntest mg)
  (debug_msg ntest "mglabel_instance_test start ntest")
  (assert_msg "check ntest" (is_a ntest class_normtester_instance))
  (assert_msg "check mg" (is_a mg class_match_graphic))
  (let ( (nloc (unsafe_get_field :nrep_loc ntest))
	 (nmatched (unsafe_get_field :ntest_matched ntest))
	 (nodout (unsafe_get_field :mchgx_nodout mg))
	 (edgout (unsafe_get_field :mchgx_edgout mg))
	 )
    (debug_msg nloc "mglabel_instance_test nloc")
    (debug_msg nmatched "mglabel_instance_test nmatched")
    (assert_msg "check nodout" (is_out nodout))
    (assert_msg "check edgout" (is_out edgout))
    ;; first table row: output the node name in blue bold and the hashcode and the tested class
    (add2out_strconst nodout "<tr><td>")
    (add2out_strconst nodout 
		      "<font color=\"violet\" face=\"Times-Roman Bold\" point-size=\"10\">")
    (mg_out_node_name nodout ntest)
    (add2out_strconst nodout "</font></td>")
    (add2out_strconst nodout "<td><font face=\"Courier\" point-size=\"8\">#")
    (add2out_longhex nodout (obj_hash ntest))
    (add2out_strconst nodout "</font></td>")
    (add2out_strconst nodout "<td><font face=\"Courier Italic\" point-size=\"8\">")
    (add2out_string nodout (get_field :named_name
				      (get_field :nocc_symb 
						 (get_field :ntinst_class ntest))))
    (add2out_strconst nodout "</font></td>")
    (add2out_strconst nodout "</tr>")
    (add2out_indentnl nodout 2)
    ;; if we have a location, it makes a row
    (cond
     ( (is_mixloc nloc)
       (add2out_strconst nodout "<tr><td rowspan=\"2\">")
       (add2out_strconst nodout "<font face=\"Courier Italic\" point-size=\"8\">")
       (add2out_mixloc nodout nloc)
       (add2out_strconst nodout "</font></td></tr>")
       (add2out_indentnl nodout 2)
       )
     )
    ;; if the matched is a locsymocc [it usually should] display it,
    ;; that is its symbol and the hashcode of the locsymocc
    (if (is_a nmatched class_nrep_locsymocc)
	(let ( (nmaloc (unsafe_get_field :nrep_loc nmatched))
	       (nmasymb (unsafe_get_field :nocc_symb nmatched))
	       (:long nmarank
		      (get_int (get_field :csym_urank nmasymb)))
	       )
	  (add2out_strconst nodout "<tr><td>")
	  (add2out_strconst nodout "<font face=\"Courier Bold\" point-size=\"8\">")
	  (add2out_string nodout (get_field :named_name nmasymb))
	  (if (>i nmarank 0)
	      (progn
		(add2out_strconst nodout " #")
		(add2out_longhex nodout nmarank)
		(add2out_strconst nodout " ")
		))
	  (add2out_strconst nodout "</font></td> <td><font point-size=\"8\">##")
	  (add2out_longhex nodout (obj_hash nmatched))
	  (add2out_strconst nodout "</font></td></tr>")
	  (add2out_indentnl nodout 2)
	  ))
    (debug_msg ntest "mglabel_instance_test end ntest")
    ))
(install_method class_normtester_instance matchgraphic_label mglabel_instance_test)

;;; output a success test
(defun mglabel_success_test (ntest mg)
  (debug_msg ntest "mglabel_success_test start ntest")
  (assert_msg "check ntest" (is_a ntest class_normtester_success))
  (assert_msg "check mg" (is_a mg class_match_graphic))
  (let ( (nloc (unsafe_get_field :nrep_loc ntest))
	 (nmatched (unsafe_get_field :ntest_matched ntest))
	 (nodout (unsafe_get_field :mchgx_nodout mg))
	 (edgout (unsafe_get_field :mchgx_edgout mg))
	 )
    (debug_msg nloc "mglabel_success_test nloc")
    (debug_msg nmatched "mglabel_success_test nmatched")
    (assert_msg "check nodout" (is_out nodout))
    (assert_msg "check edgout" (is_out edgout))
    ;; first table row: output the node name and the hashcode
    (add2out_strconst nodout "<tr><td>")
    (add2out_strconst nodout 
		      "<font color=\"sienna\" face=\"Times-Roman Bold\" point-size=\"10\">")
    (mg_out_node_name nodout ntest)
    (add2out_strconst nodout "</font></td>")
    (add2out_strconst nodout "<td><font face=\"Courier\" point-size=\"8\">#")
    (add2out_longhex nodout (obj_hash ntest))
    (add2out_strconst nodout "</font></td>")
    (add2out_strconst nodout "</tr>")
    (add2out_indentnl nodout 2)
    ;; if we have a location, it makes a row
    (cond
     ( (is_mixloc nloc)
       (add2out_strconst nodout "<tr><td rowspan=\"2\">")
       (add2out_strconst nodout "<font face=\"Courier Italic\" point-size=\"8\">")
       (add2out_mixloc nodout nloc)
       (add2out_strconst nodout "</font></td></tr>")
       (add2out_indentnl nodout 2)
       )
     )
    (debug_msg ntest "mglabel_success_test end ntest")
    ))
(install_method class_normtester_success matchgraphic_label mglabel_success_test)



;; internal function to out a tuple of test nodes in graphiz format
(defun matchgraphic_tests (testup mg)
  (debug_msg testup "matchgraphic_tests testup start")
  (debug_msg mg "matchgraphic_tests mg start")
  (assert_msg "check testup" (is_multiple testup))
  (assert_msg "check mg" (is_a mg class_match_graphic))
  (let ( (nodout (unsafe_get_field :mchgx_nodout mg))
	 (edgout (unsafe_get_field :mchgx_edgout mg))
	 )
    (add2out_indentnl nodout 0)
    (add2out_indentnl edgout 0)
    (foreach_in_multiple 
     testup
     (curtest :long tix)
     (assert_msg "check curtest" (is_a curtest class_normtester_any))
     (debug_msg curtest "matchgraphic_tests curtest")
     ;; output the node and its label
     (mg_out_node_name nodout curtest)
     (add2out_strconst nodout " [ label=<")
     (add2out_strconst nodout "<table border=\"1\" cellborder=\"1\" cellspacing=\"1\" cellpadding=\"1\">")
     (add2out_indentnl nodout 1)
     (matchgraphic_label curtest mg)
     (add2out_indentnl nodout 1)
     (add2out_strconst nodout "</table>")
     (add2out_strconst nodout ">, margin=0")
     (if (==i tix 0)
	 (add2out_strconst nodout ", style=\"bold\"")) 
     (add2out_strconst nodout " ];")
     (add2out_indentnl nodout 0)
     ;; output the outgoing edges 
     (let ( (nthen (unsafe_get_field :ntest_then curtest))
	    (nelse (unsafe_get_field :ntest_else curtest))
	    )
       (if (is_a nthen class_normtester_any)
	   (progn
	     (mg_out_node_name edgout curtest)
	     (add2out_strconst edgout " -> /*then*/ ")
	     (mg_out_node_name edgout nthen)
	     (add2out_strconst edgout " [ arrowhead=normal, color=green ];")
	     (add2out_indentnl edgout 0)
	     ))
       (if (is_a nelse class_normtester_any)
	   (progn
	     (mg_out_node_name edgout curtest)
	     (add2out_strconst edgout " -> /*else*/ ")
	     (mg_out_node_name edgout nelse)
	     (add2out_strconst edgout " [ arrowhead=diamond, color=red ];")
	     (add2out_indentnl edgout 0)
	     ))
       )
     )
    ))


;; utility to out a graphviz .dot file for the tests inside match
(defun mg_draw_match_graphviz_file (nmatch dotprefix teststupl)
  (let (
        (:long hcodnmatch (obj_hash nmatch))
        (:long cnt 0)
        (:long nbtests (multiple_length teststupl)) 
        (pathsbuf (make_strbuf discr_strbuf)) 
        (dotfilename
         (progn
           (code_chunk 
            uniqcnt 
            #{  /* mg_draw_match_graphviz_file $UNIQCNT */
            static long uniqcounter;
            uniqcounter ++;
            $CNT = uniqcounter; 
            }#)
           (assert_msg "check pathsbuf" (is_strbuf pathsbuf))
           (add2sbuf_string pathsbuf dotprefix)
           (add2sbuf_longdec pathsbuf cnt)
           (add2sbuf_strconst pathsbuf ".dot")
           (debug_msg pathsbuf "mg_draw_match_graphviz_file pathsbuf")
           (strbuf2string discr_string pathsbuf)))
        (nodbuf (make_strbuf discr_strbuf))
        (edgbuf (make_strbuf discr_strbuf))
        (mg (instance class_match_graphic
                      :mchgx_filename dotfilename
                      :mchgx_nodout nodbuf
                      :mchgx_edgout edgbuf
                      ))
        )
    (debug_msg mg "mg_draw_match_graphviz_file initial mg")
    (matchgraphic_tests teststupl mg)
    (debug_msg mg "mg_draw_match_graphviz_file final mg")
    (assert_msg "check dotfilename" (is_string dotfilename))
    (code_chunk 
     outputmg
     #{ /* mg_draw_match_graphviz_file $OUTPUTMG */
     time_t nowt = 0;
     char nowbuf[60];
     FILE* dotfil = 
     fopen (melt_string_str ((melt_ptr_t) $DOTFILENAME), "w");
     if (!dotfil) 
       melt_fatal_error ("failed to open matchdot file %s - %m", 
			 melt_string_str ((melt_ptr_t) $DOTFILENAME));
     fprintf (dotfil, "// melt matchdot file %s\n", 
                      melt_string_str ((melt_ptr_t) $DOTFILENAME));
     time (&nowt);
     memset (nowbuf, 0, sizeof(nowbuf));
     strftime (nowbuf, sizeof(nowbuf)-1,
                       "%Y %b %d %Hh%M",
                       localtime (&nowt));
     fprintf (dotfil, "// generated %s\n", nowbuf);
     fprintf (dotfil, "digraph meltmatch_%lx {\n",
                      $HCODNMATCH);
     fprintf (dotfil, " graph [ label=\"Melt Match %d #%#lx %s\", pad=\"0.5\", margin=\"0.3\" ];\n",
                      (int) $CNT, $HCODNMATCH, nowbuf);
     fprintf (dotfil, " node [ shape=\"box\", fontsize=\"12\" ];\n");
     fprintf (dotfil, "// %d tests\n", (int) $NBTESTS);
     melt_putstrbuf (dotfil, (melt_ptr_t) $NODBUF);
     fprintf (dotfil, "\n /// edges\n");
     melt_putstrbuf (dotfil, (melt_ptr_t) $EDGBUF);
     fprintf (dotfil, "\n} // eof %s\n", melt_string_str ((melt_ptr_t) $DOTFILENAME));
     fclose (dotfil);
     }#)
    ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; normalize a match
(defun normexp_match (recv env ncx psloc)
  (assert_msg "check match recv" (is_a recv class_source_match))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normalization_context))
  (debug_msg recv "normexp_match recv")
  (let ( (sloc (unsafe_get_field :loca_location recv))
	 (smatsx (unsafe_get_field :smat_matchedx recv))
	 (scases (unsafe_get_field :smat_cases recv))
	 (:long nbcases (multiple_length scases))
	 (tupvarmap (make_multiple discr_multiple nbcases))
	 (tupcstmap (make_multiple discr_multiple nbcases))
	 ;; the shabindlist & the stuffmap are shared for all match cases
	 (stuffmap (make_mapobject discr_map_objects 
				   (+i 20 (*i 5 nbcases))))
	 (shabindlist (make_list discr_list))
	 (testlist (make_list discr_list))
	 (wholectype ())		;the ctype of the whole match
	 (oldtester ())			;the previous tester
	 )
    (debug_msg smatsx "normexp_match smatsx")
    (multicall
     (nmatx nbindmatx)
     (normal_exp smatsx env ncx sloc)
     (debug_msg nmatx "normexp_match nmatx")
     (debug_msg scases "normexp_match scases")
     (let ( (ctyp (get_ctype nmatx env)) 
	    )
       (debug_msg ctyp "normexp_match ctyp")
       ;; if the matched stuff is not an object, it is a constant, so
       ;; make a binding for it
       (if (not (is_object nmatx))
	   (let (
		 (csym (clone_symbol '_matched_))
		 (cbind (instance class_normal_let_binding
				  :letbind_loc sloc
				  :binder csym
				  :letbind_type ctyp
				  :letbind_expr nmatx))
		 (clocc (instance class_nrep_locsymocc
				  :nrep_loc sloc
				  :nocc_ctyp ctyp
				  :nocc_symb csym
				  :nocc_bind cbind))
		 )
	     (assert_msg "check no binding" (null nbindmatx))
	     ;; put the clocc in the symbol cache map
	     (mapobject_put (get_field :nctx_symbcachemap ncx) csym clocc)
	     (setq nbindmatx (list cbind))
	     (setq nmatx clocc)
	     ))
       ;; if no binding list, make an empty one
       (if (null nbindmatx) (setq nbindmatx (make_list discr_list)))
       ;;
       ;; loop on each case
       (foreach_in_multiple
	(scases)
	(curcas :long ix)
	(debug_msg curcas "normexp_match curcas")
	(assert_msg "check curcas" (is_a curcas class_source_match_case))
	(let ( 
	      (curloc (unsafe_get_field :loca_location curcas))
	      (curpat (unsafe_get_field :scam_patt curcas))
	      (curbody (unsafe_get_field :scam_body curcas))
	      (mapvar (make_mapobject discr_map_objects 13))
	      (mapcst (make_mapobject discr_map_objects 11))
	      (mapor (make_mapobject discr_map_objects 7))
	      (pvarlocmap (make_mapobject discr_map_objects 23))
	      (varhdlerlist (make_list discr_list))
	      (pcn (instance class_pattern_context
			     :pctn_normctxt ncx
			     :pctn_src recv
			     :pctn_env env
			     :pctn_mapatvar mapvar
			     :pctn_mapatcst mapcst
			     :pctn_mapor mapor
			     :pctn_bindlist shabindlist
			     :pctn_stuffmap stuffmap
			     :pctn_pvarlocmap pvarlocmap
			     :pctn_tests testlist
			     :pctn_varhandlers varhdlerlist
			     ))
	      (ntestcont (instance class_container)) ;container for tester
	      )
	  (debug_msg curpat "normexp_match curpat before scan_pattern")
	  ;; I am not entirely sure of this assert! Perhaps there maybe
	  ;; strange cases where curpat is null...
	  (assert_msg "normexp_match check curpat" curpat)
	  (scan_pattern curpat curloc ctyp pcn)
	  (debug_msg curpat "normexp_match curpat after scan_pattern")
	  (debug_msg mapvar "normexp_match mapvar")
	  (debug_msg pvarlocmap "normexp_match pvarlocmap")
	  (debug_msg mapcst "normexp_match mapcst")
	  (multiple_put_nth tupvarmap ix mapvar)
	  (multiple_put_nth tupcstmap ix mapcst)
	  (debug_msg shabindlist "normexp_match shabindlist before normal_pattern")
	  (debug_msg curpat "normexp_match curpat before normal_pattern")
	  ;; normalize the current pattern, with the handler storing its topmost tester
	  (normal_pattern 
	   curpat nmatx
	   (lambda (tester) 
	     (debug_msg tester "normexp_match.lambda tester")
	     (shortbacktrace_dbg "normexp_match lambda tester" 12)
	     (assert_msg "check empty ntestcont" 
			 (null (unsafe_get_field :container_value ntestcont)))
	     (put_fields ntestcont :container_value tester))
	   pcn)
	  (debug_msg curpat "normexp_match curpat after normal_pattern")
	  (debug_msg pvarlocmap "normexp_match pvarlocmap after normal_pattern")
	  (debug_msg ntestcont "normexp_match ntestcont after normal_pattern")
	  (debug_msg shabindlist "normexp_match shabindlist after normal_pattern")
	  ;; 
	  (let ( (newenv (get_field :pctn_env pcn))
		 (curtester (get_field :container_value ntestcont))
		 ;; we need a success. For the last joker case, it
		 ;; becomes the curtester; for the usual case it is
		 ;; added as the last then. Anyway, it will contain
		 ;; the action part of the current case.
		 (newsuctester
		  (instance class_normtester_success
			    :nrep_loc curloc
			    ;; we really don't match anything
			    :ntest_matched ()
			    :ntest_then ()
			    :ntest_else ()
			    :ntest_comefrom (make_list discr_list)
			    ;; the success do should be the wrapped
			    ;; let of the normalized actions
			    :ntsuccess_do ()
			    ))
		 )
	    (debug_msg newenv "normexp_match newenv after normal_pattern")
	    (debug_msg newsuctester "normexp_match empty newsuctester")
	    (debug_msg pvarlocmap "normexp_match pvarlocmap after normal_pattern")
	    (debug_msg curcas "normexp_match curcas after normal_pattern")
	    (debug_msg curtester "normexp_match curtester after normal_pattern")
	    (debug_msg oldtester "normexp_match oldtester after normal_pattern")
	    ;; append the new success to the test list, so that it
	    ;; will get its ntest_normatch later
	    (list_append testlist newsuctester)
	    (cond 
	     ((null curtester)
	      (debug_msg curcas "normexp_match curcas for null curtester")
	      ;; curtester is null if the whole case is a joker,
	      ;; this should be the last case
	      (if (<i ix (-i (multiple_length scases) 1))
		  (error_plain sloc "joker case in MATCH is not last"))
	      ;; set the current tester to the success 
	      (setq curtester newsuctester)
	      (debug_msg curtester "normexp_match curestester set to success")
	      )
	     ;; else the curtester is not null; it cannot be a success
	     (:else
	      (assert_msg "check curtester not success" 
			  (is_not_a curtester class_normtester_success))
;;; add the newsuctester as the last then of the curtester
	      (let ( (curtestcont (instance class_container
					    :container_value curtester)) )
		(debug_msg curtestcont "normexp_match our curtestcont")
		(debug_msg newsuctester "normexp_match our newsuctester")
		(set_new_tester_last_then newsuctester curtestcont)
		(debug_msg curtestcont "normexp_match final curtestcont")
		)
	      ) ;; end when null curtester
	     )	;; end cond
	    (debug_msg curtester "normexp_match final curtester")
	    (assert_msg "check final curtester"  (is_a curtester class_normtester_any))
	    ;; if there is an oldtester, add the curtester as its last else case
	    (if (is_a oldtester class_normtester_anytester)
		(progn
		  (debug_msg oldtester "normexp_match initial oldtester")
		  (set_new_tester_all_elses curtester oldtester)
		  (debug_msg oldtester "normexp_match final oldtester")
		  ))
	    ;; always set the oldtester to the curtester
	    (setq oldtester curtester)
	    (debug_msg pcn "normexp_match pcn after lastesterloop")
	    (debug_msg pvarlocmap "normexp_match pvarlocmap after lastesterloop")
	    (let ( (sortedvars (mapobject_sorted_attribute_tuple pvarlocmap)) 
		   (sortedbindings (make_multiple discr_multiple (multiple_length sortedvars)))
		   (freshnewenv (fresh_env newenv))
		   )
	      (debug_msg sortedvars "normexp_match sortedvars")
	      ;; we have to make a list of bindings based upon the sortedvars
	      (foreach_in_multiple
	       (sortedvars)
	       (svar :long svix)
	       (debug_msg svar "normexp_match svar")
	       (let ( (socc (mapobject_get pvarlocmap svar))
		      )
		 (debug_msg socc "normexp_match socc")
		 (assert_msg "check socc" (is_a socc class_nrep_locsymocc))
		 (let ( (sbind (unsafe_get_field :nocc_bind socc)) )
		   (debug_msg sbind "normexp_match sbind")
		   (multiple_put_nth sortedbindings svix sbind)
		   (put_env freshnewenv sbind)
		   )
		 ))
	      (debug_msg freshnewenv "normexp_match freshnewenv")
	      (debug_msg sortedbindings "normexp_match sortedbindings")
	      (assert_msg "check sortedbindings" (is_multiple sortedbindings))
	      (let ( (subindlist (make_list discr_list)) 
		     )
		(foreach_in_multiple
		 (sortedbindings)
		 (cursortbind :long sortbix)
		 (debug_msg cursortbind "normexp_match cursortbind")
		 (assert_msg "check cursortbind" 
			     (is_a cursortbind class_normal_let_binding))
		 (list_append subindlist cursortbind)
		 )
		(debug_msg curbody "normexp_match curbody before normalize_tuple")
		(multicall 
		 (nbody bindsbody)
		 (normalize_tuple curbody freshnewenv ncx curloc)
		 (debug_msg curbody "normexp_match curbody after normalize_tuple")
		 (debug_msg nbody "normexp_match nbody")
		 (debug_msg bindsbody "normexp_match bindsbody")
		 (assert_msg "check bindsbody" (is_list_or_null bindsbody))
		 (foreach_in_list
		  (bindsbody)
		  (bindbodypair curbindbody)
		  (debug_msg curbindbody "normexp_match curbindbody")
		  (list_append subindlist curbindbody)
		  )
		 (debug_msg subindlist "normexp_match final subindlist")
		 (let ( (wnlet (wrap_normal_letseq nbody subindlist curloc)) 
			(lastnbody (multiple_nth nbody -1))
			(lastctype (get_ctype lastnbody freshnewenv))
			)
		   (debug_msg wnlet "normexp_match wnlet")
		   (debug_msg lastnbody "normexp_match lastnbody")
		   (debug_msg lastctype "normexp_match lastctype")
		   (put_fields newsuctester 
			       :ntsuccess_do wnlet
			       )
		   (cond ( (null wholectype)
			   (setq wholectype lastctype))
			 ( (== lastctype ctype_void)
			   (setq wholectype ctype_void))
			 ( (== wholectype ctype_void)
			   ())
			 ( (!= wholectype lastctype)
			   (error_strv curloc "invalid type of match case" 
				       (get_field :named_name lastctype))
			   (inform_strv sloc "expected type of match case"
					(get_field :named_name wholectype)))
			 )
		   (debug_msg newsuctester "normexp_match updated newsuctester")
		   ))))))) ;;; end foreach_in_multiple
       ;; end of loop on each case
       (debug_msg tupvarmap "normexp_match tupvarmap")
       (debug_msg tupcstmap "normexp_match tupcstmap")
       (debug_msg testlist "normexp_match testlist")
       (debug_msg stuffmap "normexp_match stuffmap")
       (debug_msg (let ( (stmpklist (make_list discr_list)) )
		    (foreach_in_mapobject
		     (stuffmap)
		     (lococck litest)
		     (list_append stmpklist lococck)
		     )
		    stmpklist) 
		  "normexp_match stuffmapkeylist")
       (let ( 
	     (teststupl (let ( (tt (list_to_multiple testlist discr_multiple)) )
			  (debug_msg tt "normexp_match teststupl")
			  tt))
	     (nmatch (instance class_nrep_match
			       :nrep_loc sloc
			       :nexpr_ctyp wholectype
			       :nmatch_tests teststupl
			       :nmatch_stuffmap stuffmap
			       :nmatch_matched nmatx
			       ))
	     (csym (clone_symbol 'matchres_))
	     (clocc  (instance  class_nrep_locsymocc
				:nrep_loc sloc
				:nocc_ctyp wholectype
				:nocc_symb csym)) 
	     (cbind (instance class_normal_let_binding
			      :letbind_loc sloc
			      :binder csym
			      :letbind_type wholectype
			      :letbind_expr nmatch))
	     )
	 (debug_msg csym "normexp_match csym")
	 (put_fields clocc :nocc_bind cbind)
	 (debug_msg clocc "normexp_match clocc")
	 ;; put the clocc in the symbol cache map
	 (mapobject_put (get_field :nctx_symbcachemap ncx) csym clocc)
	 ;; put the index of each test 
	 (foreach_in_multiple
	  (teststupl)
	  (curtest :long tstix)
	  (debug_msg curtest "normexp_match raw curtest")
	  (assert_msg "check curtest" (is_a curtest class_normtester_any))
	  (assert_msg "check tstix" (>=i tstix 0))
	  (assert_msg "check tstix not too big" (<i tstix 32767))
	  (messagenum_dbg "normexp_match testindex tstix" tstix)
	  (put_int curtest tstix)
	  (put_fields curtest :ntest_normatch nmatch)
	  (debug_msg curtest "normexp_match indexed curtest")
	  )
	 (if (need_dbg 1)
	     (let ( (dotprefix (get_field :container_value match_graphic_dot_prefix)) )
	       (debug_msg match_graphic_dot_prefix "normexp_match match_graphic_dot_prefix")
	       (debug_msg dotprefix "normexp_match dotprefix")
	       (if (is_string dotprefix) 
		   (mg_draw_match_graphviz_file nmatch dotprefix teststupl
		 ))))
	 (unsafe_put_fields clocc :nocc_bind cbind)
	 (debug_msg teststupl "normexp_match final teststupl")
	 (debug_msg nbindmatx "normexp_match before append nbindmatx")
	 (assert_msg "check nbindmatx" (is_list nbindmatx))
	 (list_append nbindmatx cbind)
	 (debug_msg nmatch "normexp_match final nmatch")
	 (debug_msg cbind "normexp_match final cbind")
	 (debug_msg nbindmatx "normexp_match returned nbindmatx")
	 (debug_msg clocc "normexp_match returned clocc")
	 (return clocc nbindmatx)
	 )))))

;;;;
(install_method class_source_match normal_exp normexp_match)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; A L T E R N A T E     I M P L E M E N T A T I O N
;;;;                   O F 
;;;;  P A T T E R N  -  M A T C H I N G    
;;;;;;;;;;;;;;;;
(defclass class_matching_context
  :super class_root
  :doc #{The $CLASS_MATCHING_CONTEXT is a context for normalization of
pattern matching. $MCTX_NORMCTXT is the normalization
context. $MCTX_SOURCE is the source matching
expression. $MCTX_NMATCHED is the normal matched
expression. $MCTX_NMATBIND the corresponding bindings. $MCTX_CASES is
the tuple of cases each of $CLASS_MATCH_CASE. $MCTX_ENV is the
environment of the match. $MCTX_MDATA is the initial matched data of
$CLASS_MATCHED_DATA. $MCTX_VARHANDLERS is the list of pattern variable
handlers. $MCTX_FLAGS is the list of match flags. $MCTX_ENDLABEL may
hold the ending label.}#
  :fields ( mctx_normctxt
	    mctx_source 
	    mctx_nmatched 
	    mctx_nmatbind
	    mctx_cases 
	    mctx_env 
	    mctx_mdata
	    mctx_varhandlers
	    mctx_flags
	    mctx_endlabel
	    ))

(defclass class_match_case
  :super class_proped
  :doc #{The $CLASS_MATCH_CASE describes a case match. Field
$MCASE_MCTXT is the matching context. $MCASE_SOURCE is the source
case, $MCASE_INDEX is the boxed integer rank. $MCASE_VARMAP is an
objectmap from symbols to the list of their pattern variables.}#
  :fields ( mcase_mctxt 
	    mcase_source 
	    mcase_index
	    mcase_varmap
	    ))

(defclass class_matched_data
  :super class_proped
  :doc #{The $CLASS_MATCHED_DATA describes some matched data. Field
$MDATA_SYMB gives the symbol, $MDATA_CTYPE gives the
ctype. $MDATA_ORIG is the origin step or data. $MDATA_STEPS is the
list of match steps, transformed into a tuple when all steps have been
made.}#
  :fields ( mdata_symb
	    mdata_ctype
	    mdata_orig
	    mdata_steps
	    ))



(defclass class_matched_normal_data
  :super class_matched_data
  :doc #{The $CLASS_MATCHED_NORMAL_DATA is a sub-class for the initially matched normal data. The $MDATA_ORIG field is the normal matched thing.}#
  :fields (
	   ))

(defclass class_matched_binding
  :doc #{The $CLASS_MATCHED_BINDING is a binding for matched pattern
variables.  Field $MATCHBIND_DATA gives the matched data, and field
$MATCHBIND_NBOCC is the number of occurrences.}#
  :super class_any_binding
  :fields (matchbind_data
	   matchbind_nbocc
	   ))

(defun normbind_matchbind (bind env ncx procs psloc)
  (assert_msg "check bind" (is_a bind class_matched_binding))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check ncx" (is_a ncx class_normalization_context))
  (let ( (sycmap  (unsafe_get_field :nctx_symbcachemap ncx))
	 (symb (unsafe_get_field :binder bind))
	 (mdata (unsafe_get_field :matchbind_data bind))
	 (boxnbocc (unsafe_get_field :matchbind_nbocc bind))
	 (:long nbocc (get_int boxnbocc))
	 (syocc
		(instance class_nrep_locsymocc
			  :nrep_loc psloc
			  :nocc_ctyp (get_field :mdata_ctype mdata) 
			  :nocc_symb symb
			  :nocc_bind bind) ) 
	 )
    ;; increment the number of occurrences
    (put_int boxnbocc (+i nbocc 1))
    ;; cache the result & return it
    (mapobject_put sycmap symb syocc)
    syocc
    ))
(install_method class_matched_binding  normalize_binding normbind_matchbind)

(defclass class_match_step
  :super class_located
  :doc #{The $CLASS_MATCH_STEP describes an elementary step of pattern
matching, like tests, success, etc... The $MSTEP_DATA field is the
matched data. The $MSTEP_INDEX field is the boxed integer index
counting from 1 of this step within its data, it is filled when all
steps have been made.}#
  :fields ( mstep_data
	    mstep_index 
	    ))

(defclass class_match_flag
  :super class_located
  :doc #{The $CLASS_MATCH_FLAG describes a flag related to a source
pattern. The $MFLAG_SPAT is the source pattern, and the $MFLAG_RANK is
a unique boxed integer rank, $MFLAG_STRING gives a small descriptive
string, The $MFLAG_SETSTEP is the match step setting that flag, or
else null. Match flags are initially cleared.}#
  :fields ( mflag_spat
	    mflag_rank
	    mflag_string
	    mflag_setstep
))

(defclass class_match_step_then
  :super class_match_step
  :doc #{The $CLASS_MATCH_STEP_THEN super-class is for steps with a
then edge $MSTEP_THEN.}#
  :fields (mstep_then))


(defclass class_match_step_clear
  :super class_match_step_then
  :doc #{The $CLASS_MATCH_STEP_CLEAR is a step to clear the $MSTEP_CLEARDATA tuple of matched data.}#
  :fields (mstep_cleardata))

(defclass class_match_step_with_flag
  :super class_match_step_then
  :doc #{The $CLASS_MATCH_STEP_WITH_FLAG super-class is for steps with a match
  flag $MSTEP_FLAG, in particular flag assignments and flagged successes.}#
  :fields (mstep_flag))

(defclass class_match_step_flag_set
  :super class_match_step_with_flag
  :doc #{The $CLASS_MATCH_STEP_FLAG_SET sets to true a match flag
$MSTEP_FLAG.}#
  :fields ())

(defclass class_match_step_flag_operation
  :super class_match_step_with_flag
  :doc #{The $CLASS_MATCH_STEP_FLAG_OPERATION sets the match flag according to flag arguments from the $MSTEP_FLAGARGS tuple.}#
  :fields (mstep_flagargs))

(defclass class_match_step_flag_conjonction
  :super class_match_step_flag_operation
  :doc #{The $CLASS_MATCH_STEP_FLAG_CONJONCTION sets the match
flag $MSTEP_FLAG to the conjonction of $MSTEP_FLAGARGS, which is a
tuple of match flags.}#
  :fields ())

(defclass class_match_step_flag_disjonction
  :super class_match_step_flag_operation
  :doc #{The $CLASS_MATCH_STEP_FLAG_DISJONCTION sets the match
flag $MSTEP_FLAG to the disjonction of $MSTEP_FLAGARGS, which is a
tuple of match flags.}#
  :fields ())


(defclass class_match_step_success_when_flag
  :super class_match_step_with_flag
  :doc #{The $CLASS_MATCH_STEP_SUCCESS_WHEN_FLAG step represents the normalized
action in a match. $MSTEP_FLAG is the flag
conditionning the success. $MSTEPSUCCESS_VAROCC is the tuple of
pattern variable occurrences, $MSTEPSUCCESS_BINDS is the list of local
binders, and $MSTEPSUCCESS_BODY is the normalized body tuple.}#
  :fields (
	   mstepsuccess_varocc
	   mstepsuccess_binds
	   mstepsuccess_body))

(defclass class_match_step_test
  :super class_match_step_then
  :doc #{The $CLASS_MATCH_STEP_TEST is the super-class of elementary
tests of pattern matching. The $MSTEP_THEN is the then branch, the
$MSTEP_ELSE is the else branch.}#
  :fields (mstep_else))

(defclass class_match_step_test_variable
  :super class_match_step_test
  :doc #{The $CLASS_MATCH_STEP_TEST_VARIABLE is for tests if the
data $MSTEPTESTVAR_DATA is the same as the matched data.}#
  :fields (msteptestvar_data))

(defclass class_match_step_test_group
  :super class_match_step_test
  :doc #{The $CLASS_MATCH_STEP_GROUP is used to redirect the then &
else tests to a list or tuple of subtests, i.e. to the $MSTGROUP_THEN and
$MSTGROUP_ELSE. The $MSTGROUP_START is the starting control point (for
then & else edges arriving into the group).}#
  :fields (mstgroup_start
	   mstgroup_then
	   mstgroup_else))


(defclass class_match_step_test_instance
  :super class_match_step_test
  :doc #{The $CLASS_MATCH_STEP_TEST_INSTANCE is the class for testing
instance membership. $MSTINS_CLASS is the tested class. $MSTINS_SLOTS
is the tuple of slot matched data.}#
  :fields (mstins_class
	   mstins_slots))

(defclass class_match_step_test_matcher
  :super class_match_step_test
  :doc #{The $CLASS_MATCH_STEP_TEST_MATCHER is the class for testing with
matcher. $MSTMA_MATCHER is the matcher, $MSTMA_BINDS is the local
binding list for inputs, $MSTMA_INS is the normalized inputs,
$MSTMA_OUTS is the tuple of output matched data.}#
  :fields (mstma_matcher
	   mstma_binds
	   mstma_ins
	   mstma_outs))


(defclass class_nrep_match_flag
  :super class_nrep_simple
  :doc #{The $CLASS_NREP_MATCH_FLAG is the normalized representation
of match flags, instances of $CLASS_MATCH_FLAG. $NRPFLA_FLAG is the
matched flag, and $NRPFLA_NMATCH is the instance of
$CLASS_NREP_ALTMATCH using that match flag.}#
  :fields (nrpfla_flag
	   nrpfla_nmatch
	   ))

(defclass class_nrep_matched_data
  :super class_nrep_simple
  :doc #{The $CLASS_NREP_MATCHED_DATA is the normalize representation
of match data, instance of $CLASS_MATCHED_DATA. Field $NRPMATD_CTYPE
gives the ctype of the data. Field $NRMATD_MDATA gives the
originating matched data. Field $NRMATD_RANK is a unique rank.}#
  :fields (nrmatd_ctype
	   nrmatd_mdata
	   nrmatd_rank))
  

;;;;;;;;;;;;;;;;
;;; make a flag for a given source pattern in a given matching context
(defun make_match_flag (spat mcx str)
  (debug_msg spat "make_match_flag spat")
  (debug_msg mcx "make_match_flag mcx")
  (assert_msg "check spat" (is_a spat class_source_pattern))
  (assert_msg "check mcx" (is_a mcx class_matching_context))
  (assert_msg "check str" (is_string str))
  (let ( (sloc (unsafe_get_field :loca_location spat))
	 (flaglist (unsafe_get_field :mctx_flags mcx))
	 (lastflag (pair_head (list_last flaglist)))
	 (:long lastrank (get_int (get_field :mflag_rank lastflag)))
	 )
    (assert_msg "check flaglist" (is_list flaglist))
    (assert_msg "check lastrank" (or (null lastflag) (>i lastrank 0)))
    (let ( (mflag
	    (instance class_match_flag
		      :loca_location sloc
		      :mflag_spat spat
		      :mflag_rank (make_integerbox discr_constant_integer
						   (+i lastrank 1))
		      :mflag_string str
			    ))
	   )
      (list_append flaglist mflag)
      (debug_msg mflag "make_match_flag return mflag")
      mflag
    )
))


;;;;;;;;;;;;;;;;
(defselector scan_subpatterns class_selector
  :doc #{Apply a given function $FUN to the subpatterns of reciever
  $RECV with extra context $CTX.}#
  :formals (recv fun ctx)
)

(defselector scan_step_data class_selector
  :doc #{Given a reciever $STEP, apply a given function $FUN to all
the data of the $STEP with an extra context $CTX.}#
  :formals (step fun ctx))

(defselector scan_step_flag class_selector
  :doc #{Given a reciever $STEP, apply a given function $FUN to all
the flags of the $STEP with an extra context $CTX.}#
  :formals (step fun ctx))

(defun scansubpat_anyrecv (recv fun ctx)
  (debug_msg recv "scansubpat_anyrecv recv")
  (let ( (dis (discrim recv)) )
    (errormsg_strv "unexpected scan_subpatterns for" (unsafe_get_field :named_name dis))
    (assert_msg "@$@unexpected scansubpat_anyrecv")
))
(install_method discr_any_receiver scan_subpatterns scansubpat_anyrecv)

(defun scansubpat_noop (recv fun ctx)
  ()
)
(install_method class_source_pattern_variable scan_subpatterns scansubpat_noop)
(install_method class_source_pattern_constant scan_subpatterns scansubpat_noop)

(defun scansubpat_or (recv fun ctx)
  (let ( (disjtup (unsafe_get_field :orpat_disj recv)) )
    (foreach_in_multiple
     (disjtup)
     (curdisj :long dix)
     (fun curdisj ctx))))
(install_method class_source_pattern_or scan_subpatterns scansubpat_or)

(defun scansubpat_and (recv fun ctx)
  (let ( (conjtup (unsafe_get_field :andpat_conj recv)) )
    (foreach_in_multiple
     (conjtup)
     (curconj :long cix)
     (fun curconj ctx))))
(install_method class_source_pattern_and scan_subpatterns scansubpat_and)


(defun scansubpat_construct (recv fun ctx)
  (let ( (subpatup (unsafe_get_field :ctpat_subpa recv)) )
    (foreach_in_multiple
     (subpatup)
     (curpa :long pix)
     (fun curpa ctx))))
(install_method class_source_pattern_construct scan_subpatterns scansubpat_construct)

(defun scansubpat_object (recv fun ctx)
  (let ( (patfieltup (unsafe_get_field :spat_fields recv)) )
    (foreach_in_multiple
     (patfieltup)
     (curpatfld :long flix)
     (if (is_a curpatfld class_source_field_pattern)
	 (fun (unsafe_get_field :spaf_pattern curpatfld) ctx)))))
(install_method class_source_pattern_object scan_subpatterns scansubpat_object)

(defun scansubpat_composite (recv fun ctx)
  (let ( (outup (unsafe_get_field :spac_outargs recv)) )
    (foreach_in_multiple
     (outup)
     (curout :long oix)
     (fun curout ctx))))
(install_method class_source_pattern_construct scan_subpatterns scansubpat_composite)


(defun fill_matchcase (curmcase sloc)
  (debug_msg curmcase "fill_matchcase curmcase")
  (assert_msg "check curmcase" (is_a curmcase class_match_case))
  (let (
	(ourpatvarmap (make_mapobject discr_map_objects 17))
	(curscas (unsafe_get_field :mcase_source curmcase))
	(curpat (unsafe_get_field :scam_patt curscas))
	)
    (letrec (
	     (varpatscanner 
	      (lambda (pat patvarmap)
		(debug_msg pat "fill_matchcase/varpatscanner pat")
		(if (is_a pat class_source_pattern_variable)
		    (let (
			  (pvarsymb (unsafe_get_field :spatvar_symb pat))
			  (varocclist (mapobject_get patvarmap pvarsymb))
			  )
		      (if (null varocclist)
			  (progn 
			    (setq varocclist (make_list discr_list))
			    (mapobject_put patvarmap pvarsymb varocclist)))
		      (list_append varocclist pat)
		      ))
		))
	     )
	    (varpatscanner curpat ourpatvarmap)
	    (scan_subpatterns curpat varpatscanner ourpatvarmap)
	    )
    (debug_msg ourpatvarmap "fill_matchcase ourpatvarmap")
    (unsafe_put_fields curmcase :mcase_varmap ourpatvarmap)
    ))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;; the selectors to set the then & else part of a match step
(defselector put_then_match class_selector
  :doc #{Put the then part of a match test $RECV to $THENSTEP.}#
  :formals (recv thenstep)
)

(defun start_step (step)
  (cond 
   ( (null step)
     (return)
     )
   ( (is_a step class_match_step_test_group)
     (let ( (stastep (unsafe_get_field :mstgroup_start step))
	    )
       (debug_msg step "start_step group step")
       (debug_msg stastep "stastep return stastep")
       (assert_msg "check stastep" (is_a stastep class_match_step))
       (return stastep)))
   (:else
    (debug_msg step "start_step ordinary step")
    (assert_msg "check step" (is_a step class_match_step))
    (return step))))



(defun putthen_matchthen (recv thenstep)
  (debug_msg recv "putthen_matchthen recv")
  (assert_msg "check recv" (is_a recv class_match_step_then))
  (debug_msg thenstep "putthen_matchthen thenstep")
  (assert_msg "check thenstep" (is_a thenstep class_match_step))
  (assert_msg "check recv!=then" (!= recv thenstep))
  (compile_warning "temporary check for application depth..."
		   (assert_msg "putthen_matchthen check shallow100" 
			       (melt_application_shallower 100)))
  (compile_warning "temporary backtrace when test_instance...."
		   (if (is_a recv class_match_step_test_instance)
		       (shortbacktrace_dbg "putthen_matchthen testinstance!!!" 20)))
  (let ( (mythen (unsafe_get_field :mstep_then recv))
	 (starthen  (start_step thenstep))
	 )
    (if (== recv starthen)
	(progn
	  (debug_msg starthen "putthen_matchthen recv same starthen")
	  (return)))
    (if (== mythen starthen)
	(progn
	  (debug_msg starthen "putthen_matchthen mythen same starthen")
	  (return)))
    (if (null mythen)
	(progn
	  (unsafe_put_fields recv :mstep_then starthen)
	  (debug_msg recv "putthen_matchthen updated recv")
	  (shortbacktrace_dbg "putthen_matchthen" 12)
	  )
      (progn
	(debug_msg mythen "putthen_matchthen recursing in mythen")
	(debug_msg starthen "putthen_matchthen recursing for starthen")
	(put_then_match mythen starthen)
	(debug_msg mythen "putthen_matchthen did mythen"))))
  )
(install_method class_match_step_then put_then_match putthen_matchthen)



(defun putthen_matchgroup (recv thenstep)
  (debug_msg recv "putthen_matchgroup recv")
  (assert_msg "check recv" (is_a recv class_match_step_test_group))
  (debug_msg thenstep "putthen_matchgroup thenstep")
  (assert_msg "check thenstep" (is_a thenstep class_match_step))
  (putthen_matchthen recv thenstep)
  (let ( (thengroup (unsafe_get_field :mstgroup_then recv)) )
    (cond 
     ((null thengroup)
      (return))
     ((is_a thengroup class_match_step)
      (put_then_match thengroup thenstep))
     ((is_list thengroup)
      (foreach_in_list
       (thengroup)
       (curpair curthen)
       (put_then_match curthen thenstep)))
     ((is_multiple thengroup)
      (foreach_in_multiple
       (thengroup)
       (curthen :long thix)
       (put_then_match curthen thenstep)))
     (:else
      (debug_msg thengroup "putthen_matchgroup bad thengroup")
      (assert_msg "bad thengroup" ())))))
(install_method class_match_step_test_group put_then_match putthen_matchgroup)


(defselector put_else_match class_selector
  :doc #{Put the else part of a match test $RECV to $ELSESTEP.}#
  :formals (recv elsestep)
)

;; method to putelse inside then-steps
(defun putelse_matchstepthen (recv elsestep)
  (debug_msg recv "putelse_matchstepthen recv")
  (assert_msg "check recv" (is_a recv class_match_step_then))
  (debug_msg elsestep "putelse_matchstepthen elsestep")
  (assert_msg "check elsestep" (is_a elsestep class_match_step))
  (compile_warning "temporary check for application depth..."
		   (assert_msg "putelse_matchstepthen check shallow100" 
			       (melt_application_shallower 100)))
  (let ( 
	(mythen (unsafe_get_field :mstep_then recv))
	(elsestart (start_step elsestep))
	)
    (cond 
     ( (== recv elsestart)
       (debug_msg recv "putelse_matchstepthen recv same elsestart")
       (return))
     ( (== mythen elsestep)
       (debug_msg mythen "putelse_matchstepthen mythen same elsestep")
       (return))
     ( (== mythen elsestart)
       (debug_msg mythen "putelse_matchstepthen mythen same elsestart")
       (return))
     (mythen 
      (debug_msg mythen "putelse_matchstepthen recursing in mythen")
      (debug_msg elsestart "putelse_matchstepthen recursing for elsestart")
      (debug_msg recv "putelse_matchstepthen recursing from recv")
      (put_else_match mythen elsestart)
      (debug_msg mythen "putelse_matchstepthen done recursing in mythen"))
     )
  (debug_msg recv "putelse_matchstepthen end recv")))

(install_method class_match_step_then put_else_match putelse_matchstepthen)

	  
;; method to putelse inside tests
(defun putelse_matchtest (recv elsestep)
  (debug_msg recv "putelse_matchtest recv")
  (assert_msg "check recv" (is_a recv class_match_step_test))
  (debug_msg elsestep "putelse_matchtest elsestep")
  (assert_msg "check elsestep" (is_a elsestep class_match_step))
  (compile_warning "temporary check for application depth..."
		   (assert_msg "putelse_matchtest check shallow100" 
			       (melt_application_shallower 100)))
  (let ( 
	(myelse (unsafe_get_field :mstep_else recv))
	(mythen (unsafe_get_field :mstep_then recv))
	(elsestart (start_step elsestep))
	)
    (cond 
     ( (== recv elsestep)
       (debug_msg recv "putelse_matchtest recv same as elsestep")
       (return))
     ( (== recv elsestart)
       (debug_msg recv "putelse_matchtest recv same as elsestart")
       (return))
     ( (== myelse elsestart)
       (debug_msg recv "putelse_matchtest myelse same as elsestart")
       (return))
     ( (== myelse elsestep)
       (debug_msg recv "putelse_matchtest myelse same as elsestep")
       (return))
     ( (== mythen elsestep)
       (debug_msg recv "putelse_matchtest mythen same as elsestep")
       (return))
     ( (== mythen elsestart)
       (debug_msg recv "putelse_matchtest mythen same as elsestart")
       (return))
     ( (null myelse)
       (unsafe_put_fields recv :mstep_else elsestart)
       (debug_msg recv "putelse_matchtest updated recv")
       (shortbacktrace_dbg "putelse_matchtest" 12)
       )
     (:else
      (debug_msg myelse "putelse_matchtest myelse appending then")
      (put_then_match myelse elsestart)
      )
     )
    (if mythen
	(progn
	  (debug_msg mythen "putelse_matchtest recursing in mythen")
	  (debug_msg elsestart "putelse_matchtest recursing with elsestart")
	  (put_else_match mythen elsestart)))
    ;;
    (debug_msg recv "putelse_matchtest end recv")
    ))
(install_method class_match_step_test put_else_match putelse_matchtest)


;;;;;;;;;;;;;;;;
(defun putelse_matchgroup (recv elsestep)
  (debug_msg recv "putelse_matchgroup recv")
  (assert_msg "check recv" (is_a recv class_match_step_test_group))
  (debug_msg elsestep "putelse_matchgroup elsestep")
  (assert_msg "check elsestep" (is_a elsestep class_match_step))
  (let ( (elsegroup (unsafe_get_field :mstgroup_else recv)) 
	 (elsestart (start_step elsestep))
	 (startgroup (unsafe_get_field :mstgroup_start recv))
	 )
    (debug_msg elsestart "putelse_matchgroup elsestart")
    (if startgroup
	(progn
	  (debug_msg startgroup "putelse_matchgroup recursing startgroup")
	  (put_else_match startgroup elsestart)
	  ))
    (debug_msg elsegroup "putelse_matchgroup elsegroup")
    (cond 
     ((null elsegroup)
      ())
     ((is_a elsegroup class_match_step)
      (debug_msg elsegroup "putelse_matchgroup elsegroup step")
      (put_else_match elsegroup elsestart))
     ((is_list elsegroup)
      (foreach_in_list
       (elsegroup)
       (curpair curelse)
       (debug_msg curelse "putelse_matchgroup curelse from list")
       (put_else_match curelse elsestart)))
     ((is_multiple elsegroup)
      (foreach_in_multiple
       (elsegroup)
       (curelse :long thix)
       (debug_msg curelse "putelse_matchgroup curelse from tuple")
       (put_else_match curelse elsestart)))
     (:else
      (debug_msg elsegroup "putelse_matchgroup bad elsegroup")
      (assert_msg "bad elsegroup" ())))
    (debug_msg recv "putelse_matchgroup end recv")
    ))
(install_method class_match_step_test_group put_else_match putelse_matchgroup)



(defun scanstepdata_testins (step fun ctx)
  (assert_msg "check step" (is_a step class_match_step_test_instance))
  (let ( (slotup (unsafe_get_field :mstins_slots step)) 
	 )
    (foreach_in_multiple 
     (slotup)
     (curslot :long ix)
     (if curslot 
	 (fun curslot ctx)))))
(install_method class_match_step_test_instance scan_step_data scanstepdata_testins)

(defun scanstepdata_testmatcher (step fun ctx)
  (assert_msg "check step" (is_a step class_match_step_test_matcher))
  (let ( (outs (unsafe_get_field :mstma_outs step)) 
	 )
    (foreach_in_multiple
     (outs)
     (curout :long outix)
     (if curout (fun curout ctx)))
    ))
(install_method class_match_step_test_matcher scan_step_data scanstepdata_testmatcher)

(defun scanstepflag_stepwithflag (step fun ctx)
  (assert_msg "check step" (is_a step class_match_step_with_flag))
  (let ( (flag (unsafe_get_field :mstep_flag step)) 
	 )
    (if flag (fun flag ctx))
    ))
(install_method class_match_step_with_flag scan_step_flag 
		scanstepflag_stepwithflag)

(defun scanstepflag_stepflagoper (step fun ctx)
  (assert_msg "check step" (is_a step class_match_step_flag_operation))
  (let ( (flag (unsafe_get_field :mstep_flag step))
	 (flagargs (unsafe_get_field :mstep_flagargs step))
	 )
    (if flag (fun flag ctx))
    (if flagargs
	(foreach_in_multiple 
	 (flagargs) 
	 (curflag :long flagix) 
	 (fun curflag ctx)))
    ))

(install_method class_match_step_flag_operation scan_step_flag
		scanstepflag_stepflagoper)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;; the selector to translate a pattern
(defselector translate_pattern class_selector
  :doc #{Translate a pattern into a match step. $RECV is the reciever,
  $MDATA is the matched data, $MCASE is the match case, and $SLOC is
  the source location. Returns the match step and secundarily the match flag.}#
  :formals (recv mdata mcase varmap sloc))


(defun translpat_anyrecv (recv mdata mcase varmap sloc)
  (debug_msg recv "translpat_anyrecv recv")
  (debug_msg mdata "translpat_anyrecv mdata")
  (let ( (dis (discrim recv)) )
    (debug_msg dis "translpat_anyrecv dis")
    (error_strv sloc "unexpected TRANSLATE_PATTERN for" (unsafe_get_field :named_name dis))
    (assert_msg "@$@unexpected translpat_anyrecv")
))
(install_method discr_any_receiver translate_pattern translpat_anyrecv)

(defun translpat_jokerpat (recv mdata mcase varmap sloc)
  (assert_msg "check recv" (is_a recv class_source_pattern_joker_variable))
  (debug_msg recv "translpat_jokerpat recv")
  (return)
)
(install_method class_source_pattern_joker_variable translate_pattern translpat_jokerpat)


(defun translpat_constpat (recv mdata mcase varmap sloc)
  (assert_msg "check recv" (is_a recv class_source_pattern_constant))
  (debug_msg recv "translpat_constpat recv")
  (error_plain sloc "@@unimplemented translpat_constpat")
  (assert_msg "$@$ translpat_constpat unimplemented")
)
(install_method class_source_pattern_constant translate_pattern translpat_constpat)


(defun translpat_tuplepat (recv mdata mcase varmap sloc)
  (assert_msg "check recv" (is_a recv class_source_pattern_tuple))
  (debug_msg recv "translpat_tuplepat recv")
  (error_plain sloc "@@unimplemented translpat_tuplepat")
  (assert_msg "$@$ translpat_tuplepat unimplemented")
)
(install_method class_source_pattern_tuple translate_pattern translpat_tuplepat)


(defun translpat_listpat (recv mdata mcase varmap sloc)
  (assert_msg "check recv" (is_a recv class_source_pattern_list))
  (debug_msg recv "translpat_listpat recv")
  (error_plain sloc "@@unimplemented translpat_listpat")
  (assert_msg "$@$ translpat_listpat unimplemented")
)
(install_method class_source_pattern_list translate_pattern translpat_listpat)



(defun translpat_inspat (recv mdata mcase varmap psloc)
  (debug_msg recv "translpat_inspat recv")
  (assert_msg "check recv" (is_a recv class_source_pattern_instance))
  (debug_msg mdata "translpat_inspat mdata")
  (assert_msg "check mdata" (is_a mdata class_matched_data))
  (debug_msg mcase "translpat_inspat mcase")
  (assert_msg "check mcase" (is_a mcase class_match_case))
  (let ( 
	(pclass (unsafe_get_field :spat_class recv))
	(pfields (unsafe_get_field :spat_fields recv))
	(sloc (or (unsafe_get_field :loca_location recv) psloc))
	(mctxt (unsafe_get_field :mcase_mctxt mcase))
	)
    (assert_msg "check pclass" (is_a pclass class_class))
    (let ( (:long nbfields (multiple_length (unsafe_get_field :class_fields pclass)))
	   (mflag (make_match_flag recv mctxt (get_field :named_name pclass)))
	   )
      ;; check that each mentioned field is indeed a field of the class
      (foreach_in_multiple
       (pfields)
       (curpfld :long pix)
       (assert_msg "check curpfld" (is_a curpfld class_source_field_pattern))
       (let ( (fsloc (or (unsafe_get_field :loca_location curpfld) sloc))
	      (curfld (unsafe_get_field :spaf_field curpfld))
	      (flcla (get_field :fld_ownclass curfld))
	      )
	 (assert_msg "check curfld" (is_a curfld class_field))
	 (cond ( (not (subclass_or_eq pclass flcla))
		 (error_strv sloc "bad field in object pattern"
			     (unsafe_get_field :named_name curfld))
		 (inform_strv sloc "class in pattern is" (get_field :named_name pclass))
		 (inform_strv sloc "class of field is" (get_field :named_name flcla))
		 (return)))
	 ))
      ;; find our step if its exist or else create it, also find the
      ;; last test step to add our new test in its else case
      (let ( (istep ())
	     (laststeptest ())
	     (steplist (unsafe_get_field :mdata_steps mdata))
	     )
	(foreach_in_list
	 (steplist)
	 (curpair curstep)
	 (cond 
	  ( (and (is_a curstep class_match_step_test_instance)
		 (== (unsafe_get_field :mstins_class curstep) pclass))
	    (setq curpair ())
	    (setq istep curstep)
	    )
	  ( (is_a curstep class_match_step_test)
	    (setq laststeptest curstep))
	  ))
	(debug_msg laststeptest "translpat_inspat laststeptest")
	;;
	(if (null istep)
	    (let 
		( 
		 (dslots (make_multiple discr_multiple nbfields))
		 (newstep (instance class_match_step_test_instance
				    :loca_location sloc
				    :mstep_data mdata
				    :mstep_then ()
				    :mstep_else ()
				    :mstins_class pclass
				    :mstins_slots dslots
				    ))
		 )
	      (setq istep newstep)
	      (debug_msg newstep "translpat_inspat newstep")
	      (list_append steplist newstep)
	      (debug_msg steplist "translpat_inspat updated steplist")
	      (if laststeptest
		  (progn 
		    (put_else_match laststeptest newstep)
		    (debug_msg laststeptest "translpat_inspat updated laststeptest")))
	      ))
	;; translate each mentioned non-joker field 
	(let ( (mslots (unsafe_get_field :mstins_slots istep))
	       (laststep istep)
	       (flaglist (make_list discr_list))
	       (elselist (make_list discr_list))
	       )
	  (assert_msg "check mslots" (is_multiple mslots))
	  (list_append elselist istep)
	  (foreach_in_multiple
	   (pfields)
	   (curpfld :long pix)
	   (assert_msg "check curpfld" (is_a curpfld class_source_field_pattern))
	   (let ( (fsloc (or (unsafe_get_field :loca_location curpfld) sloc))
		  (curfld (unsafe_get_field :spaf_field curpfld))
		  (curfpat (unsafe_get_field :spaf_pattern curpfld))
		  )
	     (if (is_not_a curfpat class_source_pattern_joker_variable)
		 (let ( (:long curfix (get_int curfld))
			(curslotdata (multiple_nth mslots curfix))
			)
		   (if (null curslotdata)
		       (let ( (newslot (instance class_matched_data
						 :mdata_symb (clone_symbol curfld)
						 :mdata_ctype ctype_value
						 :mdata_orig istep
						 :mdata_steps (make_list discr_list)
						 )) 
			      )
			 (debug_msg newslot " translpat_inspat newslot")
			 (setq curslotdata newslot)
			 (multiple_put_nth mslots curfix newslot)))
		   (debug_msg curfpat "translpat_inspat before translation curfpat")
		   (multicall
		    (flstep flflag)
		    (translate_pattern curfpat curslotdata mcase varmap psloc) 
		    (debug_msg flstep "translpat_inspat flstep")
		    (debug_msg flflag "translpat_inspat flflag")
		    (if flstep 
			(progn
			  (debug_msg laststep "translpat_inspat laststep")
			  (put_then_match laststep flstep)
			  (list_append elselist flstep)
			  (setq laststep flstep)
			  ))
		    (if flflag
			(list_append flaglist flflag))
		    )))))
	  (debug_msg elselist "translpat_inspat elselist")
	  (let ( 
		(stepsetflag
		 (if (list_first_element flaglist)
		     (instance class_match_step_flag_conjonction
			       :loca_location sloc
			       :mstep_data mdata
			       :mstep_then ()
			       :mstep_flag mflag
			       :mstep_flagargs (list_to_multiple flaglist discr_multiple))
		   (instance class_match_step_flag_set
			     :loca_location sloc
			     :mstep_data mdata
			     :mstep_then ()
			     :mstep_flag mflag)))
		(stepgroup (instance class_match_step_test_group
				     :loca_location sloc
				     :mstep_data mdata
				     :mstep_then ()
				     :mstep_else ()
				     :mstgroup_start istep
				     :mstgroup_then stepsetflag
				     :mstgroup_else (list_to_multiple elselist discr_multiple)
				     ))
		)
	    (put_fields mflag :mflag_setstep stepsetflag)
	    (debug_msg stepsetflag  "translpat_inspat stepsetflag")
	    (put_then_match laststep stepsetflag)
	    (debug_msg stepgroup "translpat_inspat return stepgroup")
	    (return stepgroup mflag)
	    ))))))
(install_method class_source_pattern_instance translate_pattern translpat_inspat)




(defun translpat_varpat (recv mdata mcase varmap psloc)
  (debug_msg recv "translpat_varpat recv")
  (assert_msg "check recv" (is_a recv class_source_pattern_variable))
  (debug_msg mdata "translpat_varpat mdata")
  (assert_msg "check mdata" (is_a mdata class_matched_data))
  (debug_msg mcase "translpat_varpat mcase")
  (assert_msg "check mcase" (is_a mcase class_match_case))
  (let ( 
	(sloc (or (unsafe_get_field :loca_location recv) psloc))
	(symb (unsafe_get_field :spatvar_symb recv))
	(matctx (unsafe_get_field  :mcase_mctxt mcase))
	(symbval (mapobject_get varmap symb))
	(mhandlers (get_field :mctx_varhandlers matctx))
	(steplist (unsafe_get_field :mdata_steps mdata))
	(mctxt (unsafe_get_field :mcase_mctxt mcase))
	(mflag (make_match_flag recv mctxt (get_field :named_name symb)))
	(flagstep (instance class_match_step_flag_set 
			    :loca_location sloc
			    :mstep_data mdata
			    :mstep_then ()
			    :mstep_flag mflag))
	)
    (debug_msg symb "translpat_varpat symb")
    (debug_msg symbval "translpat_varpat symbval")
    (put_fields mflag :mflag_setstep flagstep)
    (debug_msg flagstep "translpat_varpat flagstep")
    (cond 
     ( (null symbval)
       (mapobject_put varmap symb mdata)
       (debug_msg varmap "translpat_varpat updated varmap & return null")
       (list_append steplist flagstep)
       (foreach_in_list
	(mhandlers)
	(curpair curhandler)
	(curhandler recv mdata mcase symbval flagstep mflag sloc))
       (debug_msg flagstep "translpat_varpat return flagstep")
       (return flagstep mflag)
       )
     (:else
      (assert_msg "check symbval" (is_a symbval class_matched_data))
      (let ( (laststeptest ())
	     )
	(foreach_in_list
	 (steplist)
	 (curpair curteststep)
	 (cond
	  ( (and (is_a curteststep class_match_step_test_variable)
		 (== (unsafe_get_field :msteptestvar_data curteststep) symbval)
		 (== (unsafe_get_field :mstep_data curteststep) mdata))
	    (progn
	      (debug_msg curteststep "translpat_varpat found curteststep")
	      (put_then_match curteststep flagstep)
	      (foreach_in_list
	       (mhandlers)
	       (curpair curhandler)
	       (curhandler recv mdata mcase symbval curteststep mflag sloc))
	      (return curteststep mflag)))
	  ( (is_a curteststep class_match_step_test)
	    (setq laststeptest curteststep))
	  )
	 )
	(debug_msg laststeptest "translpat_varpat laststeptest")
	(let ( (steptest (instance class_match_step_test_variable
				   :loca_location sloc
				   :mstep_data mdata
				   :mstep_then flagstep
				   :msteptestvar_data symbval
				   ))
	       )
	  (list_append steplist steptest)
	  (debug_msg steptest "translpat_varpat made steptest")
	  (if laststeptest
	      (progn
		(put_else_match laststeptest steptest)
		(debug_msg laststeptest "translpat_varpat updated laststeptest")))
	  (foreach_in_list
	   (mhandlers)
	   (curpair curhandler)
	   (curhandler recv mdata mcase symbval steptest mflag sloc))
	  (debug_msg steptest "translpat_varpat return steptest")
	  (return steptest mflag)
	  ))))
    ))
(install_method class_source_pattern_variable translate_pattern translpat_varpat)



;;;;;;;;;;;;;;;;
;;; translation of and-patterns
(defun translpat_andpat (recv mdata mcase varmap psloc)
  (debug_msg recv "translpat_andpat recv")
  (assert_msg "check recv" (is_a recv class_source_pattern_and))
  (debug_msg mdata "translpat_andpat mdata")
  (assert_msg "check mdata" (is_a mdata class_matched_data))
  (debug_msg mcase "translpat_andpat mcase")
  (assert_msg "check mcase" (is_a mcase class_match_case))
  (let (
	(sloc (or (unsafe_get_field :loca_location recv) psloc))
	(sconj (unsafe_get_field :andpat_conj recv))
	(curstep ())
	(firststep ())
	(thenlist (make_list discr_list))
	(elselist (make_list discr_list))
	(flaglist (make_list discr_list))
	(mctxt (unsafe_get_field :mcase_mctxt mcase))
	(stepgroup (instance class_match_step_test_group
			     :loca_location sloc
			     :mstep_data mdata
			     :mstgroup_start ()
			     :mstgroup_then ()
			     :mstgroup_else ()
			     ))
	(mflag (make_match_flag recv mctxt '"and"))
	(flagstep (instance class_match_step_flag_conjonction
			    :loca_location sloc
			    :mstep_data mdata
			    :mstep_then ()
			    :mstep_flag mflag
			    ))
	)
    (assert_msg "check sconj" (is_multiple sconj))
    (debug_msg flagstep "translpat_andpat flagstep")
    (put_fields mflag :mflag_setstep flagstep)
    (foreach_in_multiple
     (sconj)
     (curconj :long conjix)
     (debug_msg curconj "translpat_andpat curconj")
     (multicall 
      (conjstep conjflag)
      (translate_pattern curconj mdata mcase varmap sloc)
      (debug_msg conjstep "translpat_andpat conjstep")
      (debug_msg conjflag "translpat_andpat conjflag")
      (if conjstep
	  (progn
	    (if (null curstep)
		(progn
		  (setq firststep conjstep)
		  (debug_msg firststep "translpat_andpat firststep")
		  (list_append thenlist firststep)
		  )
	      (progn
		(debug_msg curstep "translpat_andpat curstep")
		(put_then_match curstep conjstep)
		)
	      )
	    (list_append elselist conjstep)
	    (setq curstep conjstep)
	    )
	)
      (if conjflag
	  (progn
	    (assert_msg "check conjflag" (is_a conjflag class_match_flag))
	    (list_append flaglist conjflag)))
      ))
    (unsafe_put_fields stepgroup
		       :mstgroup_start firststep
		       :mstgroup_then (list_to_multiple thenlist discr_multiple)
		       :mstgroup_else (list_to_multiple elselist discr_multiple))
    (cond ( (null firststep)
	    ;; this happens only for degenerate conjonctions like ?(and ?_)
	    (warning_plain sloc "degenerate ?(AND ...) pattern")
	    (return)
	  )
	  )
    (put_fields flagstep :mstep_flagargs (list_to_multiple flaglist discr_multiple))
    (put_then_match stepgroup flagstep)
    (debug_msg stepgroup "translpat_andpat return stepgroup")
    (return stepgroup mflag)
    ))
(install_method class_source_pattern_and translate_pattern translpat_andpat)



;;; translation of or-patterns
(defun translpat_orpat (recv  mdata mcase varmap psloc)
  (debug_msg recv "translpat_orpat recv")
  (assert_msg "check recv" (is_a recv class_source_pattern_or))
  (debug_msg mdata "translpat_orpat mdata")
  (assert_msg "check mdata" (is_a mdata class_matched_data))
  (debug_msg mcase "translpat_orpat mcase")
  (assert_msg "check mcase" (is_a mcase class_match_case))
  (let (
	(firststep ())
	(prevstep ())
	(sloc (or (unsafe_get_field :loca_location recv) psloc))
	(sdisj (unsafe_get_field :orpat_disj recv))
	(mctxt (unsafe_get_field :mcase_mctxt mcase))
	(mhandlers (get_field :mctx_varhandlers mctxt))
	(stepgroup (instance class_match_step_test_group
			     :loca_location sloc
			     :mstep_data mdata
			     :mstgroup_start ()
			     :mstgroup_then ()
			     :mstgroup_else ()
			     ))
	(mflag (make_match_flag recv mctxt '"or"))
	(flagstep (instance class_match_step_flag_disjonction
			    :loca_location sloc
			    :mstep_data mdata
			    :mstep_then ()
			    :mstep_flag mflag
			    ))
	(flaglist (make_list discr_list))
	(steplist (make_list discr_list))
	)
    (debug_msg flagstep "translpat_orpat flagstep")
    (assert_msg "check sdisj" (is_multiple sdisj))
    (foreach_in_multiple
     (sdisj)
     (curdisj :long disjix)
     (debug_msg curdisj "translpat_orpat curdisj")
     (let (
	   (newvarmap (make_mapobject discr_map_objects 11))
	   (varhandler
	    (lambda 
	      (varpat varmdata varmcase varsymbval varflagstep varmflag varsloc)
	      (debug_msg varpat "translpat_orpat.varhandler varpat")
	      (debug_msg varmdata "translpat_orpat.varhandler varmdata")
	      (assert_msg "check varpat" (is_a varpat class_source_pattern_variable))
	      (assert_msg "check varmdata" (is_a varmdata class_matched_data))
	      (if (null varsymbval)
		  (progn
		    (mapobject_put newvarmap (get_field :spatvar_symb varpat)
				   varmdata)
		    (debug_msg newvarmap "translpat_orpat.varhandler updated newvarmap")
		    ))
	      ))
	   )
       (list_prepend mhandlers varhandler)
       (debug_msg curdisj "translpat_orpat curdisj before translate_pattern")
       (multicall 
	(disjstep disjflag)
	(translate_pattern curdisj mdata mcase varmap sloc)
	(debug_msg disjstep "translpat_orpat disjstep")
	(debug_msg disjflag "translpat_orpat disjflag")
	(if disjflag
	    (list_append flaglist disjflag))
	(if disjstep
	    (progn 
	      (cond 
	       ( (is_a prevstep class_match_step_clear)
		 (debug_msg prevstep "translpat_orpat prevstep clear so putthen")
		 (put_then_match prevstep disjstep))
	       ( prevstep
		 (debug_msg prevstep "translpat_orpat prevstep notnull so putelse")
		 (put_else_match prevstep disjstep)))
	      (if (>i (mapobject_count newvarmap) 0)
		  (let ( 
			(sortedsymbs (mapobject_sorted_attribute_tuple newvarmap))
			(sortedmdatas
			 (multiple_map 
			  sortedsymbs
			  (lambda (cursymb :long symbix)
			    (mapobject_get newvarmap cursymb)) 
			  ))
			(erasestep (instance class_match_step_clear
					     :loca_location (get_field :loca_location disjstep)
					     :mstep_then ()
					     :mstep_cleardata sortedmdatas
					     )
				   )
			)
		    (debug_msg erasestep "translpat_orpat erasestep")
		    (put_else_match disjstep erasestep)
		    (setq prevstep erasestep)
		    (debug_msg prevstep "translpat_orpat prevstep is erasestep")
		    )
		(progn
		  (setq prevstep disjstep)
		  (debug_msg prevstep "translpat_orpat prevstep is disjstep")
		  ))
	      (list_append steplist disjstep)
	      ))
	)
       (debug_msg newvarmap "translpat_orpat newvarmap")
       (let ( (oldvarhdler (list_popfirst mhandlers)) 
	      )
	 (assert_msg "check oldvarhdler" (== oldvarhdler varhandler))
	 ))
     ) ;;;; end foreach disjunct
    (debug_msg steplist "translpat_orpat final steplist")
    (put_fields stepgroup
		:mstgroup_start firststep
		:mstgroup_then (list_to_multiple steplist)
		:mstgroup_else ()
		)
    (debug_msg flaglist "translpat_orpat final flaglist")
    (put_fields flagstep :mstep_flagargs (list_to_multiple flaglist discr_multiple))
    (debug_msg flagstep "translpat_orpat final flagstep")
    (put_then_match stepgroup flagstep)
    (debug_msg stepgroup "translpat_orpat return stepgroup")
    (return stepgroup mflag)
    ))
(install_method class_source_pattern_or translate_pattern translpat_orpat)



;;;;;;;;;;;;;;;;
;; translation of pattern matchers (c-matchers or fun-matchers)
(defun translpat_patmat (recv mdata mcase varmap psloc)
  (debug_msg recv "translpat_patmat recv")
  (assert_msg "check recv" (is_a recv class_source_pattern_matcher))
  (debug_msg mdata "translpat_patmat mdata")
  (assert_msg "check mdata" (is_a mdata class_matched_data))
  (debug_msg mcase "translpat_patmat mcase")
  (assert_msg "check mcase" (is_a mcase class_match_case))
  (let (
	(sloc (or (unsafe_get_field :loca_location recv) psloc))
	(sopbind (unsafe_get_field :spac_operbind recv))
	(soper (unsafe_get_field :spac_operator recv))
	(sins (unsafe_get_field :spac_inargs recv))
	(souts (unsafe_get_field :spac_outargs recv))
	(matctx (unsafe_get_field  :mcase_mctxt mcase))
	(env (get_field :mctx_env matctx))
	(ncx (get_field :mctx_normctxt matctx))
	(opin (get_field :amatch_in soper))
	(opout (get_field :amatch_out soper))
	(:long nbopout (multiple_length opout))
	(curstep ())
	(mdatasteps (unsafe_get_field :mdata_steps mdata))
	(mflag (make_match_flag recv matctx (get_field :named_name soper)))
	)
    (assert_msg "check matctx" (is_a matctx class_matching_context))
    (assert_msg "check env" (is_a env class_environment))
    (debug_msg soper "translpat_patmat soper")
    (assert_msg "check soper" (is_a soper class_any_matcher))
    (debug_msg sins "translpat_patmat sins")
    (debug_msg souts "translpat_patmat souts")
    (debug_msg sopbind "translpat_patmat sopbind")
    (multicall
     (nins inbinds)
     (normalize_tuple sins env ncx sloc)
     (debug_msg nins "translpat_patmat nins")
     (debug_msg inbinds "translpat_patmat inbinds")
     (assert_msg "check inbinds" (is_list_or_null inbinds))
     (if (!=i (multiple_length nins) (multiple_length opin))
	 (error_strv sloc "bad input arity of matcher in pattern" 
		     (get_field :named_name soper)))
     (foreach_in_multiple
      (nins)
      (curnin :long nix)
      (let ( (curopin (multiple_nth opin nix))
	     (curctyp (get_ctype curnin env))
	     (inctyp (get_field :fbind_type curopin))
	     )
	(debug_msg curnin "translpat_patmat curnin")
	(debug_msg curopin "translpat_patmat curopin")
	(debug_msg curctyp "translpat_patmat curctyp")
	(assert_msg "check curopin" (is_a curopin class_formal_binding))
	(assert_msg "check curctyp" (is_a curctyp class_ctype))
	(if (!= curctyp inctyp)
	    (progn
	      (error_strv sloc "bad input type in matcher, expecting"
			  (get_field :named_name inctyp))
	      (error_strv sloc
			  "mistyped formal name in matcher is"
			  (get_field  :named_name (get_field :binder curopin)))
	      (error_strv sloc "got input type in matcher" 
			  (get_field :named_name curctyp))
	      (return)))
	))
     ;; try to find the same test step, and the last test for this mdata
     (let (
	   (laststeptest ())
	   )
       (foreach_in_list
	(mdatasteps)
	(curpairstep curdatastep)
	(assert_msg "check curdatastep" (is_a curdatastep class_match_step))
	(if (is_a curdatastep class_match_step_test)
	    (setq laststeptest curdatastep))
	(if (and
	     (is_a curdatastep class_match_step_test_matcher)
	     (== (unsafe_get_field :mstep_data curdatastep) mdata)
	     (== (unsafe_get_field :mstma_matcher curdatastep) soper)
	     (==i (list_length inbinds) 0)
	     (==i (list_length (unsafe_get_field :mstma_binds curdatastep)) 0)
	     )
	    (let ( (similarstep curdatastep)
		   (curins (unsafe_get_field :mstma_ins curdatastep))
		   )
	      (foreach_in_multiple
	       (curins)
	       (cursimin :long simix)
	       (if (!= (multiple_nth nins simix) cursimin)
		   (progn
		     (setq simix -1)
		     (setq cursimin ())
		     (setq similarstep ())))
	       )
	      (debug_msg similarstep "translpat_patmat similiarstep")
	      (if similarstep 
		  (progn
		    (setq curstep similarstep)
		    (setq curpairstep ())
		    (setq curdatastep ())))
	      ))
	)
       (debug_msg curstep "translpat_patmat custep after seeking")
       (if (null curstep)
	   (let ( 
		 (outdatatup (make_multiple discr_multiple nbopout))
		 (newstep (instance class_match_step_test_matcher
				    :loca_location sloc
				    :mstep_data mdata
				    :mstep_then ()
				    :mstep_else ()
				    :mstma_matcher soper
				    :mstma_binds inbinds
				    :mstma_ins nins
				    :mstma_outs outdatatup))
		 )
	     (setq curstep newstep)
	     (debug_msg newstep "translpat_patmat newstep")
	     (list_append mdatasteps newstep)
	     (debug_msg mdatasteps "translpat_patmat updated mdatasteps")
	     (if laststeptest
		 (progn
		   (put_else_match laststeptest newstep)
		   (debug_msg laststeptest "translpat_patmat updated laststeptest")))
	     (foreach_in_multiple
	      (opout)
	      (curoutbind :long outix)
	      (debug_msg curoutbind "translpat_patmat curoutbind")
	      (assert_msg "check curoutbind" (is_a curoutbind class_formal_binding))
	      (let ( (outsymb (get_field :binder curoutbind))
		     (outctyp (get_field :fbind_type curoutbind))
		     (newslot (instance class_matched_data
					:mdata_symb (clone_symbol outsymb)
					:mdata_ctype outctyp
					:mdata_orig newstep
					:mdata_steps (make_list discr_list)))
		     )
		(debug_msg outsymb "translpat_patmat outsymb")
		(debug_msg newslot "translpat_patmat newslot")
		(multiple_put_nth outdatatup outix newslot)
		(assert_msg "check outctyp" (is_a outctyp class_ctype))
		))
	     ))
       (debug_msg curstep "translpat_patmat curstep after making it")
       (assert_msg "check curstep" (is_a curstep class_match_step_test_matcher))
       (debug_msg souts "translpat_patmat souts again")
       (let ( 
	     (outdata (get_field :mstma_outs curstep))
	     (thenlist (make_list discr_list))
	     (elselist (make_list discr_list))
	     (flaglist (make_list discr_list))
	     (laststep curstep)
	     (testgroup (instance class_match_step_test_group
				  :loca_location sloc
				  :mstep_data mdata
				  :mstep_then ()
				  :mstep_else ()
				  :mstgroup_start curstep
				  :mstgroup_then ()
				  :mstgroup_else ()
				  ))
	     )
	 (foreach_in_multiple
	  (outdata)
	  (curoutdata :long dix)
	  (let ( (outpat (multiple_nth souts dix))
		 )
	    (debug_msg curoutdata "translpat_patmat curoutdata")
	    (debug_msg outpat "translpat_patmat outpat")
	    (multicall 
	     (outstep outflag)
	     (translate_pattern outpat curoutdata mcase varmap sloc)
	     (debug_msg outstep "translpat_patmat outstep")
	     (debug_msg outflag "translpat_patmat outflag")
	     (if outstep
		 (progn
		   (put_then_match laststep outstep)
		   (list_append elselist outstep)
		   (setq laststep outstep)
		   ))
	     (if outflag
		 (progn
		   (assert_msg "check outflag" (is_a outflag class_match_flag))
		   (list_append flaglist outflag))
	       ))))
	 (let ( (flagstep
		 (if (list_first_element flaglist)
		     (instance class_match_step_flag_conjonction
			       :loca_location sloc
			       :mstep_data mdata
			       :mstep_then ()
			       :mstep_flag mflag
			       :mstep_flagargs (list_to_multiple flaglist discr_multiple)
			       )
		   (instance class_match_step_flag_set
			     :loca_location sloc
			     :mstep_data mdata
			     :mstep_then ()
			     :mstep_flag mflag
			     )
		     )
		 )
		)
	   (debug_msg flagstep "translpat_patmat flagstep")
	   (if laststep (put_then_match laststep flagstep))
	   (put_fields mflag :mflag_setstep flagstep)
	   (put_fields
	    testgroup
	    :mstgroup_then flagstep
	    :mstgroup_else elselist)
	   (debug_msg testgroup "translpat_patmat return testgroup")
	   (return testgroup mflag)
	   )
	 )	    
       )
     )
    )
  )

(install_method class_source_pattern_matcher  translate_pattern translpat_patmat)
	

;; internal selector to output the label of a test in "HTML-like"
;; graphiz format
(defselector matchgraphic_altstep class_selector
)




;;;;;;;;;;;;;;;;
(defun mgaltstep_steptestvar (step mg)
  (debug_msg step "mgaltstep_steptestvar step")
  (assert_msg "check step" (is_a step class_match_step_test_variable))
  (assert_msg "check mg" (is_a mg class_match_graphic))
  (let ( (loca (unsafe_get_field :loca_location step))
	 (sthen (unsafe_get_field :mstep_then step))
	 (selse (unsafe_get_field :mstep_else step))
	 (testdata (unsafe_get_field :msteptestvar_data step))
	 (nodebuf (unsafe_get_field :mchgx_nodout mg))
	 (edgebuf (unsafe_get_field :mchgx_edgout mg))
	 (datamap (unsafe_get_field :mchgx_datanamemap mg))
	 (stepmap (unsafe_get_field :mchgx_stepnamemap mg))
	 (stepname (mapobject_get stepmap step))
	 (thenname (if sthen (mapobject_get stepmap sthen)))
	 (elsename (if selse (mapobject_get stepmap selse)))
	 (:long stephash (obj_hash step))
	 (dis (discrim step))
	 (clanam (get_field :named_name dis))
	 )
    (add2out_strconst nodebuf "<tr><td><font color=\"royalblue4\" face=\"Times-Roman Bold\" point-size=\"6\">")
    (code_chunk 
     outclanam
     #{ /* $OUTCLANAM */
     meltgc_add_out ((melt_ptr_t) $NODEBUF,
		     melt_string_str ((melt_ptr_t) $CLANAM) +6)	;
     }#)
    (add2out_strconst nodebuf "</font></td><td>")
    (add2out_strconst nodebuf "<font face=\"Helvetica Italic\" color=\"darkgreen\" point-size=\"6.5\">")
    (add2sbuf_short_mixloc nodebuf loca)
    (add2out_strconst nodebuf "</font></td></tr>")
    (add2out_indentnl nodebuf 0)
    (add2out_strconst nodebuf "<tr><td colspan=\"2\"><font face=\"Time-Roman Italics\" point-size=\"7\" color=\"navy\">")
    (compile_warning "testdata is usually not a symbol but a matched data...")
    (add2out_string nodebuf (get_field :named_name testdata))
    (if (is_a testdata class_cloned_symbol)
	(let ( (:long syrank (get_int (get_field :csym_urank testdata)))
	      )
	  (add2out_strconst nodebuf "$")
	  (add2out_longdec nodebuf syrank)
	  ))
    (add2out_strconst nodebuf "</font></td></tr>")
    (add2out_indentnl nodebuf 0)
    (if thenname
	(progn
	  (add2out_indentnl edgebuf 0)
	  (add2out_string edgebuf stepname)
	  (add2out_strconst edgebuf " /*then*/ -> ")
	  (add2out_string edgebuf thenname)
	  (add2out_strconst edgebuf " [ arrowhead=normal, color=green ];")
	  ))
    (if elsename
	(progn
	  (add2out_indentnl edgebuf 0)
	  (add2out_string edgebuf stepname)
	  (add2out_strconst edgebuf " /*else*/ -> ")
	  (add2out_string edgebuf elsename)
	  (add2out_strconst edgebuf " [ arrowhead=diamond, color=red ];")
	  ))
    ))
(install_method class_match_step_test_variable matchgraphic_altstep mgaltstep_steptestvar)


;;;;;;;;;;;;;;;;
(defun mgaltstep_steptestinst (step mg)
  (debug_msg step "mgaltstep_steptestinst step")
  (assert_msg "check step" (is_a step class_match_step_test_instance))
  (assert_msg "check mg" (is_a mg class_match_graphic))
  (let ( (loca (unsafe_get_field :loca_location step))
	 (sthen (unsafe_get_field :mstep_then step))
	 (selse (unsafe_get_field :mstep_else step))
	 (testclass (unsafe_get_field :mstins_class step))
	 (testslots (unsafe_get_field :mstins_slots step))
	 (nodebuf (unsafe_get_field :mchgx_nodout mg))
	 (edgebuf (unsafe_get_field :mchgx_edgout mg))
	 (datamap (unsafe_get_field :mchgx_datanamemap mg))
	 (stepmap (unsafe_get_field :mchgx_stepnamemap mg))
	 (stepname (mapobject_get stepmap step))
	 (thenname (if sthen (mapobject_get stepmap sthen)))
	 (elsename (if selse (mapobject_get stepmap selse)))
	 (:long stephash (obj_hash step))
	 (dis (discrim step))
	 (clanam (get_field :named_name dis))
	 )
    (add2out_strconst nodebuf "<tr><td><font color=\"salmon4\" face=\"Times-Roman Bold\" point-size=\"6\">")
    (code_chunk 
     outclanam
     #{ /* $OUTCLANAM */
     meltgc_add_out ((melt_ptr_t) $NODEBUF,
		     melt_string_str ((melt_ptr_t) $CLANAM) +6)	;
     }#)
    (add2out_strconst nodebuf "</font></td><td>")
    (add2out_strconst nodebuf "<font face=\"Helvetica Italic\" color=\"darkgreen\" point-size=\"6.5\">")
    (add2sbuf_short_mixloc nodebuf loca)
    (add2out_strconst nodebuf "</font></td></tr>")
    (add2out_indentnl nodebuf 0)
    (add2out_strconst nodebuf "<tr><td colspan=\"2\"><font color=\"salmon\" face=\"Helvetica Oblique\" point-size=\"6\">")
    (add2out_string nodebuf (get_field :named_name testclass))
    (add2out_strconst nodebuf "</font></td></tr>")
    (add2out_indentnl nodebuf 0)
    (foreach_in_multiple
     (testslots)
     (curslot :long slix)
     (if curslot
	 (progn
	   (assert_msg "check curslot" (is_a curslot class_matched_data))
	   (add2out_indentnl edgebuf 0)
	   (add2out_string edgebuf stepname)
	   (add2out_strconst edgebuf " /*testinslot*/ -> /*data*/")
	   (add2out_string edgebuf (mapobject_get datamap curslot))
	   (add2out_strconst edgebuf " [ arrowhead=open,")
	   (let ( (fld (multiple_nth (get_field :class_fields testclass) slix)) )
	     (assert_msg "check fld" (is_a fld class_field))
	     (add2out_strconst edgebuf " label=<<font point-size=\"6.5\" color=\"indigo\">")
	     (add2out_string edgebuf (get_field :named_name fld))
	     (add2out_strconst edgebuf "</font>>, "))
	     (add2out_strconst edgebuf " color=violet, style=dotted ];")
	   ))
     )
    (if thenname
	(progn
	  (add2out_indentnl edgebuf 0)
	  (add2out_string edgebuf stepname)
	  (add2out_strconst edgebuf " /*then*/ -> ")
	  (add2out_string edgebuf thenname)
	  (add2out_strconst edgebuf " [ arrowhead=normal, color=green ];")
	  ))
    (if elsename
	(progn
	  (add2out_indentnl edgebuf 0)
	  (add2out_string edgebuf stepname)
	  (add2out_strconst edgebuf " /*else*/ -> ")
	  (add2out_string edgebuf elsename)
	  (add2out_strconst edgebuf " [ arrowhead=diamond, color=red ];")
	  ))
    ))
(install_method class_match_step_test_instance matchgraphic_altstep mgaltstep_steptestinst)

;;;;;;;;;;;;;;;;
(defun mgaltstep_steptestgroup (step mg)
  (debug_msg step "mgaltstep_steptestgroup step")
  (assert_msg "check step" (is_a step class_match_step_test_group))
  (assert_msg "check mg" (is_a mg class_match_graphic))
  (let ( (loca (unsafe_get_field :loca_location step))
	 (sthen (unsafe_get_field :mstep_then step))
	 (selse (unsafe_get_field :mstep_else step))
	 (nodebuf (unsafe_get_field :mchgx_nodout mg))
	 (edgebuf (unsafe_get_field :mchgx_edgout mg))
	 (datamap (unsafe_get_field :mchgx_datanamemap mg))
	 (stepmap (unsafe_get_field :mchgx_stepnamemap mg))
	 (stepname (mapobject_get stepmap step))
	 (thenname (if sthen (mapobject_get stepmap sthen)))
	 (elsename (if selse (mapobject_get stepmap selse)))
	 (:long stephash (obj_hash step))
	 (dis (discrim step))
	 (clanam (get_field :named_name dis))
	 )
    (add2out_strconst nodebuf "<tr><td><font color=\"hotpink\" face=\"Times-Roman Bold\" point-size=\"6\">")
    (code_chunk 
     outclanam
     #{ /* $OUTCLANAM */
     meltgc_add_out ((melt_ptr_t) $NODEBUF,
		     melt_string_str ((melt_ptr_t) $CLANAM) +6)	;
     }#)
    (add2out_strconst nodebuf "</font></td><td>")
    (add2out_strconst nodebuf "<font face=\"Helvetica Italic\" color=\"darkgreen\" point-size=\"6.5\">")
    (add2sbuf_short_mixloc nodebuf loca)
    (add2out_strconst nodebuf "</font></td></tr>")
    (add2out_indentnl nodebuf 0)
    (if thenname
	(progn
	  (add2out_indentnl edgebuf 0)
	  (add2out_string edgebuf stepname)
	  (add2out_strconst edgebuf " /*then*/ -> ")
	  (add2out_string edgebuf thenname)
	  (add2out_strconst edgebuf " [ arrowhead=normal, color=green ];")
	  ))
    (if elsename
	(progn
	  (add2out_indentnl edgebuf 0)
	  (add2out_string edgebuf stepname)
	  (add2out_strconst edgebuf " /*else*/ -> ")
	  (add2out_string edgebuf elsename)
	  (add2out_strconst edgebuf " [ arrowhead=diamond, color=red ];")
	  ))
    ))
(install_method class_match_step_test_group matchgraphic_altstep mgaltstep_steptestgroup)

;;;;;;;;;;;;;;;;
(defun mgaltstep_steptestmatcher (step mg)
  (debug_msg step "mgaltstep_steptestmatcher step")
  (assert_msg "check step" (is_a step class_match_step_test_matcher))
  (assert_msg "check mg" (is_a mg class_match_graphic))
  (let ( (loca (unsafe_get_field :loca_location step))
	 (sthen (unsafe_get_field :mstep_then step))
	 (selse (unsafe_get_field :mstep_else step))
	 (smatcher (unsafe_get_field :mstma_matcher step))
	 (souts (unsafe_get_field :mstma_outs step))
	 (nodebuf (unsafe_get_field :mchgx_nodout mg))
	 (edgebuf (unsafe_get_field :mchgx_edgout mg))
	 (datamap (unsafe_get_field :mchgx_datanamemap mg))
	 (stepmap (unsafe_get_field :mchgx_stepnamemap mg))
	 (stepname (mapobject_get stepmap step))
	 (thenname (if sthen (mapobject_get stepmap sthen)))
	 (elsename (if selse (mapobject_get stepmap selse)))
	 (:long stephash (obj_hash step))
	 (dis (discrim step))
	 (clanam (get_field :named_name dis))
	 )
    (add2out_strconst nodebuf "<tr><td><font color=\"peru\" face=\"Times-Roman Bold\" point-size=\"6\">")
    (code_chunk 
     outclanam
     #{ /* $OUTCLANAM */
     meltgc_add_out ((melt_ptr_t) $NODEBUF,
		     melt_string_str ((melt_ptr_t) $CLANAM) +6)	;
     }#)
    (add2out_strconst nodebuf "</font></td><td>")
    (add2out_strconst nodebuf "<font face=\"Helvetica Italic\" color=\"darkgreen\" point-size=\"6.5\">")
    (add2sbuf_short_mixloc nodebuf loca)
    (add2out_strconst nodebuf "</font></td></tr>")
    (add2out_indentnl nodebuf 0)
    (add2out_strconst nodebuf "<tr><td colspan=\"2\"><font color=\"peru\" face=\"Time-Roman Italics\" point-size=\"7\">")
    (add2out_string nodebuf (get_field :named_name smatcher))
    (add2out_strconst nodebuf "</font></td></tr>")
    (add2out_indentnl nodebuf 0)
    (foreach_in_multiple
     (souts)
     (curout :long outix)
     (debug_msg curout "mgaltstep_steptestmatcher curout")
     (assert_msg "check curout" (is_a curout class_matched_data))
     (add2out_indentnl edgebuf 0)
     (add2out_string edgebuf stepname)
     (add2out_strconst edgebuf " /*matchstep*/ -> /*data*/ ")
     (add2out_string edgebuf (mapobject_get datamap curout))
     (add2out_strconst edgebuf " [ arrowhead=open, ")
     (let ( (outbind (multiple_nth (get_field :amatch_out smatcher) outix))
	    (outsymb (get_field :binder outbind))
	    )
       (if (is_a outsymb class_symbol)
	   (progn
	     (add2out_strconst edgebuf " label=<<font face=\"Helvetica\" point-size=\"6\">")
	     (add2out_string edgebuf (get_field :named_name outsymb))
	     (add2out_strconst edgebuf "</font>>, "))))
     (add2out_strconst edgebuf " color=violet, style=dotted ];")
     )
    (if thenname
	(progn
	  (add2out_indentnl edgebuf 0)
	  (add2out_string edgebuf stepname)
	  (add2out_strconst edgebuf " /*then*/ -> ")
	  (add2out_string edgebuf thenname)
	  (add2out_strconst edgebuf " [ arrowhead=normal, color=green ];")
	  ))
    (if elsename
	(progn
	  (add2out_indentnl edgebuf 0)
	  (add2out_string edgebuf stepname)
	  (add2out_strconst edgebuf " /*else*/ -> ")
	  (add2out_string edgebuf elsename)
	  (add2out_strconst edgebuf " [ arrowhead=diamond, color=red ];")
	  ))
    ))
(install_method class_match_step_test_matcher matchgraphic_altstep mgaltstep_steptestmatcher)


;;;;;;;;;;;;;;;;
(defun mgaltstep_stepsuccess (step mg)
  (debug_msg step "mgaltstep_stepsuccess step")
  (assert_msg "check step" (is_a step class_match_step_success_when_flag))
  (assert_msg "check mg" (is_a mg class_match_graphic))
  (let ( (loca (unsafe_get_field :loca_location step))
	 (sthen (unsafe_get_field :mstep_then step))
	 (sflag (unsafe_get_field :mstep_flag step))
	 (nodebuf (unsafe_get_field :mchgx_nodout mg))
	 (edgebuf (unsafe_get_field :mchgx_edgout mg))
	 (datamap (unsafe_get_field :mchgx_datanamemap mg))
	 (stepmap (unsafe_get_field :mchgx_stepnamemap mg))
	 (stepname (mapobject_get stepmap step))
	 (thenname (if sthen (mapobject_get stepmap sthen)))
	 (:long stephash (obj_hash step))
	 (flagrank (get_field :mflag_rank sflag))
	 (flagstring (get_field :mflag_string sflag))
	 (flagloc (get_field :loca_location sflag))
	 (argfstep (get_field :mflag_setstep sflag))
	 (dis (discrim step))
	 (clanam (get_field :named_name dis))
	 )
    (debug_msg sflag  "mgaltstep_stepsuccess sflag")
    (assert_msg "check sflag" (is_a sflag class_match_flag))
    (add2out_strconst nodebuf "<tr><td><font color=\"firebrick\" face=\"Times-Roman Bold\" point-size=\"6\">")
    (code_chunk 
     outclanam
     #{ /* $OUTCLANAM */
     meltgc_add_out ((melt_ptr_t) $NODEBUF,
		     melt_string_str ((melt_ptr_t) $CLANAM) +6)	;
     }#)
    (add2out_strconst nodebuf "</font></td><td>")
    (add2out_strconst nodebuf "<font face=\"Helvetica Italic\" color=\"darkgreen\" point-size=\"6.5\">")
    (add2sbuf_short_mixloc nodebuf loca)
    (add2out_strconst nodebuf "</font></td></tr>")
    (add2out_indentnl nodebuf 0)
    (add2out_strconst nodebuf "<tr><td><font color=\"turquoise4\" face=\"Times-Roman\" point-size=\"7\">flag#")
    (add2out_longdec nodebuf (get_int flagrank))
    (add2out_strconst nodebuf " ")
    (add2out_string nodebuf flagstring)
    (add2out_strconst nodebuf "</font></td><td><font face=\"Helvetiva Italic\" color=\"olivedrab\" point-size=\"6.5\">")
    (add2sbuf_short_mixloc nodebuf flagloc)
    (add2sbuf_strconst nodebuf "</font></td></tr>")
    (add2out_indentnl nodebuf 0)
    (if thenname
	(progn
	  (add2out_indentnl edgebuf 0)
	  (add2out_string edgebuf stepname)
	  (add2out_strconst edgebuf " /*then*/ -> ")
	  (add2out_string edgebuf thenname)
	  (add2out_strconst edgebuf " [ arrowhead=normal, color=green ];")
	  ))
    (if (is_a argfstep class_match_step_with_flag)
	(let ( (argfstepname (mapobject_get stepmap argfstep))
	       )
	  (debug_msg argfstep  "mgaltstep_stepsuccess argfstep")
	  (debug_msg argfstepname  "mgaltstep_stepsuccess argfstepname")
	  (assert_msg "mgaltstep_stepsuccess check argfstepname" (is_string argfstepname))
	  (add2out_indentnl edgebuf 0)
	  (add2out_string edgebuf argfstepname)
	  (add2out_strconst edgebuf " /*argflag suc*/ -> ")
	  (add2out_string edgebuf stepname)
	  (add2out_strconst edgebuf " [ arrowhead=olnormal, color=chartreuse2, style=dotted ];")
	  ))
    ))

(install_method class_match_step_success_when_flag  matchgraphic_altstep mgaltstep_stepsuccess)
;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;
(defun mgaltstep_stepclear (step mg)
  (debug_msg step "mgaltstep_stepclear step")
  (assert_msg "check step" (is_a step class_match_step_clear))
  (assert_msg "check mg" (is_a mg class_match_graphic))
  (let ( (loca (unsafe_get_field :loca_location step))
	 (sthen (unsafe_get_field :mstep_then step))
	 (scleardata (unsafe_get_field :mstep_cleardata step))
	 (nodebuf (unsafe_get_field :mchgx_nodout mg))
	 (edgebuf (unsafe_get_field :mchgx_edgout mg))
	 (datamap (unsafe_get_field :mchgx_datanamemap mg))
	 (stepmap (unsafe_get_field :mchgx_stepnamemap mg))
	 (stepname (mapobject_get stepmap step))
	 (thenname (if sthen (mapobject_get stepmap sthen)))
	 (:long stephash (obj_hash step))
	 (dis (discrim step))
	 (clanam (get_field :named_name dis))
	 )
    (add2out_strconst nodebuf "<tr><td><font color=\"SaddleBrown\" face=\"Times-Roman Bold\" point-size=\"6\">")
    (code_chunk 
     outclanam
     #{ /* $OUTCLANAM */
     meltgc_add_out ((melt_ptr_t) $NODEBUF,
		     melt_string_str ((melt_ptr_t) $CLANAM) +6)	;
     }#)
    (add2out_strconst nodebuf "</font></td><td>")
    (add2out_strconst nodebuf "<font face=\"Helvetica Italic\" color=\"darkgreen\" point-size=\"6.5\">")
    (add2sbuf_short_mixloc nodebuf loca)
    (add2out_strconst nodebuf "</font></td></tr>")
    (add2out_indentnl nodebuf 0)
    (add2out_strconst nodebuf "<tr><td><font color=\"LimeGreen\" face=\"Times-Roman Bold\" point-size=\"6\">")
    (foreach_in_multiple
     (scleardata)
     (curcdata :long cix)
     (if (>i cix 0) (add2out_strconst nodebuf " "))
     (let ( (cdatanam  (mapobject_get datamap curcdata)) 
	    )
       (add2out_string nodebuf cdatanam)
       (add2out_indentnl edgebuf 0)
       (add2out_string edgebuf cdatanam)
       (add2out_strconst edgebuf " /*cleared data*/ -> ")
       (add2out_string edgebuf stepname)
       (add2out_strconst edgebuf " [ arrowhead=open,")
       (add2out_strconst edgebuf " color=violet, style=dotted ];")
     ))
    (add2out_strconst nodebuf "</font></td></tr>")
    (add2out_indentnl nodebuf 0)
    (if thenname
	(progn
	  (add2out_indentnl edgebuf 0)
	  (add2out_string edgebuf stepname)
	  (add2out_strconst edgebuf " /*then*/ -> ")
	  (add2out_string edgebuf thenname)
	  (add2out_strconst edgebuf " [ arrowhead=normal, color=green ];")
	  ))
    ))
(install_method class_match_step_clear matchgraphic_altstep mgaltstep_stepclear)

(defun mgaltstep_stepflagset (step mg)
  (debug_msg step "mgaltstep_stepflagset step")
  (assert_msg "check step" (is_a step class_match_step_flag_set))
  (assert_msg "check mg" (is_a mg class_match_graphic))
  (let ( (loca (unsafe_get_field :loca_location step))
	 (sthen (unsafe_get_field :mstep_then step))
	 (sflag (unsafe_get_field :mstep_flag step))
	 (nodebuf (unsafe_get_field :mchgx_nodout mg))
	 (edgebuf (unsafe_get_field :mchgx_edgout mg))
	 (datamap (unsafe_get_field :mchgx_datanamemap mg))
	 (stepmap (unsafe_get_field :mchgx_stepnamemap mg))
	 (stepname (mapobject_get stepmap step))
	 (thenname (if sthen (mapobject_get stepmap sthen)))
	 (:long stephash (obj_hash step))
	 (dis (discrim step))
	 (clanam (get_field :named_name dis))
	 (flagrank (get_field :mflag_rank sflag))
	 (flagstring (get_field :mflag_string sflag))
	 (flagloc (get_field :loca_location sflag))
	 )
    (add2out_strconst nodebuf "<tr><td><font color=\"darkolivegreen4\" face=\"Times-Roman Bold\" point-size=\"6\">")
    (code_chunk 
     outclanam
     #{ /* $OUTCLANAM */
     meltgc_add_out ((melt_ptr_t) $NODEBUF,
		     melt_string_str ((melt_ptr_t) $CLANAM) +6)	;
     }#)
    (add2out_strconst nodebuf "</font></td><td>")
    (add2out_strconst nodebuf "<font face=\"Helvetica Italic\" color=\"darkgreen\" point-size=\"6.5\">")
    (add2sbuf_short_mixloc nodebuf loca)
    (add2out_strconst nodebuf "</font></td></tr>")
    (add2out_indentnl nodebuf 0)
    (add2out_strconst nodebuf "<tr><td><font color=\"turquoise4\" face=\"Times-Roman\" point-size=\"7\">flag#")
    (add2out_longdec nodebuf (get_int flagrank))
    (add2out_strconst nodebuf " ")
    (add2out_string nodebuf flagstring)
    (add2out_strconst nodebuf "</font></td><td><font face=\"Helvetiva Italic\" color=\"olivedrab\" point-size=\"6.5\"> ")
    (add2sbuf_short_mixloc nodebuf flagloc)
    (add2sbuf_strconst nodebuf "</font></td></tr>")
    (add2out_indentnl nodebuf 0)
    (if thenname
	(progn
	  (add2out_indentnl edgebuf 0)
	  (add2out_string edgebuf stepname)
	  (add2out_strconst edgebuf " /*then*/ -> ")
	  (add2out_string edgebuf thenname)
	  (add2out_strconst edgebuf " [ arrowhead=normal, color=green ];")
	  ))
    ))

(install_method class_match_step_flag_set matchgraphic_altstep mgaltstep_stepflagset)
;;;;;;;;;;;;;;;;
(defun mgaltstep_stepflagoper (step mg)
  (debug_msg step "mgaltstep_stepflagoper step")
  (assert_msg "check step" (is_a step class_match_step_flag_operation))
  (assert_msg "check mg" (is_a mg class_match_graphic))
  (let ( (loca (unsafe_get_field :loca_location step))
	 (sthen (unsafe_get_field :mstep_then step))
	 (sflag (unsafe_get_field :mstep_flag step))
	 (sflagargs (unsafe_get_field :mstep_flagargs step))
	 (nodebuf (unsafe_get_field :mchgx_nodout mg))
	 (edgebuf (unsafe_get_field :mchgx_edgout mg))
	 (datamap (unsafe_get_field :mchgx_datanamemap mg))
	 (stepmap (unsafe_get_field :mchgx_stepnamemap mg))
	 (stepname (mapobject_get stepmap step))
	 (thenname (if sthen (mapobject_get stepmap sthen)))
	 (:long stephash (obj_hash step))
	 (dis (discrim step))
	 (clanam (get_field :named_name dis))
	 (flagrank (get_field :mflag_rank sflag))
	 (flagstring (get_field :mflag_string sflag))
	 (flagloc (get_field :loca_location sflag))
	 )
    (add2out_strconst nodebuf "<tr><td><font color=\"mediumseagreen\" face=\"Times-Roman Bold\" point-size=\"6\">")
    (code_chunk 
     outclanam
     #{ /* $OUTCLANAM */
     meltgc_add_out ((melt_ptr_t) $NODEBUF,
		     melt_string_str ((melt_ptr_t) $CLANAM) +6)	;
     }#)
    (add2out_strconst nodebuf "</font></td><td>")
    (add2out_strconst nodebuf "<font face=\"Helvetica Italic\" color=\"darkgreen\" point-size=\"6.5\">")
    (add2sbuf_short_mixloc nodebuf loca)
    (add2out_strconst nodebuf "</font></td></tr>")
    (add2out_indentnl nodebuf 0)
    (add2out_strconst nodebuf "<tr><td><font color=\"turquoise4\" face=\"Times-Roman\" point-size=\"7\">flag#")
    (add2out_longdec nodebuf (get_int flagrank))
    (if flagstring
	(progn
	  (add2out_strconst nodebuf " ")
	  (add2out_string nodebuf flagstring)
	  ))
    (add2out_strconst nodebuf "</font></td><td><font face=\"Helvetiva Italic\" color=\"olivedrab\" point-size=\"6.5\">")
    (add2sbuf_short_mixloc nodebuf loca)
    (add2sbuf_strconst nodebuf "</font></td></tr>")
    (if (is_multiple sflagargs)
	(progn
	  (add2out_indentnl nodebuf 0)
	  (add2out_strconst nodebuf "<tr><td colspan=\"2\"><font color=\"goldenrod4\" face=\"Times-Roman\" point-size=\"6.5\">flags{")
	  (foreach_in_multiple
	   (sflagargs)
	   (argflag :long argix)
	   (assert_msg "check argflag" (is_a argflag class_match_flag))
	   (let ( (:long argrank (get_int (get_field  :mflag_rank argflag)))
		  (argfstep (get_field :mflag_setstep argflag))
		  )
	     (if (>i argrank 0)
		 (progn
		   (add2sbuf_strconst nodebuf " ")
		   (add2sbuf_longdec nodebuf argrank)
		   ))
	     (if (is_a argfstep class_match_step_with_flag)
		 (let ( (argfstepname (mapobject_get stepmap argfstep))
			)
		   (debug_msg argfstep "mgaltstep_stepflagoper argfstep")
		   (debug_msg argfstepname "mgaltstep_stepflagoper argfstepname")
		   (if (null argfstepname) 
		       (debug_msg stepmap "mgaltstep_stepflagoper bad stepmap"))
		   (assert_msg "check argstepname" (is_string argfstepname))
		   (add2out_indentnl edgebuf 0)
		   (add2out_string edgebuf argfstepname)
		   (add2out_strconst edgebuf " /*argflag flagop*/ -> ")
		   (add2out_string edgebuf stepname)
		   (add2out_strconst edgebuf " [ arrowhead=olnormal, color=chartreuse2, style=dotted ];")
		   ))
	     ))
	  (add2sbuf_strconst nodebuf " }</font></td></tr>")
	  ))
    (if thenname
	(progn
	  (add2out_indentnl edgebuf 0)
	  (add2out_string edgebuf stepname)
	  (add2out_strconst edgebuf " /*then*/ -> ")
	  (add2out_string edgebuf thenname)
	  (add2out_strconst edgebuf " [ arrowhead=normal, color=green ];")
	  ))
    ))

(install_method class_match_step_flag_operation matchgraphic_altstep mgaltstep_stepflagoper)



;;;;;;;;;;;;;;;;


(compile_warning "missing other methods for matchgraphic_altstep on other step classes")

(defun translate_matchcase (curmcase sloc prevstep)
  (debug_msg curmcase "translate_matchcase curmcase")
  (assert_msg "check curmcase" (is_a curmcase class_match_case))
  (let ( (matctx (unsafe_get_field  :mcase_mctxt curmcase))
	 (curscas (unsafe_get_field :mcase_source curmcase))
	 (mloc (unsafe_get_field :loca_location curscas))
	 )
    (assert_msg "check matctx" (is_a matctx class_matching_context))
    (debug_msg curscas "translate_matchcase curscas")
    (debug_msg prevstep "translate_matchcase prevstep")
    (assert_msg "check curscas" (is_a curscas class_source_match_case))
    (let (
	  (curloc (unsafe_get_field :loca_location curscas))
	  (curpat (unsafe_get_field :scam_patt curscas))
	  (curbody (unsafe_get_field :scam_body curscas))
	  (nmatx (unsafe_get_field :mctx_nmatched matctx))
	  (mdata (unsafe_get_field :mctx_mdata matctx))
	  (ncx (unsafe_get_field :mctx_normctxt matctx))
	  (env (unsafe_get_field :mctx_env matctx))
	  (varmap (make_mapobject discr_map_objects
				  (+i 12 (*i 2 (mapobject_count (unsafe_get_field :mcase_varmap curmcase)))))) 
	  (sycmap  (unsafe_get_field :nctx_symbcachemap ncx))
	  (newenv (fresh_env env))
	  )
      (debug_msg nmatx "translate_matchcase nmatx")
      (debug_msg curpat "translate_matchcase curpat")
      (debug_msg mdata "translate_matchcase mdata")
      (assert_msg "check ncx" (is_a ncx class_normalization_context))
      (assert_msg "check env" (is_a env class_environment))
      (multicall 
       (mstep mflag)
       (translate_pattern curpat mdata curmcase varmap sloc)
       (debug_msg mstep "translate_matchcase got mstep")
       (debug_msg mflag "translate_matchcase got mflag")
       (debug_msg curbody "translate_matchcase got curbody")
       (debug_msg varmap "translate_matchcase got varmap")
       (foreach_in_mapobject
	(varmap)
	(cursym curmdata)
	(assert_msg "check cursym" (is_a cursym class_symbol))
	(assert_msg "check curmdata" (is_a curmdata class_matched_data))
	(let ( (matchbind (instance class_matched_binding
				    :binder cursym
				    :matchbind_data curmdata
				    :matchbind_nbocc (make_integerbox discr_integer 0)
				    ))
	       )
	  (debug_msg matchbind "translate_matchcase matchbind")
	  (put_env newenv matchbind)
	  ))
       (debug_msg newenv "translate_matchcase updated newenv")
       (debug_msg curbody "translate_matchcase before normalizing curbody")
       (multicall
	(nbody nbinds)
	(normalize_tuple curbody newenv ncx sloc)
	(debug_msg nbody "translate_matchcase nbody after body normalization")
	(debug_msg nbinds "translate_matchcase nbinds after body normalization")
	(let (
	      (listvarocc (make_list discr_list))
	      (newbindmap (get_field :env_bind newenv))
	      (stepsucc (instance class_match_step_success_when_flag
				  :loca_location sloc
				  :mstep_data mdata
				  :mstep_then ()
				  :mstep_flag mflag
				  :mstepsuccess_varocc ()
				  :mstepsuccess_binds nbinds
				  :mstepsuccess_body nbody
				  ))
	      )
	  (foreach_in_mapobject
	   (newbindmap)
	   (bsymb binding)
	   (if (and (is_a binding class_matched_binding)
		    (>i (get_int (unsafe_get_field :matchbind_nbocc binding)) 0))
	       (let ( (syocc (mapobject_get sycmap bsymb))
		      )
		 (debug_msg syocc "translate_matchcase found syocc")
		 (assert_msg "check syocc" (is_a syocc class_nrep_locsymocc))
		 (assert_msg "check syocc binding" (== (get_field :nocc_bind syocc) binding))
		 (list_append listvarocc syocc)
		 )
	     ))
	  (debug_msg listvarocc "translate_matchcase listvarocc")
	  (debug_msg mstep "translate_matchcase have mstep")
	  (let ( (sortedvarocc
		  (multiple_sort 
		   (list_to_multiple listvarocc discr_multiple)
		   (lambda (o1 o2)
		     (compare_named_alpha (get_field :nocc_symb o1) (get_field :nocc_symb o2)))
		   discr_multiple))
		 )
	    (debug_msg sortedvarocc  "translate_matchcase sortedvarocc")
	    (put_fields 
	     stepsucc :mstepsuccess_varocc sortedvarocc))
	  (debug_msg stepsucc "translate_matchcase stepsucc")
	  (debug_msg mstep "translate_matchcase mstep before put_then")
	  (put_then_match mstep stepsucc)
	  (debug_msg mstep "translate_matchcase updated mstep")
	  (if prevstep
	      (progn
		(debug_msg prevstep "translate_matchcase got prevstep")
		(compile_warning "translate_matchcase don't put_else_match")
		;; the put_else_match is unneeded & wrong
		;; (put_else_match prevstep mstep)
		))
	  (debug_msg prevstep "translate_matchcase updated prevstep")
	  (debug_msg mstep "translate_matchcase return mstep")
	  (debug_msg stepsucc "translate_matchcase return stepsucc")
	  (return mstep stepsucc)
	  ))))))


;;;; normal representation for alternate match uses match blocks

(defclass class_nrep_altmatch
  :super class_nrep_typed_expression
  :doc #{The $CLASS_NREP_ALTMATCH is the representation for normal
matches. Field $NAMATCH_MATCHED is the normal matched
stuff. $NAMATCH_RESULT gives if any the result of the
match. $NAMATCH_BODY is the body tuple, in particular labels of
$CLASS_NREP_MATCH_LABEL. $NAMATCH_FLAGS is the tuple of normal flags,
instances of $CLASS_NREP_MATCH_FLAG.}#
  :fields (
	   namatch_matched		;the normal matched stuff
	   namatch_result		;the local for the result
	   namatch_body			;the body
	   namatch_flags		;the tuple of normalized flags
	   ))

(defclass class_nrep_match_label
  :super class_nrep_expression
  :doc #{ A normal match label of $CLASS_NREP_MATCH_LABEL is just a
point which can be jumped to. It corresponds to a match step given by
the field $NMLAB_STEP.}#
  :fields (nmlab_step))

(defclass class_nrep_match_label_end
  :super class_nrep_match_label
  :doc #{The $CLASS_NREP_MATCH_LABEL_END is for the end label.}#)

(defclass class_nrep_match_jump
  :super class_nrep_expression
  :doc #{ A normal match jump of $CLASS_NREP_MATCH_JUMP is just a goto
to a match label given by field $NMJMP_LABEL. }#
  :fields (nmjmp_label))

(defclass class_nrep_match_data_action
  :super class_nrep_expression
  :doc #{The $CLASS_NREP_MATCH_DATA_ACTION is the common super-class
for actions concerning a normal match data $NMDAC_DATA.}# 
  :fields (nmdac_data))

(defclass class_nrep_match_data_initializer
  :super class_nrep_match_data_action
  :doc #{ A normal match data initializer of
$CLASS_NREP_MATCH_DATA_INITIALIZER initialize, allocate resource, and
clears a normal match data given by field $NMDAC_DATA.}#
  :fields ())

(defclass class_nrep_match_data_clear
  :super class_nrep_match_data_action
  :doc #{ A normal match data clear of
$CLASS_NREP_MATCH_DATA_CLEAR clears a normal match data given by
field $NMDAC_DATA.}#
  :fields ())

(defclass class_nrep_match_data_finalizer
  :super class_nrep_match_data_action
  :doc #{ A normal match data finalizer of
  $CLASS_NREP_MATCH_DATA_FINALIZER finalizes and unleash any resources
  associated with a normal match data given by field $NMDAC_DATA.}#
  :fields ())


(defclass class_nrep_jump_when_is_a
  :super class_nrep_expression
  :doc #{The $CLASS_NREP_JUMP_WHEN_IS_A is testing if a simple value
$NTESTISA_VALUE us an instance of $NTESTISA_CLASS. If yes, it jumps to
$NTESTISA_JUMP.}#
  :fields (ntestisa_value 
	  ntestisa_class 
	  ntestisa_jump))

(defclass class_match_normalization_context
  :super class_root
  :doc #{The $CLASS_MATCH_NORMALIZATION_CONTEXT is agreggating data
  for normalization of a graph of match steps, indirect instances of
  $CLASS_MATCH_STEP. Field $MATNORX_RESLOC gives the instance of
  $CLASS_NREP_LOCSYMOCC for the result of the match. $MATNORX_NMATCH
  gives the partially built normal representation, instance of
  $CLASS_NREP_ALTMATCH, of the match. Field $MATNORX_FLAGMAP is the
  read-mostly map associating match flags to normalized flags. Field
  $MATNORX_STEPMAP is the read-mostly map associating match steps to
  labels of $CLASS_NREP_MATCH_LABEL. Field $MATNORX_MDATAMAP is the
  read-mostly map associating match datas to their
  normalization. $MATNORX_MDATAQUEUE is the read-mostly queue list of
  match datas to process. $MATNORX_MSTEPQUEUE is the read-mostly queue
  list of match steps, with already an associated label, to
  process. $MATNORX_BODYLIST is the incomplete list of the match
  body. $MATNORX_ENDLABEL is the ending label. $MATNORX_MATCHCTXT
  gives the matching context of $CLASS_MATCHING_CONTEXT.}#
  :fields (matnorx_resloc
	   matnorx_nmatch
	   matnorx_datamap
	   matnorx_flagmap
	   matnorx_stepmap
	   matnorx_mdataqueue 
	   matnorx_mstepqueue 
	   matnorx_bodylist
	   matnorx_endlabel
	   matnorx_matchctxt
	   ))


;;; utility to normalize a flag with a match normalization context
(defun altmatch_normalize_flag (flag nmctxt)
  (debug_msg flag "altmatch_normalize_flag flag")
  (assert_msg "altmatch_normalize_flag check flag"
	      (is_a flag class_match_flag))
  (assert_msg "altmatch_normalize_flag check nmctxt"
	      (is_a nmctxt class_match_normalization_context))
  (let ( (flagmap (unsafe_get_field :matnorx_flagmap nmctxt))
	 (nfla (mapobject_get flagmap flag))
	 (nmatch (unsafe_get_field :matnorx_nmatch nmctxt))
	 )
    (if (null nfla)
	(progn 
	  (setq nfla
		(instance class_nrep_match_flag
			  :nrpfla_flag flag
			  :nrpfla_nmatch nmatch))
	  (mapobject_put flagmap flag nfla)))
    (assert_msg "altmatch_normalize_flag check nfla"
		(is_a nfla class_nrep_match_flag))
    (return nfla)
))

;;;;;;;;;;;;;;;;
(defselector normalize_step class_selector
  :doc #{The selector $NORMALIZE_STEP normalize a given $STEP within a
match normalization context $NMCTXT, a source location $SLOC, and
returns a list or tuple of normalized expressions, or a single such
normalized expression.}#
  :formals (step nmctxt sloc)
)

;; this utility function completes a normstep if the step is the last
;; in its data, or else return the normstep unchanged...
(defun complete_normstep_if_last (step normstep nmctxt)
  (debug_msg step "complete_normstep_if_last start step")
  (debug_msg normstep "complete_normstep_if_last start normstep")
  (assert_msg "check step" (is_a step class_match_step))
  (assert_msg "check nmctxt" (is_a nmctxt  class_match_normalization_context))
  (let ( (matdata (unsafe_get_field :mstep_data step))
	 (matindex (unsafe_get_field :mstep_index step))
	 (datamap (unsafe_get_field :matnorx_datamap nmctxt))
	 (ndata (mapobject_get datamap matdata))
	 )
    (assert_msg "check matdata" (is_a matdata class_matched_data))
    (assert_msg "check matindex" (is_integerbox matindex))
    (let ( (:long numindex (get_int matindex))
	   (datasteps (unsafe_get_field :mdata_steps matdata))
	   (:long nbdatasteps (multiple_length datasteps))
	   )
      (assert_msg "check numindex" (>i numindex 0))
      (assert_msg "check nbdatasteps" (>i nbdatasteps 0))
      (assert_msg "good numindex" (<=i numindex nbdatasteps))
      (if (<i numindex nbdatasteps)
	  (progn
	    (debug_msg normstep "complete_normstep_if_last return non-last normstep")
	    (return normstep)
	    ))
      (debug_msg step "complete_normstep_if_last last step")
      (debug_msg ndata "complete_normstep_if_last ndata")
      (assert_msg "check ndata" (is_a ndata class_nrep_simple))
      (if (is_a ndata class_nrep_matched_data)
	  (let ( (clearndata (instance class_nrep_match_data_clear
				       :nmdac_data ndata))
		 (finalndata (instance class_nrep_match_data_finalizer
				       :nmdac_data ndata))
		 )
	    (debug_msg clearndata "complete_normstep_if_last clearndata")
	    (debug_msg finalndata "complete_normstep_if_last finalndata")
	    (debug_msg normstep "complete_normstep_if_last normstep")
	    (cond ( (is_object normstep)
		    (let ( (normsteptup (tuple normstep clearndata finalndata)) )
		      (debug_msg normsteptup "complete_normstep_if_last new normsteptup")
		      (return normsteptup)))
		  ( (null normstep)
		    (let ( (steptupn (tuple clearndata finalndata)) )
		      (debug_msg steptupn "complete_normstep_if_last new steptupn for nil")
		      (return steptupn)))
		  ( (is_multiple normstep)
		    (let ( (normsteplist (multiple_to_list normstep))
			   )
		      (list_append normsteplist clearndata)
		      (list_append normsteplist finalndata)
		      (let ( (newnormstep (list_to_multiple normsteplist)) )
			(debug_msg newnormstep "complete_normstep_if_last newnormstep")
			(return newnormstep)
			)))
		  ( (is_list normstep)
		    (list_append normstep clearndata)
		    (list_append normstep finalndata)
		    (debug_msg normstep "complete_normstep_if_last extended normstep")
		    (return normstep))
		  (:else
		   (debug_msg normstep "complete_normstep_if_last bad normstep")
		   (assert_msg "complete_normstep_if_last unexpected normstep" ())
		   )))
	(progn
	  (debug_msg ndata "complete_normstep_if_last ndata not a matched data")
	  (debug_msg normstep "complete_normstep_if_last unchanged normstep")
	  (return normstep))
	))))

(defun normstep_anyrecv (recv nmctxt sloc)
  (debug_msg recv "normstep_anyrecv recv")
  (assert_msg "check nmctxt" (is_a nmctxt  class_match_normalization_context))
  (let ( (dis (discrim recv))
	 (disname (get_field :named_name dis))
	 )
    (error_strv sloc "unexpected NORMALIZE_STEP for" disname)
    (debug_msg dis "normstep_anyrecv dis")
    (assert_msg "@$@ unexpected normstep_anyrecv" ())
))
(install_method  discr_any_receiver normalize_step normstep_anyrecv)


(defun normstep_mflagset (step nmctxt sloc)
  (debug_msg step "normstep_mflagset step")
  (assert_msg "check step" (is_a step class_match_step_flag_set))
  (assert_msg "check nmctxt" (is_a nmctxt  class_match_normalization_context))
  (let  ( (nsloc (or (unsafe_get_field :loca_location step) sloc))
	  (matflag (unsafe_get_field :mstep_flag step))
	  (matthen (unsafe_get_field :mstep_then step))
	  (nthen (altmatch_normalize_step matthen nmctxt))
	  (nflag (altmatch_normalize_flag matflag nmctxt))
	  (nsetflag (instance  class_nrep_setq 
			       :nrep_loc nsloc
			       :nstq_var nflag
			       :nstq_exp '1))
	  (njump (instance class_nrep_match_jump
			   :nmjmp_label nthen))
	  (nlisti (list nsetflag njump))
	  )
    (debug_msg nlisti "normstep_mflagset nlisti")
    (let ( (res (complete_normstep_if_last step nlisti nmctxt)) )
      (debug_msg res "normstep_mflagset return res")
      (return res)
      )))
(install_method class_match_step_flag_set normalize_step normstep_mflagset)

(defun normstep_mtestinstance (step nmctxt sloc)
  (debug_msg step "normstep_mtestinstance step")
  (assert_msg "check step" (is_a step class_match_step_test_instance))
  (assert_msg "check nmctxt" (is_a nmctxt  class_match_normalization_context))
  (let ( (nsloc (or (unsafe_get_field :loca_location step) sloc))
	 (matdata (unsafe_get_field :mstep_data step))
	 (matthen (unsafe_get_field :mstep_then step))
	 (matelse (unsafe_get_field :mstep_else step))
	 (matclass (unsafe_get_field :mstins_class step))
	 (matslots (unsafe_get_field :mstins_slots step))
	 (matctx (unsafe_get_field :matnorx_matchctxt nmctxt))
	 (ndata (altmatch_normalize_mdata matdata nmctxt))
	 )
    (debug_msg matclass "normstep_mtestinstance matclass")
    (debug_msg ndata "normstep_mtestinstance ndata")
    (debug_msg matslots "normstep_mtestinstance matslots")
    (debug_msg matthen "normstep_mtestinstance matthen")
    (debug_msg matelse "normstep_mtestinstance matelse")
    (assert_msg "check matclass" (is_a matclass class_class))
    (let (
	  (nthen (altmatch_normalize_step matthen nmctxt))
	  (nelse (altmatch_normalize_step matelse nmctxt))
	  (jumpthen (instance class_nrep_match_jump
			      :nmjmp_label nthen))
	  (jumpelse (instance class_nrep_match_jump
			      :nmjmp_label nelse))
	  (njthen (complete_normstep_if_last step jumpthen nmctxt))
	  (njelse (complete_normstep_if_last step jumpelse nmctxt))
	  (ncx (get_field :mctx_normctxt matctx))
	  (env (get_field :mctx_env matctx))
	  (ncla (normal_exp matclass env ncx sloc))
	  (clafields (unsafe_get_field :class_fields matclass))
	  (niflist (make_list discr_list))
	  (nifisa (instance class_nrep_ifisa
			    :nrep_loc sloc
			    :nifa_val ndata
			    :nifa_class ncla
			    :nexpr_ctyp ctype_void
			    :nif_then ()
			    :nif_else ()))
	  )
      (debug_msg nthen "normstep_mtestinstance nthen")
      (debug_msg nelse "normstep_mtestinstance nelse")
      (assert_msg "check nthen" (is_a nthen class_nrep_match_label))
      (assert_msg "check nelse" (is_a nelse class_nrep_match_label))
      (debug_msg njthen "normstep_mtestinstance njthen")
      (debug_msg njelse "normstep_mtestinstance njelse")
      (foreach_in_multiple
       (matslots)
       (curmslot :long curix)
       (if curmslot
	   (progn
	     (debug_msg curmslot "normstep_mtestinstance curmslot")
	     (assert_msg "check curmslot" (is_a curmslot class_matched_data))
	     (let ( (nslot (altmatch_normalize_mdata curmslot nmctxt))
		    (curfld (multiple_nth clafields curix))
		    (nflexp (instance class_nrep_unsafe_get_field
				      :nrep_loc nsloc
				      :nuget_obj nslot
				      :nuget_field curfld))
		    (nsetf (instance class_nrep_setq
				     :nrep_loc nsloc
				     :nstq_var nslot
				     :nstq_exp nflexp))
		    )
	       (debug_msg nslot "normstep_mtestinstance nslot")
	       (debug_msg curfld "normstep_mtestinstance curfld")
	       (debug_msg nsetf "normstep_mtestinstance nsetf")
	       (assert_msg "check curfld" (is_a curfld class_field))
	       (list_append niflist nsetf)
	       ))))
      (debug_msg nifisa "normstep_mtestinstance nifisa")
      (cond ( (is_object njthen)
	      (list_append niflist njthen))
	    ( (is_list njthen)
	      (list_append2list niflist njthen))
	    ( (is_multiple njthen)
	      (foreach_in_multiple
	       (njthen)
	       (curjthen :long jix)
	       (list_append niflist curjthen)))
	    (:else
	     (debug_msg njthen "normstep_mtestinstance unexpected njthen")
	     (assert_msg "normstep_mtestinstance unexpected njthen" ())))
      (debug_msg niflist "normstep_mtestinstance niflist")
      (let ( (nthenprogn (instance class_nrep_progn
				   :nrep_loc nsloc
				   :nprogn_seq (list_to_multiple niflist)
				   :nprogn_last ()
				   ))
	     (npelse 
	      (cond 
	       ( (is_object njelse) 
		 njelse)
	       ( (is_multiple njelse)
		 (instance class_nrep_progn
			   :nrep_loc nsloc
			   :nprogn_seq njelse
			   :nprogn_last ()))
	       (:else
		(debug_msg njelse "unexpected njelse")
		(assert_msg "normstep_mtestinstance unexpected njelse" ()))))
	     )
	(unsafe_put_fields nifisa :nif_then nthenprogn :nif_else npelse)
	)
      (debug_msg nifisa "normstep_mtestinstance updated nifisa")
      (return nifisa)
      )))
(install_method class_match_step_test_instance normalize_step normstep_mtestinstance)

(defun normstep_mtestvar (step nmctxt sloc)
  (debug_msg step "normstep_mtestvar step")
  (assert_msg "check step" (is_a step class_match_step_test_variable))
  (assert_msg "check nmctxt" (is_a nmctxt  class_match_normalization_context))
  (let  ( (nsloc (or (unsafe_get_field :loca_location step) sloc))
	  (matflag (unsafe_get_field :mstep_flag step))
	  (matthen (unsafe_get_field :mstep_then step))
	  (matelse (unsafe_get_field :mstep_else step))
	  (matdata (unsafe_get_field :mstep_data step))
	  (matestdata (unsafe_get_field :msteptestvar_data step))
	  )
    (debug_msg matthen "normstep_mtestvar matthen")
    (debug_msg matelse "normstep_mtestvar matelse")
    (debug_msg matdata "normstep_mtestvar matdata")
    (debug_msg matestdata "normstep_mtestvar matestdata")
    (let (
	  (nthen (altmatch_normalize_step matthen nmctxt))
	  (nelse (altmatch_normalize_step matelse nmctxt))
	  (matctx (unsafe_get_field :matnorx_matchctxt nmctxt))
	  (ndata (altmatch_normalize_mdata matdata nmctxt))
	  (ntestdata (altmatch_normalize_mdata matestdata nmctxt))
	  (jumpthen (instance class_nrep_match_jump
			      :nmjmp_label nthen))
	  (jumpelse (instance class_nrep_match_jump
			      :nmjmp_label nelse))
	  (njthen (complete_normstep_if_last step jumpthen nmctxt))
	  (njelse (complete_normstep_if_last step jumpelse nmctxt))
	  (ntestsame (instance class_nrep_ifsame
			       :nrep_loc nsloc
			       :nifs_left ndata
			       :nifs_right ntestdata
			       :nif_then ()
			       :nif_else ()))
	  )
      (debug_msg nthen "normstep_mtestvar nthen")
      (debug_msg nelse "normstep_mtestvar nelse")
      (debug_msg ndata "normstep_mtestvar ndata")
      (debug_msg ntestdata "normstep_mtestvar ntestdata")
      (debug_msg step "normstep_mtestvar step")
      (debug_msg ntestsame "normstep_mtestvar ntestsame")
      ;; should complete the nif_then & nif_else of ntestsame using
      ;; njthen & njelse
      (assert_msg "$@$unimplemented normstep_mtestvar"))))
(install_method class_match_step_test_variable normalize_step normstep_mtestvar)
    
;;; utility to normalize a step with a match normalization context
(defun altmatch_normalize_step (step nmctxt)
  (debug_msg step "altmatch_normalize_step step")
  (assert_msg "altmatch_normalize_step check nmctxt" (is_a nmctxt class_match_normalization_context))
  ;; special case, null step so gives the end label
  (if (null step)
      (let ( (endlab (unsafe_get_field :matnorx_endlabel nmctxt))
	     )
	(debug_msg endlab "altmatch_normalize_step null step so return endlab")
	(return endlab)))
  (assert_msg "altmatch_normalize_step check step" (is_a step class_match_step))
  (let ( (stepmap (unsafe_get_field :matnorx_stepmap nmctxt))
	 (nlab (mapobject_get stepmap step))
	 (bodyl (unsafe_get_field :matnorx_bodylist nmctxt))
	 (sloc  (get_field :loca_location step))
	 (mstepqueue (unsafe_get_field :matnorx_mstepqueue nmctxt))
	 )
    (if (null nlab)
	(let ( (newlab 
		(instance class_nrep_match_label
			  :nrep_loc sloc
			  :nmlab_step step))
	       )
	  (debug_msg newlab "altmatch_normalize_step newlab")
	  (mapobject_put stepmap step newlab)
	  (list_append mstepqueue step)
	  (debug_msg mstepqueue "altmatch_normalize_step updated mstepqueue")
	  (setq nlab newlab)
	  ))
    (assert_msg "check good nlab" (is_a nlab class_nrep_match_label))
    (return nlab)
    ))

;;; utility to normalize a matched data with a match normalization context
(defun altmatch_normalize_mdata (mdata nmctxt)
  (debug_msg mdata "altmatch_normalize_mdata mdata")
  (assert_msg "altmatch_normalize_mdata check mdata" (is_a mdata class_matched_data))
  (assert_msg "altmatch_normalize_mdata check nmctxt" (is_a nmctxt class_match_normalization_context))
  (let ( (datamap (unsafe_get_field :matnorx_datamap nmctxt))
	 (ndata (mapobject_get datamap mdata))
	 (mdataqueue (unsafe_get_field :matnorx_mdataqueue  nmctxt))
	 (bodyl (unsafe_get_field :matnorx_bodylist nmctxt))
	 )
    (if ndata
	(progn
	  (debug_msg ndata "altmatch_normalize_mdata found ndata")
	  (return ndata)))
    (if (is_a mdata class_matched_normal_data)
	(progn 
	  (setq ndata (unsafe_get_field :mdata_orig mdata))
	  (debug_msg ndata "altmatch_normalize_mdata got normal data"))
      (let ( (msymb (unsafe_get_field :mdata_symb mdata))
	     (mctyp (unsafe_get_field :mdata_ctype mdata))
	     (sloc (get_field :loca_location 
				   (get_field :mdata_orig mdata)))
	     (:long datacount (mapobject_count datamap))
	     (newdata (instance class_nrep_matched_data
				:nrep_loc sloc
				:nrmatd_ctype mctyp
				:nrmatd_mdata mdata
				:nrmatd_rank (make_integerbox discr_constant_integer
							      (+i datacount 1))
		       ))
	     (newdatainit (instance class_nrep_match_data_initializer
				    :nrep_loc ()
				    :nmdac_data newdata))
	    )
	(setq ndata newdata)
	(list_append bodyl newdatainit)
	(debug_msg newdata "altmatch_normalize_mdata made newdata")
	))
    (mapobject_put datamap mdata ndata)
    (list_append mdataqueue mdata)
    (debug_msg ndata "altmatch_normalize_mdata final ndata")
    (return ndata)
    ))


(defun altmatch_handle_normalized_mdata (matdata ndata nmctxt)
  (debug_msg matdata "altmatch_handle_normalized_mdata matdata")
  (debug_msg ndata "altmatch_handle_normalized_mdata ndata")
  (assert_msg "check matdata" (is_a matdata class_matched_data))
  (assert_msg "check ndata" (is_a ndata class_nrep_simple))
  (let ( (mstepslist (unsafe_get_field :mdata_steps matdata))
	 (mstepstupl (list_to_multiple mstepslist))
	 )
    (debug_msg mstepslist "altmatch_handle_normalized_mdata mstepslist")
    (assert_msg "check mstepslist" (is_list mstepslist))
    (foreach_in_multiple
     (mstepstupl)
     (curmstep :long stepix)
     (assert_msg "check curmstep" (is_a curmstep class_match_step))
     (put_fields curmstep 
		 :mstep_index
		 (make_integerbox discr_constant_integer (+i stepix 1)))
     )
    (unsafe_put_fields matdata :mdata_steps mstepstupl)
    (debug_msg mstepstupl "altmatch_handle_normalized_mdata mstepstupl")
    (foreach_in_multiple
     (mstepstupl)
     (curstep :long stepix)
     (debug_msg curstep "altmatch_handle_normalized_mdata befora normalizing curstep")
     (let ( (nlab (altmatch_normalize_step curstep nmctxt))
	    )
     (debug_msg nlab "altmatch_handle_normalized_mdata after normalizing nlab")
     ))
    (debug_msg nmctxt "altmatch_normalize_step final nmctxt")
    ))


;;; utility function to make a match normalization context
(defun altmatch_make_match_normalization_context (matctx matctyp sloc)
  (debug_msg matctx "altmatch_make_match_normalization_context matctx")
  (debug_msg matctyp "altmatch_make_match_normalization_context matctyp")
  (let 
      ( (nmatch (instance class_nrep_altmatch
			  :nexpr_ctyp matctyp
			  :nrep_loc sloc
			  :namatch_matched ()
			  :namatch_result ()
			  :namatch_flags ()
			  ))
	;; maybe we should handle particularily the case when matctyp
	;; is :void
	(mrsymb  (clone_symbol '_matchres))
	(mrbind (instance class_normal_let_binding
			  :letbind_loc sloc
			  :binder mrsymb
			  :letbind_type matctyp 
			  :letbind_expr ()))
	(mcalocc  (instance class_nrep_locsymocc
			    :nrep_loc sloc
			    :nocc_ctyp matctyp
			    :nocc_symb mrsymb
			    :nocc_bind mrbind
			    ))
	;; associate match flags to normal flags
	(flagmap (make_mapobject discr_map_objects 83)) 
	;; associate steps to match blocks, which can be possibly
	;; empty 
	(stepmap (make_mapobject discr_map_objects 229))
	;; associate match data to their normalization
	(datamap (make_mapobject discr_map_objects 229))
	;; the queue of matched data to process
	(mdataqueue (make_list discr_list))
	;; the queue of match steps to process
	(mstepqueue (make_list discr_list))
	;; the body queue
	(bodyl (make_list discr_list))
	;; the end label
	(endlab (instance  class_nrep_match_label_end
			   :nrep_loc sloc
			   :nmlab_step ()
		 ))
	;; the normal matching context
	(nmctxt (instance  class_match_normalization_context
			   :matnorx_resloc mcalocc
			   :matnorx_nmatch nmatch
			   :matnorx_datamap datamap
			   :matnorx_flagmap flagmap
			   :matnorx_stepmap stepmap
			   :matnorx_mdataqueue mdataqueue
			   :matnorx_mstepqueue mstepqueue
			   :matnorx_bodylist bodyl
			   :matnorx_endlabel endlab
			   :matnorx_matchctxt matctx
			   ))
	)
    (debug_msg nmctxt "altmatch_make_match_normalization_context result nmctxt")
    (return nmctxt)
    ))

;;; function to really normalize an alternate match case
(defun altmatch_normalize_match_case (mdata mcasetup matctyp sloc nmctxt)
  (debug_msg mdata "altmatch_normalize_match_case mdata")
  (debug_msg mcasetup "altmatch_normalize_match_case mcasetup")
  (debug_msg matctyp "altmatch_normalize_match_case matctyp")
  (debug_msg sloc "altmatch_normalize_match_case sloc")
  (debug_msg nmctxt "altmatch_normalize_match_case nmctxt")
  (assert_msg "check nmctxt" (is_a nmctxt class_match_normalization_context))
  (let ( (mdataqueue (unsafe_get_field :matnorx_mdataqueue nmctxt))
	 (mstepqueue (unsafe_get_field :matnorx_mstepqueue nmctxt))
	 (datamap (unsafe_get_field :matnorx_datamap nmctxt))
	 (stepmap (unsafe_get_field :matnorx_stepmap nmctxt))
	 (bodyl (unsafe_get_field :matnorx_bodylist nmctxt))
	)
    (debug_msg mdata "altmatch_normalize_match_case starting with first mdata")
    (altmatch_normalize_mdata mdata nmctxt)
    (debug_msg mdataqueue "altmatch_normalize_match_case initial mdataqueue")
    (debug_msg datamap "altmatch_normalize_match_case initial datamap")
    (forever 
     matchdatanormalizeloop
     (let ( (freshmdata (list_popfirst mdataqueue)) 
	    (ndata (mapobject_get datamap freshmdata))
	    )
       (debug_msg freshmdata "altmatch_normalize_match_case freshmdata start loop")
       (debug_msg ndata "altmatch_normalize_match_case ndata start loop")
       (if (null freshmdata) (exit matchdatanormalizeloop))
       (assert_msg "altmatch_normalize_match_case check freshmdata" 
		   (is_a freshmdata class_matched_data))
       (assert_msg "altmatch_normalize_match_case check ndata"
		   (is_a ndata class_nrep_simple))
       (altmatch_handle_normalized_mdata freshmdata ndata nmctxt)
       (debug_msg freshmdata "altmatch_normalize_match_case freshmdata after altmatch_handle_normalized_mdata")
       (debug_msg mstepqueue "altmatch_normalize_match_case mstepqueue after altmatch_handle_normalized_mdata")
       (forever
	matchstepnormalizeloop
	(let ( (freshmstep (list_popfirst mstepqueue)) 
	       (freshlab (mapobject_get stepmap freshmstep))
	       )
	  (debug_msg freshmstep "altmatch_normalize_match_case freshmstep")
	  (if (null freshmstep) (exit matchstepnormalizeloop))
	  (debug_msg freshlab "altmatch_normalize_match_case freshlab")
	  (let ( 
		 (normstep (normalize_step freshmstep nmctxt sloc)) 
		 )
	    (list_append bodyl freshlab)
	    (debug_msg normstep "altmatch_normalize_match_case normstep")
	    (cond ( (is_a normstep class_nrep_expression)
		    (list_append bodyl normstep))
		  ( (is_multiple normstep)
		    (foreach_in_multiple
		     (normstep)
		     (curnstep :long curix)
		     (assert_msg "check curnstep" (is_a curnstep class_nrep_expression))
		     (list_append bodyl curnstep)))
		  ( (is_list normstep)
		    (foreach_in_list
		     (normstep)
		     (curpair curnstep)
		     (assert_msg "check curnstep" (is_a curnstep class_nrep_expression))
		     (list_append bodyl curnstep)))
		  (:else
		   (assert_msg "invalid normstep in altmatch_normalize_match_case" ())))		     
	    )

	  ))
       )))
  )

;;; normalize a match alternate
(defun normexp_altmatch (recv env ncx psloc)
  (assert_msg "check match recv" (is_a recv class_source_match))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normalization_context))
  (debug_msg recv "normexp_altmatch recv")
  (let ( (sloc (or (unsafe_get_field :loca_location recv) psloc))
	 (smatsx (unsafe_get_field :smat_matchedx recv))
	 (scases (unsafe_get_field :smat_cases recv))
	 (:long nbcases (multiple_length scases))
	 (firststep ())
	 )
    (debug_msg scases "normexp_altmatch scases")
    (debug_msg smatsx "normexp_altmatch smatsx")
    (multicall
     (nmatx nbindmatx)
     (normal_exp smatsx env ncx sloc)
     (debug_msg nmatx "normexp_altmatch nmatx")
     (debug_msg nbindmatx "normexp_altmatch nbindmatx")
     (let ( (matctyp (get_ctype nmatx env))
	    (mcasetup (make_multiple discr_multiple nbcases))
	    (msteplist (make_list discr_list))
	    (msymb (or (get_field :nocc_symb nmatx) 
		       (clone_symbol (or (get_field :named_name nmatx)
					 '_matched_data))))
	    (mdata (instance class_matched_normal_data
			     :mdata_symb msymb
			     :mdata_ctype matctyp
			     :mdata_orig nmatx
			     :mdata_steps msteplist
			     ))
	    ;; the end label
	    (endlab (instance class_nrep_match_label_end
			      :nrep_loc sloc
			      :nmlab_step ())
		    )
	    (matctx (instance class_matching_context
			      :mctx_normctxt ncx
			      :mctx_source recv
			      :mctx_nmatched nmatx
			      :mctx_nmatbind nbindmatx
			      :mctx_cases mcasetup
			      :mctx_env env
			      :mctx_mdata mdata
			      :mctx_varhandlers (make_list discr_list)
			      :mctx_flags (make_list discr_list)
			      :mctx_endlabel endlab
			      ))
	    )
       (debug_msg matctyp "normexp_altmatch matctyp")
       (debug_msg matctx "normexp_altmatch matctx")
       ;; build each match case
       (foreach_in_multiple
	(scases)
	(curscas :long curix)
	(debug_msg curscas "normexp_altmatch curscas")
	(assert_msg "check  curscas" (is_a curscas class_source_match_case))
	(let ( (curmcase (instance class_match_case
				   :mcase_mctxt matctx
				   :mcase_source curscas
				   :mcase_index 
				   (make_integerbox discr_constant_integer curix)
				   )
			 )
	       )
	  (fill_matchcase curmcase sloc)
	  (multiple_put_nth mcasetup curix curmcase)
	  ))
       (debug_msg mcasetup "normexp_altmatch mcasetup")
       ;; translate each match case
       (let ( (prevstep ()) 
	      (matresctyp ())
	      )
	 (foreach_in_multiple
	  (mcasetup)
	  (curmcase :long mix)
	  (debug_msg curmcase "normexp_altmatch before translate_matchcase curmcase")
	  (debug_msg prevstep "normexp_altmatch before translate_matchcase prevstep")
	  (let ( (mcasloc (or (get_field :loca_location (get_field :mcase_source curmcase)) sloc))
		 )
	    (multicall
	     (curstep curstsucc)
	     (translate_matchcase curmcase mcasloc prevstep)
	     (debug_msg curstep "normexp_altmatch after translate_matchcase curstep")
	     (debug_msg curstsucc "normexp_altmatch after translate_matchcase curstsucc")
	     (assert_msg "check curstsucc" (is_a curstsucc class_match_step_success_when_flag))
	     (let ( 
		   (curstbindtup (unsafe_get_field :mstepsuccess_binds curstsucc))
		   (lastnbody
		    (multiple_nth
		     (unsafe_get_field :mstepsuccess_body curstsucc) 
		     -1))
		   (lastctyp
		    (if (is_a lastnbody class_nrep_locsymocc)
			(unsafe_get_field :nocc_ctyp lastnbody)
		      (let ( (newcurenv (fresh_env env))
			     )
			(foreach_in_multiple
			 (curstbindtup)
			 (curstepbind :long bix)
			 (put_env newcurenv curstepbind)
			 )
			(get_ctype lastnbody newcurenv)
			)))
		   )
	       (debug_msg lastnbody "normexp_altmatch lastnbody")
	       (debug_msg lastctyp "normexp_altmatch lastctyp")
	       (assert_msg "check lastctyp" (is_a lastctyp class_ctype))
	       (cond ( (null matresctyp)
		       (setq matresctyp lastctyp))
		     ( (== matresctyp lastctyp)
		       (void))
		     ( (== matresctyp ctype_void)
		       (void))
		     ( (== lastctyp ctype_void)
		       (setq matresctyp ctype_void))
		     (:else
		      (warning_plain mcasloc "MATCH cases with incompatible types so using :VOID")
		      (setq matresctyp ctype_void)))
	       (if curstep (setq prevstep curstep))
	       (if (null firststep)
		   (setq firststep curstep))
	       ))
	    (debug_msg prevstep "normexp_altmatch updated prevstep")
	    ))
	 (debug_msg firststep "normexp_altmatch firststep")
	 (debug_msg matresctyp "normexp_altmatch matresctyp")
	 ;;
	 (debug_msg mdata "normexp_altmatch updated mdata")
	 (if (need_dbg 1)
	     (let ( (dotprefix (get_field :container_value match_graphic_dot_prefix)) )
	       (debug_msg match_graphic_dot_prefix "normexp_altmatch match_graphic_dot_prefix")
	       (debug_msg dotprefix "normexp_altmatch dotprefix")
	       (if (is_string dotprefix) 
		   (mg_altdraw_graphviz mdata dotprefix))))
	 (let ( (nmctxt (altmatch_make_match_normalization_context matctx matresctyp sloc))
		)
	   (debug_msg nmctxt "normexp_altmatch initial nmctxt")
	   ;;
	   (multicall
	    (normatch norbindmatch)
	    (altmatch_normalize_match_case mdata mcasetup matctyp sloc nmctxt)
	    (debug_msg nmctxt "normexp_match after altmatch_normalize_case nmctxt")
	    (error_plain sloc "@@unimplemented normexp_altmatch")
	    (assert_msg "@@unimplemented normexp_altmatch")
	    (return)
	    )))))))

(defun alternate_match_optset (optsymb :cstring opts)
  (debug_msg optsymb "alternate_match_optset optsymb")
  (informsg_plain "enabling alternate matching implementation")
  (install_method class_source_match normal_exp normexp_altmatch)
)
(register_option
 'alternate_match
 '"Enable alternate pattern-matching implementation"
 alternate_match_optset)





;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun mg_altdraw_graphviz (mdata dotprefix)
  (let ( (mapdata (make_mapobject discr_map_objects 43))
	 (mapstep (make_mapobject discr_map_objects 43))
	 (nodebuf (make_strbuf discr_strbuf))
	 (edgebuf (make_strbuf discr_strbuf))
	 (datacountbox (make_integerbox discr_integer 0))
	 (:long cnt 0) 
	 (:long mdatahash (obj_hash mdata))
	 (pathsbuf (make_strbuf discr_strbuf)) 
	 (dotfilename
	  (progn
	    (code_chunk 
	     uniqcnt 
	     #{  /* mg_draw_match_graphviz_file $UNIQCNT */
	     static long uniqcounter	;
	     uniqcounter ++		;
	     $CNT = uniqcounter		; 
	     }#)
	    (assert_msg "check pathsbuf" (is_strbuf pathsbuf))
	    (add2sbuf_string pathsbuf dotprefix)
	    (add2sbuf_strconst pathsbuf "+")
	    (add2sbuf_longdec pathsbuf cnt)
	    (add2sbuf_strconst pathsbuf ".dot")
	    (debug_msg pathsbuf "mg_draw_match_graphviz_file pathsbuf")
	    (strbuf2string discr_string pathsbuf)))
	 (mg (instance class_match_graphic
		       :mchgx_filename dotfilename
		       :mchgx_nodout nodebuf
		       :mchgx_edgout edgebuf
		       :mchgx_datanamemap mapdata
		       :mchgx_stepnamemap mapstep
		       ))
	 )
					;;; recursive scan of data & steps to fill the mapdata associating
					;;; each data with its printable name and mapstep associating each
					;;; step with its printable name
    (letrec 
     ( (scandata 
	(lambda (data)
	  (debug_msg data "mg_altdraw_graphviz/scandata data")
	  (assert_msg "mg_altdraw_graphviz.scandata check data" (is_a data class_matched_data))
	  (let ( (oldname ( (mapobject_get mapdata data) ))
		 )
	    (if oldname
		(progn 
		  (debug_msg oldname "mg_altdraw_graphviz/scandata found oldname")
		  (return oldname))))
	  (let ( (nambuf (make_strbuf discr_strbuf))
		 (msymb (unsafe_get_field :mdata_symb data))
		 (:long datacnt (+i 1 (get_int datacountbox)))
		 (msteps (unsafe_get_field :mdata_steps data))
		 )
	    (add2sbuf_strconst nambuf "mdata_")
	    (add2sbuf_longdec nambuf datacnt)
	    (put_int datacountbox datacnt)
	    (add2sbuf_strconst nambuf "_")
	    (add2sbuf_cident nambuf (get_field :named_name msymb))
	    (if (is_a msymb class_cloned_symbol)
		(progn
		  (add2sbuf_strconst nambuf "__")
		  (add2sbuf_longdec nambuf (get_int (unsafe_get_field :csym_urank msymb)))))
	    (let ( (newname  (strbuf2string discr_string nambuf))
		   )
	      (mapobject_put mapdata data newname)
	    (foreach_in_list
	     (msteps)
	     (curpair curstep)
	     (scanstep curstep))
	    (return newname)
	    )
	  )))
       (scanstep 
	(lambda (step)
	  (debug_msg step "mg_altdraw_graphviz/scanstep step")
	  (assert_msg "mg_altdraw_graphviz.scanstep check step" (is_a step class_match_step))
	  (let ( (oldname (mapobject_get mapstep step)) 
		 )
	    (if oldname
		(progn
		  (debug_msg oldname "mg_altdraw_graphviz.scanstep found oldname")
		  (return oldname))))
	  (let ( (nambuf (make_strbuf discr_strbuf))
		 (:long mapcnt (mapobject_count mapstep))
		 (disnam (get_field :named_name (discrim step)))
		 (sdata (unsafe_get_field :mstep_data step))
		 )
	    (code_chunk chunkdisnam
			#{ meltgc_add_strbuf ((melt_ptr_t)$nambuf,
					      melt_string_str((melt_ptr_t)$disnam)+strlen("CLASS_")) }#)
	    (add2sbuf_strconst nambuf "__")
	    (add2sbuf_longdec nambuf (+i mapcnt 1))
	    (mapobject_put mapstep step (strbuf2string discr_string nambuf))
	    (if sdata (scandata sdata))
	    (scan_step_data step scandata ())
	    (scan_step_flag step scanflag ())
	    (let (
	          ;;; these are checked get fields!!
		  (sthen (get_field :mstep_then step))
		  (selse (get_field :mstep_else step))
		  (sflag (get_field :mstep_flag step))
		  )
	      (if sthen (scanstep sthen))
	      (if selse (scanstep selse))
	      (if sflag (scanflag sflag))
	      ))))
       (scanflag
	(lambda (flag)
	  (debug_msg flag  "mg_altdraw_graphviz.scanflag flag")
	  (let ( (flstep (get_field :mflag_setstep flag))
		 )
	    (if flstep
		(progn
		  (debug_msg flstep "mg_altdraw_graphviz.scanflag flstep")
		  (assert_msg "check flstep" (is_a flstep class_match_step))
		  (scanstep flstep)
		  ))
	  )))
       )
     (debug_msg mdata "mg_altdraw_graphviz before scandata mdata")
     (debug_msg scandata "mg_altdraw_graphviz scandata")
     (scandata mdata)
     (debug_msg mdata "mg_altdraw_graphviz after scandata mdata")
     (debug_msg mapdata "mg_altdraw_graphviz after scandata mapdata")
     (debug_msg mapstep "mg_altdraw_graphviz after scandata mapstep")
     )
					;;
    (let (
	  (:long datacount 0)
	  (:long stepcount 0)
	  (tupdata (make_multiple discr_multiple (mapobject_count mapdata)))
	  (tupstep (make_multiple discr_multiple (mapobject_count mapstep)))
	  )
      (foreach_in_mapobject
       (mapdata)
       (curdata dataname)
       (multiple_put_nth tupdata datacount curdata)
       (setq datacount (+i 1 datacount))
       )
      (foreach_in_mapobject
       (mapstep)
       (curstep stepname)
       (multiple_put_nth tupstep stepcount curstep)
       (setq stepcount (+i 1 stepcount))
       )
      (let (
	    (sortupdata 
	     (multiple_sort
	      tupdata
	      (lambda (d1 d2)
		(let ( 
		      (sn1 (mapobject_get mapdata d1))
		      (sn2 (mapobject_get mapdata d2))
		      )
		  (cond 
		   ( (string< sn1 sn2) 
		     '-1)
		   ( (string> sn1 sn2)
		     '1)
		   (:else
		    '0
		    )))
		)
	      discr_multiple
	      ))
	    (sortupstep 
	     (multiple_sort
	      tupstep
	      (lambda (s1 s2)
		(let ( 
		      (sn1 (mapobject_get mapstep s1))
		      (sn2 (mapobject_get mapstep s2))
		      )
		  (cond 
		   ( (string< sn1 sn2) 
		     '-1)
		   ( (string> sn1 sn2)
		     '1)
		   (:else
		    '0
		    )))
		)
	      discr_multiple
	      ))
	    )
					;; draw the data nodes
	(debug_msg sortupdata "mg_altdraw_graphviz sortupdata")
	(foreach_in_multiple
	 (sortupdata)
	 (curdata :long dix)
	 (debug_msg curdata "mg_altdraw_graphviz curdata")
	 (assert_msg "mg_altdraw_graphviz check curdata" (is_a curdata class_matched_data))
	 (let ( 
	       (curdataname (mapobject_get mapdata curdata))
	       (datactype (unsafe_get_field :mdata_ctype curdata))
	       (datasymb (unsafe_get_field :mdata_symb curdata))
	       (datasteps (unsafe_get_field :mdata_steps curdata))
	       )
	   (add2out_indentnl nodebuf 0)
	   (add2out_string nodebuf curdataname)
	   (add2out_strconst nodebuf " [ margin=0, ")
	   (if (== curdata mdata)
	       (add2out_strconst nodebuf " style=\"bold,dashed,filled,rounded\", fillcolor=\"lightyellow\", ")
	     (add2out_strconst nodebuf " style=\"dashed,rounded\", "))
	   (add2out_strconst nodebuf "label=<<table border=\"0\" cellborder=\"0\"")
	   (add2out_strconst nodebuf " cellspacing=\"1\" cellpadding=\"1\">")
	   (add2out_indentnl nodebuf 0)
	   (add2out_strconst nodebuf "<tr><td><font color=\"green\" face=\"Times-Roman Bold\" point-size=\"7\">")
	   (add2out_string nodebuf curdataname)
	   (add2out_strconst nodebuf "</font></td><td><font face=\"Courier\" point-size=\"6.5\">#")
	   (add2out_longhex nodebuf (obj_hash curdata))
	   (add2out_strconst nodebuf "</font></td></tr>")
	   (add2out_indentnl nodebuf 0)
	   (add2out_strconst nodebuf "<tr><td><font color=\"darkgreen\" face=\"Times-Roman Italic\" point-size=\"7\">")
	   (add2out_string nodebuf (get_field :named_name datasymb))
	   (if (is_a datasymb class_cloned_symbol)
	       (let ( (:long clonum (get_int (unsafe_get_field :csym_urank datasymb)))
		      )
		 (add2out_strconst nodebuf "<font point-size=\"6\">$")
		 (add2out_longdec nodebuf clonum)
		 (add2out_strconst nodebuf "</font>")
		 ))
	   (add2out_strconst nodebuf "</font></td><td><font color=\"brown\" face=\"Helvetica Oblique\" point-size=\"6\">")
	   (add2out_string nodebuf (get_field :named_name (get_field :ctype_keyword datactype)))
	   
	   (add2out_strconst nodebuf "</font></td></tr>")
	   (add2out_strconst nodebuf "</table>> ];")
	   (add2out_indentnl nodebuf 0)
					;;; output edges to the steps
	   (foreach_in_list
	    (datasteps)
	    (pairstep curstep)
	    (add2out_indentnl edgebuf 0)
	    (add2out_string edgebuf curdataname)
	    (add2out_strconst edgebuf " /*data*/ -> /*step*/ ")
	    (add2out_string edgebuf (mapobject_get mapstep curstep))
	    (add2out_strconst edgebuf " [ arrowhead=open, color=blueviolet, style=dotted ];")
	    )
	   )
	 )
					;; draw the step nodes
	(debug_msg sortupstep "mg_altdraw_graphviz sortupstep")
	(foreach_in_multiple
	 (sortupstep)
	 (curstep :long dix)
	 (debug_msg curstep "mg_altdraw_graphviz curstep")
	 (assert_msg "mg_altdraw_graphviz check curstep" (is_a curstep class_match_step))
	 (let ( 
	       (curstepname (mapobject_get mapstep curstep))
	       )
	   (assert_msg "mg_altdraw_graphviz check curstepname" (is_string curstepname))
	   (add2out_indentnl nodebuf 0)
	   (add2out_string nodebuf curstepname)
	   (add2out_strconst nodebuf " [ margin=0, ")
	   (if (is_a curstep class_match_step_success_when_flag)
	       (add2out_strconst nodebuf " style=\"filled\", bgcolor=\"palegreen\", ")
	     )
	   (add2out_strconst nodebuf "label=<<table border=\"1\" cellborder=\"1\"")
	   (add2out_strconst nodebuf " cellspacing=\"1\" cellpadding=\"1\">")
	   (add2out_indentnl nodebuf 0)
	   (add2out_strconst nodebuf "<tr><td><font color=\"blue\" face=\"Times-Roman Bold\" point-size=\"7\">")
	   (add2out_string nodebuf curstepname)
	   (add2out_strconst nodebuf "</font></td><td><font face=\"Courier\" point-size=\"6\">#")
	   (add2out_longhex nodebuf (obj_hash curstep))
	   (add2out_strconst nodebuf "</font></td></tr>")
	   (add2out_indentnl nodebuf 0)
	   (matchgraphic_altstep curstep mg)
	   (add2out_strconst nodebuf "</table>> ];")
	   (add2out_indentnl nodebuf 0)
	   )
	 )
	;; output the file
	(let (
	      )
	  (code_chunk 
	   outputmgfile
	   #{ /* $outputmgfile start */
     time_t nowt = 0;
     char nowbuf[60];
     FILE* dotfil = 
     fopen (melt_string_str ((melt_ptr_t) $DOTFILENAME), "w");
     if (!dotfil) 
        melt_fatal_error ("failed to open matchdot file %s - %m", 
		     melt_string_str ((melt_ptr_t) $DOTFILENAME));
     fprintf (dotfil, "// melt matchdot file %s\n", 
                      melt_string_str ((melt_ptr_t) $DOTFILENAME));
     time (&nowt);
     memset (nowbuf, 0, sizeof(nowbuf));
     strftime (nowbuf, sizeof(nowbuf)-1,
                       "%Y %b %d %Hh%M",
                       localtime (&nowt));
     fprintf (dotfil, "// generated %s\n", nowbuf);
     fprintf (dotfil, "digraph meltaltmatch_%lx {", $MDATAHASH);
     fprintf (dotfil, " graph [ label=<<font color='firebrick' point-size='9' face='Helvetica Bold'>Melt Alt Match %s ** %s</font>>,",
		      lbasename (melt_string_str ((melt_ptr_t) $DOTFILENAME)),
		      nowbuf);
     fprintf (dotfil," pad=\"0.5\", margin=\"0.3\" ];\n");
     fprintf (dotfil, " node [ shape=\"box\", fontsize=\"9\" ];\n");
     melt_putstrbuf (dotfil, (melt_ptr_t) $NODEBUF);
     fprintf (dotfil, "\n /// edges\n");
     melt_putstrbuf (dotfil, (melt_ptr_t) $EDGEBUF);
     fprintf (dotfil, "\n} // eof %s\n", melt_string_str ((melt_ptr_t) $DOTFILENAME));
     fclose (dotfil);
	   /* $outputmgfile end */
	   }#)
	)))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; export our classes
(export_class
 class_pattern_context
 class_normtester_any
 class_normtester_anytester
 class_normtester_disjunction
 class_normtester_instance
 class_normtester_matcher
 class_normtester_or_clear
 class_normtester_or_initial_clear
 class_normtester_or_transmit
 class_normtester_same
 class_normtester_success
 class_nrep_match
 ;;
 ;; for alternate matching
 class_matching_context
 class_match_case
 class_matched_data
 class_matched_normal_data
 class_matched_binding
 class_match_step
 class_match_flag
 class_match_step_then
 class_match_step_clear
 class_match_step_with_flag
 class_match_step_flag_set
 class_match_step_flag_operation 
 class_match_step_flag_conjonction 
 class_match_step_flag_disjonction 
 class_match_step_success_when_flag
 class_match_step_test
 class_match_step_test_variable
 class_match_step_test_group
 class_match_step_test_instance
 class_match_step_test_matcher
 ;;
 class_nrep_altmatch
 class_nrep_match_flag
 )

;;; export our values
(export_values
 scan_pattern
 normal_pattern
 )

;; eof warmelt-normatch.melt
