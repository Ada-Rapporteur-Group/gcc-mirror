;; file warmelt-normatch.melt -*- Lisp -*-
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(comment "***
    Copyright 2008, 2009, 2010 Free Software Foundation, Inc.
    Contributed by Basile Starynkevitch <basile@starynkevitch.net>

    This file is part of GCC.

    GCC is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.

    GCC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.
***")

;; the copyright notice above apply both to warmelt-normatch.melt and 
;; to the generated file  warmelt-normatch*.c

;;    This file is part of a bootstrapping compiler for the MELT lisp
;;    dialect, compiler which should be able to compile itself (into
;;    generated C file[s])


;;; class for the context of normalization of patterns
(defclass class_pattern_context
  :super class_root
  :doc #{The $CLASS_PATTERN_CONTEXT is for context of patterns'
normalization. $PCTN_NORMCTXT is the
$CLASS_NORMALIZATION_CONTEXT. $PCTN_SRC is the source match
expression. $PCTN_MAPATVAR is the mapping from symbols to pattern
variables. $PCTN_MAPATCNST is the mapping from constant objects to
pattern constants. $PCTN_MAPOR is the mapping from or source patterns
to their map of symbols to pattern variables. $PCTN_BINDLIST is the
binding list for input arguments in matcher. $PCTN_STUFFMAP is the
mapping from a matched stuff to the list of normaltesters matching
it. $PCTN_PVARLOCMAP maps pattern variable symbols to local
occurrences. $PCTN_TESTS is the list of normal
testers. $PCTN_VARHANDERS is a list of pattern variable handler when
scanning variables.}#
  :fields (pctn_normctxt		;the class_normalization_context
	   pctn_src			;the source match expressioon
	   pctn_env			;the current environment
	   ;; mapping symbols to patternvars
	   pctn_mapatvar		;objmap of patternvars
	   ;; mapping constant objects to their patternconsts
	   pctn_mapatcst		;objmap of patternconst
	   ;; mapping or source patterns to their map of symbols to patternvars
	   pctn_mapor
	   ;; binding list for input arguments in matcher
	   pctn_bindlist		;binding list 
	   ;; mapping matched stuff with list of normtesters
	   pctn_stuffmap
	   ;; mapping pattern variable symbols to local occurrences 
	   pctn_pvarlocmap
	   ;; list of tests
	   pctn_tests
	   ;; list of pattern variables handlers when scanning
	   pctn_varhandlers
	   ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; selector to scan a pattern
;;; invoked with :
;;; * the source pattern as reciever
;;; * a parent source location
;;; * a ctype
;;; * a normpatcontext
(defselector scan_pattern class_selector
  )



;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;;; catch-all for scanning any reciever (by failing)
(defun scanpat_anyrecv (recv psloc ctyp pcn)
  (debug_msg recv "scanpat_anypattern recv")
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (let ( (myclass (discrim recv))
	 (myclassname (get_field :named_name myclass)) )
    (error_strv psloc 
		"unimplemented scan_pattern for any " myclassname)
    (assert_msg "catchall scan_pattern unimplemented for any reciever" ())
    ))
(install_method discr_any_receiver scan_pattern scanpat_anyrecv)


;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;;; catch-all for scanning any pattern (by failing)
(defun scanpat_anypattern (recv psloc ctyp pcn)
  (debug_msg recv "scanpat_anypattern recv")
  (assert_msg "check recv" (is_a recv class_source_pattern))
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (let ( (myclass (discrim recv))
	 (myclassname (get_field :named_name myclass)) )
    (debug_msg myclass "scanpat_anypattern myclass [discrim of recv]")
    (error_strv psloc 
		"unimplemented scan_pattern for pattern " myclassname)
    (assert_msg "catchall scan_pattern unimplemented for pattern" ())
    ))
(install_method class_source_pattern scan_pattern scanpat_anypattern)

;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;; scanning pattern variable
(defun scanpat_srcpatvar (recv psloc ctyp pcn)
  (debug_msg recv "scanpat_srcpatvar recv")
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (assert_msg "check recv" (is_a recv class_source_pattern_variable))
  (let ( (sloc (unsafe_get_field :loca_location recv))
	 (svar (unsafe_get_field :spatvar_symb recv))
	 (mapvar (unsafe_get_field :pctn_mapatvar pcn))
	 (varhdlerlist (unsafe_get_field :pctn_varhandlers pcn))
	 (mvar (mapobject_get mapvar svar))
	 )
    (cond ( (null mvar)
	    (mapobject_put mapvar svar recv)
	    (debug_msg svar "scanpat_srcpatvar return new svar")
	    (setq mvar recv)
	    )
	  (:else
	   (debug_msg mvar "scanpat_srcpatvar return found mvar")
	   ))
    (assert_msg "check mvar" (is_a mvar class_source_pattern_variable))
    (let ( (nboccbox (unsafe_get_field :spatvar_nbocc mvar)) 
	   (:long nbocc (get_int nboccbox))
	   )
      (put_int nboccbox (+i nbocc 1)))
    (foreach_in_list
     (varhdlerlist)
     (curpair curhdler)
     (if (is_closure curhdler)
	 (curhdler mvar pcn recv)))
    ))
(install_method class_source_pattern_variable scan_pattern scanpat_srcpatvar)

;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;; scanning pattern joker
(defun scanpat_srcpatjoker (recv psloc ctyp pcn)
  (debug_msg recv "scanpat_srcpatjoker recv")
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (assert_msg "check recv" (is_a recv class_source_pattern_joker_variable))
  ;; just return
  (return)
  )
(install_method class_source_pattern_joker_variable scan_pattern scanpat_srcpatjoker)



;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;; scanning a pattern constant
(defun scanpat_srcpatconst (recv psloc ctyp pcn)
  (debug_msg recv "scanpat_srcpatconst recv")
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (assert_msg "check recv" (is_a recv class_source_pattern_constant))
  (let ( (sconst (unsafe_get_field :spat_constx recv))
	 (sloc (unsafe_get_field :loca_location recv))
	 (ncx (unsafe_get_field :pctn_normctxt pcn))
	 (mapcst (unsafe_get_field :pctn_mapatcst pcn))
	 (mcst (if (is_object sconst) (mapobject_get mapcst sconst)))
	 (ncst mcst)
	 (bindlist (unsafe_get_field :pctn_bindlist pcn))
	 (env (unsafe_get_field :pctn_env pcn))
	 )
    (assert_msg "check bindlist" (is_list bindlist))
    (cond 
     ( (not (is_object sconst))
       (debug_msg sconst "scanpat_srcpatconst nonobj literal const")
	(setq ncst sconst)
       )
     ( (null mcst)
       (multicall
	(nconst nbindconst)
	(normal_exp sconst env ncx sloc)
	(debug_msg nconst "scanpat_srcpatconst nconst")
	(mapobject_put mapcst sconst nconst)
	(if nbindconst (list_append2list bindlist nbindconst))
	(setq ncst nconst)
	))
     (:else
      (debug_msg mcst "scanpat_srcpatconst got mcst")
      ))
    (debug_msg ncst "scanpat_srcpatconst ncst")
    (let ( (rectyp (get_ctype ncst env)) )
      (debug_msg rectyp "scanpat_srcpatconst rectyp")
      (assert_msg "check rectyp" (is_a rectyp class_ctype))
      (cond ((!= rectyp ctyp)
	     (error_strv sloc "invalid ctype in constant pattern - expecting"
			 (unsafe_get_field :named_name rectyp))
	     (warning_strv sloc "got ctype"
			   (unsafe_get_field :named_name ctyp))
	     ))
      )))
(install_method class_source_pattern_constant scan_pattern scanpat_srcpatconst)

;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;; scanning a pattern object or instance
(defun scanpat_srcpatobject (recv psloc ctyp pcn)
  (debug_msg recv "scanpat_srcpatobject recv")
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (assert_msg "check recv" (is_a recv class_source_pattern_object))
  (let ( (sloc (unsafe_get_field :loca_location recv))
	 (scla (unsafe_get_field :spat_class recv))
	 (sfields (unsafe_get_field :spat_fields recv))
	 )
    (assert_msg "check scla" (is_a scla class_class))
    (assert_msg "check sfields" (is_multiple sfields))
    (foreach_in_multiple
     (sfields)
     (fldpa :long ix)
     (assert_msg "check fldp" (is_a fldpa class_source_field_pattern))
     (let ( (fld (let ( ( f (get_field :spaf_field fldpa)) )
		   (assert_msg "check fld" (is_a f class_field))
		   f))
	    (flcla (get_field :fld_ownclass fld))
	    (fpat (unsafe_get_field :spaf_pattern fldpa))
	    )
       (cond ( (not (subclass_or_eq scla flcla))
	       (error_strv sloc "bad field in object pattern"
			   (unsafe_get_field :named_name fld))
	       (inform_strv sloc "class in pattern is" (get_field :named_name scla))
	       (inform_strv sloc "class of field is" (get_field :named_name flcla))
	       (return)))
       (scan_pattern fpat sloc ctype_value pcn)
       )
     )
    (debug_msg recv "scanpat_srcpatobject end recv")
    )
  )
(install_method class_source_pattern_object scan_pattern scanpat_srcpatobject)


;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;; scanning a composite pattern 
(defun scanpat_srcpatcomposite (recv psloc ctyp pcn)
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (debug_msg recv "scanpat_srcpatcomposite start recv")
  (debug_msg ctyp "scanpat_srcpatcomposite start ctyp")
  (assert_msg "check ctyp" (is_a ctyp class_ctype))
  (assert_msg "check recv" (is_a recv class_source_pattern_composite))
  (let ( (sloc (unsafe_get_field :loca_location recv))
	 (soper (let ((sop (unsafe_get_field :spac_operator recv)))
		  (debug_msg sop "scanpat_srcpatcomposite soper")
		  (assert_msg "check soper" (is_a sop class_any_matcher))
		  sop))
	 (sins (unsafe_get_field :spac_inargs recv)) 
	 (souts (unsafe_get_field :spac_outargs recv)) 
	 (matmb (let ( (mb (unsafe_get_field :amatch_matchbind soper)) )
		  (debug_msg mb "scanpat_srcpatcomposite matmb")
		  (assert_msg "check matmb" (is_a mb class_formal_binding))
		  mb))
	 (matin (unsafe_get_field :amatch_in soper))
	 (matout (unsafe_get_field :amatch_out soper))
	 (opnam (unsafe_get_field :named_name soper))
	 (matctyp (unsafe_get_field :fbind_type matmb))
	 (env (unsafe_get_field :pctn_env pcn))
	 (ncx (unsafe_get_field :pctn_normctxt pcn))
	 (bindlist (unsafe_get_field :pctn_bindlist pcn))
	 )
    (assert_msg "check matctyp" (is_a matctyp class_ctype))
    (debug_msg matout "scanpat_srcpatcomposite matout")
    (cond ((!= ctyp matctyp)
	   (error_strv sloc "invalid ctype in composite pattern - expecting"
		       (unsafe_get_field :named_name matctyp))
	   (warning_strv sloc "got ctype"
			 (unsafe_get_field :named_name ctyp))
	   (debug_msg ctyp "scanpat_srcpatcomposite mismatched ctyp")
	   (debug_msg matctyp "scanpat_srcpatcomposite mismatched matctyp")
	   (debug_msg recv "scanpat_srcpatcomposite mismatched recv")
	   ;;
	   (return)))
    (multicall 
     (nins bindins)
     (normalize_tuple sins env ncx sloc)
     (debug_msg nins "scanpat_srcpatcomposite nins")
     (if bindins (list_append2list bindlist bindins))
     (debug_msg souts "scanpat_srcpatcomposite souts")
     (debug_msg matout "scanpat_srcpatcomposite matout")
     (foreach_in_multiple
      (souts)
      (pout :long ix)
      (debug_msg pout "scanpat_srcpatcomposite before scan_pattern pout")
      (let ( (curobind (multiple_nth matout ix)) 
	     (curctype (get_field :fbind_type curobind))
	     )
	(debug_msg curobind "scanpat_srcpatcomposite curobind")
	(debug_msg curctype "scanpat_srcpatcomposite curctype")
	(assert_msg "check curctype" (is_a curctype class_ctype))
	(scan_pattern pout sloc curctype pcn)
	(debug_msg pout "scanpat_srcpatcomposite after scan_pattern pout")
	))
     (debug_msg recv "scanpat_srcpatcomposite end recv")
     )))
(install_method class_source_pattern_composite scan_pattern scanpat_srcpatcomposite)


;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;; scanning or pattern
(defun scanpat_srcpator (recv psloc ctyp pcn)
  (debug_msg recv "scanpat_srcpator recv")
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (assert_msg "check recv" (is_a recv class_source_pattern_or))
  (debug_msg pcn "scanpat_srcpator pcn start")
  (let ( (sloc (unsafe_get_field :loca_location recv))
	 (sdisj (unsafe_get_field :orpat_disj recv))
	 (pvarmap (unsafe_get_field :pctn_mapatvar pcn))
	 (:long cntpvarmap (mapobject_count pvarmap))
	 (ownvarmap (make_mapobject discr_map_objects (+i 4 (*i cntpvarmap 2))))
	 (varhdlerlist (unsafe_get_field :pctn_varhandlers pcn))
	 (ownvarhandler
	  (lambda (mvar mypcn pvar)
	    (debug_msg mvar "scanpat_srcpator.ownvarhandler mvar")
	    (assert_msg "check mvar" (is_a mvar class_source_pattern_variable))
	    (assert_msg "check mypcn" (== mypcn pcn))
	    (let ( (msymb (unsafe_get_field :spatvar_symb mvar)) )
	      (mapobject_put ownvarmap msymb mvar))
	    ))
	 (inipvarmap 
	  (let ( 
		(inimap (make_mapobject discr_map_objects
					(+i 3 (/i (*i cntpvarmap 5) 4))))
		)
	    (foreach_in_mapobject 
	     (pvarmap)
	     (cursym curpatvar)
	     (mapobject_put inimap cursym curpatvar))
	    inimap))
	 )
    (debug_msg sdisj "scanpat_srcpator sdisj")
    (assert_msg "check sdisj" (is_multiple sdisj))
    (list_prepend varhdlerlist ownvarhandler)
    (foreach_in_multiple
     (sdisj)
     (dis :long ix)
     (debug_msg dis "scanpat_srcpator dis")
     (scan_pattern dis sloc ctyp pcn)
     )
    (let ( (:long incrpvarmap 
		  (-i (mapobject_count pvarmap)
		      cntpvarmap))
	   (pmapor (get_field :pctn_mapor pcn))
	   (orvarmap (make_mapobject discr_map_objects
				     (+i 3 (/i (*i incrpvarmap 5) 4))))
	   (oldvarhdler (list_popfirst varhdlerlist))
	   )
      (assert_msg "check pmapor" (is_mapobject pmapor))
      (assert_msg "check oldvarhdler" (== oldvarhdler ownvarhandler))
      ;; scan the updated pvarmap for new entries w.r.t. inipvarmap
      (foreach_in_mapobject 
       (pvarmap)
       (cursym curpatvar)
       (assert_msg "check cursym" (is_a cursym class_symbol))
       (assert_msg "check curpatvar" 
		   (is_a curpatvar class_source_pattern_variable))
       (assert_msg "good curpatvar"
		   (== (get_field :spatvar_symb curpatvar) cursym))
       (if (null (mapobject_get inipvarmap cursym))
	   (mapobject_put orvarmap cursym curpatvar))
       )
      (debug_msg orvarmap "scanpat_srcpator orvarmap")
      (mapobject_put pmapor recv orvarmap)
      )
    (debug_msg pcn "scanpat_srcpator pcn end")
    (debug_msg recv "scanpat_srcpator recv end")
    ))
(install_method class_source_pattern_or scan_pattern scanpat_srcpator)




;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;; scanning and pattern
(defun scanpat_srcpatand (recv psloc ctyp pcn)
  (debug_msg recv "scanpat_srcpatand recv")
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (assert_msg "check recv" (is_a recv class_source_pattern_and))
  (let ( (sloc (unsafe_get_field :loca_location recv))
	 (sconj (unsafe_get_field :andpat_conj recv))
	 )
    (assert_msg "check sconj" (is_multiple sconj))
    (foreach_in_multiple
     (sconj)
     (dis :long ix)
     (scan_pattern dis sloc ctyp pcn)
     )
    (debug_msg recv "scanpat_srcpatand end recv")
    ))
(install_method class_source_pattern_and scan_pattern scanpat_srcpatand)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; selector to normalize a pattern
;;; reciever is the pattern to normalize
;;; arguments are
;;; the normal matched stuff
;;; the closure (if any) to handle the newly created stuff -e.g. tester
;;; the pattern context


(defselector normal_pattern class_selector)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defclass class_normal_or_variable
  :super class_root
  :fields (
	   norvar_norexp
	   norvar_locsym 
	   norvar_patvar		
	   norvar_nrepor
	   )
  :doc #{The $CLASS_NORMAL_OR_VARIABLE is an internal class for
  normalization of variables under an $OR pattern. Field
  $NORVAR_PATVAR gives the associated pattern variable, field
  $NORVAR_NREPOR gives the normalized or pattern, and field
  $NORVAR_LOCSYM gives the local symbol occurrence if any.
  $NORVAR_NOREXP gives the normalized matched expression.}#
  )
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; all the testers share a common superclass
(defclass class_normtester_any 
  :super class_nrep_expression	;inherit fields: nrep_loc
  :fields (ntest_matched       	;normal matched thing
	   ntest_then		;tester to run if successful
	   ntest_else		;tester to run if failed
	   ntest_normatch	;the containing normalized match
	   ;; a list of class_nrep_locsymocc 
	   ntest_locclist	;the local occurence list inside the test
	   ;; list of tests going into this one
	   ntest_comefrom
	   ))



;; final successful tester (always succeed) just evaluate the expression
(defclass class_normtester_success
  :super class_normtester_any
  :fields (ntsuccess_do		;single expression (usually a normlet)
	   ))
 
;; quasi-tester used at failing end of disjuncts to clear a list of variables
(defclass class_normtester_or_clear
  :super class_normtester_any
  :fields (ntorclear_locsym    ;tuple of symbol occurrences to clear
	   ))

;; quasi-tester used at start of or to initialize & clear a list of variables
(defclass class_normtester_or_initial_clear
  :super class_normtester_or_clear
  :fields (
	   ))

;; quasi-tester used at succeeding end of disjuncts to transmit a list of variables
(defclass class_normtester_or_transmit
  :super class_normtester_any
  :fields (ntortransmit_dst		;tuple of locsymocc destinations
	   ntortransmit_src		;tuple of [normal] sources
))


;; all real tests share this superclass
(defclass class_normtester_anytester
  :super class_normtester_any
  :fields (
	   ))

;;; the tester wrapping or.  Needed to share the same ntest_then
;;; between disjuncts
(compile_warning "we probably need to compute the ntdisj_setorvar field somewhere")
(defclass class_normtester_disjunction
  :super class_normtester_anytester
  :fields (ntdisjuncts			;the tuple of disjunct tests
	   ntdisj_freshorvar		;the tuple of fresh or variables
	   ntdisj_setorvar		;the tuple of already set or variables
	   )
)
;; test for same (ie identical) stuff
(defclass class_normtester_same
  :super class_normtester_anytester
  :fields (ntsame_identical		;checked normal stuff
	   ))

;; test for matcher
(defclass class_normtester_matcher
    :super class_normtester_anytester
    :fields (
	     ntmatch_matcher		;the matcher
	     ntmatch_matndata		;the marcher's normal data
	     ;; both inargs & outlocs are normalized
	     ntmatch_inargs		;its input arguments tuple
	     ntmatch_outlocs		;its output locals
	     ))


;; test for instance
(defclass class_normtester_instance
    :super class_normtester_anytester
    :fields (ntinst_class		;the class 
	     ;; a tuple similar to the class's fields
	     ntinst_fieldlocs		;the tuple of field locals or nil
	     ))

;;;;;;;;;;;;;;;;
(defclass class_nrep_match
  :super class_nrep_typed_expression
  :fields (nmatch_tests			;sequence of tests
	   nmatch_stuffmap		;mapping matched stuff with
					;list or normal tests
	   nmatch_matched		;the normal matched stuff
	   ))

;;;;;; utility function to register a new normtester
(defun register_new_normtester (ntest pcn)
  (debug_msg ntest "register_new_normtester ntest")
  (debug_msg pcn "register_new_normtester pcn")
  (assert_msg "check ntest" (is_a ntest class_normtester_any))
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (let ( (nmatched (unsafe_get_field :ntest_matched ntest))
	 (stuffmap (unsafe_get_field :pctn_stuffmap pcn))
	 )
    (assert_msg "check nmatched" (is_object nmatched))
    (assert_msg "check stuffmap" (is_mapobject stuffmap))
    (let (
	  (ntlist
	   (let ( (ntl (mapobject_get stuffmap nmatched)) )
	     (if (is_list ntl) 
		 ntl
	       (let ( (newntl (make_list discr_list)) )
		 (mapobject_put stuffmap nmatched newntl)
		 newntl)
	       )))
	  )
      (assert_msg "check ntlist" (is_list ntlist))
      (list_append ntlist ntest)
      (debug_msg stuffmap "register_new_normtester updated stuffmap")
      (return)
      )))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; utility to set the then of a last test; also handle the case of
;; disjunctions by propagating into them
(defun put_tester_then (curtester thentester)
  (debug_msg curtester "put_tester_then curtester")
  (debug_msg thentester "put_tester_then thentester")
  (assert_msg "check curtester" (is_a curtester class_normtester_any))
  (assert_msg "check thentester" (is_a thentester class_normtester_any))
  (assert_msg "check curtester has no then" 
	     (null (unsafe_get_field :ntest_then curtester)))
  (let ( (thencome (unsafe_get_field :ntest_comefrom thentester)) )
    (assert_msg "check thencome" (is_list thencome))
    (list_append thencome curtester))
  (assert_msg "check curtester not a normtester success"
	      (is_not_a curtester class_normtester_success))
  (unsafe_put_fields curtester :ntest_then thentester)
  ;;; propagate into disjunctions
  (if (is_a curtester class_normtester_disjunction)
      (let ( (curdisjtuple (unsafe_get_field :ntdisjuncts curtester)) )
	(debug_msg curdisjtuple "put_tester_then curdisjtuple")
	(foreach_in_multiple 
	 (curdisjtuple)
	 (curdisj :long disjix)
	 (debug_msg curdisj "put_tester_then curdisj")
	 (let ( (curcont (instance class_container :container_value curdisj)) )
	 (debug_msg curcont "put_tester_then curcont start")
	 (set_new_tester_last_then thentester curcont)
	 (debug_msg curcont "put_tester_then curcont done")
	 ))
      ))
  (debug_msg curtester "put_tester_then curtester done")
)

;; utility to set the newtester to the last of a ntest_then linked list
(defun set_new_tester_last_then (newtester testercont)
  (debug_msg newtester "set_new_tester_last_then newtester")
  (debug_msg testercont "set_new_tester_last_then testercont")
  (shortbacktrace_dbg "set_new_tester_last_then start" 15)
  (assert_msg "check newtester" (is_a newtester class_normtester_any))
  (assert_msg "check testercont" (is_a testercont class_container))
  (let ( (curtester (get_field :container_value testercont)) )
    (forever 
     lastesterloop
     (debug_msg curtester "set_new_tester_last_then loop curtester")
     ;; indeed a safe get_field to handle the nil case!
     (let ( (nextester (get_field :ntest_then curtester)) )
       (if (is_a nextester class_normtester_any)
	   (setq curtester nextester)
	 (exit lastesterloop))))
    (debug_msg curtester "set_new_tester_last_then final curtester")
    (assert_msg "check curtester set_new_tester_last_then" curtester)
    (put_fields testercont :container_value curtester)
    (put_tester_then curtester newtester)
    (debug_msg testercont "set_new_tester_last_then end testercont")
    ))


;; recursive utility to set a newtester as all the unset else branches
;; of a given partester return the list of updated testers, ie the
;; updatlist - which should be null initially
(defun set_new_tester_all_elses (newtester partester updatlist)
  (debug_msg newtester "set_new_tester_all_elses newtester")
  (debug_msg partester "set_new_tester_all_elses partester")
  (shortbacktrace_dbg "set_new_tester_all_elses start" 15)
  (assert_msg "check newtester" (is_a newtester class_normtester_any))
  (assert_msg "check partester" (is_a partester class_normtester_any))
  (if (null updatlist) 
      (setq updatlist (make_list discr_list)))
  (assert_msg "check updatlist" (is_list updatlist))
  (forever
   allelseloop
   (debug_msg partester "set_new_tester_all_elses allelseloop partester")
   (cond
    ((null partester) 
     (exit allelseloop))
    ((is_a partester class_normtester_anytester)
     (let ( (eltest (unsafe_get_field :ntest_else partester)) 
	    (thtest (unsafe_get_field :ntest_then partester))
	    )
       (cond
	((null eltest)
	 (put_fields partester :ntest_else newtester)
	 (debug_msg partester "set_new_tester_all_elses updated partester")
	 (list_append updatlist partester)
	 )
	(:else
	 (foreach_in_list
	  (updatlist)
	  (curpair curtest)
	  (if (== curtest partester) 
	      (exit allelseloop))
	  (if (== curtest newtester)
	      (exit allelseloop))
	  )
	 (setq partester eltest))
	)
       (cond ( (is_a thtest class_normtester_anytester)
	 (foreach_in_list
	  (updatlist)
	  (curpair curtest)
	  (if (== curtest thtest) 
	      (exit allelseloop))
	  (if (== curtest newtester)
	      (exit allelseloop))
	  )
	 (debug_msg thtest "set_new_tester_all_elses before recursion")
	 (set_new_tester_all_elses newtester thtest updatlist)
	 (debug_msg thtest "set_new_tester_all_elses after recursion")
	 )))
     )
    (:else
     (exit allelseloop)))
   ) ;;;; end forever allelseloop
  (debug_msg updatlist "set_new_tester_all_elses return updatlist")
  (return updatlist)
  )
  


;;; expansion of tuples in cmatcher should be done in warmelt-genobj

;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;;; catch-all for normpat any reciever (by failing)
(defun normpat_anyrecv (recv nmatch hdler pcn)
  (debug_msg recv "normpat_anyrecv recv")
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (let ( (myclass (discrim recv))
	 (myclassname (get_field :named_name myclass)) 
	 (psloc (get_field :loca_location (get_field :pctn_src pcn)))
	 )
    (error_strv psloc 
		"unimplemented normal_pattern for any " myclassname)
    (assert_msg "catchall normal_pattern unimplemented" ())
    ))
(install_method discr_any_receiver normal_pattern normpat_anyrecv)

;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;;; catch-all for normpat any pattern (by failing)
(defun normpat_anypat (recv nmatch hdler  pcn)
  (debug_msg recv "normpat_anyrecv recv")
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (assert_msg "check recv" (is_a recv class_source_pattern))
  (let ( (myclass (discrim recv))
	 (myclassname (get_field :named_name myclass)) 
	 (psloc (get_field :loca_location (get_field :pctn_src pcn)))
	 )
    (error_strv psloc 
		"unimplemented NORMAL_PATTERN for pattern of " myclassname)
    (assert_msg "catchall normal_pattern unimplemented on pattern" ())
    ))
(install_method class_source_pattern normal_pattern normpat_anypat)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; internal function when normalizing a variable pattern to generate
;;; or reuse a test
(defun normvarpat_genreusetest (sloc nmatch lococc testlist tstuff hdler pcn)
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (assert_msg "check lococc" (is_a lococc class_nrep_locsymocc))
  (let (
	(tester ())
	(curhdler hdler)
	)
    (forever 
     loopstuff
     (debug_msg tstuff "normvarpat_genreusetest tstuff")
     (cond 
      ( (== (get_field :ntsame_identical tstuff) lococc)
	(setq tester tstuff)
	(exit loopstuff)
	)
      ( (is_a tstuff class_normtester_any)
	(setq tstuff (get_field :ntest_else tstuff))
	(setq curhdler 
	      (lambda (tester)
		(shortbacktrace_dbg "normvarpat_genreusetest lambda curhdler" 15)
		(put_fields tstuff :ntest_else tester)
		(debug_msg tstuff "normvarpat_genreusetest lambda curhdler updatelse of tstuff")
		(list_append (get_field :ntest_comefrom tester) tstuff)
		))
	)
      (:else
       (let ( (newtester (instance class_normtester_same
				   :nrep_loc sloc
				   :ntest_matched nmatch
				   :ntest_then ()
				   :ntest_else ()
				   :ntest_locclist ()
				   :ntest_comefrom (make_list discr_list)
				   :ntsame_identical lococc))
	      )
	 (shortbacktrace_dbg "normvarpat_genreusetest making same newtester" 15)
	 (register_new_normtester newtester pcn)
	 (debug_msg newtester "normvarpat_genreusetest newtester same")
	 (setq tester newtester)
	 (list_append testlist newtester)
	 (curhdler newtester)
	 (exit loopstuff)
	 )
       )
      )
     )
    )
  )

;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;;; normalize variable pattern
(defun normpat_variablepat (recv nmatch hdler pcn)
  (debug_msg recv "normpat_variablepat recv")
  (debug_msg nmatch "normpat_variablepat nmatch")
  (assert_msg "check recv" (is_a recv class_source_pattern_variable))
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (shortbacktrace_dbg "normpat_variablepat begin" 15) 
  (let ( (stuffmap (get_field :pctn_stuffmap pcn))
	 (pvarlocmap (get_field :pctn_pvarlocmap pcn)) 
	 (psloc (get_field :loca_location (get_field :pctn_src pcn)))
	 (sloc (get_field :loca_location recv))
	 (patvar (get_field :spatvar_symb recv))
	 (tstuff (mapobject_get stuffmap nmatch))
	 (lococc (mapobject_get pvarlocmap patvar))
	 (env (get_field :pctn_env pcn))
	 (ncx (get_field :pctn_normctxt pcn))
	 (testlist (get_field :pctn_tests pcn))
	 )
    (debug_msg tstuff "normpat_variablepat tstuff")
    (debug_msg lococc "normpat_variablepat lococc")
    (debug_msg patvar "normpat_variablepat patvar")
    (compile_warning "we need to generate the clear of all or-variables")
    (cond 
     ( (is_a lococc class_nrep_locsymocc)
       ;; patvar already bound, generate or reuse a same test
       (debug_msg lococc "normpat_variablepat alreadybound lococc")
       (normvarpat_genreusetest sloc nmatch lococc testlist tstuff hdler pcn)
       )
     ;; process specially or variables
     ((is_a lococc class_normal_or_variable)
      (debug_msg lococc "normpat_variablepat lococc orvariable")
      (compile_warning "normpat_variablepat unhandled orvariable")
      (let ( (realococc (unsafe_get_field :norvar_locsym lococc)) 
	     (npatvar (unsafe_get_field :norvar_patvar lococc))
	     (patsym (get_field :spatvar_symb npatvar))
	     )
	(debug_msg npatvar "normpat_variablepat orvariable npatvar")
	(assert_msg "check patsym == patvar" (== patsym patvar))
	(debug_msg realococc "normpat_variablepat orvariable realococc")
	(cond ( (null realococc)
		;; the or-variable was not bound at all
		(let ( 
		      (ctyp (get_ctype nmatch env))
		      (cbind (instance class_normal_let_binding
				       :letbind_loc sloc
				       :binder patsym
				       :letbind_type ctyp
				       :letbind_expr nmatch
				       ))
		      (clocc (instance class_nrep_locsymocc
				       :nrep_loc sloc
				       :nocc_ctyp ctyp
				       :nocc_symb patsym
				       :nocc_bind cbind))
		      )
		  (debug_msg clocc "normpat_variablepat fresh orvariable clocc")
		  (put_fields lococc 
			      :norvar_locsym clocc
			      :norvar_norexp nmatch)
		  (debug_msg lococc "normpat_variablepat updated fresh orvariable lococc")
		  (shortbacktrace_dbg "normpat_variablepat updated fresh orvar" 15)
		  ;; put the clocc in the symbol cache map
		  (mapobject_put (get_field :nctx_symbcachemap ncx) patvar clocc)
		  (mapobject_put pvarlocmap patvar clocc)
		  (debug_msg pvarlocmap "normpat_variablepat updated fresh orvariable pvarlocmap")
		  )
		)
	      ;;
	      ;; the or-variable was already bound within the same
	      ;; disjunct, so generate or reuse a same test
	      ( (is_a realococc class_nrep_locsymocc)
		(debug_msg realococc "normpat_variablepat bound orvariable realococccc")
		(normvarpat_genreusetest sloc nmatch realococc testlist tstuff hdler pcn)
		)
	      ;; the or-variable was already bound in a previous
	      ;; disjunction
	      ( (is_box realococc)
		(let ( 
		      (ctyp (get_ctype nmatch env))
		      (bxclocc (box_content realococc))
		      )
		  (debug_msg bxclocc "normpat_variablepat bxclocc")
		  (assert_msg "check bxclocc" (is_a bxclocc class_nrep_locsymocc))
		  ;; check ctype compatibility with former occurence
		  (let (
			 (prevctyp (unsafe_get_field :nocc_ctyp bxclocc))
			 )
		    (if (!= ctyp prevctyp)
			(let ( (prevsloc (unsafe_get_field :nrep_loc bxclocc)) 
			       )
			  (error_strv sloc "incompatible type for pattern variable inside OR pattern"
				      (get_field :named_name (unsafe_get_field :nocc_symb bxclocc)))
			  (inform_strv sloc "disjunct pattern variable occurs here with type"
				       (get_field :named_name (get_field :ctype_keyword ctyp)))
			  (inform_strv prevsloc "disjunct pattern variable occurs previously with type"
				       (get_field :named_name (get_field :ctype_keyword prevctyp)))
			  )))
		  (put_fields lococc 
			      :norvar_locsym bxclocc
			      :norvar_norexp nmatch)
		  (debug_msg lococc "normpat_variablepat updated reusing orvariable lococc")
		  (shortbacktrace_dbg "normpat_variablepat updated reused orvar" 15)
		))
	      ;; unexpected case
	      (:else
	       (assert_msg "normpat_variablepat corruption" ())
	       )
	      )
	)
      )
     ;; else patvar unbound, so bind it 
     ((null lococc)
      (let ( (ctyp (get_ctype nmatch env))
	     (cbind (instance class_normal_let_binding
			      :letbind_loc sloc
			      :binder patvar
			      :letbind_type ctyp
			      :letbind_expr nmatch
			      ))
	     (clocc (instance class_nrep_locsymocc
			      :nrep_loc sloc
			      :nocc_ctyp ctyp
			      :nocc_symb patvar
			      :nocc_bind cbind))
	     )
	(debug_msg ctyp "normpat_variablepat ctyp")
	(debug_msg clocc "normpat_variablepat new clocc")
	(shortbacktrace_dbg "normpat_variablepat:: new clocc" 12)
	;; put the clocc in the symbol cache map
	(mapobject_put (get_field :nctx_symbcachemap ncx) patvar clocc)
	(mapobject_put pvarlocmap patvar clocc)
	(debug_msg patvar "normpat_variablepat updated patvar")
	(debug_msg clocc "normpat_variablepat updated clocc")
	(debug_msg pvarlocmap "normpat_variablepat updated pvarlocmap")
	)
      )
     (:else
      (assert_msg "normpat_variablepat unexpected lococc" ())
      )
     )
    )
  )
(install_method class_source_pattern_variable normal_pattern normpat_variablepat)
;;;;;;;;;;;;;;;;





;;; normalize joker pattern
(defun normpat_jokerpat (recv nmatch hdler pcn)
  (debug_msg recv "normpat_jokerpat recv")
  (debug_msg nmatch "normpat_jokerpat nmatch")
  (assert_msg "check recv" (is_a recv class_source_pattern_joker_variable))
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  ;; we need nothing more, a joker pattern is essentially a black hole..
)
(install_method class_source_pattern_joker_variable normal_pattern normpat_jokerpat)




;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;;; normalize instance pattern
(defun normpat_instancepat (recv nmatch hdler pcn)
  (debug_msg recv "normpat_instancepat recv start")
  (debug_msg nmatch "normpat_instancepat nmatch")
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (assert_msg "check recv" (is_a recv class_source_pattern_instance))
  (let ( (psloc (get_field :loca_location (get_field :pctn_src pcn)))
	 (sloc (get_field :loca_location recv))
	 (env (unsafe_get_field :pctn_env pcn))
	 (patcla (get_field :spat_class recv))
	 (patfields (get_field :spat_fields recv))
	 (oldenv env)
	 (ncx (get_field :pctn_normctxt pcn))
	 (stuffmap (get_field :pctn_stuffmap pcn))
	 (tstuff (mapobject_get stuffmap nmatch))
	 (tester ())
	 (curhdler hdler)
	 (testlist (get_field :pctn_tests pcn))
	 ;; we know for sure that patcla is a class_class
	 ;; hence its normalization does not make any bindings!
	 (npatcla (normal_exp patcla env ncx sloc))
	 )
    (assert_msg "check patcla" (is_a patcla class_class))
    ;; find the tester in the stuff
    (forever
     loopstuff
     (debug_msg tstuff "normpat_instancepat loop tstuff")
     ;; check if tstuff is a class_normtester_instance with good :ntinst_class
     (cond
      ( (== (get_field :ntinst_class tstuff) patcla)
	(setq tester tstuff)
	(exit loopstuff)
	)
      ((is_a tstuff class_normtester_any)
       (setq tstuff (get_field :ntest_else tstuff))
       (setq curhdler
	     (lambda (tester)
	       (shortbacktrace_dbg "normpat_instancepat lambda" 15)
	       (put_fields tstuff :ntest_else tester)
	       (debug_msg tstuff "normpat_instancepat lambda updatelse of tstuff")
	       (list_append (get_field :ntest_comefrom tester) tstuff)
	       ))
       )
      (:else
       (let ( 
	     (newfieldlocs
	      (make_multiple 
	       discr_multiple
	       (multiple_length (get_field :class_fields patcla))
	       ))
	     (newtester 
	      (instance class_normtester_instance
			:nrep_loc sloc
			:ntest_matched nmatch
			:ntest_then ()
			:ntest_else ()
			:ntest_locclist (make_list discr_list)
			:ntest_comefrom (make_list discr_list)
			:ntinst_class npatcla
			:ntinst_fieldlocs newfieldlocs
			))
	     )
	 (debug_msg newtester "normpat_instancepat newtester")
	 (register_new_normtester newtester pcn)
	 (setq tester newtester)
	 (list_append testlist newtester)
	 (debug_msg curhdler "normpat_instancepat before calling curhdler")
	 (curhdler tester)
	 (debug_msg curhdler "normpat_instancepat after calling curhdler")
	 (exit loopstuff)
	 )
       ))
     )
    (debug_msg tester "normpat_instancepat tester")
    (debug_msg recv "normpat_instancepat recv after tester")
    (debug_msg patcla "normpat_instancepat patcla")
    (let ( (testloccl (get_field :ntest_locclist tester)) 
	   (testercont (instance class_container
				 :container_value tester
				 ))
	   )
      (debug_msg testercont "normpat_instancepat testercont before loop")
      (assert_msg "check testbindl" (is_list testloccl))
      (foreach_in_multiple
       (patfields)
       (curpatf :long patix)
       (debug_msg curpatf "normpat_instancepat curpatf in loop")
       (debug_msg testercont "normpat_instancepat testercont in loop")
       (assert_msg "check curpatf" (is_a curpatf class_source_field_pattern))
       (let ( (floc (get_field :loca_location curpatf))
	      (curfld (get_field :spaf_field curpatf))
	      (cursubpat (get_field :spaf_pattern curpatf))
	      (curfldcla (get_field :fld_ownclass curfld))
	      (subhdler 
	       (lambda (newsubtester)
		 (debug_msg newsubtester "normpat_instancepat.subhdler newsubtester")
		 (debug_msg testercont "normpat_instancepat.subhdler testercont")
		 (shortbacktrace_dbg "normpat_instancepat.subhdler" 16)
		 (let ( (prevtester (get_field :container_value testercont)) )
		   (debug_msg prevtester "normpat_instancepat.subhdler prevtester")
		   (assert_msg "check prevtester" (is_a prevtester class_normtester_anytester))
		   (set_new_tester_last_then newsubtester testercont)
		   )
		 (debug_msg newsubtester "normpat_instancepat.subhdler end newsubtester")
		 ))
	      )
	 (debug_msg curfld "normpat_instancepat curfld")
	 (cond  ( (== curfldcla patcla) ())
		( (subclass_of patcla curfldcla) ())
		(:else (error_strv floc "bad field in instance pattern" (get_field :named_name curfld))))
	 (debug_msg cursubpat "normpat_instancepat before normal_pattern cursubpat")
	 (let ( (curloccl ())
		)
	   (debug_msg testloccl "normpat_instancepat scanning testloccl")
	   ;; try to find an existing local occurrence for the field
	   (foreach_in_list 
	    (testloccl)
	    (testpair testlocsy)
	    (assert_msg "check testlocsy" (is_a testlocsy class_nrep_locsymocc))
	    (if (== curfld
		    (get_field :nuget_field (get_field :letbind_expr (get_field :nocc_bind testlocsy))))
		(progn
		  (setq testpair ())	;to exist from foreach
		  (setq curloccl testlocsy)))
	    )
	   (debug_msg curloccl "normpat_instancepat got curloccl")
	   ;; if no local occurrence found, add a new one
	   (if (null curloccl)
	       (let ( 
		     (newsym (clone_symbol (get_field :named_name curfld))) 
		     (nflexp (instance class_nrep_unsafe_get_field
				       :nrep_loc floc
				       :nuget_obj nmatch
				       :nuget_field curfld))
		     (newbind (instance class_normal_let_binding
					:binder newsym
					:letbind_type ctype_value
					:letbind_expr nflexp
					:letbind_loc floc))
		     (newlocc (instance class_nrep_locsymocc
					:nrep_loc floc
					:nocc_ctyp ctype_value
					:nocc_symb newsym
					:nocc_bind newbind
					))
		     )
		 (multiple_put_nth 
		  (get_field :ntinst_fieldlocs tester) 
		  (get_int curfld)
		  newlocc)
		 ;; put the newlocc in the symbol cache map
		 (mapobject_put (get_field :nctx_symbcachemap ncx) newsym newlocc)
		 (debug_msg tester "normpat_instancepat updated fieldlocs tester")
		 (list_append testloccl newlocc)
		 (debug_msg newlocc "normpat_instancepat made newlocc")
		 (setq curloccl newlocc)
		 ))
	   (debug_msg cursubpat "normpat_instancepat before normal_pattern cursubpat")
	   (normal_pattern cursubpat curloccl subhdler pcn)
	   (debug_msg cursubpat "normpat_instancepat after normal_pattern cursubpat")
	   (debug_msg curpatf "normpat_instancepat did curpatf")
	   )
	 )))
    (debug_msg tester "normpat_instancepat final tester")
    )
  (debug_msg recv "normpat_instancepat recv end")
  )
(install_method class_source_pattern_instance normal_pattern normpat_instancepat)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;;; normalize a conjonction [and of subpatterns]
(defun normpat_andpat (recv nmatch hdler pcn)
  (debug_msg recv "normpat_andpat recv")
  (debug_msg nmatch "normpat_andpat nmatch")
  (debug_msg pcn "normpat_andpat pcn")
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (assert_msg "check recv" (is_a recv class_source_pattern_and))
  (let (
	(sloc (get_field :loca_location recv))
	(conjpats (get_field :andpat_conj recv))
	(testercont (instance class_container))
	(subhdler
	 (lambda (newtester) 
	   (debug_msg newtester "normpat_andpat.subhdler newtester")
	   (debug_msg testercont "normpat_andpat.subhdler testercont")
	   (let ( (prevtester (get_field :container_value testercont)) )
	     (cond
	      ((is_a prevtester class_normtester_any)
	       (debug_msg prevtester "normpat_andpat.subhdler prevtester")
	       (set_new_tester_last_then newtester testercont)
	       )
	      (:else
	       (debug_msg newtester "normpat_andpat.subhdler before calling hdler")
	       (hdler newtester)
	       (put_fields testercont :container_value newtester)
	       (debug_msg newtester "normpat_andpat.subhdler after calling hdler")
	       ))
	     (debug_msg testercont "normpat_andpat.subhdler done testercont")
	     )))
	)
    (foreach_in_multiple 
     (conjpats)
     (subpat :long subix)
     (debug_msg testercont "normpat_andpat testercont")
     (debug_msg subpat "normpat_andpat subpat before normal_pattern")
     (normal_pattern subpat nmatch subhdler pcn)
     (debug_msg subpat "normpat_andpat subpat after normal_pattern")
     (debug_msg testercont "normpat_andpat subpat testercont")
     )
    (debug_msg recv "normpat_andpat recv end")
    ))
(install_method class_source_pattern_and normal_pattern normpat_andpat)




;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;;; normalize a disjunction [or of subpatterns]

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun normpat_orpat (recv nmatch hdler pcn)
  (debug_msg recv "normpat_orpat recv")
  (shortbacktrace_dbg "normpat_orpat called" 16)
  (debug_msg nmatch "normpat_orpat nmatch")
  (debug_msg pcn "normpat_orpat pcn")
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (assert_msg "check recv" (is_a recv class_source_pattern_or))
  (let (
	(sloc (get_field :loca_location recv))
	(disjpats (get_field :orpat_disj recv))
	(testlist (get_field :pctn_tests pcn))
	(subtestlist (make_list discr_list)) ;; the list of subtests
	(stuffmap (get_field :pctn_stuffmap pcn))
	(pvarlocmap (get_field :pctn_pvarlocmap pcn)) 
	(mapor (get_field :pctn_mapor pcn))
	(ncx (get_field :pctn_normctxt pcn))
	(orvarmap (mapobject_get mapor recv)) 
	(sortedorsymbs (mapobject_sorted_attribute_tuple orvarmap))
	(disjtester (instance class_normtester_disjunction 
			      :nrep_loc sloc
			      :ntest_matched nmatch
			      :ntest_then ()
			      :ntest_else ()
			      :ntest_comefrom (make_list discr_list)
			      :ntdisjuncts ()
			      :ntdisj_freshorvar ()
			      :ntdisj_setorvar ()
			      )) 
	(sortorvars 
	 (multiple_map 
	  sortedorsymbs
	  (lambda (orsymb :long orix)
	    (let (
		  (curvarpat (mapobject_get orvarmap orsymb))
		  (curorvar (instance class_normal_or_variable
				      :norvar_patvar curvarpat
				      :norvar_nrepor disjtester
				      :norvar_norexp ()
				      :norvar_locsym ())
			    )
		  )
	      (assert_msg "check curvarpat"
			  (is_a curvarpat class_source_pattern_variable))
	      (put_int curorvar orix)
	      (debug_msg curorvar "normpat_orpat/sortlambda curorvar")
	      (debug_msg curvarpat "normpat_orpat/sortlambda curvarpat")
	      (debug_msg orsymb "normpat_orpat/sortlambda orsymb")
	      (mapobject_put pvarlocmap orsymb curorvar)
	      (debug_msg pvarlocmap "normpat_orpat/sortlambda updated pvarlocmap")
	      (return curorvar)
	      ))
	  ))
	(prevcont (instance class_container
			    :container_value disjtester))
	)
    (debug_msg stuffmap "normpat_orpat orig stuffmap")
    (debug_msg pvarlocmap "normpat_orpat orig pvarlocmap")
    (debug_msg orvarmap "normpat_orpat orvarmap")
    (assert_msg "check orvarmap" (is_mapobject orvarmap))
    (debug_msg sortedorsymbs "normpat_orpat sortedorsymbs")
    (debug_msg sortorvars "normpat_orpat sortorvars")
    ;; first register and handle the empty disjtester
    (debug_msg disjtester "normpat_orpat disjtester")
    (register_new_normtester disjtester pcn)
    (hdler disjtester)
    (list_append testlist disjtester)
    (debug_msg disjtester "normpat_orpat handled disjtester")
;;;;;;;;;;;;;;;;
;;;; foreach disjunctive subpattern
    (foreach_in_multiple
     (disjpats)
     (curdisj :long disjix)
     (let ( (clearloclist (make_list discr_list))
	    )
       (foreach_in_multiple
	(sortorvars)
	(curorvar :long orvix)
	(assert_msg "check curorvar" (is_a curorvar class_normal_or_variable))
	(let ( (orvarlocc (unsafe_get_field :norvar_locsym curorvar))
	       )
	  (if (is_a orvarlocc class_nrep_locsymocc)
	      (let ( (orvarbox (make_box discr_box orvarlocc)) )
		(put_fields curorvar :norvar_locsym orvarbox)
		(list_append clearloclist orvarlocc)
		))
	  ))
       (let (
	     (norclear (instance class_normtester_or_clear
				 :nrep_loc sloc
				 :ntest_matched nmatch
				 :ntest_then ()
				 :ntest_else ()
				 :ntest_comefrom (make_list discr_list)
				 :ntorclear_locsym (list_to_multiple clearloclist)
				 ))
	     )
;;;;;;;;;;;;;;;;
	 ;; normalize the current disjunct
	 (debug_msg curdisj "normpat_orpat curdisj before normalization")
	 ;; add the norclear
	 (let (
	       (prevtest (get_field :container_value prevcont))
	       (prevloc (get_field :nrep_loc prevtest))
	       )
	   (debug_msg prevtest "normpat_orpat prevtest")
	   (debug_msg norclear "normpat_orpat norclear")
	   (list_append testlist norclear)
	   (debug_msg norclear "normpat_orclear setallelses norclear")
	   (debug_msg prevtest "normpat_orclear setallelses prevtest")
	   (set_new_tester_all_elses norclear prevtest)
	   (put_fields prevcont :container_value norclear)
	   (debug_msg prevcont "normpat_orpat prevcont with norclear")
	   ;;
	   (let (
		 (subdisjbox (make_box discr_box ()))
		 (subdisjhandler 
		  (lambda (subtester)
		    (debug_msg subtester "normpat_orpat.lambda subtester")
		    (box_put subdisjbox subtester)
		    (let (
			  (prevtestsub (unsafe_get_field :container_value prevcont))
			  )
		      (list_append subtestlist subtester)
		      (debug_msg subtester "normpat_orpat.lambda setlastthen subtester")
		      (debug_msg prevcont "normpat_orpat.lambda setlastthen subtester")
		      (set_new_tester_last_then subtester prevcont)
		      (debug_msg subtester "normpat_orpat.lambda done subtester")
		      (put_fields prevcont :container_value subtester)
		      (debug_msg prevcont "normpat_orpat prevcont with subtester")
		      ))
		  )
		 )
	     (normal_pattern curdisj nmatch 
			     subdisjhandler pcn)       
	     (debug_msg curdisj "normpat_orpat curdisj after normalization")
	     (let (
		   (lastdisj (box_content subdisjbox))
		   (prevtestrans (unsafe_get_field :container_value prevcont))
		   (nortransm (instance class_normtester_or_transmit
					:nrep_loc sloc
					:ntest_matched nmatch
					:ntest_then ()
					:ntest_else ()
					:ntest_comefrom (make_list discr_list)
					:ntortransmit_dst ()
					:ntortransmit_src ()
					))
		   )
	       (debug_msg prevtestrans "normpat_orpat prevtestrans")
	       (list_append testlist nortransm)
	       (debug_msg nortransm "normpat_orpat setlasthen nortransm")
	       (debug_msg prevcont "normpat_orpat setlasthen prevcont")
	       (set_new_tester_last_then nortransm prevcont)
	       ;; if no proper disjunct test was generated, add the
	       ;; ortransmit to the list of tests, so that distributing
	       ;; the then thru the disjunct still works!
	       (if (null lastdisj)
		   (list_append subtestlist nortransm))
	       )
	     )
	   )
	 (debug_msg curdisj "normpat_orpat done curdisj")
	 )
       )
     )
    ;;
    (debug_msg pvarlocmap "normpat_orpat pvarlocmap before freshorvar")
    (debug_msg subtestlist "normpat_orpat final subtestlist")
    (let ( (freshorvar
	    (multiple_map
	     sortorvars
	     (lambda (curorvar :long orix)
	       (assert_msg "check curorvar" (is_a curorvar class_normal_or_variable))
	       (let ( (orlocsy (unsafe_get_field :norvar_locsym curorvar))
		      (patvar (unsafe_get_field :norvar_patvar curorvar))
		      (orsymb (get_field :spatvar_symb patvar))
		      )
		 (if (is_box orlocsy)
		     (setq orlocsy (box_content orlocsy)))
		 ;; the pvarlocmap should already have orsymb bound to orlocsy
		 (debug_msg orsymb "normpat_orpat/finalambda orsymb")
		 (debug_msg orlocsy "normpat_orpat/finalambda orlocsy")
		 (return orlocsy))
	       ))
	    )
	   )
      (debug_msg freshorvar "normpat_orpat final freshorvar")
      (put_fields disjtester 
		  :ntdisjuncts (list_to_multiple subtestlist)
		  :ntdisj_freshorvar freshorvar
		  )
      (debug_msg disjtester "normpat_orpat final disjtester")
      )
    ;;
    (compile_warning "@$@unimplemented normpat_orpat")
    (debug_msg recv "enf normpat_orpat recv")
    ))

(install_method class_source_pattern_or normal_pattern normpat_orpat)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;
;;; normalize anymatcher pattern
(defun normpat_anymatchpat (recv nmatch hdler pcn)
  (debug_msg recv "normpat_anymatchpat recv")
  (debug_msg nmatch "normpat_anymatchpat nmatch")
  (debug_msg pcn "normpat_anymatchpat pcn")
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (assert_msg "check recv" (is_a recv class_source_pattern_matcher))
  (shortbacktrace_dbg "normpat_anymatchpat start" 14)
  (let (
	(sloc (get_field :loca_location recv))
	(mat (get_field :spac_operator recv))
	(matopbind (get_field :spac_operbind recv))
	(inargs (get_field :spac_inargs recv))
	(outargs (get_field :spac_outargs recv))
	(env (unsafe_get_field :pctn_env pcn))
	(oldenv env)
	(ncx (unsafe_get_field :pctn_normctxt pcn))
	(bindlist (unsafe_get_field :pctn_bindlist pcn))
	(stuffmap (unsafe_get_field :pctn_stuffmap pcn))
	(matchctype (get_ctype nmatch env))
	(testlist (get_field :pctn_tests pcn))
	)
    (assert_msg "check mat" (is_a mat class_any_matcher))
    (assert_msg "check matopbind" (is_a matopbind class_any_binding))
    (debug_msg inargs "normpat_anymatchpat inargs")
    (debug_msg mat "normpat_anymatchpat mat")
    (debug_msg matopbind "normpat_anymatchpat matopbind")
    (let ( 
	  (matvar (let ( (mv (get_field :binder matopbind)) )
		    (debug_msg mv "normpat_anymatchpat matvar")
		    (assert_msg "check matvar's binding"
				(== (find_env env mv) matopbind))
		    mv
		    ))
	  ;; we know that matvar is a symbol so its normalization
	  ;; returns a single value
	  (matndata (normal_exp matvar env ncx sloc))
	  )
      (debug_msg matndata "normpat_anymatchpat matndata")
      (multicall
       (nins bindins)
       (normalize_tuple inargs env ncx sloc)
       (debug_msg nins "normpat_anymatchpat nins")
       (debug_msg bindins "normpat_anymatchpat bindins")
       (if bindins (list_append2list bindlist bindins))
       (let (
	     (inmatchs (get_field :amatch_in mat))
	     (outmatchs (get_field :amatch_out mat))
	     (matbind (get_field :amatch_matchbind mat))
	     (outbinds ())
	     (tester ())
	     )
	 ;; check compatibility of ctype
	 (if (!= matchctype (get_field :fbind_type matbind))
	     (progn
	       (error_strv sloc "unexpected matched type" (get_field :named_name matchctype))
	       (inform_strv sloc "expecting type in matcher" (get_field :named_name (get_field :fbind_type matbind)))))
	 ;; input args
	 (debug_msg inargs "normpat_anymatchpat inargs")
	 (debug_msg inmatchs "normpat_anymatchpat inmatchs")
	 (let ( (:long nbinargs  (multiple_length inargs)) )
	   (if (!=i nbinargs (multiple_length inmatchs))
	       (error_strv 
		sloc 
		"formal and actual number of input matching arguments differ for anymatch"
		(get_field :named_name mat)))
	   (if (>i nbinargs 0)
	       (let ( (newenv (fresh_env env)) )
		 (foreach_in_multiple
		  (nins)
		  (ncurin :long ix)
		  (debug_msg ncurin "normpat_anymatchpat ncurin")
		  (let ( (curmatch (multiple_nth inmatchs ix)) 
			 (curctype (get_ctype ncurin env))
			 (matchtype (get_field :fbind_type curmatch))
			 )
		    (debug_msg curmatch "normpat_anymatchpat curmatch")
		    (assert_msg "check curmatch" 
				(is_a curmatch class_formal_binding))
		    (debug_msg curctype "normpat_anymatchpat curctype")
		    (debug_msg matchtype "normpat_anymatchpat matchtype")
		    (if (!= curctype matchtype)
			(progn
			  (error_strv sloc
				      "type mismatch for match argument in matcher"
				      (get_field :named_name mat))
			  (inform_strv sloc
				       "mismatched formal name in matcher is"
				       (get_field :named_name (get_field :binder curmatch)))
			  (inform_strv sloc
				       "mismatched input type is"
				       (get_field :named_name curctype))
			  (inform_strv sloc
				       "expected match type is"
				       (get_field :named_name matchtype))
			  )
		      (let ( (newb (instance class_normal_let_binding
					     :letbind_loc sloc
					     :binder (get_field :binder curmatch)
					     :letbind_type curctype
					     :letbind_expr ncurin)
				   )
			     )
			(debug_msg newb "normpat_anymatchpat newb")
			(put_env newenv newb)
			))))
		 (setq env newenv)
		 (put_fields pcn :pctn_env newenv)
		 )))
	 ;; output args
	 (debug_msg outargs "normpat_anymatchpat outargs")
	 (debug_msg outmatchs "normpat_anymatchpat outmatchs")
	 (let ( (:long nboutargs (multiple_length outargs)) ) 
	   (if (!=i nboutargs (multiple_length outmatchs))
	       (error_strv 
		sloc 
		"formal and actual number of output matched arguments differ for anymatch"
		(get_field :named_name mat)))
	   (let ( (tstuff (mapobject_get stuffmap nmatch)) 
		  (curhdler hdler)
		  )
	     (forever 
	      loopstuff
	      (debug_msg tstuff "normpat_anymatchpat tstuff")
	      (cond 
	       ((and (is_a tstuff class_normtester_matcher)
		     (== (get_field :ntmatch_matcher tstuff) mat))
		(let ((tinargs (get_field :ntmatch_inargs tstuff)) 
		      (:long good 1)
		      )
		  (foreach_in_multiple
		   (tinargs)
		   (curinarg :long ix)
		   (let ( (nthins (multiple_nth nins ix)) )
		     (if (!= curinarg nthins)
			 (setq good 0)))
		   )
		  (if good 
		      (progn 
			(debug_msg tstuff "normpat_anymatchpat good tstuff")
			(setq tester tstuff)
			(exit loopstuff))
		    (progn
		      (setq tstuff (get_field :ntest_else tstuff))
		      (setq curhdler
			    (lambda (tester)
			      (shortbacktrace_dbg "normpat_anymatchpat lambda updating else" 15)
			      (put_fields tstuff :ntest_else tester)
			      (debug_msg tstuff "normpat_anymatchpat lambda updatelse of tstuff")
			      (list_append (get_field :ntest_comefrom tester) tstuff)
			      ))
		      ))
		  )
		(assert_msg "normpat_anymatchpat incomplete found tstuff" ())
		)
	       ((is_a tstuff class_normtester_any)
		(setq tstuff (get_field :ntest_else tstuff))
		(setq curhdler
		      (lambda (tester)
			(put_fields tstuff :ntest_else tester)
			(shortbacktrace_dbg "normpat_anymatchpat updatelse" 15)
			(debug_msg tstuff "normpat_anymatchpat updatelse tsuff")
			(list_append (get_field :ntest_comefrom tester) tstuff)
			))
		)
	       (:else
		(let
		    ( (outlocs
		       (multiple_map 
			outmatchs
			(lambda (curoutmatch :long ix)
			  (debug_msg curoutmatch "normpat_anymatchpat curoutmatch")
			  (assert_msg "check curoutmatch" (is_a curoutmatch class_formal_binding))
			  (let ( (csym (clone_symbol (get_field :binder curoutmatch)))
				 (curtyp (get_field :fbind_type curoutmatch))
				 (cbind (instance class_normal_let_binding
						  :letbind_loc sloc
						  :binder csym
						  :letbind_type curtyp
						  ;; this is really nil,
						  ;; the binding should
						  ;; be cleared
						  :letbind_expr ()
						  ))
				 (clocc (instance class_nrep_locsymocc
						  :nrep_loc sloc
						  :nocc_ctyp curtyp
						  :nocc_symb csym
						  :nocc_bind cbind))
				 )
			    ;; put the clocc in the symbol cache map
			    (mapobject_put (get_field :nctx_symbcachemap ncx) csym clocc)
			    clocc
			    ))))
		      (newtester 
		       (instance class_normtester_matcher
				 :nrep_loc sloc
				 :ntest_matched nmatch
				 :ntest_then ()
				 :ntest_else ()
;;;; one could imagine having some
;;;; subclass of cmatcher which add
;;;; additional local stuff...
				 :ntest_locclist (multiple_to_list outlocs)
				 :ntest_comefrom (make_list discr_list)
				 :ntmatch_matcher mat
				 :ntmatch_matndata matndata
				 :ntmatch_inargs nins
				 :ntmatch_outlocs outlocs
				 ))
		      )
		  (debug_msg newtester "normpat_anymatchpat newtester")
		  (register_new_normtester newtester pcn)
		  (setq tester newtester)
		  (list_append testlist newtester)
		  (shortbacktrace_dbg "normpat_anymatchpat before curhdler" 12)
		  (curhdler newtester)
		  (exit loopstuff)
		  ))
	       ))
	     )
	   )
	 (debug_msg tester "normpat_anymatchpat got tester")
	 (assert_msg "check tester" (is_a tester class_normtester_matcher))
	 ;;	
	 (let ( (outlocs (get_field :ntmatch_outlocs tester)) )
	   (debug_msg outlocs "normpat_anymatchpat outlocs from tester")
	   (debug_msg outargs "normpat_anymatchpat outargs before foreach")
	   (debug_msg outmatchs "normpat_anymatchpat outmatchs before foreach")
	   (foreach_in_multiple
	    (outmatchs)
	    (curmatch :long ixm)
	    (messagenum_dbg "normpat_anymatchpat ixm in outmatchs" ixm)
	    (debug_msg curmatch "normpat_anymatchpat curmatch in foreach")
	    (let ( (clocc (multiple_nth outlocs ixm)) 
		   (curout (multiple_nth outargs ixm))
		   (testercont (instance class_container
					 :container_value tester))
		   (subhdler 
		    ;; put the new tester as the last element of its
		    ;; ntest_then chain
		    (lambda (newtester)
		      (debug_msg newtester "normpat_anymatchpat subhdler newtester")
		      (shortbacktrace_dbg "normpat_anymatchpat subhdler" 14)
		      (set_new_tester_last_then newtester testercont)
		      ))
		   )
	      (debug_msg curout "normpat_anymatchpat curout before normal_pattern")
	      (debug_msg clocc "normpat_anymatchpat clocc before normal_pattern")
	      (shortbacktrace_dbg "normpat_anymatchpat before normal_pattern curout" 14)
	      (normal_pattern curout clocc subhdler pcn)
	      (debug_msg curmatch "normpat_anymatchpat curout after normal_pattern")
	      )
	    )
	   )
	 (debug_msg outbinds "normpat_anymatchpat outbinds")
	 )
       )
      )
    (if (!= env oldenv)
	(put_fields pcn :pctn_env oldenv))
    )
  )
(install_method class_source_pattern_matcher normal_pattern normpat_anymatchpat)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;; 
;;;; normalize a constant pattern
(defun normpat_constpat (recv nmatch hdler pcn)
  (debug_msg recv "normpat_constpat recv")
  (debug_msg nmatch "normpat_constpat nmatch")
  (debug_msg pcn "normpat_constpat pcn")
  (assert_msg "check pcn" (is_a pcn class_pattern_context))
  (assert_msg "check recv" (is_a recv class_source_pattern_constant))
  (let (
	(sloc (get_field :loca_location recv))
	(sconst (get_field :spat_constx recv))
	(stuffmap (get_field :pctn_stuffmap pcn))
	(pvarlocmap (get_field :pctn_pvarlocmap pcn)) 
	(psloc (get_field :loca_location (get_field :pctn_src pcn)))
	(tstuff (mapobject_get stuffmap nmatch))
	(env (get_field :pctn_env pcn))
	(ncx (get_field :pctn_normctxt pcn))
	(testlist (get_field :pctn_tests pcn))
	(mapcst (get_field :pctn_mapatcst pcn))
	)
;;; the constant has already been normalized in scanpat_srcpatconst
    (debug_msg tstuff "normpat_constpat tstuff")
    (let (
	  (tester ())
	  (curhdler hdler)
	  (nconst (if (is_object sconst) (mapobject_get mapcst sconst) sconst))
	  )
      (debug_msg nconst "normpat_constpat nconst")
      (forever 
       loopstuff
       (debug_msg tstuff "normpat_constpat tstuff")
       (cond
	( (== (get_field :ntsame_identical tstuff) nconst)
	  (setq tester tstuff)
	  (exit loopstuff))
	( (is_a tstuff class_normtester_any)
	  (setq tstuff (get_field :ntest_else tstuff))
	  (setq curhdler 
		(lambda (tester)
		  (put_fields tstuff :ntest_else tester)
		  (shortbacktrace_dbg "normpat_constpat lambda updatelse" 15)
		  (debug_msg tstuff "normpat_constpat lambda updatelse tstuff")
		  (list_append (get_field :ntest_comefrom tester) tstuff)
		  ))
	  )
	(:else
	 (let ( (newtester (instance class_normtester_same
				     :nrep_loc psloc
				     :ntest_matched nmatch
				     :ntest_then ()
				     :ntest_else ()
				     :ntest_locclist ()
				     :ntest_comefrom (make_list discr_list)
				     :ntsame_identical nconst))
		)
	   (shortbacktrace_dbg "normpat_constpat making newtester same" 15)
	   (register_new_normtester newtester pcn)
	   (debug_msg newtester "normpat_constpat newtester same")
	   (setq tester newtester)
	   (list_append testlist newtester)
	   (curhdler newtester)
	   (exit loopstuff)
	   )
	 )
	)
       )				;end forever
      (debug_msg tester "normpat_constpat got tester")
      )
    )
  )
(install_method class_source_pattern_constant normal_pattern normpat_constpat)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; to ease debugging, we offer the option to generate .dot files
;;;;; for graphviz (see http://www.graphviz.org/ for more)

;;  the instance containing the string value prefix of the generated
;;  .dot file, should be something like /tmp/mygr to generated
;;  /tmp/mygr1.dot /tmp/mygr2.dot etc...
(definstance match_graphic_dot_prefix class_container
  :container_value ())

(defun match_graphic_optset (optsymb :cstring prefixs)
  (debug_msg optsymb "match_graphic_optset optsumb")
  (let ( (prefstr (make_stringconst discr_string prefixs)) )
    (put_fields match_graphic_dot_prefix :container_value prefstr)
    (debug_msg match_graphic_dot_prefix
	       "match_graphic_optset match_graphic_dot_prefix")
    (return match_graphic_dot_prefix)
    ))

(register_option
 'match_graphic
 '"Prefix for Graphviz .dot files generated about match normalization when debugging" 
 match_graphic_optset)
		 

;;; a private class to help generate dot graphics
(defclass class_match_graphic
  :doc #{$CLASS_MATCH_GRAPHIC is a private class to generate graphviz
  .dot graphics files to debug the MELT translation of matching. Don't
  use it yourself.}#
  :super class_proped
  :fields (
	   mchgx_filename		;the filename
	   mchgx_nodout			;the output strbuf for nodes
	   mchgx_edgout			;the output strbuf for edges
	   mchgx_datanamemap		;the objmap for name of datas
	   mchgx_stepnamemap		;the objmap for name of steps
	   ))

;; internal function to out the node name for the match graphic
(defun mg_out_node_name (out ntest)
  (assert_msg "check out" (is_out out))
  (assert_msg "check ntest" (is_a ntest class_normtester_any))
  (let ( (cla (discrim ntest))
	 (clanam (get_field :named_name cla))
	 (:long clanamlen (string_length clanam))
	 (:long ix (get_int ntest))
	)
    ;; the classname starts with CLASS_ which has six characters, we
    ;; skip them for the node name
    (assert_msg "check clanamlen" (>i clanamlen 6))
    (code_chunk outchunk
		#{ /* mg_node_name $OUTCHUNK */
		meltgc_add_out ((melt_ptr_t) $OUT,
				melt_string_str ((melt_ptr_t) $CLANAM) +6);
		meltgc_out_printf ((melt_ptr_t) $OUT, "_%d",
				   (int) $IX);
		}#
		)
    ))

;; internal selector to output the label of a test in "HTML-like"
;; graphiz format
(defselector matchgraphic_label class_selector
)

(defun mglabel_any_test (ntest mg)
  (debug_msg ntest "mglabel_any_test start ntest")
  (assert_msg "check ntest" (is_a ntest class_normtester_any))
  (assert_msg "check mg" (is_a mg class_match_graphic))
  (let ( (nloc (unsafe_get_field :nrep_loc ntest))
	 (nmatched (unsafe_get_field :ntest_matched ntest))
	 (nodout (unsafe_get_field :mchgx_nodout mg))
	 (edgout (unsafe_get_field :mchgx_edgout mg))
	 )
    (debug_msg nloc "mglabel_any_test nloc")
    (debug_msg nmatched "mglabel_any_test nmatched")
    (assert_msg "check nodout" (is_out nodout))
    (assert_msg "check edgout" (is_out edgout))
    ;; first table row: output the node name in blue bold and the hashcode
    (add2out_strconst nodout "<tr><td>")
    (add2out_strconst nodout 
		      "<font color=\"blue\" face=\"Times-Roman Bold\" point-size=\"10\">")
    (mg_out_node_name nodout ntest)
    (add2out_strconst nodout "</font></td>")
    (add2out_strconst nodout "<td><font face=\"Courier\" point-size=\"8\">#")
    (add2out_longhex nodout (obj_hash ntest))
    (add2out_strconst nodout "</font></td>")
    (add2out_strconst nodout "</tr>")
    (add2out_indentnl nodout 2)
    ;; if we have a location, it makes a row
    (cond
     ( (is_mixloc nloc)
       (add2out_strconst nodout "<tr><td rowspan=\"2\">")
       (add2out_strconst nodout "<font face=\"Courier Italic\" point-size=\"8\">")
       (add2out_mixloc nodout nloc)
       (add2out_strconst nodout "</font></td></tr>")
       (add2out_indentnl nodout 2)
       )
     )
    ;; if the matched is a locsymocc [it usually should] display it,
    ;; that is its symbol and the hashcode of the locsymocc
    (if (is_a nmatched class_nrep_locsymocc)
	(let ( (nmaloc (unsafe_get_field :nrep_loc nmatched))
	       (nmasymb (unsafe_get_field :nocc_symb nmatched))
	       (:long nmarank
		      (get_int (get_field :csym_urank nmasymb)))
	       )
	  (add2out_strconst nodout "<tr><td>")
	  (add2out_strconst nodout "<font face=\"Courier Bold\" point-size=\"8\">")
	  (add2out_string nodout (get_field :named_name nmasymb))
	  (if (>i nmarank 0)
	      (progn
		(add2out_strconst nodout " #")
		(add2out_longhex nodout nmarank)
		(add2out_strconst nodout " ")
		))
	  (add2out_strconst nodout "</font></td> <td><font point-size=\"8\">##")
	  (add2out_longhex nodout (obj_hash nmatched))
	  (add2out_strconst nodout "</font></td></tr>")
	  (add2out_indentnl nodout 2)
	  ))
    (debug_msg ntest "mglabel_any_test end ntest")
    ))
(install_method class_normtester_any matchgraphic_label mglabel_any_test)

;; output an instance test
(defun mglabel_instance_test (ntest mg)
  (debug_msg ntest "mglabel_instance_test start ntest")
  (assert_msg "check ntest" (is_a ntest class_normtester_instance))
  (assert_msg "check mg" (is_a mg class_match_graphic))
  (let ( (nloc (unsafe_get_field :nrep_loc ntest))
	 (nmatched (unsafe_get_field :ntest_matched ntest))
	 (nodout (unsafe_get_field :mchgx_nodout mg))
	 (edgout (unsafe_get_field :mchgx_edgout mg))
	 )
    (debug_msg nloc "mglabel_instance_test nloc")
    (debug_msg nmatched "mglabel_instance_test nmatched")
    (assert_msg "check nodout" (is_out nodout))
    (assert_msg "check edgout" (is_out edgout))
    ;; first table row: output the node name in blue bold and the hashcode and the tested class
    (add2out_strconst nodout "<tr><td>")
    (add2out_strconst nodout 
		      "<font color=\"violet\" face=\"Times-Roman Bold\" point-size=\"10\">")
    (mg_out_node_name nodout ntest)
    (add2out_strconst nodout "</font></td>")
    (add2out_strconst nodout "<td><font face=\"Courier\" point-size=\"8\">#")
    (add2out_longhex nodout (obj_hash ntest))
    (add2out_strconst nodout "</font></td>")
    (add2out_strconst nodout "<td><font face=\"Courier Italic\" point-size=\"8\">")
    (add2out_string nodout (get_field :named_name
				      (get_field :nocc_symb 
						 (get_field :ntinst_class ntest))))
    (add2out_strconst nodout "</font></td>")
    (add2out_strconst nodout "</tr>")
    (add2out_indentnl nodout 2)
    ;; if we have a location, it makes a row
    (cond
     ( (is_mixloc nloc)
       (add2out_strconst nodout "<tr><td rowspan=\"2\">")
       (add2out_strconst nodout "<font face=\"Courier Italic\" point-size=\"8\">")
       (add2out_mixloc nodout nloc)
       (add2out_strconst nodout "</font></td></tr>")
       (add2out_indentnl nodout 2)
       )
     )
    ;; if the matched is a locsymocc [it usually should] display it,
    ;; that is its symbol and the hashcode of the locsymocc
    (if (is_a nmatched class_nrep_locsymocc)
	(let ( (nmaloc (unsafe_get_field :nrep_loc nmatched))
	       (nmasymb (unsafe_get_field :nocc_symb nmatched))
	       (:long nmarank
		      (get_int (get_field :csym_urank nmasymb)))
	       )
	  (add2out_strconst nodout "<tr><td>")
	  (add2out_strconst nodout "<font face=\"Courier Bold\" point-size=\"8\">")
	  (add2out_string nodout (get_field :named_name nmasymb))
	  (if (>i nmarank 0)
	      (progn
		(add2out_strconst nodout " #")
		(add2out_longhex nodout nmarank)
		(add2out_strconst nodout " ")
		))
	  (add2out_strconst nodout "</font></td> <td><font point-size=\"8\">##")
	  (add2out_longhex nodout (obj_hash nmatched))
	  (add2out_strconst nodout "</font></td></tr>")
	  (add2out_indentnl nodout 2)
	  ))
    (debug_msg ntest "mglabel_instance_test end ntest")
    ))
(install_method class_normtester_instance matchgraphic_label mglabel_instance_test)

;;; output a success test
(defun mglabel_success_test (ntest mg)
  (debug_msg ntest "mglabel_success_test start ntest")
  (assert_msg "check ntest" (is_a ntest class_normtester_success))
  (assert_msg "check mg" (is_a mg class_match_graphic))
  (let ( (nloc (unsafe_get_field :nrep_loc ntest))
	 (nmatched (unsafe_get_field :ntest_matched ntest))
	 (nodout (unsafe_get_field :mchgx_nodout mg))
	 (edgout (unsafe_get_field :mchgx_edgout mg))
	 )
    (debug_msg nloc "mglabel_success_test nloc")
    (debug_msg nmatched "mglabel_success_test nmatched")
    (assert_msg "check nodout" (is_out nodout))
    (assert_msg "check edgout" (is_out edgout))
    ;; first table row: output the node name and the hashcode
    (add2out_strconst nodout "<tr><td>")
    (add2out_strconst nodout 
		      "<font color=\"sienna\" face=\"Times-Roman Bold\" point-size=\"10\">")
    (mg_out_node_name nodout ntest)
    (add2out_strconst nodout "</font></td>")
    (add2out_strconst nodout "<td><font face=\"Courier\" point-size=\"8\">#")
    (add2out_longhex nodout (obj_hash ntest))
    (add2out_strconst nodout "</font></td>")
    (add2out_strconst nodout "</tr>")
    (add2out_indentnl nodout 2)
    ;; if we have a location, it makes a row
    (cond
     ( (is_mixloc nloc)
       (add2out_strconst nodout "<tr><td rowspan=\"2\">")
       (add2out_strconst nodout "<font face=\"Courier Italic\" point-size=\"8\">")
       (add2out_mixloc nodout nloc)
       (add2out_strconst nodout "</font></td></tr>")
       (add2out_indentnl nodout 2)
       )
     )
    (debug_msg ntest "mglabel_success_test end ntest")
    ))
(install_method class_normtester_success matchgraphic_label mglabel_success_test)



;; internal function to out a tuple of test nodes in graphiz format
(defun matchgraphic_tests (testup mg)
  (debug_msg testup "matchgraphic_tests testup start")
  (debug_msg mg "matchgraphic_tests mg start")
  (assert_msg "check testup" (is_multiple testup))
  (assert_msg "check mg" (is_a mg class_match_graphic))
  (let ( (nodout (unsafe_get_field :mchgx_nodout mg))
	 (edgout (unsafe_get_field :mchgx_edgout mg))
	 )
    (add2out_indentnl nodout 0)
    (add2out_indentnl edgout 0)
    (foreach_in_multiple 
     testup
     (curtest :long tix)
     (assert_msg "check curtest" (is_a curtest class_normtester_any))
     (debug_msg curtest "matchgraphic_tests curtest")
     ;; output the node and its label
     (mg_out_node_name nodout curtest)
     (add2out_strconst nodout " [ label=<")
     (add2out_strconst nodout "<table border=\"1\" cellborder=\"1\" cellspacing=\"1\" cellpadding=\"1\">")
     (add2out_indentnl nodout 1)
     (matchgraphic_label curtest mg)
     (add2out_indentnl nodout 1)
     (add2out_strconst nodout "</table>")
     (add2out_strconst nodout ">, margin=0")
     (if (==i tix 0)
	 (add2out_strconst nodout ", style=\"bold\"")) 
     (add2out_strconst nodout " ];")
     (add2out_indentnl nodout 0)
     ;; output the outgoing edges 
     (let ( (nthen (unsafe_get_field :ntest_then curtest))
	    (nelse (unsafe_get_field :ntest_else curtest))
	    )
       (if (is_a nthen class_normtester_any)
	   (progn
	     (mg_out_node_name edgout curtest)
	     (add2out_strconst edgout " -> /*then*/ ")
	     (mg_out_node_name edgout nthen)
	     (add2out_strconst edgout " [ arrowhead=normal, color=green ];")
	     (add2out_indentnl edgout 0)
	     ))
       (if (is_a nelse class_normtester_any)
	   (progn
	     (mg_out_node_name edgout curtest)
	     (add2out_strconst edgout " -> /*else*/ ")
	     (mg_out_node_name edgout nelse)
	     (add2out_strconst edgout " [ arrowhead=diamond, color=red ];")
	     (add2out_indentnl edgout 0)
	     ))
       )
     )
    ))


;; utility to out a graphviz .dot file for the tests inside match
(defun mg_draw_match_graphviz_file (nmatch dotprefix teststupl)
  (let (
        (:long hcodnmatch (obj_hash nmatch))
        (:long cnt 0)
        (:long nbtests (multiple_length teststupl)) 
        (pathsbuf (make_strbuf discr_strbuf)) 
        (dotfilename
         (progn
           (code_chunk 
            uniqcnt 
            #{  /* mg_draw_match_graphviz_file $UNIQCNT */
            static long uniqcounter;
            uniqcounter ++;
            $CNT = uniqcounter; 
            }#)
           (assert_msg "check pathsbuf" (is_strbuf pathsbuf))
           (add2sbuf_string pathsbuf dotprefix)
           (add2sbuf_longdec pathsbuf cnt)
           (add2sbuf_strconst pathsbuf ".dot")
           (debug_msg pathsbuf "mg_draw_match_graphviz_file pathsbuf")
           (strbuf2string discr_string pathsbuf)))
        (nodbuf (make_strbuf discr_strbuf))
        (edgbuf (make_strbuf discr_strbuf))
        (mg (instance class_match_graphic
                      :mchgx_filename dotfilename
                      :mchgx_nodout nodbuf
                      :mchgx_edgout edgbuf
                      ))
        )
    (debug_msg mg "mg_draw_match_graphviz_file initial mg")
    (matchgraphic_tests teststupl mg)
    (debug_msg mg "mg_draw_match_graphviz_file final mg")
    (assert_msg "check dotfilename" (is_string dotfilename))
    (code_chunk 
     outputmg
     #{ /* mg_draw_match_graphviz_file $OUTPUTMG */
     time_t nowt = 0;
     char nowbuf[60];
     FILE* dotfil = 
     fopen (melt_string_str ((melt_ptr_t) $DOTFILENAME), "w");
     if (!dotfil) 
     fatal_error("failed to open matchdot file %s - %m", 
                 melt_string_str ((melt_ptr_t) $DOTFILENAME));
     fprintf (dotfil, "// melt matchdot file %s\n", 
                      melt_string_str ((melt_ptr_t) $DOTFILENAME));
     time (&nowt);
     memset (nowbuf, 0, sizeof(nowbuf));
     strftime (nowbuf, sizeof(nowbuf)-1,
                       "%Y %b %d %Hh%M",
                       localtime (&nowt));
     fprintf (dotfil, "// generated %s\n", nowbuf);
     fprintf (dotfil, "digraph meltmatch_%lx {\n",
                      $HCODNMATCH);
     fprintf (dotfil, " graph [ label=\"Melt Match %d #%#lx %s\", pad=\"0.5\", margin=\"0.3\" ];\n",
                      (int) $CNT, $HCODNMATCH, nowbuf);
     fprintf (dotfil, " node [ shape=\"box\", fontsize=\"12\" ];\n");
     fprintf (dotfil, "// %d tests\n", (int) $NBTESTS);
     melt_putstrbuf (dotfil, (melt_ptr_t) $NODBUF);
     fprintf (dotfil, "\n /// edges\n");
     melt_putstrbuf (dotfil, (melt_ptr_t) $EDGBUF);
     fprintf (dotfil, "\n} // eof %s\n", melt_string_str ((melt_ptr_t) $DOTFILENAME));
     fclose (dotfil);
     }#)
    ))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; normalize a match
(defun normexp_match (recv env ncx psloc)
  (assert_msg "check match recv" (is_a recv class_source_match))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normalization_context))
  (debug_msg recv "normexp_match recv")
  (let ( (sloc (unsafe_get_field :loca_location recv))
	 (smatsx (unsafe_get_field :smat_matchedx recv))
	 (scases (unsafe_get_field :smat_cases recv))
	 (:long nbcases (multiple_length scases))
	 (tupvarmap (make_multiple discr_multiple nbcases))
	 (tupcstmap (make_multiple discr_multiple nbcases))
	 ;; the shabindlist & the stuffmap are shared for all match cases
	 (stuffmap (make_mapobject discr_map_objects 
				   (+i 20 (*i 5 nbcases))))
	 (shabindlist (make_list discr_list))
	 (testlist (make_list discr_list))
	 (wholectype ())		;the ctype of the whole match
	 (oldtester ())			;the previous tester
	 )
    (debug_msg smatsx "normexp_match smatsx")
    (multicall
     (nmatx nbindmatx)
     (normal_exp smatsx env ncx sloc)
     (debug_msg nmatx "normexp_match nmatx")
     (debug_msg scases "normexp_match scases")
     (let ( (ctyp (get_ctype nmatx env)) 
	    )
       (debug_msg ctyp "normexp_match ctyp")
       ;; if the matched stuff is not an object, it is a constant, so
       ;; make a binding for it
       (if (not (is_object nmatx))
	   (let (
		 (csym (clone_symbol '_matched_))
		 (cbind (instance class_normal_let_binding
				  :letbind_loc sloc
				  :binder csym
				  :letbind_type ctyp
				  :letbind_expr nmatx))
		 (clocc (instance class_nrep_locsymocc
				  :nrep_loc sloc
				  :nocc_ctyp ctyp
				  :nocc_symb csym
				  :nocc_bind cbind))
		 )
	     (assert_msg "check no binding" (null nbindmatx))
	     ;; put the clocc in the symbol cache map
	     (mapobject_put (get_field :nctx_symbcachemap ncx) csym clocc)
	     (setq nbindmatx (list cbind))
	     (setq nmatx clocc)
	     ))
       ;; if no binding list, make an empty one
       (if (null nbindmatx) (setq nbindmatx (make_list discr_list)))
       ;;
       ;; loop on each case
       (foreach_in_multiple
	(scases)
	(curcas :long ix)
	(debug_msg curcas "normexp_match curcas")
	(assert_msg "check curcas" (is_a curcas class_source_match_case))
	(let ( 
	      (curloc (unsafe_get_field :loca_location curcas))
	      (curpat (unsafe_get_field :scam_patt curcas))
	      (curbody (unsafe_get_field :scam_body curcas))
	      (mapvar (make_mapobject discr_map_objects 13))
	      (mapcst (make_mapobject discr_map_objects 11))
	      (mapor (make_mapobject discr_map_objects 7))
	      (pvarlocmap (make_mapobject discr_map_objects 23))
	      (varhdlerlist (make_list discr_list))
	      (pcn (instance class_pattern_context
			     :pctn_normctxt ncx
			     :pctn_src recv
			     :pctn_env env
			     :pctn_mapatvar mapvar
			     :pctn_mapatcst mapcst
			     :pctn_mapor mapor
			     :pctn_bindlist shabindlist
			     :pctn_stuffmap stuffmap
			     :pctn_pvarlocmap pvarlocmap
			     :pctn_tests testlist
			     :pctn_varhandlers varhdlerlist
			     ))
	      (ntestcont (instance class_container)) ;container for tester
	      )
	  (debug_msg curpat "normexp_match curpat before scan_pattern")
	  ;; I am not entirely sure of this assert! Perhaps there maybe
	  ;; strange cases where curpat is null...
	  (assert_msg "normexp_match check curpat" curpat)
	  (scan_pattern curpat curloc ctyp pcn)
	  (debug_msg curpat "normexp_match curpat after scan_pattern")
	  (debug_msg mapvar "normexp_match mapvar")
	  (debug_msg pvarlocmap "normexp_match pvarlocmap")
	  (debug_msg mapcst "normexp_match mapcst")
	  (multiple_put_nth tupvarmap ix mapvar)
	  (multiple_put_nth tupcstmap ix mapcst)
	  (debug_msg shabindlist "normexp_match shabindlist before normal_pattern")
	  (debug_msg curpat "normexp_match curpat before normal_pattern")
	  ;; normalize the current pattern, with the handler storing its topmost tester
	  (normal_pattern 
	   curpat nmatx
	   (lambda (tester) 
	     (debug_msg tester "normexp_match.lambda tester")
	     (shortbacktrace_dbg "normexp_match lambda tester" 12)
	     (assert_msg "check empty ntestcont" 
			 (null (unsafe_get_field :container_value ntestcont)))
	     (put_fields ntestcont :container_value tester))
	   pcn)
	  (debug_msg curpat "normexp_match curpat after normal_pattern")
	  (debug_msg pvarlocmap "normexp_match pvarlocmap after normal_pattern")
	  (debug_msg ntestcont "normexp_match ntestcont after normal_pattern")
	  (debug_msg shabindlist "normexp_match shabindlist after normal_pattern")
	  ;; 
	  (let ( (newenv (get_field :pctn_env pcn))
		 (curtester (get_field :container_value ntestcont))
		 ;; we need a success. For the last joker case, it
		 ;; becomes the curtester; for the usual case it is
		 ;; added as the last then. Anyway, it will contain
		 ;; the action part of the current case.
		 (newsuctester
		  (instance class_normtester_success
			    :nrep_loc curloc
			    ;; we really don't match anything
			    :ntest_matched ()
			    :ntest_then ()
			    :ntest_else ()
			    :ntest_comefrom (make_list discr_list)
			    ;; the success do should be the wrapped
			    ;; let of the normalized actions
			    :ntsuccess_do ()
			    ))
		 )
	    (debug_msg newenv "normexp_match newenv after normal_pattern")
	    (debug_msg newsuctester "normexp_match empty newsuctester")
	    (debug_msg pvarlocmap "normexp_match pvarlocmap after normal_pattern")
	    (debug_msg curcas "normexp_match curcas after normal_pattern")
	    (debug_msg curtester "normexp_match curtester after normal_pattern")
	    (debug_msg oldtester "normexp_match oldtester after normal_pattern")
	    ;; append the new success to the test list, so that it
	    ;; will get its ntest_normatch later
	    (list_append testlist newsuctester)
	    (cond 
	     ((null curtester)
	      (debug_msg curcas "normexp_match curcas for null curtester")
	      ;; curtester is null if the whole case is a joker,
	      ;; this should be the last case
	      (if (<i ix (-i (multiple_length scases) 1))
		  (error_plain sloc "joker case in MATCH is not last"))
	      ;; set the current tester to the success 
	      (setq curtester newsuctester)
	      (debug_msg curtester "normexp_match curestester set to success")
	      )
	     ;; else the curtester is not null; it cannot be a success
	     (:else
	      (assert_msg "check curtester not success" 
			  (is_not_a curtester class_normtester_success))
;;; add the newsuctester as the last then of the curtester
	      (let ( (curtestcont (instance class_container
					    :container_value curtester)) )
		(debug_msg curtestcont "normexp_match our curtestcont")
		(debug_msg newsuctester "normexp_match our newsuctester")
		(set_new_tester_last_then newsuctester curtestcont)
		(debug_msg curtestcont "normexp_match final curtestcont")
		)
	      ) ;; end when null curtester
	     )	;; end cond
	    (debug_msg curtester "normexp_match final curtester")
	    (assert_msg "check final curtester"  (is_a curtester class_normtester_any))
	    ;; if there is an oldtester, add the curtester as its last else case
	    (if (is_a oldtester class_normtester_anytester)
		(progn
		  (debug_msg oldtester "normexp_match initial oldtester")
		  (set_new_tester_all_elses curtester oldtester)
		  (debug_msg oldtester "normexp_match final oldtester")
		  ))
	    ;; always set the oldtester to the curtester
	    (setq oldtester curtester)
	    (debug_msg pcn "normexp_match pcn after lastesterloop")
	    (debug_msg pvarlocmap "normexp_match pvarlocmap after lastesterloop")
	    (let ( (sortedvars (mapobject_sorted_attribute_tuple pvarlocmap)) 
		   (sortedbindings (make_multiple discr_multiple (multiple_length sortedvars)))
		   (freshnewenv (fresh_env newenv))
		   )
	      (debug_msg sortedvars "normexp_match sortedvars")
	      ;; we have to make a list of bindings based upon the sortedvars
	      (foreach_in_multiple
	       (sortedvars)
	       (svar :long svix)
	       (debug_msg svar "normexp_match svar")
	       (let ( (socc (mapobject_get pvarlocmap svar))
		      )
		 (debug_msg socc "normexp_match socc")
		 (assert_msg "check socc" (is_a socc class_nrep_locsymocc))
		 (let ( (sbind (unsafe_get_field :nocc_bind socc)) )
		   (debug_msg sbind "normexp_match sbind")
		   (multiple_put_nth sortedbindings svix sbind)
		   (put_env freshnewenv sbind)
		   )
		 ))
	      (debug_msg freshnewenv "normexp_match freshnewenv")
	      (debug_msg sortedbindings "normexp_match sortedbindings")
	      (assert_msg "check sortedbindings" (is_multiple sortedbindings))
	      (let ( (subindlist (make_list discr_list)) 
		     )
		(foreach_in_multiple
		 (sortedbindings)
		 (cursortbind :long sortbix)
		 (debug_msg cursortbind "normexp_match cursortbind")
		 (assert_msg "check cursortbind" 
			     (is_a cursortbind class_normal_let_binding))
		 (list_append subindlist cursortbind)
		 )
		(debug_msg curbody "normexp_match curbody before normalize_tuple")
		(multicall 
		 (nbody bindsbody)
		 (normalize_tuple curbody freshnewenv ncx curloc)
		 (debug_msg curbody "normexp_match curbody after normalize_tuple")
		 (debug_msg nbody "normexp_match nbody")
		 (debug_msg bindsbody "normexp_match bindsbody")
		 (assert_msg "check bindsbody" (is_list_or_null bindsbody))
		 (foreach_in_list
		  (bindsbody)
		  (bindbodypair curbindbody)
		  (debug_msg curbindbody "normexp_match curbindbody")
		  (list_append subindlist curbindbody)
		  )
		 (debug_msg subindlist "normexp_match final subindlist")
		 (let ( (wnlet (wrap_normal_letseq nbody subindlist curloc)) 
			(lastnbody (multiple_nth nbody -1))
			(lastctype (get_ctype lastnbody freshnewenv))
			)
		   (debug_msg wnlet "normexp_match wnlet")
		   (debug_msg lastnbody "normexp_match lastnbody")
		   (debug_msg lastctype "normexp_match lastctype")
		   (put_fields newsuctester 
			       :ntsuccess_do wnlet
			       )
		   (cond ( (null wholectype)
			   (setq wholectype lastctype))
			 ( (== lastctype ctype_void)
			   (setq wholectype ctype_void))
			 ( (== wholectype ctype_void)
			   ())
			 ( (!= wholectype lastctype)
			   (error_strv curloc "invalid type of match case" 
				       (get_field :named_name lastctype))
			   (inform_strv sloc "expected type of match case"
					(get_field :named_name wholectype)))
			 )
		   (debug_msg newsuctester "normexp_match updated newsuctester")
		   ))))))) ;;; end foreach_in_multiple
       ;; end of loop on each case
       (debug_msg tupvarmap "normexp_match tupvarmap")
       (debug_msg tupcstmap "normexp_match tupcstmap")
       (debug_msg testlist "normexp_match testlist")
       (debug_msg stuffmap "normexp_match stuffmap")
       (debug_msg (let ( (stmpklist (make_list discr_list)) )
		    (foreach_in_mapobject
		     (stuffmap)
		     (lococck litest)
		     (list_append stmpklist lococck)
		     )
		    stmpklist) 
		  "normexp_match stuffmapkeylist")
       (let ( 
	     (teststupl (let ( (tt (list_to_multiple testlist)) )
			  (debug_msg tt "normexp_match teststupl")
			  tt))
	     (nmatch (instance class_nrep_match
			       :nrep_loc sloc
			       :nexpr_ctyp wholectype
			       :nmatch_tests teststupl
			       :nmatch_stuffmap stuffmap
			       :nmatch_matched nmatx
			       ))
	     (csym (clone_symbol 'matchres_))
	     (clocc  (instance  class_nrep_locsymocc
				:nrep_loc sloc
				:nocc_ctyp wholectype
				:nocc_symb csym)) 
	     (cbind (instance class_normal_let_binding
			      :letbind_loc sloc
			      :binder csym
			      :letbind_type wholectype
			      :letbind_expr nmatch))
	     )
	 (debug_msg csym "normexp_match csym")
	 (put_fields clocc :nocc_bind cbind)
	 (debug_msg clocc "normexp_match clocc")
	 ;; put the clocc in the symbol cache map
	 (mapobject_put (get_field :nctx_symbcachemap ncx) csym clocc)
	 ;; put the index of each test 
	 (foreach_in_multiple
	  (teststupl)
	  (curtest :long tstix)
	  (debug_msg curtest "normexp_match raw curtest")
	  (assert_msg "check curtest" (is_a curtest class_normtester_any))
	  (assert_msg "check tstix" (>=i tstix 0))
	  (assert_msg "check tstix not too big" (<i tstix 32767))
	  (messagenum_dbg "normexp_match testindex tstix" tstix)
	  (put_int curtest tstix)
	  (put_fields curtest :ntest_normatch nmatch)
	  (debug_msg curtest "normexp_match indexed curtest")
	  )
	 (if (need_dbg 1)
	     (let ( (dotprefix (get_field :container_value match_graphic_dot_prefix)) )
	       (debug_msg match_graphic_dot_prefix "normexp_match match_graphic_dot_prefix")
	       (debug_msg dotprefix "normexp_match dotprefix")
	       (if (is_string dotprefix) 
		   (mg_draw_match_graphviz_file nmatch dotprefix teststupl
		 ))))
	 (unsafe_put_fields clocc :nocc_bind cbind)
	 (debug_msg teststupl "normexp_match final teststupl")
	 (debug_msg nbindmatx "normexp_match before append nbindmatx")
	 (assert_msg "check nbindmatx" (is_list nbindmatx))
	 (list_append nbindmatx cbind)
	 (debug_msg nmatch "normexp_match final nmatch")
	 (debug_msg cbind "normexp_match final cbind")
	 (debug_msg nbindmatx "normexp_match returned nbindmatx")
	 (debug_msg clocc "normexp_match returned clocc")
	 (return clocc nbindmatx)
	 )))))

;;;;
(install_method class_source_match normal_exp normexp_match)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; A L T E R N A T E     I M P L E M E N T A T I O N
;;;;                   O F 
;;;;  P A T T E R N  -  M A T C H I N G    
;;;;;;;;;;;;;;;;
(defclass class_matching_context
  :super class_root
  :doc #{The $CLASS_MATCHING_CONTEXT is a context for normalization of
pattern matching. $MXCT_NORMCTXT is the normalization
context. $MXCT_SOURCE is the source matching
expression. $MXCT_NMATCHED is the normal matched
expression. $MXCT_CASES is the tuple of cases each of
$CLASS_MATCH_CASE. $MXCT_ENV is the environment of the
match. $MXCT_MDATA is the initial matched data of
$CLASS_MATCHED_DATA. $MXCT_VARHANDLERS is the list of pattern variable
handlers.}#
  :fields ( mxct_normctxt
	    mxct_source 
	    mxct_nmatched 
	    mxct_cases 
	    mxct_env 
	    mxct_mdata
	    mxct_varhandlers
	    ))

(defclass class_match_case
  :super class_proped
  :doc #{The $CLASS_MATCH_CASE describes a case match. Field
$MCASE_MCTXT is the matching context. $MCASE_SOURCE is the source
case, $MCASE_INDEX is the boxed integer rank. $MCASE_VARMAP is an
objectmap from symbols to the list of their pattern variables.}#
  :fields ( mcase_mctxt 
	    mcase_source 
	    mcase_index
	    mcase_varmap
	    ))

(defclass class_matched_data
  :super class_proped
  :doc #{The $CLASS_MATCHED_DATA describes some matched data. Field
$MDATA_SYMB gives the symbol, $MDATA_CTYPE gives the
ctype. $MDATA_ORIG is the origin step or data. $MDATA_STEPS is the list of match steps.}#
  :fields ( mdata_symb
	    mdata_ctype
	    mdata_orig
	    mdata_steps
	    ))

(defclass class_matched_binding
  :doc #{The $CLASS_MATCHED_BINDING is a binding for matched pattern
variables.  Field $MATCHBIND_DATA gives the matched data, and field
$MATCHBIND_NBOCC is the number of occurrences.}#
  :super class_any_binding
  :fields (matchbind_data
	   matchbind_nbocc
	   ))

(defun normbind_matchbind (bind env ncx procs psloc)
  (assert_msg "check bind" (is_a bind class_matched_binding))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check ncx" (is_a ncx class_normalization_context))
  (let ( (sycmap  (unsafe_get_field :nctx_symbcachemap ncx))
	 (symb (unsafe_get_field :binder bind))
	 (mdata (unsafe_get_field :matchbind_data bind))
	 (boxnbocc (unsafe_get_field :matchbind_nbocc bind))
	 (:long nbocc (get_int boxnbocc))
	 (syocc
		(instance class_nrep_locsymocc
			  :nrep_loc psloc
			  :nocc_ctyp (get_field :mdata_ctype mdata) 
			  :nocc_symb symb
			  :nocc_bind bind) ) 
	 )
    ;; increment the number of occurrences
    (put_int boxnbocc (+i nbocc 1))
    ;; cache the result & return it
    (mapobject_put sycmap symb syocc)
    syocc
    ))
(install_method class_matched_binding  normalize_binding normbind_matchbind)

(defclass class_match_step
  :super class_located
  :doc #{The $CLASS_MATCH_STEP describes an elementary step of pattern
matching, like tests, success, etc... The $MSTEP_DATA is the matched
data.}#
  :fields ( mstep_data
	    ))

(defclass class_match_step_then
  :super class_match_step
  :doc #{The $CLASS_MATCH_STEP_THEN super-class is for steps with a
then edge $MSTEP_THEN.}#
  :fields (mstep_then))

(defclass class_match_step_set_variable
  :super class_match_step_then
  :doc #{The $CLASS_MATCH_STEP_SET_VARIABLE step sets a variable of
symbol $MSTEPSETVAR_SYMB to the matched data.}#
  :fields (mstepsetvar_symb))

(defclass class_match_step_success
  :super class_match_step_then
  :doc #{The $CLASS_MATCH_STEP_SUCCESS step represents the normalized
action in a match. $MSTEPSUCCESS_VAROCC is the tuple of pattern
variable occurrences, $MSTEPSUCCESS_BINDS is the list of local
binders, and $MSTEPSUCCESS_BODY is the normalized body tuple.}#
  :fields (mstepsuccess_varocc
	   mstepsuccess_binds
	   mstepsuccess_body))

(defclass class_match_step_test
  :super class_match_step_then
  :doc #{The $CLASS_MATCH_STEP_TEST is the super-class of elementary
tests of pattern matching. The $MSTEP_THEN is the then branch, the
$MSTEP_ELSE is the else branch.}#
  :fields (mstep_else))

(defclass class_match_step_test_variable
  :super class_match_step_test
  :doc #{The $CLASS_MATCH_STEP_TEST_VARIABLE is for tests if the
variable $MSTEPTESTVAR_SYMB is the same as the matched data.}#
  :fields (msteptestvar_symb))

(defclass class_match_step_test_group
  :super class_match_step_test
  :doc #{The $CLASS_MATCH_STEP_GROUP is used to redirect the then &
else tests to a list of subtests, ie to the $MSTGROUP_THEN and
$MSTGROUP_ELSE. The $MSTGROUP_START is the starting control point (for then & else edges arriving into the group).}#
  :fields (mstgroup_start
	   mstgroup_then
	   mstgroup_else))


(defclass class_match_step_test_instance
  :super class_match_step_test
  :doc #{The $CLASS_MATCH_STEP_TEST_INSTANCE is the class for testing
instance membership. $MSTINS_CLASS is the tested class. $MSTINS_SLOTS
is the tuple of slot matched data.}#
  :fields (mstins_class
	   mstins_slots))

(defclass class_match_step_test_matcher
  :super class_match_step_test
  :doc #{The $CLASS_MATCH_STEP_TEST_MATCHER is the class for testing with
matcher. $MSTMA_MATCHER is the matcher, $MSTMA_BINDS is the local
binding list for inputs, $MSTMA_INS is the normalized inputs,
$MSTMA_OUTS is the tuple of output matched data.}#
  :fields (mstma_matcher
	   mstma_binds
	   mstma_ins
	   mstma_outs))

(defselector scan_subpatterns class_selector
  :doc #{Apply a given function $FUN to the subpatterns of reciever
  $RECV with extra context $CTX.}#
  :formals (recv fun ctx)
)

(defselector scan_step_data class_selector
  :doc #{Given a reciever $STEP, apply a given function $FUN to all
the data of the $STEP with an extra context $CTX.}#
  :formals (step fun ctx))

(defun scansubpat_anyrecv (recv fun ctx)
  (debug_msg recv "scansubpat_anyrecv recv")
  (let ( (dis (discrim recv)) )
    (errormsg_strv "unexpected scan_subpatterns for" (unsafe_get_field :named_name dis))
    (assert_msg "@$@unexpected scansubpat_anyrecv")
))
(install_method discr_any_receiver scan_subpatterns scansubpat_anyrecv)

(defun scansubpat_noop (recv fun ctx)
  ()
)
(install_method class_source_pattern_variable scan_subpatterns scansubpat_noop)
(install_method class_source_pattern_constant scan_subpatterns scansubpat_noop)

(defun scansubpat_or (recv fun ctx)
  (let ( (disjtup (unsafe_get_field :orpat_disj recv)) )
    (foreach_in_multiple
     (disjtup)
     (curdisj :long dix)
     (fun curdisj ctx))))
(install_method class_source_pattern_or scan_subpatterns scansubpat_or)

(defun scansubpat_and (recv fun ctx)
  (let ( (conjtup (unsafe_get_field :andpat_conj recv)) )
    (foreach_in_multiple
     (conjtup)
     (curconj :long cix)
     (fun curconj ctx))))
(install_method class_source_pattern_and scan_subpatterns scansubpat_and)


(defun scansubpat_construct (recv fun ctx)
  (let ( (subpatup (unsafe_get_field :ctpat_subpa recv)) )
    (foreach_in_multiple
     (subpatup)
     (curpa :long pix)
     (fun curpa ctx))))
(install_method class_source_pattern_construct scan_subpatterns scansubpat_construct)

(defun scansubpat_object (recv fun ctx)
  (let ( (patfieltup (unsafe_get_field :spat_fields recv)) )
    (foreach_in_multiple
     (patfieltup)
     (curpatfld :long flix)
     (if (is_a curpatfld class_source_field_pattern)
	 (fun (unsafe_get_field :spaf_pattern curpatfld) ctx)))))
(install_method class_source_pattern_object scan_subpatterns scansubpat_object)

(defun scansubpat_composite (recv fun ctx)
  (let ( (outup (unsafe_get_field :spac_outargs recv)) )
    (foreach_in_multiple
     (outup)
     (curout :long oix)
     (fun curout ctx))))
(install_method class_source_pattern_construct scan_subpatterns scansubpat_composite)


(defun fill_matchcase (curmcase sloc)
  (debug_msg curmcase "fill_matchcase curmcase")
  (assert_msg "check curmcase" (is_a curmcase class_match_case))
  (let (
	(ourpatvarmap (make_mapobject discr_map_objects 17))
	(curscas (unsafe_get_field :mcase_source curmcase))
	(curpat (unsafe_get_field :scam_patt curscas))
	)
    (letrec (
	     (varpatscanner 
	      (lambda (pat patvarmap)
		(debug_msg pat "fill_matchcase/varpatscanner pat")
		(if (is_a pat class_source_pattern_variable)
		    (let (
			  (pvarsymb (unsafe_get_field :spatvar_symb pat))
			  (varocclist (mapobject_get patvarmap pvarsymb))
			  )
		      (if (null varocclist)
			  (progn 
			    (setq varocclist (make_list discr_list))
			    (mapobject_put patvarmap pvarsymb varocclist)))
		      (list_append varocclist pat)
		      ))
		))
	     )
	    (varpatscanner curpat ourpatvarmap)
	    (scan_subpatterns curpat varpatscanner ourpatvarmap)
	    )
    (debug_msg ourpatvarmap "fill_matchcase ourpatvarmap")
    (unsafe_put_fields curmcase :mcase_varmap ourpatvarmap)
    ))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;; the selectors to set the then & else part of a match step
(defselector put_then_match class_selector
  :doc #{Put the then part of a match test $RECV to $THENSTEP.}#
  :formals (recv thenstep)
)

(defun start_step (step)
  (cond 
   ( (null step)
     (return)
     )
   ( (is_a step class_match_step_test_group)
     (let ( (stastep (unsafe_get_field :mstgroup_start step))
	    )
       (debug_msg step "start_step group step")
       (debug_msg stastep "stastep return stastep")
       (assert_msg "check stastep" (is_a stastep class_match_step))
       (return stastep)))
   (:else
    (debug_msg step "start_step ordinary step")
    (assert_msg "check step" (is_a step class_match_step))
    (return step))))

(defun putthen_matchthen (recv thenstep)
  (debug_msg recv "putthen_matchthen recv")
  (assert_msg "check recv" (is_a recv class_match_step_then))
  (debug_msg thenstep "putthen_matchthen thenstep")
  (assert_msg "check thenstep" (is_a thenstep class_match_step))
  (let ( (mythen (unsafe_get_field :mstep_then recv)) 
	 )
    (if (null mythen)
	(progn
	  (unsafe_put_fields recv :mstep_then (start_step thenstep))
	  (debug_msg recv "putthen_matchthen updated recv"))
      (progn
	(debug_msg mythen "putthen_matchthen mythen")
	(put_then_match mythen thenstep)
	(debug_msg mythen "putthen_matchthen did mythen"))))
  )
(install_method class_match_step_then put_then_match putthen_matchthen)

(defun putthen_matchgroup (recv thenstep)
  (debug_msg recv "putthen_matchgroup recv")
  (assert_msg "check recv" (is_a recv class_match_step_test_group))
  (debug_msg thenstep "putthen_matchgroup thenstep")
  (assert_msg "check thenstep" (is_a thenstep class_match_step))
  (putthen_matchthen recv thenstep)
  (let ( (thengroup (unsafe_get_field :mstgroup_then recv)) )
    (cond 
     ((null thengroup)
      (return))
     ((is_a thengroup class_match_step)
      (put_then_match thengroup thenstep))
     ((is_list thengroup)
      (foreach_in_list
       (thengroup)
       (curpair curthen)
       (put_then_match curthen thenstep)))
     ((is_multiple thengroup)
      (foreach_in_multiple
       (thengroup)
       (curthen :long thix)
       (put_then_match curthen thenstep)))
     (:else
      (debug_msg thengroup "putthen_matchgroup bad thengroup")
      (assert_msg "bad thengroup" ())))))
(install_method class_match_step_test_group put_then_match putthen_matchgroup)


(defselector put_else_match class_selector
  :doc #{Put the else part of a match test $RECV to $ELSESTEP.}#
  :formals (recv elsestep)
)

(defun putelse_matchtest (recv elsestep)
  (debug_msg recv "putelse_matchtest recv")
  (assert_msg "check recv" (is_a recv class_match_step_test))
  (debug_msg elsestep "putelse_matchtest elsestep")
  (assert_msg "check elsestep" (is_a elsestep class_match_step))
  (compile_warning "putelse_matchtest should handle when else already exists")
  (let ( (myelse (unsafe_get_field :mstep_else recv))
	 )
    (cond ( (null myelse)
	    (unsafe_put_fields recv :mstep_else  (start_step elsestep))
	    (debug_msg recv "putelse_matchtest updated recv")
	    )
	  (:else
	   ;; we probably should add the else to each then...
	   (assert_msg "$@$unexpected putelse_matchtest already else")))
))
(install_method class_match_step_test put_else_match putelse_matchtest)

(defun putelse_matchgroup (recv elsestep)
  (debug_msg recv "putelse_matchgroup recv")
  (assert_msg "check recv" (is_a recv class_match_step_test_group))
  (debug_msg elsestep "putelse_matchgroup elsestep")
  (assert_msg "check elsestep" (is_a elsestep class_match_step))
  (let ( (elsegroup (unsafe_get_field :mstgroup_else recv)) 
	 (elsestart (start_step elsestep))
	 )
    (debug_msg elsestep "putelse_matchgroup elsestart")
    (unsafe_put_fields recv :mstep_else elsestart)
    (debug_msg elsegroup "putelse_matchgroup elsegroup")
    (cond 
     ((null elsegroup)
      ())
     ((is_a elsegroup class_match_step)
      (debug_msg elsegroup "putelse_matchgroup elsegroup step")
      (put_else_match elsegroup elsestart))
     ((is_list elsegroup)
      (foreach_in_list
       (elsegroup)
       (curpair curelse)
       (debug_msg curelse "putelse_matchgroup curelse from list")
       (put_else_match curelse elsestart)))
     ((is_multiple elsegroup)
      (foreach_in_multiple
       (elsegroup)
       (curelse :long thix)
       (debug_msg curelse "putelse_matchgroup curelse from tuple")
       (put_else_match curelse elsestart)))
     (:else
      (debug_msg elsegroup "putelse_matchgroup bad elsegroup")
      (assert_msg "bad elsegroup" ())))
    (debug_msg recv "putelse_matchgroup end recv")
    ))
(install_method class_match_step_test_group put_else_match putelse_matchgroup)



(defun scanstep_testins (step fun ctx)
  (assert_msg "check step" (is_a step class_match_step_test_instance))
  (let ( (slotup (unsafe_get_field :mstins_slots step)) 
	 )
    (foreach_in_multiple 
     (slotup)
     (curslot :long ix)
     (if curslot 
	 (fun curslot ctx)))))
(install_method class_match_step_test_instance scan_step_data scanstep_testins)

(defun scanstep_testmatcher (step fun ctx)
  (assert_msg "check step" (is_a step class_match_step_test_matcher))
  (let ( (outs (unsafe_get_field :mstma_outs step)) 
	 )
    (foreach_in_multiple
     (outs)
     (curout :long outix)
     (if curout (fun curout ctx)))
    ))
(install_method class_match_step_test_matcher scan_step_data scanstep_testmatcher)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;; the selector to translate a pattern
(defselector translate_pattern class_selector
  :doc #{Translate a pattern into a match step. $RECV is the reciever,
  $MDATA is the matched data, $MCASE is the match case, and $SLOC is
  the source location}#
  :formals (recv mdata mcase varmap sloc))


(defun translpat_anyrecv (recv mdata mcase varmap sloc)
  (debug_msg recv "translpat_anyrecv recv")
  (debug_msg mdata "translpat_anyrecv mdata")
  (let ( (dis (discrim recv)) )
    (debug_msg dis "translpat_anyrecv dis")
    (error_strv sloc "unexpected TRANSLATE_PATTERN for" (unsafe_get_field :named_name dis))
    (assert_msg "@$@unexpected translpat_anyrecv")
))
(install_method discr_any_receiver translate_pattern translpat_anyrecv)

(defun translpat_jokerpat (recv mdata mcase varmap sloc)
  (assert_msg "check recv" (is_a recv class_source_pattern_joker_variable))
  (debug_msg recv "translpat_jokerpat recv")
  (return)
)
(install_method class_source_pattern_joker_variable translate_pattern translpat_jokerpat)




(defun translpat_inspat (recv mdata mcase varmap psloc)
  (debug_msg recv "translpat_inspat recv")
  (assert_msg "check recv" (is_a recv class_source_pattern_instance))
  (debug_msg mdata "translpat_inspat mdata")
  (assert_msg "check mdata" (is_a mdata class_matched_data))
  (debug_msg mcase "translpat_inspat mcase")
  (assert_msg "check mcase" (is_a mcase class_match_case))
  (let ( 
	(pclass (unsafe_get_field :spat_class recv))
	(pfields (unsafe_get_field :spat_fields recv))
	(sloc (or (unsafe_get_field :loca_location recv) psloc))
	)
    (assert_msg "check pclass" (is_a pclass class_class))
    (let ( (:long nbfields (multiple_length (unsafe_get_field :class_fields pclass)))
	   )
      ;; check that each mentioned field is indeed a field of the class
      (foreach_in_multiple
       (pfields)
       (curpfld :long pix)
       (assert_msg "check curpfld" (is_a curpfld class_source_field_pattern))
       (let ( (fsloc (or (unsafe_get_field :loca_location curpfld) sloc))
	      (curfld (unsafe_get_field :spaf_field curpfld))
	      (flcla (get_field :fld_ownclass curfld))
	      )
	 (assert_msg "check curfld" (is_a curfld class_field))
	 (cond ( (not (subclass_or_eq pclass flcla))
		 (error_strv sloc "bad field in object pattern"
			     (unsafe_get_field :named_name curfld))
		 (inform_strv sloc "class in pattern is" (get_field :named_name pclass))
		 (inform_strv sloc "class of field is" (get_field :named_name flcla))
		 (return)))
	 ))
      ;; find our step if its exist or else create it
      (let ( (istep ())
	     (steplist (unsafe_get_field :mdata_steps mdata))
	     )
	(foreach_in_list
	 (steplist)
	 (curpair curstep)
	 (cond 
	  ( (and (is_a curstep class_match_step_test_instance)
		 (== (unsafe_get_field :mstins_class curstep) pclass))
	    (setq curpair ())
	    (setq istep curstep)
	    )))
	(if (null istep)
	    (let 
		( 
		 (dslots (make_multiple discr_multiple nbfields))
		 (newstep (instance class_match_step_test_instance
				    :loca_location sloc
				    :mstep_data mdata
				    :mstep_then ()
				    :mstep_else ()
				    :mstins_class pclass
				    :mstins_slots dslots
				    ))
		 )
	      (setq istep newstep)
	      (debug_msg newstep "translpat_inspat newstep")
	      (list_append steplist newstep)
	      (debug_msg steplist "translpat_inspat updated steplist")
	      ))
	;; translate each mentioned non-joker field 
	(let ( (mslots (unsafe_get_field :mstins_slots istep))
	       (laststep istep)
	       (elselist (make_list discr_list))
	       )
	  (assert_msg "check mslots" (is_multiple mslots))
	  (list_append elselist istep)
	  (foreach_in_multiple
	   (pfields)
	   (curpfld :long pix)
	   (assert_msg "check curpfld" (is_a curpfld class_source_field_pattern))
	   (let ( (fsloc (or (unsafe_get_field :loca_location curpfld) sloc))
		  (curfld (unsafe_get_field :spaf_field curpfld))
		  (curfpat (unsafe_get_field :spaf_pattern curpfld))
		  )
	     (if (is_not_a curfpat class_source_pattern_joker_variable)
		 (let ( (:long curfix (get_int curfld))
			(curslotdata (multiple_nth mslots curfix))
			)
		   (if (null curslotdata)
		       (let ( (newslot (instance class_matched_data
						 :mdata_symb (clone_symbol curfld)
						 :mdata_ctype ctype_value
						 :mdata_orig istep
						 :mdata_steps (make_list discr_list)
						 )) 
			      )
			 (debug_msg newslot " translpat_inspat newslot")
			 (setq curslotdata newslot)
			 (multiple_put_nth mslots curfix newslot)))
		   (debug_msg curfpat "translpat_inspat before translation curfpat")
		   (let ( (flstep (translate_pattern curfpat curslotdata 
						     mcase varmap psloc)) 
			  )
		     (debug_msg flstep "translpat_inspat flstep")
		     (if flstep 
			 (progn
			   (debug_msg laststep "translpat_inspat laststep")
			   (put_then_match laststep flstep)
			   (list_append elselist flstep)
			   (setq laststep flstep)
			   ))
		     )))))
	  (debug_msg elselist "translpat_inspat elselist")
	  (let ( (stepgroup (instance class_match_step_test_group
				      :loca_location sloc
				      :mstep_data mdata
				      :mstep_then ()
				      :mstep_else ()
				      :mstgroup_start istep
				      :mstgroup_then laststep
				      :mstgroup_else (list_to_multiple elselist)
				      ))
		 )
	    (debug_msg stepgroup "translpat_inspat return stepgroup")
	    (return stepgroup)
	    ))))))
(install_method class_source_pattern_instance translate_pattern translpat_inspat)


(defun translpat_varpat (recv mdata mcase varmap psloc)
  (debug_msg recv "translpat_varpat recv")
  (assert_msg "check recv" (is_a recv class_source_pattern_variable))
  (debug_msg mdata "translpat_varpat mdata")
  (assert_msg "check mdata" (is_a mdata class_matched_data))
  (debug_msg mcase "translpat_varpat mcase")
  (assert_msg "check mcase" (is_a mcase class_match_case))
  (let ( 
	(sloc (or (unsafe_get_field :loca_location recv) psloc))
	(symb (unsafe_get_field :spatvar_symb recv))
	(matctx (unsafe_get_field  :mcase_mctxt mcase))
	(symbval (mapobject_get varmap symb))
	(mhandlers (get_field :mxct_varhandlers matctx))
	(steplist (unsafe_get_field :mdata_steps mdata))
	)
    (debug_msg symb "translpat_varpat symb")
    (debug_msg symbval "translpat_varpat symbval")
    (foreach_in_list
     (mhandlers)
     (curpair curhandler)
     (curhandler recv mdata mcase symbval sloc))
    (cond 
     ( (null symbval)
       (mapobject_put varmap symb mdata)
       (debug_msg varmap "translpat_varpat updated varmap")
       (foreach_in_list
	(steplist)
	(curpair cursetstep)
	(if (and (is_a cursetstep class_match_step_set_variable)
		 (== (unsafe_get_field :mstepsetvar_symb cursetstep) symb)
		 (== (unsafe_get_field :mstep_data cursetstep) mdata))
	    (progn
	      (debug_msg cursetstep "translpat_varpat found cursetstep")
	      (return cursetstep)))
	)
       (let ( (stepset (instance class_match_step_set_variable
				 :loca_location sloc
				 :mstep_data mdata
				 :mstep_then ()
				 :mstepsetvar_symb symb
				 ))
	      )
	 (compile_warning "the step set variable should probably be inserted before any tests on the same data..")
	 (debug_msg stepset "translpat_varpat return stepset")
	 (list_append steplist stepset)
	 (return stepset)
	 ))
     (:else
      (assert_msg "check symbval" (is_a symbval class_matched_data))
       (foreach_in_list
	(steplist)
	(curpair curteststep)
	(if (and (is_a curteststep class_match_step_test_variable)
		 (== (unsafe_get_field :msteptestvar_symb curteststep) symb)
		 (== (unsafe_get_field :mstep_data curteststep) mdata))
	    (progn
	      (debug_msg curteststep "translpat_varpat found curteststep")
	      (return curteststep)))
	)
      (let ( (steptest (instance class_match_step_test_variable
				 :loca_location sloc
				 :mstep_data mdata
				 :mstep_then ()
				 :msteptestvar_symb symb
				 ))
	     )
	(list_append steplist steptest)
	(debug_msg steptest "translpat_varpat return steptest")
	(return steptest)
	)))
    ))
(install_method class_source_pattern_variable translate_pattern translpat_varpat)



;;;;;;;;;;;;;;;;
;;; translation of and-patterns
(defun translpat_andpat (recv mdata mcase varmap psloc)
  (debug_msg recv "translpat_andpat recv")
  (assert_msg "check recv" (is_a recv class_source_pattern_and))
  (debug_msg mdata "translpat_andpat mdata")
  (assert_msg "check mdata" (is_a mdata class_matched_data))
  (debug_msg mcase "translpat_andpat mcase")
  (assert_msg "check mcase" (is_a mcase class_match_case))
  (let (
	(sloc (or (unsafe_get_field :loca_location recv) psloc))
	(sconj (unsafe_get_field :andpat_conj recv))
	(curstep ())
	(firststep ())
	(thenlist (make_list discr_list))
	(elselist (make_list discr_list))
	(stepgroup (instance class_match_step_test_group
			     :loca_location sloc
			     :mstep_data mdata
			     :mstgroup_start ()
			     :mstgroup_then ()
			     :mstgroup_else ()
			     ))
	)
    (assert_msg "check sconj" (is_multiple sconj))
    (foreach_in_multiple
     (sconj)
     (curconj :long conjix)
     (debug_msg curconj "translpat_andpat curconj")
     (let ( (conjstep 
	     (translate_pattern curconj mdata mcase varmap sloc))
	    )
       (debug_msg conjstep "translpat_andpat conjstep")
       (if conjstep
	   (progn
	     (if (null curstep)
		 (progn
		   (setq firststep conjstep)
		   (list_append thenlist firststep)
		   )
	       (progn
		 (debug_msg curstep "translpat_andpat curstep")
		 (put_then_match curstep conjstep)
		 )
	       )
	     (list_append elselist conjstep)
	     (setq curstep conjstep)
	     )
	 )))
    (unsafe_put_fields stepgroup
		       :mstgroup_start firststep
		       :mstgroup_then (list_to_multiple thenlist discr_multiple)
		       :mstgroup_else (list_to_multiple elselist discr_multiple))
    (cond ( (null firststep)
	    ;; this happens only for degenerate conjonctions like ?(and ?_)
	    (warning_plain sloc "degenerate ?(AND ...) pattern")
	    (setq stepgroup ()))
	  )
    (debug_msg stepgroup "translpat_andpat return stepgroup")
    (return stepgroup)
    ))
(install_method class_source_pattern_and translate_pattern translpat_andpat)



;;; translation of or-patterns
(defun translpat_orpat (recv  mdata mcase varmap psloc)
  (debug_msg recv "translpat_orpat recv")
  (assert_msg "check recv" (is_a recv class_source_pattern_or))
  (debug_msg mdata "translpat_orpat mdata")
  (assert_msg "check mdata" (is_a mdata class_matched_data))
  (debug_msg mcase "translpat_orpat mcase")
  (assert_msg "check mcase" (is_a mcase class_match_case))
  (let (
	(sloc (or (unsafe_get_field :loca_location recv) psloc))
	)
    (error_plain sloc "unimplemented translpat_orpat")
    (assert_msg "@$@unimplemented translpat_orpat")
    ))
(install_method class_source_pattern_or translate_pattern translpat_orpat)



;;;;;;;;;;;;;;;;
;; translation of pattern matchers (c-matchers or fun-matchers)
(defun translpat_patmat (recv mdata mcase varmap psloc)
  (debug_msg recv "translpat_patmat recv")
  (assert_msg "check recv" (is_a recv class_source_pattern_matcher))
  (debug_msg mdata "translpat_patmat mdata")
  (assert_msg "check mdata" (is_a mdata class_matched_data))
  (debug_msg mcase "translpat_patmat mcase")
  (assert_msg "check mcase" (is_a mcase class_match_case))
  (let (
	(sloc (or (unsafe_get_field :loca_location recv) psloc))
	(sopbind (unsafe_get_field :spac_operbind recv))
	(soper (unsafe_get_field :spac_operator recv))
	(sins (unsafe_get_field :spac_inargs recv))
	(souts (unsafe_get_field :spac_outargs recv))
	(matctx (unsafe_get_field  :mcase_mctxt mcase))
	(env (get_field :mxct_env matctx))
	(ncx (get_field :mxct_normctxt matctx))
	(opin (get_field :amatch_in soper))
	(opout (get_field :amatch_out soper))
	(:long nbopout (multiple_length opout))
	(curstep ())
	(mdatasteps (unsafe_get_field :mdata_steps mdata))
	)
    (assert_msg "check matctx" (is_a matctx class_matching_context))
    (assert_msg "check env" (is_a env class_environment))
    (debug_msg soper "translpat_patmat soper")
    (assert_msg "check soper" (is_a soper class_any_matcher))
    (debug_msg sins "translpat_patmat sins")
    (debug_msg souts "translpat_patmat souts")
    (debug_msg sopbind "translpat_patmat sopbind")
    (multicall
     (nins inbinds)
     (normalize_tuple sins env ncx sloc)
     (debug_msg nins "translpat_patmat nins")
     (debug_msg inbinds "translpat_patmat inbinds")
     (assert_msg "check inbinds" (is_list_or_null inbinds))
     (if (!=i (multiple_length nins) (multiple_length opin))
	 (error_strv sloc "bad input arity of matcher in pattern" 
		     (get_field :named_name soper)))
     (foreach_in_multiple
      (nins)
      (curnin :long nix)
      (let ( (curopin (multiple_nth opin nix))
	     (curctyp (get_ctype curnin env))
	     (inctyp (get_field :fbind_type curopin))
	     )
	(debug_msg curnin "translpat_patmat curnin")
	(debug_msg curopin "translpat_patmat curopin")
	(debug_msg curctyp "translpat_patmat curctyp")
	(assert_msg "check curopin" (is_a curopin class_formal_binding))
	(assert_msg "check curctyp" (is_a curctyp class_ctype))
	(if (!= curctyp inctyp)
	    (progn
	      (error_strv sloc "bad input type in matcher, expecting"
			  (get_field :named_name inctyp))
	      (error_strv sloc
			  "mistyped formal name in matcher is"
			  (get_field  :named_name (get_field :binder curopin)))
	      (error_strv sloc "got input type in matcher" 
			  (get_field :named_name curctyp))
	      (return)))
	))
     ;; try to find the same test step
     (foreach_in_list
      (mdatasteps)
      (curpairstep curdatastep)
      (assert_msg "check curdatastep" (is_a curdatastep class_match_step))
      (if (and
	   (is_a curdatastep class_match_step_test_matcher)
	   (== (unsafe_get_field :mstep_data curdatastep) mdata)
	   (== (unsafe_get_field :mstma_matcher curdatastep) soper)
	   (==i (list_length inbinds) 0)
	   (==i (list_length (unsafe_get_field :mstma_binds curdatastep)) 0)
	   )
	  (let ( (similarstep curdatastep)
		 (curins (unsafe_get_field :mstma_ins curdatastep))
		 )
	    (foreach_in_multiple
	     (curins)
	     (cursimin :long simix)
	     (if (!= (multiple_nth nins simix) cursimin)
		 (progn
		   (setq simix -1)
		   (setq cursimin ())
		   (setq similarstep ())))
	     )
	    (debug_msg similarstep "translpat_patmat similiarstep")
	    (if similarstep 
		(progn
		  (setq curstep similarstep)
		  (setq curpairstep ())
		  (setq curdatastep ())))
	    ))
      )
     (debug_msg curstep "translpat_patmat custep after seeking")
     (if (null curstep)
	 (let ( 
	       (outdatatup (make_multiple discr_multiple nbopout))
	       (newstep (instance class_match_step_test_matcher
			       :loca_location sloc
			       :mstep_data mdata
			       :mstep_then ()
			       :mstep_else ()
			       :mstma_matcher soper
			       :mstma_binds inbinds
			       :mstma_ins nins
			       :mstma_outs outdatatup))
	       )
	   (setq curstep newstep)
	   (debug_msg newstep "translpat_patmat newstep")
	   (list_append mdatasteps newstep)
	   (debug_msg mdatasteps "translpat_patmat updated mdatasteps")
	   (foreach_in_multiple
	    (opout)
	    (curoutbind :long outix)
	    (debug_msg curoutbind "translpat_patmat curoutbind")
	    (assert_msg "check curoutbind" (is_a curoutbind class_formal_binding))
	    (let ( (outsymb (get_field :binder curoutbind))
		   (outctyp (get_field :fbind_type curoutbind))
		   (newslot (instance class_matched_data
				      :mdata_symb (clone_symbol outsymb)
				      :mdata_ctype outctyp
				      :mdata_orig newstep
				      :mdata_steps (make_list discr_list)))
		   )
	      (debug_msg outsymb "translpat_patmat outsymb")
	      (debug_msg newslot "translpat_patmat newslot")
	      (multiple_put_nth outdatatup outix newslot)
	      (assert_msg "check outctyp" (is_a outctyp class_ctype))
	      ))
	   ))
     (debug_msg curstep "translpat_patmat curstep after making it")
     (assert_msg "check curstep" (is_a curstep class_match_step_test_matcher))
     (debug_msg souts "translpat_patmat souts again")
     (let ( 
	   (outdata (get_field :mstma_outs curstep))
	   (thenlist (make_list discr_list))
	   (elselist (make_list discr_list))
	   (laststep curstep)
	   (testgroup (instance class_match_step_test_group
				:loca_location sloc
				:mstep_data mdata
				:mstep_then ()
				:mstep_else ()
				:mstgroup_start curstep
				:mstgroup_then ()
				:mstgroup_else ()
				))
	   )
       (foreach_in_multiple
	(outdata)
	(curoutdata :long dix)
	(let ( (outpat (multiple_nth souts dix))
	       )
	(debug_msg curoutdata "translpat_patmat curoutdata")
	(debug_msg outpat "translpat_patmat outpat")
	(let ( (outstep (translate_pattern outpat curoutdata mcase varmap sloc))
	       )
	  (debug_msg outstep "translpat_patmat outstep")
	  (if outstep
	      (progn
		(put_then_match laststep outstep)
		(list_append elselist outstep)
		(setq laststep outstep)
		))
	)))
       (put_fields
	testgroup
	:mstgroup_then curstep
	:mstgroup_else elselist)
       (debug_msg testgroup "translpat_patmat return testgroup")
       (return testgroup)
       )
	    
     )
    )
  )
(install_method class_source_pattern_matcher  translate_pattern translpat_patmat)
	

;; internal selector to output the label of a test in "HTML-like"
;; graphiz format
(defselector matchgraphic_altstep class_selector
)

(defun mgaltstep_stepsetvar (step mg)
  (debug_msg step "mgaltstep_stepsetvar step")
  (assert_msg "check step" (is_a step class_match_step_set_variable))
  (assert_msg "check mg" (is_a mg class_match_graphic))
  (let ( (loca (unsafe_get_field :loca_location step))
	 (sthen (unsafe_get_field :mstep_then step))
	 (setsymb (unsafe_get_field :mstepsetvar_symb step))
	 (nodebuf (unsafe_get_field :mchgx_nodout mg))
	 (edgebuf (unsafe_get_field :mchgx_edgout mg))
	 (datamap (unsafe_get_field :mchgx_datanamemap mg))
	 (stepmap (unsafe_get_field :mchgx_stepnamemap mg))
	 (stepname (mapobject_get stepmap step))
	 (thenname (if sthen (mapobject_get stepmap sthen)))
	 (:long stephash (obj_hash step))
	 (dis (discrim step))
	 (clanam (get_field :named_name dis))
	 )
    (add2out_strconst nodebuf "<tr><td><font color=\"saddlebrown\" face=\"Times-Roman Bold\" point-size=\"6\">")
    (code_chunk 
     outclanam
     #{ /* $OUTCLANAM */
     meltgc_add_out ((melt_ptr_t) $NODEBUF,
		     melt_string_str ((melt_ptr_t) $CLANAM) +6)	;
     }#)
    (add2out_strconst nodebuf "</font></td><td>")
    (add2out_strconst nodebuf "<font face=\"Helvetica Italic\" color=\"darkgreen\" point-size=\"6.5\">")
    (add2sbuf_short_mixloc nodebuf loca)
    (add2out_strconst nodebuf "</font></td></tr>")
    (add2out_indentnl nodebuf 0)
    (add2out_strconst nodebuf "<tr><td colspan=\"2\"><font face=\"Time-Roman Italics\" point-size=\"7\">")
    (add2out_string nodebuf (get_field :named_name setsymb))
    (if (is_a setsymb class_cloned_symbol)
	(let ( (:long syrank (get_int (get_field :csym_urank setsymb)))
	      )
	  (add2out_strconst nodebuf "$")
	  (add2out_longdec nodebuf syrank)
	  ))
    (add2out_strconst nodebuf "</font></td></tr>")
    (add2out_indentnl nodebuf 0)
    (if thenname
	(progn
	  (add2out_indentnl edgebuf 0)
	  (add2out_string edgebuf stepname)
	  (add2out_strconst edgebuf " /*then*/ -> ")
	  (add2out_string edgebuf thenname)
	  (add2out_strconst edgebuf " [ arrowhead=normal, color=green ];")
	  ))
    ))
(install_method class_match_step_set_variable  matchgraphic_altstep mgaltstep_stepsetvar)


;;;;;;;;;;;;;;;;
(defun mgaltstep_steptestvar (step mg)
  (debug_msg step "mgaltstep_steptestvar step")
  (assert_msg "check step" (is_a step class_match_step_test_variable))
  (assert_msg "check mg" (is_a mg class_match_graphic))
  (let ( (loca (unsafe_get_field :loca_location step))
	 (sthen (unsafe_get_field :mstep_then step))
	 (selse (unsafe_get_field :mstep_else step))
	 (testsymb (unsafe_get_field :msteptestvar_symb step))
	 (nodebuf (unsafe_get_field :mchgx_nodout mg))
	 (edgebuf (unsafe_get_field :mchgx_edgout mg))
	 (datamap (unsafe_get_field :mchgx_datanamemap mg))
	 (stepmap (unsafe_get_field :mchgx_stepnamemap mg))
	 (stepname (mapobject_get stepmap step))
	 (thenname (if sthen (mapobject_get stepmap sthen)))
	 (elsename (if selse (mapobject_get stepmap selse)))
	 (:long stephash (obj_hash step))
	 (dis (discrim step))
	 (clanam (get_field :named_name dis))
	 )
    (add2out_strconst nodebuf "<tr><td><font color=\"royalblue4\" face=\"Times-Roman Bold\" point-size=\"6\">")
    (code_chunk 
     outclanam
     #{ /* $OUTCLANAM */
     meltgc_add_out ((melt_ptr_t) $NODEBUF,
		     melt_string_str ((melt_ptr_t) $CLANAM) +6)	;
     }#)
    (add2out_strconst nodebuf "</font></td><td>")
    (add2out_strconst nodebuf "<font face=\"Helvetica Italic\" color=\"darkgreen\" point-size=\"6.5\">")
    (add2sbuf_short_mixloc nodebuf loca)
    (add2out_strconst nodebuf "</font></td></tr>")
    (add2out_indentnl nodebuf 0)
    (add2out_strconst nodebuf "<tr><td colspan=\"2\"><font face=\"Time-Roman Italics\" point-size=\"7\" color=\"navy\">")
    (add2out_string nodebuf (get_field :named_name testsymb))
    (if (is_a testsymb class_cloned_symbol)
	(let ( (:long syrank (get_int (get_field :csym_urank testsymb)))
	      )
	  (add2out_strconst nodebuf "$")
	  (add2out_longdec nodebuf syrank)
	  ))
    (add2out_strconst nodebuf "</font></td></tr>")
    (add2out_indentnl nodebuf 0)
    (if thenname
	(progn
	  (add2out_indentnl edgebuf 0)
	  (add2out_string edgebuf stepname)
	  (add2out_strconst edgebuf " /*then*/ -> ")
	  (add2out_string edgebuf thenname)
	  (add2out_strconst edgebuf " [ arrowhead=normal, color=green ];")
	  ))
    (if elsename
	(progn
	  (add2out_indentnl edgebuf 0)
	  (add2out_string edgebuf stepname)
	  (add2out_strconst edgebuf " /*else*/ -> ")
	  (add2out_string edgebuf elsename)
	  (add2out_strconst edgebuf " [ arrowhead=diamond, color=red ];")
	  ))
    ))
(install_method class_match_step_test_variable matchgraphic_altstep mgaltstep_steptestvar)


;;;;;;;;;;;;;;;;
(defun mgaltstep_steptestinst (step mg)
  (debug_msg step "mgaltstep_steptestinst step")
  (assert_msg "check step" (is_a step class_match_step_test_instance))
  (assert_msg "check mg" (is_a mg class_match_graphic))
  (let ( (loca (unsafe_get_field :loca_location step))
	 (sthen (unsafe_get_field :mstep_then step))
	 (selse (unsafe_get_field :mstep_else step))
	 (testclass (unsafe_get_field :mstins_class step))
	 (testslots (unsafe_get_field :mstins_slots step))
	 (nodebuf (unsafe_get_field :mchgx_nodout mg))
	 (edgebuf (unsafe_get_field :mchgx_edgout mg))
	 (datamap (unsafe_get_field :mchgx_datanamemap mg))
	 (stepmap (unsafe_get_field :mchgx_stepnamemap mg))
	 (stepname (mapobject_get stepmap step))
	 (thenname (if sthen (mapobject_get stepmap sthen)))
	 (elsename (if selse (mapobject_get stepmap selse)))
	 (:long stephash (obj_hash step))
	 (dis (discrim step))
	 (clanam (get_field :named_name dis))
	 )
    (add2out_strconst nodebuf "<tr><td><font color=\"salmon4\" face=\"Times-Roman Bold\" point-size=\"6\">")
    (code_chunk 
     outclanam
     #{ /* $OUTCLANAM */
     meltgc_add_out ((melt_ptr_t) $NODEBUF,
		     melt_string_str ((melt_ptr_t) $CLANAM) +6)	;
     }#)
    (add2out_strconst nodebuf "</font></td><td>")
    (add2out_strconst nodebuf "<font face=\"Helvetica Italic\" color=\"darkgreen\" point-size=\"6.5\">")
    (add2sbuf_short_mixloc nodebuf loca)
    (add2out_strconst nodebuf "</font></td></tr>")
    (add2out_indentnl nodebuf 0)
    (add2out_strconst nodebuf "<tr><td colspan=\"2\"><font color=\"salmon\" face=\"Helvetica Oblique\" point-size=\"6\">")
    (add2out_string nodebuf (get_field :named_name testclass))
    (add2out_strconst nodebuf "</font></td></tr>")
    (add2out_indentnl nodebuf 0)
    (foreach_in_multiple
     (testslots)
     (curslot :long slix)
     (if curslot
	 (progn
	   (assert_msg "check curslot" (is_a curslot class_matched_data))
	   (add2out_indentnl edgebuf 0)
	   (add2out_string edgebuf stepname)
	   (add2out_strconst edgebuf " /*testinslot*/ -> /*data*/")
	   (add2out_string edgebuf (mapobject_get datamap curslot))
	   (add2out_strconst edgebuf " [ arrowhead=open,")
	   (let ( (fld (multiple_nth (get_field :class_fields testclass) slix)) )
	     (assert_msg "check fld" (is_a fld class_field))
	     (add2out_strconst edgebuf " label=<<font point-size=\"6.5\" color=\"indigo\">")
	     (add2out_string edgebuf (get_field :named_name fld))
	     (add2out_strconst edgebuf "</font>>, "))
	     (add2out_strconst edgebuf " color=violet, style=dotted ];")
	   ))
     )
    (if thenname
	(progn
	  (add2out_indentnl edgebuf 0)
	  (add2out_string edgebuf stepname)
	  (add2out_strconst edgebuf " /*then*/ -> ")
	  (add2out_string edgebuf thenname)
	  (add2out_strconst edgebuf " [ arrowhead=normal, color=green ];")
	  ))
    (if elsename
	(progn
	  (add2out_indentnl edgebuf 0)
	  (add2out_string edgebuf stepname)
	  (add2out_strconst edgebuf " /*else*/ -> ")
	  (add2out_string edgebuf elsename)
	  (add2out_strconst edgebuf " [ arrowhead=diamond, color=red ];")
	  ))
    ))
(install_method class_match_step_test_instance matchgraphic_altstep mgaltstep_steptestinst)

;;;;;;;;;;;;;;;;
(defun mgaltstep_steptestgroup (step mg)
  (debug_msg step "mgaltstep_steptestgroup step")
  (assert_msg "check step" (is_a step class_match_step_test_group))
  (assert_msg "check mg" (is_a mg class_match_graphic))
  (let ( (loca (unsafe_get_field :loca_location step))
	 (sthen (unsafe_get_field :mstep_then step))
	 (selse (unsafe_get_field :mstep_else step))
	 (nodebuf (unsafe_get_field :mchgx_nodout mg))
	 (edgebuf (unsafe_get_field :mchgx_edgout mg))
	 (datamap (unsafe_get_field :mchgx_datanamemap mg))
	 (stepmap (unsafe_get_field :mchgx_stepnamemap mg))
	 (stepname (mapobject_get stepmap step))
	 (thenname (if sthen (mapobject_get stepmap sthen)))
	 (elsename (if selse (mapobject_get stepmap selse)))
	 (:long stephash (obj_hash step))
	 (dis (discrim step))
	 (clanam (get_field :named_name dis))
	 )
    (add2out_strconst nodebuf "<tr><td><font color=\"hotpink\" face=\"Times-Roman Bold\" point-size=\"6\">")
    (code_chunk 
     outclanam
     #{ /* $OUTCLANAM */
     meltgc_add_out ((melt_ptr_t) $NODEBUF,
		     melt_string_str ((melt_ptr_t) $CLANAM) +6)	;
     }#)
    (add2out_strconst nodebuf "</font></td><td>")
    (add2out_strconst nodebuf "<font face=\"Helvetica Italic\" color=\"darkgreen\" point-size=\"6.5\">")
    (add2sbuf_short_mixloc nodebuf loca)
    (add2out_strconst nodebuf "</font></td></tr>")
    (add2out_indentnl nodebuf 0)
    (if thenname
	(progn
	  (add2out_indentnl edgebuf 0)
	  (add2out_string edgebuf stepname)
	  (add2out_strconst edgebuf " /*then*/ -> ")
	  (add2out_string edgebuf thenname)
	  (add2out_strconst edgebuf " [ arrowhead=normal, color=green ];")
	  ))
    (if elsename
	(progn
	  (add2out_indentnl edgebuf 0)
	  (add2out_string edgebuf stepname)
	  (add2out_strconst edgebuf " /*else*/ -> ")
	  (add2out_string edgebuf elsename)
	  (add2out_strconst edgebuf " [ arrowhead=diamond, color=red ];")
	  ))
    ))
(install_method class_match_step_test_group matchgraphic_altstep mgaltstep_steptestgroup)

;;;;;;;;;;;;;;;;
(defun mgaltstep_steptestmatcher (step mg)
  (debug_msg step "mgaltstep_steptestmatcher step")
  (assert_msg "check step" (is_a step class_match_step_test_matcher))
  (assert_msg "check mg" (is_a mg class_match_graphic))
  (let ( (loca (unsafe_get_field :loca_location step))
	 (sthen (unsafe_get_field :mstep_then step))
	 (selse (unsafe_get_field :mstep_else step))
	 (smatcher (unsafe_get_field :mstma_matcher step))
	 (souts (unsafe_get_field :mstma_outs step))
	 (nodebuf (unsafe_get_field :mchgx_nodout mg))
	 (edgebuf (unsafe_get_field :mchgx_edgout mg))
	 (datamap (unsafe_get_field :mchgx_datanamemap mg))
	 (stepmap (unsafe_get_field :mchgx_stepnamemap mg))
	 (stepname (mapobject_get stepmap step))
	 (thenname (if sthen (mapobject_get stepmap sthen)))
	 (elsename (if selse (mapobject_get stepmap selse)))
	 (:long stephash (obj_hash step))
	 (dis (discrim step))
	 (clanam (get_field :named_name dis))
	 )
    (add2out_strconst nodebuf "<tr><td><font color=\"peru\" face=\"Times-Roman Bold\" point-size=\"6\">")
    (code_chunk 
     outclanam
     #{ /* $OUTCLANAM */
     meltgc_add_out ((melt_ptr_t) $NODEBUF,
		     melt_string_str ((melt_ptr_t) $CLANAM) +6)	;
     }#)
    (add2out_strconst nodebuf "</font></td><td>")
    (add2out_strconst nodebuf "<font face=\"Helvetica Italic\" color=\"darkgreen\" point-size=\"6.5\">")
    (add2sbuf_short_mixloc nodebuf loca)
    (add2out_strconst nodebuf "</font></td></tr>")
    (add2out_indentnl nodebuf 0)
    (add2out_strconst nodebuf "<tr><td colspan=\"2\"><font color=\"peru\" face=\"Time-Roman Italics\" point-size=\"7\">")
    (add2out_string nodebuf (get_field :named_name smatcher))
    (add2out_strconst nodebuf "</font></td></tr>")
    (add2out_indentnl nodebuf 0)
    (foreach_in_multiple
     (souts)
     (curout :long outix)
     (debug_msg curout "mgaltstep_steptestmatcher curout")
     (assert_msg "check curout" (is_a curout class_matched_data))
     (add2out_indentnl edgebuf 0)
     (add2out_string edgebuf stepname)
     (add2out_strconst edgebuf " /*matchstep*/ -> /*data*/ ")
     (add2out_string edgebuf (mapobject_get datamap curout))
     (add2out_strconst edgebuf " [ arrowhead=open, ")
     (let ( (outbind (multiple_nth (get_field :amatch_out smatcher) outix))
	    (outsymb (get_field :binder outbind))
	    )
       (if (is_a outsymb class_symbol)
	   (progn
	     (add2out_strconst edgebuf " label=<<font face=\"Helvetica\" point-size=\"6\">")
	     (add2out_string edgebuf (get_field :named_name outsymb))
	     (add2out_strconst edgebuf "</font>>, "))))
     (add2out_strconst edgebuf " color=violet, style=dotted ];")
     )
    (if thenname
	(progn
	  (add2out_indentnl edgebuf 0)
	  (add2out_string edgebuf stepname)
	  (add2out_strconst edgebuf " /*then*/ -> ")
	  (add2out_string edgebuf thenname)
	  (add2out_strconst edgebuf " [ arrowhead=normal, color=green ];")
	  ))
    (if elsename
	(progn
	  (add2out_indentnl edgebuf 0)
	  (add2out_string edgebuf stepname)
	  (add2out_strconst edgebuf " /*else*/ -> ")
	  (add2out_string edgebuf elsename)
	  (add2out_strconst edgebuf " [ arrowhead=diamond, color=red ];")
	  ))
    ))
(install_method class_match_step_test_matcher matchgraphic_altstep mgaltstep_steptestmatcher)


;;;;;;;;;;;;;;;;
(defun mgaltstep_stepsuccess (step mg)
  (debug_msg step "mgaltstep_stepsuccess step")
  (assert_msg "check step" (is_a step class_match_step_success))
  (assert_msg "check mg" (is_a mg class_match_graphic))
  (let ( (loca (unsafe_get_field :loca_location step))
	 (sthen (unsafe_get_field :mstep_then step))
	 (nodebuf (unsafe_get_field :mchgx_nodout mg))
	 (edgebuf (unsafe_get_field :mchgx_edgout mg))
	 (datamap (unsafe_get_field :mchgx_datanamemap mg))
	 (stepmap (unsafe_get_field :mchgx_stepnamemap mg))
	 (stepname (mapobject_get stepmap step))
	 (thenname (if sthen (mapobject_get stepmap sthen)))
	 (:long stephash (obj_hash step))
	 (dis (discrim step))
	 (clanam (get_field :named_name dis))
	 )
    (add2out_strconst nodebuf "<tr><td><font color=\"firebrick\" face=\"Times-Roman Bold\" point-size=\"6\">")
    (code_chunk 
     outclanam
     #{ /* $OUTCLANAM */
     meltgc_add_out ((melt_ptr_t) $NODEBUF,
		     melt_string_str ((melt_ptr_t) $CLANAM) +6)	;
     }#)
    (add2out_strconst nodebuf "</font></td><td>")
    (add2out_strconst nodebuf "<font face=\"Helvetica Italic\" color=\"darkgreen\" point-size=\"6.5\">")
    (add2sbuf_short_mixloc nodebuf loca)
    (add2out_strconst nodebuf "</font></td></tr>")
    (add2out_indentnl nodebuf 0)
    (if thenname
	(progn
	  (add2out_indentnl edgebuf 0)
	  (add2out_string edgebuf stepname)
	  (add2out_strconst edgebuf " /*then*/ -> ")
	  (add2out_string edgebuf thenname)
	  (add2out_strconst edgebuf " [ arrowhead=normal, color=green ];")
	  ))
    ))

(install_method class_match_step_success  matchgraphic_altstep mgaltstep_stepsuccess)
;;;;;;;;;;;;;;;;


(compile_warning "missing other methods for matchgraphic_altstep on other step classes")

(defun translate_matchcase (curmcase sloc prevstep)
  (debug_msg curmcase "translate_matchcase curmcase")
  (assert_msg "check curmcase" (is_a curmcase class_match_case))
  (let ( (matctx (unsafe_get_field  :mcase_mctxt curmcase))
	 (curscas (unsafe_get_field :mcase_source curmcase))
	 (mloc (unsafe_get_field :loca_location curscas))
	 )
    (assert_msg "check matctx" (is_a matctx class_matching_context))
    (debug_msg curscas "translate_matchcase curscas")
    (debug_msg prevstep "translate_matchcase prevstep")
    (assert_msg "check curscas" (is_a curscas class_source_match_case))
    (let (
	  (curloc (unsafe_get_field :loca_location curscas))
	  (curpat (unsafe_get_field :scam_patt curscas))
	  (curbody (unsafe_get_field :scam_body curscas))
	  (nmatx (unsafe_get_field :mxct_nmatched matctx))
	  (mdata (unsafe_get_field :mxct_mdata matctx))
	  (ncx (unsafe_get_field :mxct_normctxt matctx))
	  (env (unsafe_get_field :mxct_env matctx))
	  (varmap (make_mapobject discr_map_objects
				  (+i 12 (*i 2 (mapobject_count (unsafe_get_field :mcase_varmap curscas)))))) 
	  (sycmap  (unsafe_get_field :nctx_symbcachemap ncx))
	  )
      (debug_msg nmatx "translate_matchcase nmatx")
      (debug_msg curpat "translate_matchcase curpat")
      (debug_msg mdata "translate_matchcase mdata")
      (assert_msg "check ncx" (is_a ncx class_normalization_context))
      (assert_msg "check env" (is_a env class_environment))
      (let ( (mstep (translate_pattern curpat mdata curmcase varmap sloc)) 
	     (newenv (fresh_env env))
	     )
	(debug_msg mstep "translate_matchcase got mstep")
	(debug_msg curbody "translate_matchcase got curbody")
	(debug_msg varmap "translate_matchcase got varmap")
	(foreach_in_mapobject
	 (varmap)
	 (cursym curmdata)
	 (assert_msg "check cursym" (is_a cursym class_symbol))
	 (assert_msg "check curmdata" (is_a curmdata class_matched_data))
	 (let ( (matchbind (instance class_matched_binding
				     :binder cursym
				     :matchbind_data curmdata
				     :matchbind_nbocc (make_integerbox discr_integer 0)
				     ))
		)
	   (debug_msg matchbind "translate_matchcase matchbind")
	   (put_env newenv matchbind)
	   ))
	(debug_msg newenv "translate_matchcase updated newenv")
	(debug_msg curbody "translate_matchcase before normalizing curbody")
	(multicall
	 (nbody nbinds)
	 (normalize_tuple curbody newenv ncx sloc)
	 (debug_msg nbody "translate_matchcase nbody after body normalization")
	 (debug_msg nbinds "translate_matchcase nbinds after body normalization")
	 (let (
	       (listvarocc (make_list discr_list))
	       (newbindmap (get_field :env_bind newenv))
	       (stepsucc (instance class_match_step_success
				   :loca_location sloc
				   :mstep_data mdata
				   :mstep_then ()
				   :mstepsuccess_varocc ()
				   :mstepsuccess_binds nbinds
				   :mstepsuccess_body nbody
				   ))
	       )
	   (foreach_in_mapobject
	    (newbindmap)
	    (bsymb binding)
	    (if (and (is_a binding class_matched_binding)
		     (>i (get_int (unsafe_get_field :matchbind_nbocc binding)) 0))
		(let ( (syocc (mapobject_get sycmap bsymb))
		       )
		  (debug_msg syocc "translate_matchcase found syocc")
		  (assert_msg "check syocc" (is_a syocc class_nrep_locsymocc))
		  (assert_msg "check syocc binding" (== (get_field :nocc_bind syocc) binding))
		  (list_append listvarocc syocc)
		  )
	      ))
	   (debug_msg listvarocc "translate_matchcase listvarocc")
	   (debug_msg mstep "translate_matchcase have mstep")
	   (let ( (sortedvarocc
		   (multiple_sort 
		    (list_to_multiple listvarocc discr_multiple)
		    (lambda (o1 o2)
		      (compare_named_alpha (get_field :nocc_symb o1) (get_field :nocc_symb o2)))
		    discr_multiple))
		  )
	     (debug_msg sortedvarocc  "translate_matchcase sortedvarocc")
	     (put_fields 
	      stepsucc :mstepsuccess_varocc sortedvarocc))
	   (put_then_match mstep stepsucc)
	   (debug_msg mstep "translate_matchcase updated mstep")
	   (if prevstep (put_else_match prevstep mstep))
	   (debug_msg prevstep "translate_matchcase updated prevstep")
	   (debug_msg stepsucc "translate_matchcase stepsucc")
	   (return mstep)
	   ))))))



(defun normexp_altmatch (recv env ncx psloc)
  (assert_msg "check match recv" (is_a recv class_source_match))
  (assert_msg "check env" (is_a env class_environment))
  (assert_msg "check nctxt" (is_a ncx class_normalization_context))
  (debug_msg recv "normexp_match recv")
  (let ( (sloc (or (unsafe_get_field :loca_location recv) psloc))
	 (smatsx (unsafe_get_field :smat_matchedx recv))
	 (scases (unsafe_get_field :smat_cases recv))
	 (:long nbcases (multiple_length scases))
	 )
    (debug_msg smatsx "normexp_altmatch smatsx")
    (multicall
     (nmatx nbindmatx)
     (normal_exp smatsx env ncx sloc)
     (debug_msg nmatx "normexp_altmatch nmatx")
     (debug_msg nbindmatx "normexp_altmatch nbindmatx")
     (let ( (matctyp (get_ctype nmatx env))
	    (mcasetup (make_multiple discr_multiple nbcases))
	    (msteplist (make_list discr_list))
	    (msymb (or (get_field :nocc_symb nmatx) 
		       (clone_symbol (or (get_field :named_name nmatx)
					 '_matched_data))))
	    (mdata (instance class_matched_data
			     :mdata_symb msymb
			     :mdata_ctype matctyp
			     :mdata_orig nmatx
			     :mdata_steps msteplist
			     ))
	    (matctx (instance class_matching_context
			      :mxct_normctxt ncx
			      :mxct_source recv
			      :mxct_nmatched nmatx
			      :mxct_cases mcasetup
			      :mxct_env env
			      :mxct_mdata mdata
			      :mxct_varhandlers (make_list discr_list)
			      ))
	    )
       (debug_msg matctyp "normexp_altmatch matctyp")
       (debug_msg matctx "normexp_altmatch matctx")
       ;; build each match case
       (foreach_in_multiple
	(scases)
	(curscas :long curix)
	(debug_msg curscas "normexp_altmatch curscas")
	(assert_msg "check  curscas" (is_a curscas class_source_match_case))
	(let ( (curmcase (instance class_match_case
				   :mcase_mctxt matctx
				   :mcase_source curscas
				   :mcase_index 
				   (make_integerbox discr_integer curix)
				   )
			 )
	       )
	  (fill_matchcase curmcase sloc)
	  (multiple_put_nth mcasetup curix curmcase)
	  ))
       (debug_msg mcasetup "normexp_altmatch mcasetup")
       ;; translate each match case
       (let ( (prevstep ()) 
	      )
       (foreach_in_multiple
	(mcasetup)
	(curmcase :long mix)
	(debug_msg curmcase "normexp_altmatch before translate_matchcase curmcase")
	(debug_msg prevstep "normexp_altmatch before translate_matchcase prevstep")
	(let ( (curstep (translate_matchcase curmcase sloc prevstep))
	       )
	  (debug_msg curstep "normexp_altmatch after translate_matchcase curstep")
	  (if curstep (setq prevstep curstep))
	)))
       ;;
       (debug_msg mdata "normexp_altmatch updated mdata")
       (if (need_dbg 1)
	   (let ( (dotprefix (get_field :container_value match_graphic_dot_prefix)) )
	     (debug_msg match_graphic_dot_prefix "normexp_atmatch match_graphic_dot_prefix")
	     (debug_msg dotprefix "normexp_match dotprefix")
	     (if (is_string dotprefix) 
		 (mg_altdraw_graphviz mdata dotprefix))))
       (error_plain sloc "@@unimplemented normexp_altmatch")
       (compile_warning "@@unimplemented normexp_altmatch")
       (return)
       ))))

(defun alternate_match_optset (optsymb :cstring opts)
  (debug_msg optsymb "alternate_match_optset optsymb")
  (informsg_plain "enabling alternate matching implementation")
  (install_method class_source_match normal_exp normexp_altmatch)
)
(register_option
 'alternate_match
 '"Enable alternate pattern-matching implementation"
 alternate_match_optset)





;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun mg_altdraw_graphviz (mdata dotprefix)
  (let ( (mapdata (make_mapobject discr_map_objects 43))
	 (mapstep (make_mapobject discr_map_objects 43))
	 (nodebuf (make_strbuf discr_strbuf))
	 (edgebuf (make_strbuf discr_strbuf))
	 (:long cnt 0) 
	 (:long mdatahash (obj_hash mdata))
	 (pathsbuf (make_strbuf discr_strbuf)) 
	 (dotfilename
	  (progn
	    (code_chunk 
	     uniqcnt 
	     #{  /* mg_draw_match_graphviz_file $UNIQCNT */
	     static long uniqcounter	;
	     uniqcounter ++		;
	     $CNT = uniqcounter		; 
	     }#)
	    (assert_msg "check pathsbuf" (is_strbuf pathsbuf))
	    (add2sbuf_string pathsbuf dotprefix)
	    (add2sbuf_strconst pathsbuf "+")
	    (add2sbuf_longdec pathsbuf cnt)
	    (add2sbuf_strconst pathsbuf ".dot")
	    (debug_msg pathsbuf "mg_draw_match_graphviz_file pathsbuf")
	    (strbuf2string discr_string pathsbuf)))
	 (mg (instance class_match_graphic
		       :mchgx_filename dotfilename
		       :mchgx_nodout nodebuf
		       :mchgx_edgout edgebuf
		       :mchgx_datanamemap mapdata
		       :mchgx_stepnamemap mapstep
		       ))
	 )
					;;; recursive scan of data & steps to fill the mapdata associating
					;;; each data with its printable name and mapstep associating each
					;;; step with its printable name
    (letrec 
     ( (scandata 
	(lambda (data)
	  (debug_msg data "mg_altdraw_graphviz/scandata data")
	  (assert_msg "mg_altdraw_graphviz.scandata check data" (is_a data class_matched_data))
	  (let ( (oldname ( (mapobject_get mapdata data) ))
		 )
	    (if oldname
		(progn 
		  (debug_msg oldname "mg_altdraw_graphviz/scandata found oldname")
		  (return oldname))))
	  (let ( (nambuf (make_strbuf discr_strbuf))
		 (msymb (unsafe_get_field :mdata_symb data))
		 (:long mapcnt (mapobject_count mapdata))
		 (msteps (unsafe_get_field :mdata_steps data))
		 )
	    (add2sbuf_strconst nambuf "mdata_")
	    (add2sbuf_longdec nambuf (+i mapcnt 1))
	    (add2sbuf_strconst nambuf "_")
	    (add2sbuf_cident nambuf (get_field :named_name msymb))
	    (if (is_a msymb class_cloned_symbol)
		(progn
		  (add2sbuf_strconst nambuf "__")
		  (add2sbuf_longdec nambuf (get_int (unsafe_get_field :csym_urank msymb)))))
	    (mapobject_put mapdata data (strbuf2string discr_string nambuf))
	    (foreach_in_list
	     (msteps)
	     (curpair curstep)
	     (scanstep curstep))
	    )
	  ))
       (scanstep 
	(lambda (step)
	  (debug_msg step "mg_altdraw_graphviz/scanstep step")
	  (assert_msg "mg_altdraw_graphviz.scanstep check step" (is_a step class_match_step))
	  (let ( (oldname (mapobject_get mapstep step)) 
		 )
	    (if oldname
		(progn
		  (debug_msg oldname "mg_altdraw_graphviz.scanstep found oldname")
		  (return oldname))))
	  (let ( (nambuf (make_strbuf discr_strbuf))
		 (:long mapcnt (mapobject_count mapstep))
		 (disnam (get_field :named_name (discrim step)))
		 (sdata (unsafe_get_field :mstep_data step))
		 )
	    (code_chunk chunkdisnam
			#{ meltgc_add_strbuf ((melt_ptr_t)$nambuf,
					      melt_string_str((melt_ptr_t)$disnam)+strlen("CLASS_")) }#)
	    (add2sbuf_strconst nambuf "__")
	    (add2sbuf_longdec nambuf (+i mapcnt 1))
	    (mapobject_put mapstep step (strbuf2string discr_string nambuf))
	    (if sdata (scandata sdata))
	    (scan_step_data step scandata ())
	    (let (
					;; these are checked get fields!!
		  (sthen (get_field :mstep_then step))
		  (selse (get_field :mstep_else step))
		  )
	      (if sthen (scanstep sthen))
	      (if selse (scanstep selse))
	      ))))
       )
     (debug_msg mdata "mg_altdraw_graphviz before scandata mdata")
     (debug_msg scandata "mg_altdraw_graphviz scandata")
     (scandata mdata)
     (debug_msg mdata "mg_altdraw_graphviz after scandata mdata")
     (debug_msg mapdata "mg_altdraw_graphviz after scandata mapdata")
     (debug_msg mapstep "mg_altdraw_graphviz after scandata mapstep")
     )
					;;
    (let (
	  (:long datacount 0)
	  (:long stepcount 0)
	  (tupdata (make_multiple discr_multiple (mapobject_count mapdata)))
	  (tupstep (make_multiple discr_multiple (mapobject_count mapstep)))
	  )
      (foreach_in_mapobject
       (mapdata)
       (curdata dataname)
       (multiple_put_nth tupdata datacount curdata)
       (setq datacount (+i 1 datacount))
       )
      (foreach_in_mapobject
       (mapstep)
       (curstep stepname)
       (multiple_put_nth tupstep stepcount curstep)
       (setq stepcount (+i 1 stepcount))
       )
      (let (
	    (sortupdata 
	     (multiple_sort
	      tupdata
	      (lambda (d1 d2)
		(let ( 
		      (sn1 (mapobject_get mapdata d1))
		      (sn2 (mapobject_get mapdata d2))
		      )
		  (cond 
		   ( (string< sn1 sn2) 
		     '-1)
		   ( (string> sn1 sn2)
		     '1)
		   (:else
		    '0
		    )))
		)
	      discr_multiple
	      ))
	    (sortupstep 
	     (multiple_sort
	      tupstep
	      (lambda (s1 s2)
		(let ( 
		      (sn1 (mapobject_get mapstep s1))
		      (sn2 (mapobject_get mapstep s2))
		      )
		  (cond 
		   ( (string< sn1 sn2) 
		     '-1)
		   ( (string> sn1 sn2)
		     '1)
		   (:else
		    '0
		    )))
		)
	      discr_multiple
	      ))
	    )
					;; draw the data nodes
	(debug_msg sortupdata "mg_altdraw_graphviz sortupdata")
	(foreach_in_multiple
	 (sortupdata)
	 (curdata :long dix)
	 (debug_msg curdata "mg_altdraw_graphviz curdata")
	 (assert_msg "mg_altdraw_graphviz check curdata" (is_a curdata class_matched_data))
	 (let ( 
	       (curdataname (mapobject_get mapdata curdata))
	       (datactype (unsafe_get_field :mdata_ctype curdata))
	       (datasymb (unsafe_get_field :mdata_symb curdata))
	       (datasteps (unsafe_get_field :mdata_steps curdata))
	       )
	   (add2out_indentnl nodebuf 0)
	   (add2out_string nodebuf curdataname)
	   (add2out_strconst nodebuf " [ margin=0, ")
	   (if (== curdata mdata)
	       (add2out_strconst nodebuf " style=\"bold,dashed,filled,rounded\", fillcolor=\"lightyellow\", ")
	     (add2out_strconst nodebuf " style=\"dashed,rounded\", "))
	   (add2out_strconst nodebuf "label=<<table border=\"0\" cellborder=\"0\"")
	   (add2out_strconst nodebuf " cellspacing=\"1\" cellpadding=\"1\">")
	   (add2out_indentnl nodebuf 0)
	   (add2out_strconst nodebuf "<tr><td><font color=\"green\" face=\"Times-Roman Bold\" point-size=\"7\">")
	   (add2out_string nodebuf curdataname)
	   (add2out_strconst nodebuf "</font></td><td><font face=\"Courier\" point-size=\"6.5\">#")
	   (add2out_longhex nodebuf (obj_hash curdata))
	   (add2out_strconst nodebuf "</font></td></tr>")
	   (add2out_indentnl nodebuf 0)
	   (add2out_strconst nodebuf "<tr><td><font color=\"darkgreen\" face=\"Times-Roman Italic\" point-size=\"7\">")
	   (add2out_string nodebuf (get_field :named_name datasymb))
	   (if (is_a datasymb class_cloned_symbol)
	       (let ( (:long clonum (get_int (unsafe_get_field :csym_urank datasymb)))
		      )
		 (add2out_strconst nodebuf "<font point-size=\"6\">$")
		 (add2out_longdec nodebuf clonum)
		 (add2out_strconst nodebuf "</font>")
		 ))
	   (add2out_strconst nodebuf "</font></td><td><font color=\"brown\" face=\"Helvetica Oblique\" point-size=\"6\">")
	   (add2out_string nodebuf (get_field :named_name (get_field :ctype_keyword datactype)))
	   
	   (add2out_strconst nodebuf "</font></td></tr>")
	   (add2out_strconst nodebuf "</table>> ];")
	   (add2out_indentnl nodebuf 0)
					;;; output edges to the steps
	   (foreach_in_list
	    (datasteps)
	    (pairstep curstep)
	    (add2out_indentnl edgebuf 0)
	    (add2out_string edgebuf curdataname)
	    (add2out_strconst edgebuf " /*data*/ -> /*step*/ ")
	    (add2out_string edgebuf (mapobject_get mapstep curstep))
	    (add2out_strconst edgebuf " [ arrowhead=open, color=blueviolet, style=dotted ];")
	    )
	   )
	 )
					;; draw the step nodes
	(debug_msg sortupstep "mg_altdraw_graphviz sortupstep")
	(foreach_in_multiple
	 (sortupstep)
	 (curstep :long dix)
	 (debug_msg curstep "mg_altdraw_graphviz curstep")
	 (assert_msg "mg_altdraw_graphviz check curstep" (is_a curstep class_match_step))
	 (let ( 
	       (curstepname (mapobject_get mapstep curstep))
	       )
	   (add2out_indentnl nodebuf 0)
	   (add2out_string nodebuf curstepname)
	   (add2out_strconst nodebuf " [ margin=0, ")
	   (if (is_a curstep class_match_step_success)
	       (add2out_strconst nodebuf " style=\"filled\", bgcolor=\"palegreen\", ")
	     )
	   (add2out_strconst nodebuf "label=<<table border=\"1\" cellborder=\"1\"")
	   (add2out_strconst nodebuf " cellspacing=\"1\" cellpadding=\"1\">")
	   (add2out_indentnl nodebuf 0)
	   (add2out_strconst nodebuf "<tr><td><font color=\"blue\" face=\"Times-Roman Bold\" point-size=\"7\">")
	   (add2out_string nodebuf curstepname)
	   (add2out_strconst nodebuf "</font></td><td><font face=\"Courier\" point-size=\"6\">#")
	   (add2out_longhex nodebuf (obj_hash curstep))
	   (add2out_strconst nodebuf "</font></td></tr>")
	   (add2out_indentnl nodebuf 0)
	   (matchgraphic_altstep curstep mg)
	   (add2out_strconst nodebuf "</table>> ];")
	   (add2out_indentnl nodebuf 0)
	   )
	 )
	;; output the file
	(let (
	      )
	  (code_chunk 
	   outputmgfile
	   #{ /* $outputmgfile start */
     time_t nowt = 0;
     char nowbuf[60];
     FILE* dotfil = 
     fopen (melt_string_str ((melt_ptr_t) $DOTFILENAME), "w");
     if (!dotfil) 
     fatal_error("failed to open matchdot file %s - %m", 
                 melt_string_str ((melt_ptr_t) $DOTFILENAME));
     fprintf (dotfil, "// melt matchdot file %s\n", 
                      melt_string_str ((melt_ptr_t) $DOTFILENAME));
     time (&nowt);
     memset (nowbuf, 0, sizeof(nowbuf));
     strftime (nowbuf, sizeof(nowbuf)-1,
                       "%Y %b %d %Hh%M",
                       localtime (&nowt));
     fprintf (dotfil, "// generated %s\n", nowbuf);
     fprintf (dotfil, "digraph meltaltmatch_%lx {", $MDATAHASH);
     fprintf (dotfil, " graph [ label=<<font color='firebrick' point-size='9' face='Helvetica Bold'>Melt Alt Match %s ** %s</font>>,",
		      lbasename (melt_string_str ((melt_ptr_t) $DOTFILENAME)),
		      nowbuf);
     fprintf (dotfil," pad=\"0.5\", margin=\"0.3\" ];\n");
     fprintf (dotfil, " node [ shape=\"box\", fontsize=\"9\" ];\n");
     melt_putstrbuf (dotfil, (melt_ptr_t) $NODEBUF);
     fprintf (dotfil, "\n /// edges\n");
     melt_putstrbuf (dotfil, (melt_ptr_t) $EDGEBUF);
     fprintf (dotfil, "\n} // eof %s\n", melt_string_str ((melt_ptr_t) $DOTFILENAME));
     fclose (dotfil);
	   /* $outputmgfile end */
	   }#)
	)))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; export our classes
(export_class
 class_matching_context
 class_pattern_context
 class_normtester_any
 class_normtester_anytester
 class_normtester_disjunction
 class_normtester_instance
 class_normtester_matcher
 class_normtester_or_clear
 class_normtester_or_initial_clear
 class_normtester_or_transmit
 class_normtester_same
 class_normtester_success
 class_nrep_match
 )

;;; export our values
(export_values
 scan_pattern
 normal_pattern
 )

;; eof warmelt-normatch.melt
