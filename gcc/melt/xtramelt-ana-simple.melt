;; -*- Lisp -*-
;; file xtramelt-ana-simple.melt
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(comment "***
    Copyright 2009, 2011, 2012 Free Software Foundation, Inc.
    Contributed by Basile Starynkevitch <basile@starynkevitch.net>

    This file is part of GCC.

    GCC is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.

    GCC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.
***")



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; small analysis

(defclass class_smallcfun
  :super class_named
  :fields (scfun_decl
	   scfun_entbb
	   ))

(defclass class_smallbb
  :super class_proped
  :fields (sbb_bbcont
	   ))

(defclass class_smallanalysis 
  :super class_analysis_state
  :fields (sman_cfuns			;list of class_smallcfun-s
	   sman_cfundict		;dict of class_smallcfun-s
	   sman_cfuntreemap		;treemap of class_smallcfun-s
	   sman_bbtable			;hashtable bb -> class_smallbb
	   ))

(defclass class_smallabstractenv
  :super class_proped
  :fields (abenv_maptree		;a maptree C ident -> abstract values
	   abenv_parenv			;the parent abstract env
	   abenv_pplpoly		;the PPL polyhedron
	   abenv_vectrees		;the vector naming PPL variables as trees
))

(defun put_abstrenv (abenv :tree tr :value val)
  (assert_msg "check abenv" (is_a abenv class_smallabstractenv))
  (assert_msg "check tr" tr)
  (maptree_put (get_field :abenv_maptree abenv) tr val)
)

(defun get_abstrenv (abenv :tree tr)
  (assert_msg "check abenv" (is_a abenv class_smallabstractenv))
  (maptree_get (get_field :abenv_maptree abenv) tr)
)

(defun fresh_abstrenv (abpar)
  (assert_msg "check abpar" (is_a abpar class_smallabstractenv))
  (let ( (newabenv (instance class_smallabstractenv
			     :abenv_maptree (make_maptree discr_map_trees 10)
			     :abenv_parenv abpar)) )
    (return newabenv)
))

;;; find a tree inside a small abstract env - return primarily the
;;; boxed tree and secondly its index
(defun find_tree_smallabstractenv (abenv :tree tr)
  (debug "find_tree_smallabstractenv abenv=" abenv " tr=" tr)
  (assert_msg "check abenv" (is_a abenv class_smallabstractenv))
  (let ( (:long ix -1)
	 (btree ()) 
	 (varvect (get_field :abenv_vectrees abenv))
	 (:long curix 0)
	 (:long vectlen (multiple_length varvect))
	 )
    (forever 
     loop
     (if (>=i curix vectlen) (exit loop))
     (let ( (curcomp (multiple_nth varvect curix)) )
       (if (==t (tree_content curcomp) tr)
	   (progn
	     (debug "find_tree_smallabstractenv return curcomp=" curcomp " curix=" curix)
	     (return curcomp curix))
	 )
       (setq curix (+i curix 1))
       )))
  (debug "find_tree_smallabstractenv return NIL")
  (return)
  )

(defun dbgout_smallabstractenv (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debug_information))
  (assert_msg "check self" (is_a self class_smallabstractenv))
  (let ( (dis (discrim self)) 
	 (out (unsafe_get_field :dbgi_out dbgi)) 
	 (:long onum (obj_num self)) 
	 ) 
    (add2sbuf_strconst out "|")
    (add2sbuf_string out (get_field :named_name dis))
    (add2sbuf_strconst out "/")
    (add2sbuf_longhex out (obj_hash self))
    (if onum
	(progn
	  (add2sbuf_strconst out "#")
	  (add2sbuf_longdec out onum)))
    (add2sbuf_strconst out "{")
    (let ( (:long offpar (get_int abenv_parenv)) 
	   (:long offvnam (get_int abenv_vectrees)) 
	   (:long oldmaxdepth (get_int (unsafe_get_field :dbgi_maxdepth dbgi)))
	   (:long newmaxdepth  (-i (/i oldmaxdepth 2) 1))
	   )
      (if (<i newmaxdepth 0) (setq newmaxdepth 0))
      (if (melt_need_dbglim depth oldmaxdepth)
	  (progn
	    (and (>i depth 0) (>i oldmaxdepth 3)
		 (put_int (unsafe_get_field :dbgi_maxdepth dbgi) newmaxdepth))
	    (dbgout_fields self dbgi (+i depth 1) 0 offpar)
					;(add2sbuf_indentnl out depth)
	    (let ( (polyv (get_field :abenv_pplpoly self)) )
	      (if polyv
		  (progn
		    (add2sbuf_strconst out "@ppl.poly@[")
		    (ppl_ppstrbuf out 
				  (get_field :abenv_pplpoly self)
				  depth 
				  (get_field :abenv_vectrees self))
		    (add2sbuf_strconst out "]@"))
		(add2sbuf_strconst out "@ppl.poly*nil*")))
	    (add2sbuf_indentnl out depth)
	    (if (melt_need_dbglim (+i depth 2) newmaxdepth)
		(dbgout_fields self dbgi (+i depth 2) offvnam -1)
	      (add2sbuf_strconst out ".._.."))
	    (put_int (unsafe_get_field :dbgi_maxdepth dbgi) oldmaxdepth)
	    )))
    (add2sbuf_strconst out "}")
    )
  )
(install_method class_smallabstractenv dbg_output dbgout_smallabstractenv)

(definstance initial_smallabstractenv class_smallabstractenv
  :abenv_maptree (make_maptree discr_map_trees 20))

(definstance smallana_cont class_reference)


(defun smallana_cfun_entbb (sman :tree decltree :basic_block bbent)
  (debug "smallana_cfun_entbb sman=" sman " decltree=" decltree " bbent=" bbent)
  (match 
   decltree
   ;; the joker below is acutally nil
   ( ?(tree_function_decl_named ?funam ?(tree_block ?treevars ?_))
      (debug "smallana_cfun_entbb treevars of function" treevars)
      (push_cfun_decl decltree)
      ;;;;;
      (each_param_in_fundecl
       (decltree)
       (:tree argdtree)
       (debug "smallana_cfun_entbb argdtree" argdtree)
       (match 
	argdtree
	( ?(tree_parm_decl
	    ?(and ?argdtype 
;		  ?(tree_integer_type ?typname ?bigmin ?bigmax ?isiz)) ?argdcl ?argname)
                  ?_) ?_ )
	   )
	( ?(tree_parm_decl_named ?argdtype  ?argname ?arguid)
	   (debug "smallana_cfun_entbb argdtype=" argdtype " argname=" argname " arguid=" arguid)
	   )
	( ?_ 
	  ;; (assert_msg "unexpected argdtree" ())	  
	  (shortbacktrace_dbg "unexpected tree in smallana_cfun_entbb" 12)
	  )
	)
       (debug "smallana_cfun_entbb argdecltree" argdtree)
       )
      ;;;;
      (let ( (fname (make_stringconst discr_string funam)) 
	    (scf (instance class_smallcfun
			    :named_name fname
			    :scfun_decl (make_tree discr_tree decltree)
			    :scfun_entbb (make_basicblock discr_basic_block bbent)))
	     )
	(debug "smallana_cfun_entbb fname=" fname)
	(list_append (get_field :sman_cfuns sman) scf)
	(mapstring_putstr (get_field :sman_cfundict sman) fname scf)
	(maptree_put (get_field :sman_cfuntreemap sman) decltree scf)
	)
      (pop_cfun)
      )
   ( ?(tree_var_decl ?_ ?_ ?_)
      (debug  "smallana_cfun_entbb decl of variable" decltree)
      (inform_at_tree decltree "smallana: global variable not analyzed")
      )
   ( ?_
     (debug "smallana_cfun_entbb other decl" decltree)
     (inform_at_tree decltree "smallana: other declaration not analyzed")
     ;; (assert_msg "smallana_cfun_entbb @$@UNIMPLEMENTED DECL" ())
     (shortbacktrace_dbg "smallana_cfun_entbb unexepcted declree" 14)
     () )
   )
  (debug "smallana_cfun_entbb sman=" sman)
  )


(defun smallana_gimple (sman :gimple g)
  (debug "smallana_gimple sman=" sman " g=" g)
  (match 
   g
   ( ?(gimple_assign_single ?lhs ?rhs)
      (debug "smallana_gimple gimple_assign_single lhs=" lhs " rhs=" rhs)
      )
   ( ?(gimple_assign_cast ?lhs ?rhs)
      (debug "smallana_gimple gimple_assign_cast lhs=" lhs " rhs=" rhs)
      )
   ( ?(gimple_assign_copy ?lhs ?rhs)
      (debug "smallana_gimple gimple_assign_copy lhs=" lhs " rhs=" rhs)
      )
   ( ?(gimple_assign_ssa_name_copy ?lhs ?rhs)
      (debug "smallana_gimple gimple_assign_ssa_name_copy lhs=" lhs " rhs=" rhs)
      )
   ( ?(gimple_assign_unary_nop ?lhs ?rhs)
      (debug "smallana_gimple gimple_assign_unary_nop lhs=" lhs " rhs=" rhs)
      )
   ( ?(gimple_assign_plus ?lhs ?rhs1 ?rhs2)
      (debug "smallana_gimple gimple_assign_plus lhs=" lhs 
	     " rhs1=" rhs1 " rhs2=" rhs2)
      )
   ( ?(gimple_assign_pointerplus ?lhs ?rhs1 ?rhs2)
      (debug "smallana_gimple gimple_assign_pointerplus lhs=" lhs 
	     " rhs1=" rhs1 " rhs2=" rhs2)
      )
   ( ?(gimple_assign_mult ?lhs ?rhs1 ?rhs2)
      (debug "smallana_gimple gimple_assign_mult lhs=" lhs
	     " rhs1=" rhs1 " rhs2=" rhs2)
      )
   ( ?(gimple_assign_binaryop ?lhs ?rhs1 ?rhs2 ?opcod)
      (debug "smallana_gimple gimple_assign_binaryop lhs=" lhs
	     " rhs1=" rhs1 " rhs2=" rhs2)
      ;;(shortbacktrace_dbg "smallana_gimple gimple_assign_binaryop unexpected" 15)
      (assert_msg "smallana_gimple gimple_assign_binaryop unhandled" ())
      )
   ( ?(gimple_cond_lessequal ?lhs ?rhs)
      (debug "smallana_gimple gimple_cond_lessequal lhs=" lhs " rhs=" rhs)
      (shortbacktrace_dbg "@$@unimplemented smallana_gimple gimple_cond_lessequal" 15)
      )
   ( ?(gimple_cond_notequal ?lhs ?rhs)
      (debug "smallana_gimple gimple_cond_notequal lhs=" lhs " rhs=" rhs)
      (shortbacktrace_dbg "@$@unimplemented smallana_gimple gimple_cond_notequal" 15)
      )
   ( ?(gimple_cond_greater ?lhs ?rhs)
      (debug "smallana_gimple gimple_cond_greater lhs=" lhs " rhs" rhs)
      (shortbacktrace_dbg "@$@unimplemented smallana_gimple gimple_cond_greater" 15)
      )
   ( ?(gimple_cond_true)
      (shortbacktrace_dbg "@$@unimplemented smallana_gimple gimple_cond_true" 15)
      )
   ( ?(gimple_call ?lhs ?fndecl ?_)
      (debug "smallana_gimple gimple_call lhs=" lhs " fndecl=" fndecl)
      (shortbacktrace_dbg "@$@unimplemented smallana_gimple gimple_call" 15)
      )
   ( ?(gimple_return ?retval)
      (debug "smallana_gimple gimple_return retval" retval)
      (shortbacktrace_dbg "@$@unimplemented smallana_gimple gimple_return" 15)
      )
   ( ?_
     (debug "smallana_gimple other!gimple" g)
     ;;(shortbacktrace_dbg "smallana_gimple unexpected gimple" 15)
     (assert_msg "smallana_gimple @$@ UNIMPLEMENTED GIMPLE" ())
     )
   )
  )

(defun smallana_bb (sman :basic_block bb)
  (debug "smallana_bb start sman=" sman "bb=" bb)
  (assert_msg "check sman" (is_a sman class_smallanalysis))
  (let ( (bbtab (get_field :sman_bbtable sman)) 
	 )
    (assert_msg "check bbtab" (is_mapbasicblock bbtab))
    (let ( (sbb (mapbasicblock_get bbtab bb)) )
      (if sbb (return))
      (setq sbb (instance class_smallbb
			  :sbb_bbcont (make_basicblock discr_basic_block bb)))
      (mapbasicblock_put bbtab bb sbb)
      (eachgimple_in_basicblock 
       (bb)
       (:gimple g)
       (smallana_gimple sman g)
       )
      (debug "smallana_bb end sman=" sman)
      )))


(defun smallana_cfun_bb (sman :tree cfdecl :basic_block fbb)
  (debug "smallana_bb_cfun start sman=" sman " cfdecl=" cfdecl " fbb=" fbb)
  (assert_msg "check sman" (is_a sman class_smallanalysis))
  (match cfdecl
	 ( ?(and ?decltree ?(tree_function_decl ?funam ?(tree_block ?treevars ?_)))
	    (debug "smallana_bb_cfun decltree=" decltree " treevars=" treevars
		   " funam=" funam)
	    )
	 ( ?_ 
	   (void)
	 )
	 )
  (smallana_bb sman fbb)
  (debug "smallana_bb_cfun end sman=" sman)
  )


(defun smaninterp_cfun (sman abenv cfun)
  (debug "smaninterp_fun sman=" sman " abenv=" abenv " cfun=" cfun)
  (assert_msg "check sman" (is_a sman class_smallanalysis))
  (assert_msg "check abenv" (is_a abenv class_smallabstractenv))
  (assert_msg "check cfun" (is_a cfun class_smallcfun))
  (let ( (:basic_block bbent 
		      (basicblock_content (get_field :scfun_entbb cfun)))
	 (:tree fundecl (tree_content (get_field :scfun_decl cfun)))
	 )
    (push_cfun_decl fundecl)
    (smaninterp_basicblock sman abenv bbent)
    ;(assert_msg "@$@unimplemented smaninterp_fun" ())
    (shortbacktrace_dbg "@$@unimplemented smaninterp_fun" 15)
    (pop_cfun)
    ))


(defun smaninterp_basicblock (sman abenv :basic_block bb)
  (debug "smaninterp_basicblock sman=" sman " abenv=" abenv " bb=" bb)
  (assert_msg "check sman" (is_a sman class_smallanalysis))
  (assert_msg "check abenv" (is_a abenv class_smallabstractenv))
  (forever 
   bbloop
   (debug "smaninterp_basicblock bb" bb)
   (if (isnull_basicblock bb)
       (exit bbloop))
   (eachgimple_in_basicblock 
    (bb)
    (:gimple g)
    (debug "smaninterp_basicblock g" g)
    (smaninterp_gimple sman abenv g bb)
    )
   (setq bb (basicblock_single_succ bb))
   (debug "smaninterp_basicblock succ bb" bb)
   )
  (debug  "smaninterp_basicblock done")
  ;(assert_msg "@$@unimplemented smaninterp_basicblock" ())
  (shortbacktrace_dbg "@$@unimplemented smaninterp_basicblock" 15)
  )


;;;;;;;;;;;;;;;;
(defun sman_propagate_constraints_call (abenv newabenv tupvarbind)
  (debug "sman_propagate_constraints_call abenv=" abenv " newabenv=" newabenv 
	 " tupvarbind=" tupvarbind)
  (assert_msg "check newabenv" (is_a newabenv class_smallabstractenv))
  (let ( (pplvarslist (make_list discr_list)) 
	 (:ppl_constraint_system consys (raw_new_ppl_empty_constraint_system))
	 (:long nbpplvars 0)
	 )
    (foreach_in_multiple
     (tupvarbind)
     (curvarbind :long bindix)
     (debug "sman_propagate_constraints_call curvarbind=" curvarbind
	    " bindix=" bindix)
     (let ( (:tree parmtype (tree_content (multiple_nth curvarbind 0)))
	    (parmdeclval (multiple_nth curvarbind 1))
	    (:tree parmdecl (tree_content parmdeclval))
	    (:tree curarg (tree_content (multiple_nth curvarbind 2)))
	    )
       (debug "sman_propagate_constraints_call parmtype=" parmtype 
	      " parmdecl=" parmdecl " curarg=" curarg)
       (messagenum_dbg  "sman_propagate_constraints_call nbpplvars" nbpplvars)
       (match 
	curarg
	( ?(tree_integer_cst ?k)
	   (messagenum_dbg  "sman_propagate_constraints_call curarg const.int. k" k)
	   ;; add the constraint {parmdecl == k}
	   (let (
		 (:ppl_coefficient coefarg (ppl_coefficient_from_tree curarg)) 
		 (:ppl_coefficient coefm1 (ppl_coefficient_from_long -1)) 
		 (:ppl_linear_expression liex (make_ppl_linear_expression))
		 )
	     (debug_ppl_coefficient "sman_propagate_constraints_call coefarg" coefarg)
	     (messagenum_dbg  "sman_propagate_constraints_call nbpplvars" nbpplvars)
	     (ppl_Linear_Expression_add_to_coefficient liex nbpplvars coefm1)
	     (ppl_Linear_Expression_add_to_inhomogeneous liex coefarg)
	     (debug_ppl_linear_expression "sman_propagate_constraints_call liex" liex)
	     (let ( (:ppl_constraint cons (make_ppl_constraint liex "==")) )
	       (debug_ppl_constraint "sman_propagate_constraints_call cons" cons)
	       (ppl_Constraint_System_insert_Constraint consys cons)
	       (ppl_delete_Constraint cons)
	       )
	     (ppl_delete_Coefficient coefm1)
	     (ppl_delete_Coefficient coefarg)
	     (ppl_delete_Linear_Expression liex)
	     )
	   (setq  nbpplvars (+i nbpplvars 1)) 
	   (list_append pplvarslist parmdeclval)
	   )
	( ?_
	  (assert_msg "sman_propagate_constraints_call @$@unimplemented curarg tree" ())))
       ))
    (let ( (:ppl_polyhedron poly (ppl_NNC_Polyhedron_from_Constraint_System consys)) 
	   (polyv (make_ppl_polyhedron_same discr_ppl_polyhedron poly))
	   )
      (debug "sman_propagate_constraints_call polyv=" polyv)
      (assert_msg "check polyv" polyv)
      (put_fields newabenv 
		  :abenv_pplpoly polyv
		  :abenv_vectrees (list_to_multiple pplvarslist))
      ))
  (debug "sman_propagate_constraints_call final newabenv=" newabenv)
  )

;;;;;;;;;;;;;;;;
;; pass both the relation and the opposite relation when changing signs
(defun sman_add_cmp_constraint (sman abenv polyv :tree lhs rhs :cstring rel opprel)
  (debug "sman_add_cmp_constraint abenv=" abenv "polyv=" polyv 
	 "lhs=" lhs "rhs=" rhs)
  (assert_msg "check sman" (is_a sman class_smallanalysis))
  (assert_msg "check abenv" (is_a abenv class_smallabstractenv))
  (assert_msg "check polyv" (== (discrim polyv) discr_ppl_polyhedron))
  (let ( (:long lvix -1) 		;left var index
	 (:long rvix -1)		;right var index
	 )
;;; handle the left hand side lhs
    (match 
     lhs
     (?(tree_ssa_name 
	?(and ?ldeclvar ?(tree_decl ?lvar ?lname ?luid)) 
	?lvalu ?lversion ?ldefg)
       (debug "sman_add_cmp_constraint ssa_name ldeclvar=" ldeclvar
        " lvar=" lvar " lvalu=" lvalu)
       (messagenum_dbg "sman_add_cmp_constraint lversion" lversion)
       (debug "sman_add_cmp_constraint ssa_name ldefg=" ldefg)
       (multicall
	(boxtr :long trix)
	(find_tree_smallabstractenv abenv lvar)
	(debug "sman_add_cmp_constraint ssa_name boxtr=" boxtr "trix=" trix)
	(if boxtr 
	    (progn (setq lvix trix) ())
	  (progn 
	    (assert_msg "sman_add_cmp_constraint dont know what to do lvar" ())
	    ()
	    ))
	)
       ()
       )
     (?(tree_integer_cst ?lk)
       ()				;this is ok
       )
     (?_
      (assert_msg "unexpected lhs in sman_add_cmp_constraint" ()))
     )				    ;end match lhs
;;; handle the right hand side rhs
    (match 
     rhs
     (?(tree_ssa_name ?rvar ?rvalu ?rversion ?rdefg)
       (debug "sman_add_cmp_constraint ssa_name rvar=" rvar
	      " rvalu=" rvalu " rversion=" rversion " rdefg=" rdefg)
       (multicall
	(boxtr :long trix)
	(find_tree_smallabstractenv abenv rvar)
	(debug "sman_add_cmp_constraint ssa_name boxtr=" boxtr)
	(if 
	    boxtr 
	    (progn (setq rvix trix) ())
	  (assert_msg "sman_add_cmp_constraint dont know what to do rvar" ()))
	)
       ()
       )
     (?(tree_integer_cst ?rk)
       ()				;this is ok
       )
     (?_
      (assert_msg "unexpected rhs in sman_add_cmp_constraint" ()))
     )					;end match rhs
    (cond
     ( (and (>=i lvix 0) (<i rvix 0)) ;left is variable, right is constant
       (let (
	     (:ppl_polyhedron poly (ppl_polyhedron_content polyv))
	     (:ppl_linear_expression liex (make_ppl_linear_expression))
	     (:ppl_coefficient coefright (ppl_coefficient_from_tree rhs))
	     (:ppl_coefficient coefm1 (ppl_coefficient_from_long -1)) 
	     )
	 (assert_msg "check poly" poly)
	 (ppl_Linear_Expression_add_to_coefficient liex lvix coefm1)
	 (ppl_Linear_Expression_add_to_inhomogeneous liex coefright)
	 (let ( (:ppl_constraint newcons (make_ppl_constraint liex opprel)) )
	   (debug_ppl_constraint "sman_add_cmp_constraint leftvar constraint" newcons)
	   (ppl_Polyhedron_add_constraint poly newcons)
	   (debug_ppl_polyhedron "sman_add_cmp_constraint updated poly" poly)
	   (ppl_delete_Coefficient coefm1)
	   (ppl_delete_Coefficient coefright)
	   (ppl_delete_Linear_Expression liex)
	   (ppl_delete_Constraint newcons)
	   )
	 )
       )
     ( (and (<i lvix 0) (>=i rvix 0)) ;left is constant, right is variable
       (let ( (:ppl_coefficient coefleft (ppl_coefficient_from_tree lhs))
	      (:ppl_coefficient coefm1 (ppl_coefficient_from_long -1)) 
	      (:ppl_linear_expression liex (make_ppl_linear_expression))
	      (:ppl_polyhedron poly (ppl_polyhedron_content polyv))
	      )
	 (ppl_Linear_Expression_add_to_coefficient liex rvix coefm1)
	 (ppl_Linear_Expression_add_to_inhomogeneous liex coefleft)
	 (let ( (:ppl_constraint newcons (make_ppl_constraint liex opprel)) )
	   (debug_ppl_constraint "sman_add_cmp_constraint rightvar constraint" newcons)
	   (ppl_Polyhedron_add_constraint poly newcons)
	   (ppl_delete_Coefficient coefm1)
	   (ppl_delete_Coefficient coefleft)
	   (ppl_delete_Linear_Expression liex)
	   (ppl_delete_Constraint newcons)
	   )
	 )
       ()
       )
     ( (and (>=i lvix 0) (>=i rvix 0)) ;both left & right are variable
       (let ( (:ppl_coefficient coef1 (ppl_coefficient_from_long 1))
	      (:ppl_coefficient coefm1 (ppl_coefficient_from_long -1)) 
	      (:ppl_linear_expression liex (make_ppl_linear_expression))
	      (:ppl_polyhedron poly (ppl_polyhedron_content polyv))
	      )
	 (ppl_Linear_Expression_add_to_coefficient liex lvix coef1)
	 (ppl_Linear_Expression_add_to_coefficient liex rvix coefm1)
	 (let ( (:ppl_constraint newcons (make_ppl_constraint liex rel)) )
	   (debug_ppl_constraint "sman_add_cmp_constraint bothvar constraint" newcons)
	   (ppl_Polyhedron_add_constraint poly newcons)
	   (ppl_delete_Coefficient coefm1)
	   (ppl_delete_Coefficient coef1)
	   (ppl_delete_Linear_Expression liex)
	   (ppl_delete_Constraint newcons)
	   )
	 )
       ()
       )
     (:else
      (assert_msg "unexpected left & right in sman_add_cmp_constraint" ())
      ))
    )
  (debug "sman_add_cmp_constraint final polyv=" polyv)
  )

;;;;;;;;;;;;;;;;
;;;; utility to interpret an arithmetic compare test
(defun sman_arithm_compare
  (sman abenv
;;; the entire gimple and its containing basicblock
	:gimple g :basic_block bb 
;;; the extracted lefthandside righthandside 
	:tree lhs rhs 
;;; the relation string [eg "<="] its opposite for negative numbers [eg ">="] and
;;; its negation [eg ">"] and the opposite of the negation [eg "<"]
	:cstring rel opprel notrel notopprel)
  ;; check arguments
  (assert_msg "check sman" (is_a sman class_smallanalysis))
  (assert_msg "check abenv" (is_a abenv class_smallabstractenv))
  (debug "sman_arithm_compare gimple g=" g " bb=" bb " abenv=" abenv)
  ;; extract the polyhedron value and clone it for the other branch
  (let ( (polyv (get_field :abenv_pplpoly abenv)) 
	 (:ppl_polyhedron poly (ppl_polyhedron_content polyv))
	 (clonpolyv (make_ppl_polyhedron_cloned discr_ppl_polyhedron poly))
	 (:ppl_polyhedron clonpoly (ppl_polyhedron_content clonpolyv))
	 )
    (debug "sman_arithm_compare before sman_add_cmp_constraint polyv=" polyv)
    ;; handle the true branch by adding the constraint from the test
    (sman_add_cmp_constraint sman abenv polyv lhs rhs rel opprel)
    (debug "sman_arithm_compare after sman_add_cmp_constraint polyv=" polyv)
    (if (ppl_Polyhedron_is_empty poly)
	(progn
	  (debug "sman_arithm_compare true branch impossible" g)
	  )
      (progn
	(debug "sman_arithm_compare true branch possible g=" g " bb=" bb)
	(foreach_basicblock_succ_edge 
	 (bb)
	 (:edge eg :long eix)
	 (debug "sman_arithm_compare true succedge eg=" eg " eix=" eix)
	 (if (edge_for_true_value eg)
	     (let ( (:basic_block tbb (edge_dest_bb eg)) 
		    (oldpolyv (get_field :abenv_pplpoly abenv))
		    )
	       ;; in the true case, the oldpolyv should be polyv
	       (assert_msg "check polyv==oldpolyv" (== oldpolyv polyv))
	       (debug "sman_arithm_compare truesucc tbb=" tbb " abenv=" abenv)
	       (smaninterp_basicblock sman abenv tbb)
	       (debug "sman_arithm_compare true after tbb abenv=" abenv)
	       ))
	 )
	))
    ;; handle the false branch by adding the constraint incompatible with the test
    (debug "sman_arithm_compare before sman_add_cmp_constraintclonpolyv=" clonpolyv)
    (sman_add_cmp_constraint sman abenv clonpolyv lhs rhs notrel notopprel)
    (debug "sman_arithm_compare after sman_add_cmp_constraint clonpolyv=" clonpolyv)
    (if (ppl_Polyhedron_is_empty clonpoly)
	(progn
	  (debug "sman_arithm_compare false branch impossible" g)
	  )
      (progn
	(debug "sman_arithm_compare false branch possible g=" g " bb=" bb)
	(foreach_basicblock_succ_edge 
	 (bb)
	 (:edge eg :long eix)
	 (debug "sman_arithm_compare false succedge eg=" eg " eix=" eix)
	 (if (edge_for_false_value eg)
	     (let ( (:basic_block fbb (edge_dest_bb eg)) 
		    (oldpolyv (get_field :abenv_pplpoly abenv))
		    )
	       (debug "sman_arithm_compare falsesucc fbb=" fbb)
	       (put_fields abenv :abenv_pplpoly clonpolyv)
	       (debug "sman_arithm_compare false updated abenv=" abenv)
	       (smaninterp_basicblock sman abenv fbb)
	       (put_fields abenv :abenv_pplpoly oldpolyv)
	       (debug "sman_arithm_compare false restored abenv=" abenv)
	       ))
	 )
	))
    )
  (debug "sman_arithm_compare ended sman=" sman)
)

;;;;;;;;;;;;;;;;
(defun smaninterp_gimple (sman abenv :gimple g :basic_block bb)
  (assert_msg "check sman" (is_a sman class_smallanalysis))
  (assert_msg "check abenv" (is_a abenv class_smallabstractenv))
  (debug "smaninterp_gimple abenv=" abenv " g=" g " bb=" bb)
  ;; we really should count the number of times we are calling
  ;; smaninterp_gimple and returns immediately with a warning if calling
  ;; too often/too deeply. The point is that an small analysis of a
  ;; buggy program could make the compiler loop.
  (compile_warning "we should check that we don't call too often or too deeply in smaninterp_gimple" ())
  (match 
   g
   ;; handle calls
   (?(gimple_call ?lhs ?fndecl ?nargs)
     (debug "smaninterp_gimple call lhs=" lhs " fndecl=" fndecl)
     (let ( (:long argix 0) 
	    (newabenv (fresh_abstrenv abenv))
	    (tupvarbind (make_multiple discr_multiple nargs))
	    )
       (each_param_in_fundecl 
	(fndecl)
	(:tree curparamdcl)
	(messagenum_dbg  "smaninterp_gimple curparamdecl argix" argix)
	(debug "smaninterp_gimple curparamdecl" curparamdcl)
	(let ( (:tree curarg (gimple_call_nth_arg g argix)) )
	  (debug "smaninterp_gimple curarg" curarg)
	  (match 
	   curparamdcl
	   (?(tree_parm_decl ?parmtype ?parmdecl)
	     (debug "smaninterp_gimple parmtype=" parmtype
		    " parmdecl=" parmdecl)
	     (multiple_put_nth tupvarbind argix
			       (tuple 
				(make_tree discr_tree parmtype)
				(make_tree discr_tree parmdecl)
				(make_tree discr_tree curarg)))
	     )
	   (?_ 
	    (assert_msg "inexpected curparamdcl" ())
	    )
	   )
	  (setq argix (+i argix 1))
	  ))
       (debug "smaninterp_gimple tupvarbind=" tupvarbind)
       (sman_propagate_constraints_call abenv newabenv tupvarbind)
       (debug "smaninterp_gimple propagated newabenv="  newabenv 
	      " fndecl=" fndecl " sman=" sman)
       (let (
	     (calledcfun (maptree_get (get_field :sman_cfuntreemap sman) fndecl)) )
	 (debug "smaninterp_gimple calledcfun=" calledcfun)
	 (if calledcfun
	     (smaninterp_cfun sman newabenv calledcfun)
	   )
	 )
       (shortbacktrace_dbg "@$@unimplemented smaninterp_gimple call" 15)
					;(assert_msg "@$@unimplemented smaninterp_gimple call" ())
       )
     )
   ;; handle conditional <=
   ( ?(gimple_cond_lessequal ?lhs ?rhs)
      (debug "smaninterp_gimple cond<= lhs=" lhs " rhs=" rhs 
	     " before sman_arithm_compare abenv=" abenv)
      (sman_arithm_compare sman abenv
			   g bb
			   lhs rhs
			   "<=" ">=" ">" "<")
      (debug "smaninterp_gimple cond<= after sman_arithm_compare abenv=" abenv)
      (assert_msg "@$@unimplemented smaninterp_gimple cond<=" ())
      )
   ;; handle conditional <
   ( ?(gimple_cond_less ?lhs ?rhs)
      (debug "smaninterp_gimple cond< lhs=" lhs " rhs=" rhs)
      (shortbacktrace_dbg "@$@unimplemented smaninterp_gimple cond<" 15)
      (assert_msg "@$@unimplemented smaninterp_gimple cond<" ())
      )
   ;; handle conditional >
   ( ?(gimple_cond_greater ?lhs ?rhs)
      (debug "smaninterp_gimple cond> lhs=" lhs " rhs=" rhs)
      (shortbacktrace_dbg "@$@unimplemented smaninterp_gimple cond>" 15)
      (assert_msg "@$@unimplemented smaninterp_gimple cond>" ())
      )
   ;; handle conditional true
   ( ?(gimple_cond_true)
      ;;(shortbacktrace_dbg "@$@unimplemented smaninterp_gimple condtrue" 15)
      (assert_msg "@$@unimplemented smaninterp_gimple condtrue" ())
      )
   ;; handle conditional false
   ( ?(gimple_cond_false)
      ;;(shortbacktrace_dbg "@$@unimplemented smaninterp_gimple condfalse" 15)
      (assert_msg "@$@unimplemented smaninterp_gimple condfalse" ())
      )
   ;; handle single assign
   ( ?(gimple_assign_single ?lhs ?rhs)
      (debug "smallana_gimple gimple_assign_single lhs=" lhs " rhs=" rhs " g=" g)
      (assert_msg "@$@unimplemented smaninterp_gimple singleassign" ())
      )
   ;; handle cast assign
   ( ?(gimple_assign_cast ?lhs ?rhs)
      (debug "smallana_gimple gimple_assign_cast lhs=" lhs " rhs=" rhs)
      (let ( (:tree lhstype (tree_type lhs))
	     (:tree rhstype (tree_type rhs))
	     (:long widenningcast 0)
	     )
	(debug "smallana_gimple gimple_assign_cast lhstype=" lhstype
	       " rhstype=" rhstype)
	(match 
	 rhstype
	 ( ?(tree_integer_type ?rname ?rbigmin ?rbigmax ?rsize)
	    (match 
	     lhstype
	     ( ?(tree_integer_type ?lname ?lbigmin ?lbigmax ?lsize)
		(code_chunk 
		 testinsidsmangim
		 #{ /* smallana_gimple $TESTINSIDSMANGIM */
		   mpz_t $TESTINSIDSMANGIM#_lminz;
		   mpz_t $TESTINSIDSMANGIM#_lmaxz;
		   mpz_t $TESTINSIDSMANGIM#_rminz;
		   mpz_t $TESTINSIDSMANGIM#_rmaxz;
		   mpz_init_set_ui($TESTINSIDSMANGIM#_lminz, 0UL);
		   mpz_init_set_ui($TESTINSIDSMANGIM#_lmaxz, 0UL);
		   mpz_init_set_ui($TESTINSIDSMANGIM#_rminz, 0UL);
		   mpz_init_set_ui($TESTINSIDSMANGIM#_rmaxz, 0UL);
		   if ($LSIZE >= $RSIZE 
		      && melt_fill_mpz_from_mixbigint((melt_ptr_t) $LBIGMIN, $TESTINSIDSMANGIM#_lminz)
	              && melt_fill_mpz_from_mixbigint((melt_ptr_t) $LBIGMAX, $TESTINSIDSMANGIM#_lmaxz)
		      && melt_fill_mpz_from_mixbigint((melt_ptr_t) $RBIGMIN, $TESTINSIDSMANGIM#_rminz)
	              && melt_fill_mpz_from_mixbigint((melt_ptr_t) $RBIGMAX, $TESTINSIDSMANGIM#_rmaxz)
		      && mpz_cmp($TESTINSIDSMANGIM#_lminz, $TESTINSIDSMANGIM#_rminz) <= 0
		      && mpz_cmp($TESTINSIDSMANGIM#_lmaxz, $TESTINSIDSMANGIM#_rmaxz) >= 0)
		         $WIDENNINGCAST = 1;
		   mpz_clear($TESTINSIDSMANGIM#_lminz);
		   mpz_clear($TESTINSIDSMANGIM#_lmaxz);
		   mpz_clear($TESTINSIDSMANGIM#_rminz);
		   mpz_clear($TESTINSIDSMANGIM#_rmaxz);
		 }#)
		)
	     ( ?_ (void))
	    ))
	 (?_ (void))
	 )	 
	(if widenningcast
	    (progn
	    (assert_msg "@$@unimplemented smaninterp_gimple widenningcast" ())
	      )
	  (progn
	    (assert_msg "@$@unimplemented smaninterp_gimple non widenningcast" ())
	    ))
	(debug "unimplemented smaninterp_gimple assign_cast g" g)
	(assert_msg "@$@unimplemented smaninterp_gimple castassign" ())
	))
   ;; default 
   (?_ 
    (debug "unimplemented smaninterp_gimple g" g)
    (assert_msg "@$@unimplemented smaninterp_gimple" ()))
   )
  )



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun smallana_interpret (sman)
  (debug "smallana_interpret sman=" sman)
  (assert_msg "check sman" (is_a sman class_smallanalysis))
  (let ( (mainf (mapstring_rawget (get_field :sman_cfundict sman) "main")) 
	 )
    (debug "smallana_interpret mainf=" mainf)
    (assert_msg "check mainf" (is_a mainf class_smallcfun))
    (smaninterp_cfun sman initial_smallabstractenv mainf)
    (debug "smallana_interpret end sman=" sman)
    )
)

;;; our small analysis gate for latessa
;; for some reason, the smallana is triggered twice, and the first run
;; is enough...
(defun smallanapass_gate (latessapass)
  (debug "smallanapass_gate  at start smallana_cont=" smallana_cont)
  (let ( (oldsman !smallana_cont) )
    (if oldsman
	(progn
	  (shortbacktrace_dbg "smallanapass_gate already got oldsman" 20)
	  (debug "smallanapass_gate already got oldsman=" oldsman)
	  (return ()))
      (return smallana_cont)
      )))


;;; apparently only the entrybb loop matter in the latessa pass...
(defun smallanapass_exec (latessapass)
  (debug  "smallanapass_exec start latessapass=" latessapass)
  (let ( (cfuns (make_list discr_list))
	 (cfundict (make_mapstring discr_map_strings 20))
	 (cfuntreemap (make_maptree discr_map_trees 20))
	 (sman (instance class_smallanalysis
			 :sman_cfuns cfuns
			 :sman_cfundict cfundict
			 :sman_cfuntreemap cfuntreemap
			 :sman_bbtable (make_mapbasicblock discr_map_basic_blocks 20)
			 )) 
	 )
    (debug "smallanapass_exec at start sman=" sman)
    ;; don't bother do_each_cfun_body here.. it is not done...
    (each_cgraph_fun_entryblock
     ()
     (:tree decl :basic_block bbent bbexit)
     (debug "smallana exec eachcgraph decl=" decl)
     (smallana_cfun_entbb sman decl bbent bbexit)
     )
    ;;
    (debug "smallanapass_exec after eachentrybb sman=" sman)
    ;;
    (each_bb_cfun
     ()
     (:basic_block cfbb :tree cfdecl)
     (smallana_cfun_bb sman cfdecl cfbb)
     )
    ;;
    (debug "smallanapass_exec after eachbbcfun sman" sman)
    ;;
    (smallana_interpret sman)
    ;;
    (put_fields  smallana_cont :referenced_value sman)
    (debug "smallanapass_exec final smallana_cont=" smallana_cont)
    ))

;;; our small analysis mode -fmelt=smallana
(defun smallana_docmd (cmd moduldata)
  (let ( (smallana_ipa_gccpass 
	  (compile_warning "should create and register a simple ipa pass" ())) )
  ;; fill the ipa pass
  (put_fields smallana_ipa_gccpass
  :gccpass_gate smallanapass_gate
  :gccpass_exec smallanapass_exec)
  (debug  "smallana_ipa_gccpass=" smallana_ipa_gccpass)
  (assert_msg "$@$incomplete smallana_mode" ())
  (return cmd)			;return non-nil to continue compilation
  ))


;;;
(definstance smallana_mode
  class_melt_mode
  :named_name '"smallana"
  :meltmode_help '"install a small analysis pass"
  :meltmode_fun smallana_docmd
)
(install_melt_mode smallana_mode)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; a pass to test that all relevant cmatcher-s are eough to scan a source program
(defclass class_justscan_data 
  :super class_proped
  :fields (juscan_pass 
	   juscan_data
	   juscan_fundecl		;boxed current function decl tree
	   juscan_curbb			;boxed current basic block
	   ))

(defun justscanpass_gate  (pass)
  (debug "justscanpass_gate at start pass=" pass)
  ;; retrieve the data associated to the cfun in the pass. If it
  ;; exists (i.e. is not null) we avoid running the pass again
  (let ( (grdata (maptree_get (get_field :gccpass_data pass) (cfun_decl))) )
    (debug "justscanpass_gate cfundecl=" (cfun_decl) " grdata=" grdata)
    (if grdata 
	() ;; return null, so avoid executing the pass
      pass)
    ))

(defun justscanpass_exec (pass)
  (debug "justscanpass_exec at start pass=" pass)
  (code_chunk dbgcfun #{ /* $dbgcfun :: */
	      debugeprintf("justscanpass_exec start cfun=%p cfg=%p", 
			   (void*)cfun, cfun?cfun->cfg:NULL) ; 
	      }#) 
  (assert_msg "justscanpass_exec check cfun has cfg" (cfun_has_cfg))
  (let ( (jsdata (instance class_justscan_data 
			   :juscan_pass pass
			   )) )
    ;; add our grdata associated to the cfun_decl in the pass data,
    ;; hence the gate will avoid running the pass twice
    (maptree_put (get_field :gccpass_data pass) (cfun_decl) jsdata)
    (justscan_tree jsdata (cfun_decl))
    ;; gimple ssa passes have a cfg..
    (each_bb_cfun 
     ()
     (:basic_block bb :tree fundecl)
     (put_fields jsdata :juscan_fundecl (make_tree discr_tree fundecl))
     (if bb (justscan_bb jsdata bb))
     )
    (debug "justscanpass_exec final jsdata=" jsdata)
    )
  )

(defun justscan_tree (jsdata :tree t)
  (if t
      (match 
       t
       (?(tree_function_decl ?_ ?tfinit)
	 (if tfinit (justscan_tree jsdata tfinit)))
       (?(tree_of_type ?ttyp)
	 (if ttyp (justscan_tree jsdata ttyp)))
       (?(tree_var_decl ?_ ?_ ?_)
	 )
       (?(tree_block ?tvars ?tsublocks)
	 (if tvars (justscan_tree jsdata tvars))
	 (if tsublocks (justscan_tree jsdata tsublocks))
	 )
       (?(tree_parm_decl ?tptyp ?tpdecl)
	 (if tptyp (justscan_tree jsdata tptyp))
	 (if tpdecl (justscan_tree jsdata tpdecl))
	 )
       (?(tree_decl ?tdecl ?_ ?_)
	 (if tdecl (justscan_tree jsdata tdecl)))
       (?(tree_integer_type ?_ ?_ ?_ ?_)
	 )
       (?(tree_integer_cst ?_)
	 )
       (?(tree_ssa_name ?tvar ?tvalu ?_ ?defg)
	 (if tvar (justscan_tree jsdata tvar))
	 (if tvalu (justscan_tree jsdata tvalu))
	 (if defg (justscan_gimple jsdata defg))
	 )
       (?_
	(debug "unhandled tree" t)
	(warning_at_tree t "unhandled tree by justscan")
	(warning_at_tree (tree_content (get_field :juscan_fundecl jsdata)) "justscan function decl")
	(assert_msg "unhandled tree justscan" ())
	)))
  )

(defun justscan_gimple (jsdata :gimple g)
  (if g
      (match 
       g
       (?(gimple_assign_single ?lhs ?rhs)
	 (justscan_tree jsdata lhs)
	 (justscan_tree jsdata rhs)
	 )
       (?(gimple_assign_cast ?lhs ?rhs)
	 (justscan_tree jsdata lhs)
	 (justscan_tree jsdata rhs)
	 )
       (?(gimple_assign_copy ?lhs ?rhs)
	 (justscan_tree jsdata lhs)
	 (justscan_tree jsdata rhs)
	 )
       (?(gimple_assign_ssa_name_copy ?lhs ?rhs)
	 (justscan_tree jsdata lhs)
	 (justscan_tree jsdata rhs)
	 )
       (?(gimple_assign_unary_nop ?lhs ?rhs)
	 (justscan_tree jsdata lhs)
	 (justscan_tree jsdata rhs)
	 )
       (?(gimple_assign_plus ?lhs ?rhs1 ?rhs2)
	 (justscan_tree jsdata lhs)
	 (justscan_tree jsdata rhs1)
	 (justscan_tree jsdata rhs2)
	 )
       (?(gimple_assign_minus ?lhs ?rhs1 ?rhs2)
	 (justscan_tree jsdata lhs)
	 (justscan_tree jsdata rhs1)
	 (justscan_tree jsdata rhs2)
	 )
       (?(gimple_assign_pointerplus ?lhs ?rhs1 ?rhs2)
	 (justscan_tree jsdata lhs)
	 (justscan_tree jsdata rhs1)
	 (justscan_tree jsdata rhs2)
	 )
       (?(gimple_assign_mult ?lhs ?rhs1 ?rhs2)
	 (justscan_tree jsdata lhs)
	 (justscan_tree jsdata rhs1)
	 (justscan_tree jsdata rhs2)
	 )
       (?(gimple_assign_trunc_div ?lhs ?rhs1 ?rhs2)
	 (justscan_tree jsdata lhs)
	 (justscan_tree jsdata rhs1)
	 (justscan_tree jsdata rhs2)
	 )
       (?(gimple_assign_ceil_div ?lhs ?rhs1 ?rhs2)
	 (justscan_tree jsdata lhs)
	 (justscan_tree jsdata rhs1)
	 (justscan_tree jsdata rhs2)
	 )
       (?(gimple_assign_floor_div ?lhs ?rhs1 ?rhs2)
	 (justscan_tree jsdata lhs)
	 (justscan_tree jsdata rhs1)
	 (justscan_tree jsdata rhs2)
	 )
       (?(gimple_assign_round_div ?lhs ?rhs1 ?rhs2)
	 (justscan_tree jsdata lhs)
	 (justscan_tree jsdata rhs1)
	 (justscan_tree jsdata rhs2)
	 )
       (?(gimple_assign_rdiv ?lhs ?rhs1 ?rhs2)
	 (justscan_tree jsdata lhs)
	 (justscan_tree jsdata rhs1)
	 (justscan_tree jsdata rhs2)
	 )
       (?_
	(debug "unhandled gimple" g)
	(warning_at_gimple g "unhandled gimple by justscan")
	(warning_at_tree (tree_content (get_field :juscan_fundecl jsdata)) "justscan function decl")
	(assert_msg "unhandled gimple justscan" ())
	)
       )
    ))

(defun justscan_bb (jsdata :basic_block bb)
  (debug "justscan_bbdcl  start jsdata=" jsdata " bb=" bb)
  (if bb
      (let ( (oldbb (get_field :juscan_curbb jsdata)) )
	(put_fields jsdata :juscan_curbb (make_basicblock discr_basic_block bb))
	(eachgimple_in_basicblock 
	 (bb)
	 (:gimple g)
	 (justscan_gimple jsdata bb)
	 )
	(put_fields jsdata :juscan_curbb oldbb)
	)))


;;;;;;;;;;;;;;;;
;;; our just scan mode -fmelt=justscan
(defun justscan_docmd (cmd moduldata)
  (let ( (justscanpass
	  (instance class_gcc_gimple_pass
		    :named_name '"melt_justscanpass"
		    :gccpass_gate justscanpass_gate
		    :gccpass_exec justscanpass_exec
		    :gccpass_data (make_maptree discr_map_trees 100)
		    :gccpass_properties_required ()
	      ))
        )
  (install_melt_gcc_pass justscanpass "after" "phiopt" 0)
  (debug  "justscan_mode installed pass=" justscanpass)
  (return cmd)			;return non-nil to continue compilation
  ))



(definstance justscan_mode
  class_melt_mode
  :named_name '"justscan"
  :meltmode_help '"install a pass scanning all the code"
  :meltmode_fun justscan_docmd
)
(install_melt_mode justscan_mode)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; a pass to help write MELT code in C.
;; it checks that the meltfram__ structure is correctly dimensionned.

(defclass class_melt_frame_data 
  :super class_root
  :fields (meltfram_funcount
	   ))

(defun meltframe_gate (pass)
  (debug "meltframe_gate at start pass=" pass)
  (with_cfun_decl
   ()
   (:tree cfundecl)
   (match cfundecl
	  ;; melt-runtime.c has has garbage collecting MELT functions starting with meltgc_
	  ( ?(tree_function_decl_named ?(cstring_prefixed "meltgc_") ?_)
	     )
	  ;; MELT generated routines start with meltrout_
	  ( ?(tree_function_decl_named ?(cstring_prefixed "meltrout_") ?_)
	     )
	  ( ?(tree_function_decl_named ?(cstring_same "start_module_melt") ?_)
	     )
	  (?_
	   (return)
	   )
	  )
   (let ( (meltdata (get_field :gccpass_data pass))
	  (:long meltfuncount (get_int (get_field :meltfram_funcount meltdata)))
	  )
     (put_fields meltdata 
		 :meltfram_funcount (make_integerbox discr_integer 
						     (+i meltfuncount 1)))
     )
   (return pass)
   )
  )


(defun meltframe_update_tuple_ptr  (tup :long ix :gimple g)
  (let ( (curlist (multiple_nth tup ix))
	 )
    (if (is_list curlist)
	(list_append curlist (make_gimple discr_gimple g))
      (let ( (newlist (list (make_gimple discr_gimple g))) 
	     )
	(multiple_put_nth tup ix newlist)
	))))

(defun meltframe_exec (pass)
  (debug "meltframe_exec at start pass=" pass)
  (let ( (:long declcnt 0)
	 (:long bbcnt 0)
	 (:long gimplecnt 0)
	 (:tree tmeltframdecl (null_tree))
	 (:tree tmeltframtype (null_tree))
	 (:tree tmeltframvarptr (null_tree))
	 (:tree tfundecl (cfun_decl))
	 (:long nbvarptr 0)
	 )
    (each_local_decl_cfun
     ()
     (:tree tlocdecl :long ix)
     (debug "meltframe_exec tlocdecl" tlocdecl)
     (match tlocdecl 
	    (?(tree_var_decl_named
	       ?(and ?tvtyp 
		     ?(tree_record_type_with_fields ?tmeltframrecnam 
						    ?tmeltframfields))
	       ?(cstring_same "meltfram__") ?_)
	      (setq tmeltframdecl tlocdecl)
	      (setq tmeltframtype tvtyp)
	      (debug "meltframe_exec tmeltframdecl=" tmeltframdecl
		     " tmeltframtype=" tmeltframtype
		     " tmeltframrecnam=" tmeltframrecnam 
		     " tmeltframfields" tmeltframfields)
	      (foreach_field_in_record_type
	       (tmeltframfields)
	       (:tree tcurfield)
	       (debug "meltframe_exec tcurfield" tcurfield)
	       (match tcurfield
		      ( ?(tree_field_decl
			  ?(tree_identifier 
			    ?(cstring_same "mcfr_varptr"))
			  ?(tree_array_type ?telemtype 
					    ?(tree_integer_type_bounded ?tindextype
									?(tree_integer_cst 0)
									?(tree_integer_cst ?lmax) 
									?tsize)))
			 (debug "meltframe_exec telemtype=" telemtype
				" tindextype=" tindextype 
				" tsize=" tsize
				" lmax=" lmax)
			 (setq tmeltframvarptr tcurfield)
			 (setq nbvarptr lmax)
			 )
		      (?_ 
		       (void)))
	       )
	      )
	    (?_ (void)))
     (setq declcnt (+i declcnt 1))
     )
    (debug "meltframe_exec declcnt=" declcnt
	   " found tmeltframdecl=" tmeltframdecl 
	   " tmeltframvarptr=" tmeltframvarptr)
    (if tmeltframdecl
	(void)
      (warning_at_tree tfundecl "MELT routine without meltfram__"))
    (let ( (tupuseptr (make_multiple discr_multiple nbvarptr))
	   (tupdefptr (make_multiple discr_multiple nbvarptr))
	   )
      (each_bb_cfun 
       ()
       (:basic_block bb :tree fundecl)
       (debug "meltframe_exec fundecl" fundecl)
       (setq bbcnt (+i bbcnt 1))
       (eachgimple_in_basicblock 
	(bb)
	(:gimple g)
	(debug "meltframe_exec g" g)
	(setq gimplecnt (+i gimplecnt 1))
	(match g
	       ( ?(gimple_call_3
		   ?lhs ?(tree_function_decl_named ?(cstring_same "memset") ?_)
		   ?(tree_addr_expr tmeltframtype tmeltframdecl) ?arg2 ?arg3)
		  (debug "meltframe_exec call3 memset arg2=" arg2 " arg3=" arg3)
		  )
	       ( ?(gimple_assign_single
		   tmeltframdecl
		   ?rhs)
		  (debug "meltframe_exec gimple_assign_single meltfram rhs" rhs)
		  )
	       ( ?(gimple_assign_single
		   ?(tree_array_ref 
		     ?(tree_component_ref 
		       tmeltframdecl
		       tmeltframvarptr)
		     ?(tree_integer_cst ?ixkdst))
		   ?(tree_array_ref 
		     ?(tree_component_ref 
		       tmeltframdecl
		       tmeltframvarptr)
		     ?(tree_integer_cst ?ixksrc)))
		  (debug "meltframe_exec gimple_assign_single varptrsrcdest ixkdst=" ixkdst 
			 " ixksrc=" ixksrc)
		  (cond 
		   ( (<i ixkdst 0)
		     (warning_at_gimple g "negative meltvarptr destination pointer index")
		     )
		   ( (<i ixksrc 0)
		     (warning_at_gimple g "negative meltvarptr source pointer index")
		     )
		   ( (>i ixkdst nbvarptr)
		     (warning_at_gimple g "to big meltvarptr destination pointer index")
		     )
		   ( (>i ixksrc nbvarptr)
		     (warning_at_gimple g "to big meltvarptr source pointer index")
		     )
		   ( (==i ixksrc ixkdst)
		     (warning_at_gimple g "useless selfassign meltvarptr")
		     )
		   (:else
		    (meltframe_update_tuple_ptr tupdefptr ixkdst g)
		    (meltframe_update_tuple_ptr tupuseptr ixksrc g)
		    )
		   )
		  )
	       ( ?(gimple_assign_single
		   ?(tree_array_ref 
		     ?(tree_component_ref 
		       tmeltframdecl
		       tmeltframvarptr)
		     ?(tree_integer_cst ?ixkdst))
		   ?rhs)
		  (debug "meltframe_exec gimple_assign_single varptrdest ixkdst=" ixkdst
			 " rhs=" rhs)
		  (cond
		   ( (<i ixkdst 0)
		     (warning_at_gimple g "negative meltvarptr destination pointer index")
		     )
		   ( (>i ixkdst nbvarptr)
		     (warning_at_gimple g "too big meltvarptr destination pointer index")
		     )
		   (:else
		    (meltframe_update_tuple_ptr tupdefptr ixkdst g)
		    ))
		  )
	       ( ?(gimple_assign_single
		   ?lhs
		   ?(tree_array_ref 
		     ?(tree_component_ref 
		       tmeltframdecl
		       tmeltframvarptr)
		     ?(tree_integer_cst ?ixksrc)))
		  (debug "meltframe_exec gimple_assign_single varptrsrc lhs=" lhs
			 " ixksrc=" ixksrc)
		  (cond
		   ( (<i ixksrc 0)
		     (warning_at_gimple g "negative meltvarptr source pointer index")
		     )
		   ( (>i ixksrc nbvarptr)
		     (warning_at_gimple g "too big meltvarptr source pointer index")
		     )
		   (:else
		    (meltframe_update_tuple_ptr tupuseptr ixksrc g)
		    ))
		  )
	       ( ?(gimple_assign_single ?lhs ?rhs)
		  (debug "meltframe_exec gimple_assign_single lhs=" lhs " rhs=" rhs)
		  )
	       ( ?_ 
		 ())
	       )
	)
       )
      (foreach_in_multiple 
       (tupuseptr)
       (curuselist :long ix)
       (if (is_non_empty_list curuselist)
	   ()
	 (warning_at_tree_decl_with_number
	  tfundecl "meltvarptr not used at index" ix)
	 )
       )
      (foreach_in_multiple 
       (tupdefptr)
       (curdeflist :long ix)
       (if (is_non_empty_list curdeflist)
	   ()
	 (warning_at_tree_decl_with_number
	  tfundecl "meltvarptr not assigned at index" ix)
	 )
       )
      (debug "meltframe_exec bbcnt=" bbcnt" gimplecnt=" gimplecnt)
     
      )
    )
  )



(defun meltframe_docmd (cmd moduldata)
  (let ( (meltframedata
	  (instance class_melt_frame_data
		    :meltfram_funcount (make_integerbox discr_integer 0)
		    ))
	(meltframepass
	  (instance class_gcc_gimple_pass
		    :named_name '"melt_frame_pass"
		    :gccpass_gate meltframe_gate
		    :gccpass_exec meltframe_exec
		    :gccpass_data meltframedata
		    :gccpass_properties_required ()
		    ))
	 )
    (install_melt_gcc_pass meltframepass "after" "ssa" 0)
    (at_exit_first 
     (lambda (x)
       (debug " at exit meltframedata=" meltframedata)
       (let ( (:long nbmeltrout
		     (get_int (get_field :meltfram_funcount meltframedata)))
	      )
	 (code_chunk 
	  informnbmelt
	  #{/* $INFORMNBMELT */ 
	    inform(UNKNOWN_LOCATION, "melt_frame_pass found %ld MELT routines", $NBMELTROUT);
	  }#))))
    (debug "meltframe_docmd installed pass meltframepass=" meltframepass)
    (return cmd)	       ;return non-nil to continue compilation
    ))

(definstance meltframe_mode
  class_melt_mode
  :named_name '"meltframe"
  :meltmode_help '"install a pass checking MELT frame accesses"
  :meltmode_fun meltframe_docmd
)
(install_melt_mode meltframe_mode)

;; eof xtramelt-ana-simple.melt
