;; -*- Lisp -*-
;; file xtramelt-ana-simple.melt
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(comment "***
    Copyright 2009, 2011, 2012 Free Software Foundation, Inc.
    Contributed by Basile Starynkevitch <basile@starynkevitch.net>

    This file is part of GCC.

    GCC is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.

    GCC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.
***")






;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; a pass to test that all relevant cmatcher-s are eough to scan a source program
(defclass class_justscan_data 
  :super class_proped
  :fields (juscan_pass 
	   juscan_data
	   juscan_fundecl		;boxed current function decl tree
	   juscan_curbb			;boxed current basic block
	   ))

(defun justscanpass_gate  (pass)
  (debug "justscanpass_gate at start pass=" pass)
  ;; retrieve the data associated to the cfun in the pass. If it
  ;; exists (i.e. is not null) we avoid running the pass again
  (let ( (grdata (maptree_get (get_field :gccpass_data pass) (cfun_decl))) )
    (debug "justscanpass_gate cfundecl=" (cfun_decl) " grdata=" grdata)
    (if grdata 
	() ;; return null, so avoid executing the pass
      pass)
    ))

(defun justscanpass_exec (pass)
  (debug "justscanpass_exec at start pass=" pass)
  (code_chunk dbgcfun #{ /* $dbgcfun :: */
	      debugeprintf("justscanpass_exec start cfun=%p cfg=%p", 
			   (void*)cfun, cfun?cfun->cfg:NULL) ; 
	      }#) 
  (assert_msg "justscanpass_exec check cfun has cfg" (cfun_has_cfg))
  (let ( (jsdata (instance class_justscan_data 
			   :juscan_pass pass
			   )) )
    ;; add our grdata associated to the cfun_decl in the pass data,
    ;; hence the gate will avoid running the pass twice
    (maptree_put (get_field :gccpass_data pass) (cfun_decl) jsdata)
    (justscan_tree jsdata (cfun_decl))
    ;; gimple ssa passes have a cfg..
    (each_bb_cfun 
     ()
     (:basic_block bb :tree fundecl)
     (put_fields jsdata :juscan_fundecl (make_tree discr_tree fundecl))
     (if bb (justscan_bb jsdata bb))
     )
    (debug "justscanpass_exec final jsdata=" jsdata)
    )
  )

(defun justscan_tree (jsdata :tree t)
  (if t
      (match 
       t
       (?(tree_function_decl ?_ ?tfinit)
	 (if tfinit (justscan_tree jsdata tfinit)))
       (?(tree_of_type ?ttyp)
	 (if ttyp (justscan_tree jsdata ttyp)))
       (?(tree_var_decl ?_ ?_ ?_)
	 )
       (?(tree_block ?tvars ?tsublocks)
	 (if tvars (justscan_tree jsdata tvars))
	 (if tsublocks (justscan_tree jsdata tsublocks))
	 )
       (?(tree_parm_decl ?tptyp ?tpdecl)
	 (if tptyp (justscan_tree jsdata tptyp))
	 (if tpdecl (justscan_tree jsdata tpdecl))
	 )
       (?(tree_decl ?tdecl ?_ ?_)
	 (if tdecl (justscan_tree jsdata tdecl)))
       (?(tree_integer_type ?_ ?_ ?_ ?_)
	 )
       (?(tree_integer_cst ?_)
	 )
       (?(tree_ssa_name ?tvar ?tvalu ?_ ?defg)
	 (if tvar (justscan_tree jsdata tvar))
	 (if tvalu (justscan_tree jsdata tvalu))
	 (if defg (justscan_gimple jsdata defg))
	 )
       (?_
	(debug "unhandled tree" t)
	(warning_at_tree t "unhandled tree by justscan")
	(warning_at_tree (tree_content (get_field :juscan_fundecl jsdata)) "justscan function decl")
	(assert_msg "unhandled tree justscan" ())
	)))
  )

(defun justscan_gimple (jsdata :gimple g)
  (if g
      (match 
       g
       (?(gimple_assign_single ?lhs ?rhs)
	 (justscan_tree jsdata lhs)
	 (justscan_tree jsdata rhs)
	 )
       (?(gimple_assign_cast ?lhs ?rhs)
	 (justscan_tree jsdata lhs)
	 (justscan_tree jsdata rhs)
	 )
       (?(gimple_assign_copy ?lhs ?rhs)
	 (justscan_tree jsdata lhs)
	 (justscan_tree jsdata rhs)
	 )
       (?(gimple_assign_ssa_name_copy ?lhs ?rhs)
	 (justscan_tree jsdata lhs)
	 (justscan_tree jsdata rhs)
	 )
       (?(gimple_assign_unary_nop ?lhs ?rhs)
	 (justscan_tree jsdata lhs)
	 (justscan_tree jsdata rhs)
	 )
       (?(gimple_assign_plus ?lhs ?rhs1 ?rhs2)
	 (justscan_tree jsdata lhs)
	 (justscan_tree jsdata rhs1)
	 (justscan_tree jsdata rhs2)
	 )
       (?(gimple_assign_minus ?lhs ?rhs1 ?rhs2)
	 (justscan_tree jsdata lhs)
	 (justscan_tree jsdata rhs1)
	 (justscan_tree jsdata rhs2)
	 )
       (?(gimple_assign_pointerplus ?lhs ?rhs1 ?rhs2)
	 (justscan_tree jsdata lhs)
	 (justscan_tree jsdata rhs1)
	 (justscan_tree jsdata rhs2)
	 )
       (?(gimple_assign_mult ?lhs ?rhs1 ?rhs2)
	 (justscan_tree jsdata lhs)
	 (justscan_tree jsdata rhs1)
	 (justscan_tree jsdata rhs2)
	 )
       (?(gimple_assign_trunc_div ?lhs ?rhs1 ?rhs2)
	 (justscan_tree jsdata lhs)
	 (justscan_tree jsdata rhs1)
	 (justscan_tree jsdata rhs2)
	 )
       (?(gimple_assign_ceil_div ?lhs ?rhs1 ?rhs2)
	 (justscan_tree jsdata lhs)
	 (justscan_tree jsdata rhs1)
	 (justscan_tree jsdata rhs2)
	 )
       (?(gimple_assign_floor_div ?lhs ?rhs1 ?rhs2)
	 (justscan_tree jsdata lhs)
	 (justscan_tree jsdata rhs1)
	 (justscan_tree jsdata rhs2)
	 )
       (?(gimple_assign_round_div ?lhs ?rhs1 ?rhs2)
	 (justscan_tree jsdata lhs)
	 (justscan_tree jsdata rhs1)
	 (justscan_tree jsdata rhs2)
	 )
       (?(gimple_assign_rdiv ?lhs ?rhs1 ?rhs2)
	 (justscan_tree jsdata lhs)
	 (justscan_tree jsdata rhs1)
	 (justscan_tree jsdata rhs2)
	 )
       (?_
	(debug "unhandled gimple" g)
	(warning_at_gimple g "unhandled gimple by justscan")
	(warning_at_tree (tree_content (get_field :juscan_fundecl jsdata)) "justscan function decl")
	(assert_msg "unhandled gimple justscan" ())
	)
       )
    ))

(defun justscan_bb (jsdata :basic_block bb)
  (debug "justscan_bbdcl  start jsdata=" jsdata " bb=" bb)
  (if bb
      (let ( (oldbb (get_field :juscan_curbb jsdata)) )
	(put_fields jsdata :juscan_curbb (make_basicblock discr_basic_block bb))
	(eachgimple_in_basicblock 
	 (bb)
	 (:gimple g)
	 (justscan_gimple jsdata bb)
	 )
	(put_fields jsdata :juscan_curbb oldbb)
	)))


;;;;;;;;;;;;;;;;
;;; our just scan mode -fmelt=justscan
(defun justscan_docmd (cmd moduldata)
  (let ( (justscanpass
	  (instance class_gcc_gimple_pass
		    :named_name '"melt_justscanpass"
		    :gccpass_gate justscanpass_gate
		    :gccpass_exec justscanpass_exec
		    :gccpass_data (make_maptree discr_map_trees 100)
		    :gccpass_properties_required ()
	      ))
        )
  (install_melt_gcc_pass justscanpass "after" "phiopt" 0)
  (debug  "justscan_mode installed pass=" justscanpass)
  (return cmd)			;return non-nil to continue compilation
  ))



(definstance justscan_mode
  class_melt_mode
  :named_name '"justscan"
  :meltmode_help '"install a pass scanning all the code"
  :meltmode_fun justscan_docmd
)
(install_melt_mode justscan_mode)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; a pass to help write MELT code in C.
;; it checks that the meltfram__ structure is correctly dimensionned.

(defclass class_melt_frame_data 
  :super class_root
  :fields (meltfram_funcount
	   ))

(defun meltframe_gate (pass)
  (debug "meltframe_gate at start pass=" pass)
  (with_cfun_decl
   ()
   (:tree cfundecl)
   (match cfundecl
	  ;; melt-runtime.c has has garbage collecting MELT functions starting with meltgc_
	  ( ?(tree_function_decl_named ?(cstring_prefixed "meltgc_") ?_)
	     )
	  ;; MELT generated routines start with meltrout_
	  ( ?(tree_function_decl_named ?(cstring_prefixed "meltrout_") ?_)
	     )
	  ( ?(tree_function_decl_named ?(cstring_same "melt_start_this_module") ?_)
	     )
	  (?_
	   (return)
	   )
	  )
   (let ( (meltdata (get_field :gccpass_data pass))
	  (:long meltfuncount (get_int (get_field :meltfram_funcount meltdata)))
	  )
     (put_fields meltdata 
		 :meltfram_funcount (make_integerbox discr_integer 
						     (+i meltfuncount 1)))
     )
   (return pass)
   )
  )


(defun meltframe_update_tuple_ptr  (tup :long ix :gimple g)
  (let ( (curlist (multiple_nth tup ix))
	 )
    (if (is_list curlist)
	(list_append curlist (make_gimple discr_gimple g))
      (let ( (newlist (list (make_gimple discr_gimple g))) 
	     )
	(multiple_put_nth tup ix newlist)
	))))

(defun meltframe_exec (pass)
  (debug "meltframe_exec at start pass=" pass)
  (let ( (:long declcnt 0)
	 (:long bbcnt 0)
	 (:long gimplecnt 0)
	 (:tree tmeltframdecl (null_tree))
	 (:tree tmeltframtype (null_tree))
	 (:tree tmeltframvarptr (null_tree))
	 (:tree tfundecl (cfun_decl))
	 (:long nbvarptr 0)
	 )
    (each_local_decl_cfun
     ()
     (:tree tlocdecl :long ix)
     (debug "meltframe_exec tlocdecl" tlocdecl)
     (match tlocdecl 
	    (?(tree_var_decl_named
	       ?(and ?tvtyp 
		     ?(tree_record_type_with_fields ?tmeltframrecnam 
						    ?tmeltframfields))
	       ?(cstring_same "meltfram__") ?_)
	      (setq tmeltframdecl tlocdecl)
	      (setq tmeltframtype tvtyp)
	      (debug "meltframe_exec tmeltframdecl=" tmeltframdecl
		     " tmeltframtype=" tmeltframtype
		     " tmeltframrecnam=" tmeltframrecnam 
		     " tmeltframfields" tmeltframfields)
	      (foreach_field_in_record_type
	       (tmeltframfields)
	       (:tree tcurfield)
	       (debug "meltframe_exec tcurfield" tcurfield)
	       (match tcurfield
		      ( ?(tree_field_decl
			  ?(tree_identifier 
			    ?(cstring_same "mcfr_varptr"))
			  ?(tree_array_type ?telemtype 
					    ?(tree_integer_type_bounded ?tindextype
									?(tree_integer_cst 0)
									?(tree_integer_cst ?lmax) 
									?tsize)))
			 (debug "meltframe_exec telemtype=" telemtype
				" tindextype=" tindextype 
				" tsize=" tsize
				" lmax=" lmax)
			 (setq tmeltframvarptr tcurfield)
			 (setq nbvarptr lmax)
			 )
		      (?_ 
		       (void)))
	       )
	      )
	    (?_ (void)))
     (setq declcnt (+i declcnt 1))
     )
    (debug "meltframe_exec declcnt=" declcnt
	   " found tmeltframdecl=" tmeltframdecl 
	   " tmeltframvarptr=" tmeltframvarptr)
    (if tmeltframdecl
	(void)
      (warning_at_tree tfundecl "MELT routine without meltfram__"))
    (let ( (tupuseptr (make_multiple discr_multiple nbvarptr))
	   (tupdefptr (make_multiple discr_multiple nbvarptr))
	   )
      (each_bb_cfun 
       ()
       (:basic_block bb :tree fundecl)
       (debug "meltframe_exec fundecl" fundecl)
       (setq bbcnt (+i bbcnt 1))
       (eachgimple_in_basicblock 
	(bb)
	(:gimple g)
	(debug "meltframe_exec g" g)
	(setq gimplecnt (+i gimplecnt 1))
	(match g
	       ( ?(gimple_call_3
		   ?lhs ?(tree_function_decl_named ?(cstring_same "memset") ?_)
		   ?(tree_addr_expr tmeltframtype tmeltframdecl) ?arg2 ?arg3)
		  (debug "meltframe_exec call3 memset arg2=" arg2 " arg3=" arg3)
		  )
	       ( ?(gimple_assign_single
		   tmeltframdecl
		   ?rhs)
		  (debug "meltframe_exec gimple_assign_single meltfram rhs" rhs)
		  )
	       ( ?(gimple_assign_single
		   ?(tree_array_ref 
		     ?(tree_component_ref 
		       tmeltframdecl
		       tmeltframvarptr)
		     ?(tree_integer_cst ?ixkdst))
		   ?(tree_array_ref 
		     ?(tree_component_ref 
		       tmeltframdecl
		       tmeltframvarptr)
		     ?(tree_integer_cst ?ixksrc)))
		  (debug "meltframe_exec gimple_assign_single varptrsrcdest ixkdst=" ixkdst 
			 " ixksrc=" ixksrc)
		  (cond 
		   ( (<i ixkdst 0)
		     (warning_at_gimple g "negative meltvarptr destination pointer index")
		     )
		   ( (<i ixksrc 0)
		     (warning_at_gimple g "negative meltvarptr source pointer index")
		     )
		   ( (>i ixkdst nbvarptr)
		     (warning_at_gimple g "to big meltvarptr destination pointer index")
		     )
		   ( (>i ixksrc nbvarptr)
		     (warning_at_gimple g "to big meltvarptr source pointer index")
		     )
		   ( (==i ixksrc ixkdst)
		     (warning_at_gimple g "useless selfassign meltvarptr")
		     )
		   (:else
		    (meltframe_update_tuple_ptr tupdefptr ixkdst g)
		    (meltframe_update_tuple_ptr tupuseptr ixksrc g)
		    )
		   )
		  )
	       ( ?(gimple_assign_single
		   ?(tree_array_ref 
		     ?(tree_component_ref 
		       tmeltframdecl
		       tmeltframvarptr)
		     ?(tree_integer_cst ?ixkdst))
		   ?rhs)
		  (debug "meltframe_exec gimple_assign_single varptrdest ixkdst=" ixkdst
			 " rhs=" rhs)
		  (cond
		   ( (<i ixkdst 0)
		     (warning_at_gimple g "negative meltvarptr destination pointer index")
		     )
		   ( (>i ixkdst nbvarptr)
		     (warning_at_gimple g "too big meltvarptr destination pointer index")
		     )
		   (:else
		    (meltframe_update_tuple_ptr tupdefptr ixkdst g)
		    ))
		  )
	       ( ?(gimple_assign_single
		   ?lhs
		   ?(tree_array_ref 
		     ?(tree_component_ref 
		       tmeltframdecl
		       tmeltframvarptr)
		     ?(tree_integer_cst ?ixksrc)))
		  (debug "meltframe_exec gimple_assign_single varptrsrc lhs=" lhs
			 " ixksrc=" ixksrc)
		  (cond
		   ( (<i ixksrc 0)
		     (warning_at_gimple g "negative meltvarptr source pointer index")
		     )
		   ( (>i ixksrc nbvarptr)
		     (warning_at_gimple g "too big meltvarptr source pointer index")
		     )
		   (:else
		    (meltframe_update_tuple_ptr tupuseptr ixksrc g)
		    ))
		  )
	       ( ?(gimple_assign_single ?lhs ?rhs)
		  (debug "meltframe_exec gimple_assign_single lhs=" lhs " rhs=" rhs)
		  )
	       ( ?_ 
		 ())
	       )
	)
       )
      (foreach_in_multiple 
       (tupuseptr)
       (curuselist :long ix)
       (if (is_non_empty_list curuselist)
	   ()
	 (warning_at_tree_decl_with_number
	  tfundecl "meltvarptr not used at index" ix)
	 )
       )
      (foreach_in_multiple 
       (tupdefptr)
       (curdeflist :long ix)
       (if (is_non_empty_list curdeflist)
	   ()
	 (warning_at_tree_decl_with_number
	  tfundecl "meltvarptr not assigned at index" ix)
	 )
       )
      (debug "meltframe_exec bbcnt=" bbcnt" gimplecnt=" gimplecnt)
     
      )
    )
  )



(defun meltframe_docmd (cmd moduldata)
  (let ( (meltframedata
	  (instance class_melt_frame_data
		    :meltfram_funcount (make_integerbox discr_integer 0)
		    ))
	(meltframepass
	  (instance class_gcc_gimple_pass
		    :named_name '"melt_frame_pass"
		    :gccpass_gate meltframe_gate
		    :gccpass_exec meltframe_exec
		    :gccpass_data meltframedata
		    :gccpass_properties_required ()
		    ))
	 )
    (install_melt_gcc_pass meltframepass "after" "ssa" 0)
    (at_exit_first 
     (lambda (x)
       (debug " at exit meltframedata=" meltframedata)
       (let ( (:long nbmeltrout
		     (get_int (get_field :meltfram_funcount meltframedata)))
	      )
	 (code_chunk 
	  informnbmelt
	  #{/* $INFORMNBMELT */ 
	    inform(UNKNOWN_LOCATION, "melt_frame_pass found %ld MELT routines", $NBMELTROUT);
	  }#))))
    (debug "meltframe_docmd installed pass meltframepass=" meltframepass)
    (return cmd)	       ;return non-nil to continue compilation
    ))

(definstance meltframe_mode
  class_melt_mode
  :named_name '"meltframe"
  :meltmode_help '"install a pass checking MELT frame accesses"
  :meltmode_fun meltframe_docmd
)
(install_melt_mode meltframe_mode)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; interactive Read Eval Print loop
(defclass class_read_eval_print_loop_data 
  :super class_proped
  :fields (repl_env
	   repl_counter
	   repl_contref
	   repl_data))

(defun repl_processor (inch inlist)
  (debug "repl_processor inch=" inch "\n inlist=" inlist)
  (assert_msg "check inch" (is_a inch class_input_channel_handler))
  (let ( (repldata (get_field :inch_data inch))
	 (replenv (get_field :repl_env repldata))
	 (replcounterv (get_field :repl_counter repldata))
	 (replcontref (get_field :repl_contref repldata))
	 (:long replcount (get_int replcounterv))
	 )
    (assert_msg "check repldata" (is_a repldata class_read_eval_print_loop_data))
    (assert_msg "check replenv" (is_a replenv class_environment))
    (assert_msg "check replcounterv" (is_integerbox replcounterv))
    (cond ((null inlist)
	   (code_chunk eofrepl_chk 
		       #{ /* repl_processor $EOFREPL_CHK */ 
		       printf ("\n;;; End of Input on Read-Eval-Print-Loop #%ld\n",
			       $REPLCOUNT) ;
		       fflush (NULL)	   ;
		       }#)
	   (set_ref replcontref :true)
	   )
	  (:else
	   (assert_msg "check inlist" (is_list inlist))
	   (setq replcount (+i replcount 1))
	   (put_int replcounterv replcount)
	   (let ( 
		 (:long inlistlen (list_length inlist))
		 (stdout (get_field :sysdata_stdout initial_system_data))
		 )
	     (code_chunk beforevalrepl_chk
			 #{ /* repl_processor $BEFOREVALREPL_CHK */
			 printf ("\n;; MELT REPL evaluation #%ld of %ld expressions\n",
				 $REPLCOUNT, $INLISTLEN) ;
			 fflush (NULL)			 ; 
			 }#)
	     (set_ref replcontref ())
	     (let ( (res ())
		    (occmap (make_mapobject  discr_map_objects 50))
		    (dbgi (instance class_debug_information
				    :dbgi_out stdout
				    :dbgi_occmap occmap
				    :dbgi_maxdepth '8))
		    )
	       (debug "repl_processor before translate&run inlist=" inlist
		      "\n replenv=" replenv)
	       (block_signals 
		() ()
		(setq res (translate_run_melt_expressions inlist replenv)))
	       (debug "repl_processor run res=" res "\n replenv=" replenv "\n dbgi=" dbgi "\n")
	       (add2out stdout "\n;; Result of REPL #" replcount " is:\n")
	       (dbg_out res dbgi 0)
	       (add2out stdout "\n\n")
	       )
	     )
	   ))))

(defun repl_docmd (cmd moduldata)
  (assert_msg "check moduldata" (is_a moduldata class_environment))
  (let ( (newenv (fresh_env moduldata '"the interactive Read-Eval-Print-Loop environment"))
	 (refcont (instance class_reference))
	 (evalcounter (make_integerbox discr_integer 0))
	 (repldata (instance class_read_eval_print_loop_data
			     :repl_env newenv
			     :repl_counter evalcounter
			     :repl_contref refcont
			     ))
	 (contfun (lambda () (set_ref refcont :true)))
	 (waitfun (lambda (msgv)
		    (debug "repl_docmd/waitfun start refcont=" refcont 
			   " evalcounter=" evalcounter "\n msgv=" msgv)
		    (forever waitfunloop
			     (let ( (:long evalcount (get_int evalcounter)) 
				    )
			       (if (!refcont) (exit waitfunloop))
			       (code_chunk waitfunloop_chk
					   #{ /* repl_docmd $WAITFUNLOOP_CHK */
					   const char* $WAITFUNLOOP_CHK#_msg = 
					   melt_string_str ($MSGV) ;
					   if ($WAITFUNLOOP_CHK#_msg)
					   printf ("\n;; MELT REPL#%ld waiting: %s\n", 
						   $EVALCOUNT, $WAITFUNLOOP_CHK#_msg) ;
					   else
					   printf ("\n;; MELT REPL#%ld waiting ?\n", 
						   $EVALCOUNT) ;
					   fflush (NULL)       ;
					   }#)
			       (poll_all_inputs 3000))
			     (debug "repl_docmd/waitfun end refcont=" refcont 
				    " evalcounter=" evalcounter)
			     )))
	 (contvalbind (instance class_value_binding
				:binder 'continue
				:vbind_value contfun))
	 (waitreplbind (instance class_value_binding
				 :binder 'wait-repl
				 :vbind_value waitfun))
	 )
    (put_env newenv contvalbind)
    (put_env newenv waitreplbind)
    (debug "repl_docmd newenv=" newenv " repldata=" repldata)
    (register_input_channel_handler repl_processor repldata 0)
    (code_chunk replwelcome_chk 
		#{ /* repl_docmd $REPLWELCOME_CHK */
		printf ("; Welcome to the MELT interactive Read-Eval-Print-Loop [=REPL]\n") ;
		printf ("; Type a sequence of MELT expressions to be evaluated\n") ;
		printf ("; End that sequence with two (2) consecutive newlines.\n") ;
		printf ("; Call the CONTINUE function like (CONTINUE) to exit this REPL, or give an end-of-file thru ^D\n") ;
		printf ("; Call (WAIT-REPL [welcome-string-value]) from a hook to wait for more input and exit of the REPL\n") ;
		fflush (NULL)		;
		}#)
    ;; register waiting REPL after all passes
    (register_all_passes_end_hook_first
     (lambda (endp)
       (debug "repl_docmd/endpasses endp=" endp)
       (code_chunk endp_chk
		   #{ /* repl_docmd/endpasses $ENDP_CHK */
		   printf ("; GCC MELT ended all passes\n")	 ;
		   printf ("; type (CONTINUE) to proceed.\n")	 ;
		   fflush (NULL)				 ;
		   }#)
       (waitfun '"ended all GCC passes")))
    ;; register waiting REPL after compilation unit ended
    (at_finish_unit_first
     (lambda (finp)
       (debug "repl_docmd/finishunit finp=" finp)
       (code_chunk finp_chk
		   #{ /* repl_docmd/finishunit $FINP_CHK */
		   printf ("; GCC MELT finished compilation unit\n") ;
		   printf ("; type (CONTINUE) to proceed.\n")	     ;
		   fflush (NULL)				     ;
		   }#)
       (waitfun '"finished compilation unit")))
    ;; register last REPL at exit
    (at_exit_last 
     (lambda (exip)
       (debug "repl_docmd/atexit exip=" exip)
       (code_chunk endp_chk
		   #{ /* repl_docmd/endpasses $ENDP_CHK */
		   printf ("; GCC MELT exiting\n");
		   printf ("; type (CONTINUE) to proceed.\n");
		   fflush (NULL);
		   }#)
       (waitfun '"GCC MELT exiting")))
    (waitfun '"GCC MELT initial wait")	;initial wait for REPL
    (return repldata)		 ;return something to succeed the mode
    ))

(definstance repl_mode
  class_melt_mode
  :named_name '"repl"
  :meltmode_help '"interactive Read Eval Print Loop mode"
  :meltmode_fun repl_docmd
)
(install_melt_mode repl_mode)
;; eof xtramelt-ana-simple.melt
