;; file warmelt-moremacro.melt -*- Lisp -*-
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(comment "***
    Copyright 2008 - 2013 Free Software Foundation, Inc.
    Contributed by Basile Starynkevitch <basile@starynkevitch.net>

    This file is part of GCC.

    GCC is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.

    GCC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.
***")

;; the copyright notice above apply both to warmelt-moremacro.melt and 
;; to the generated files warmelt-moremacro*.c
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;    This file is part of a bootstrapping compiler for the MELT lisp
;;    dialect, compiler which should be able to compile itself (into
;;    generated C file[s])
;;    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; this file should define macros which are used only later in
;; warmelt* files...

;; the each_component_in_list macro has to be in a file after the
;; expand_tuple_slice_as_tuple function

(defmacro each_component_in_list (sexp env mexpander modctx)
  :doc #{Macro $EACH_COMPONENT_IN_LIST to be invoked with a
  list-giving @var{expr} and a local variable @var{compvar} expands into
  @code{(foreach_pair_component_in_list (@var{expr}) 
					(@var{curpairvar} @var{compvar}) @var{body...})} 
  where @var{curpairvar} is fresh.}#
  (debug "each_component_in_list macro sexp=" sexp "\n env=" debug_less env)
  (let (
	(sloc (get_field :loca_location sexp))
	(sexcont (get_field :sexp_contents sexp))
	)
    (debug "each_component_in_list sloc=" debug_less sloc " sexcont=" sexcont)
    (assert_msg "check sexcont" (is_list sexcont) sexcont)
    (let ( 
	  (tcont (list_to_multiple sexcont discr_multiple))
	  (:long tcontlen (multiple_length tcont))
	  )
      (debug "each_component_in_list tcont=" tcont "; tcontlen=" tcontlen)
      (assert_msg "check tcont" (is_multiple tcont) tcont sexcont)
      (assert_msg "check tcontlen" (>i tcontlen 0) tcontlen tcont)
      (when (<i tcontlen 4)
	(error_plain sloc "EACH_COMPONENT_IN_LIST <expr-list> <var-comp> too short")
	(return () ()))
      (let ( 
	    (sexplist (let ( (se (multiple_nth tcont 1)) 
			     )
			(debug "each_component_in_list sexplist=" se)
			se))
	    (svarcomp  (let ( (sv (multiple_nth tcont 2))
			      )
			 (debug "each_component_in_list svarcomp=" sv)
			 sv))
	    (mlistexp (let ( (me (mexpander sexplist env mexpander modctx))
			     )
			(debug "each_component_in_list mlistexp=" me)
			me))
	    (mvarcomp  (let ( (mv (mexpander svarcomp env mexpander modctx))
			      )
			 (debug "each_component_in_list mvarcomp=" mv)
			 mv))
	    (bodyexp (progn 
		       (debug "each_component_in_list tcont=" tcont
			      "\n.. before expand_tuple_slice_as_tuple=" expand_tuple_slice_as_tuple)
		       (let ( (be (expand_tuple_slice_as_tuple tcont 3 -1 env mexpander modctx))
			      )
		       (debug "each_component_in_list bodyexp=" be)
		       be)))
	    )
	(when (is_not_a mvarcomp class_symbol)
	  (error_plain sloc "EACH_COMPONENT_IN_LIST <expr-list> <var-comp> bad second argument for component variable")
	  (return () ()))
	(with_cloned_symb 
	 (curpairinlistsymb)
	 (let ( (resexp
		 `(foreach_pair_component_in_list 
		   (,mlistexp)
		   (,curpairinlistsymb ,mvarcomp)
		   ,bodyexp))
		)
	   (debug "each_component_in_list resexp=" resexp)
	   (let ( (mexp (mexpander resexp env mexpander modctx))
		  )
	     (put_fields mexp :loca_location sloc)
	     (debug "each_component_in_list final mexp=" mexp)
	     (return mexp)
	     )
	   ))))))

(export_macro each_component_in_list)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun filtergccversion (versionstr)
  (assert_msg "check versionstr" (is_string versionstr) versionstr )
  (let ( (:long versionlen (string_length versionstr))
	 (res ())
	 )
    (code_chunk 
     filtergcc
     #{ if ($VERSIONLEN>0 /*$FILTERGCC*/
	    && !strncmp (melt_string_str((melt_ptr_t)$VERSIONSTR),
			 melt_gccversionstr,
			 $VERSIONLEN))
        $RES = $VERSIONSTR; 
	}#)
    (return res)))

(defun mexpand_gccif (sexpr env mexpander modctx)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr) sexpr)
  (assert_msg "check env" (is_a env class_environment) env)
  (debug "mexpand_gccif sexpr" sexpr)
  (let (
	(cont (unsafe_get_field :sexp_contents sexpr))
	(sloc  (unsafe_get_field :loca_location sexpr))
	(curpair (pair_tail (list_first cont)))
	(curif (pair_head curpair)) 
	(restpair (pair_tail curpair))
	)
    (if (is_a curif class_sexpr)
	(let ( (xcurif (get_field :sexp_contents curif))
	      )
	  (debug "mexpand_gccif xcurif=" xcurif)
	  (setq curif xcurif)
	  ))
    (debug "mexpand_gccif curif" curif)
    (cond 
     ((is_string curif)
      (if (filtergccversion curif)
	  (let ( (exprest (expand_pairlist_as_tuple restpair env mexpander modctx))
		 )
	    (debug "mexpand_gccif return exprest" exprest)
	    (return exprest))
	(progn
	  (debug "mexpand_gccif sexpr gcc version mismatched" sexpr)
	  (return))))
     ((is_list curif)
      (let ( (ok ())
	     )
	(foreach_pair_component_in_list 
	 (curif)
	 (curpair curstr)
	 (if (not (is_string curstr))
	     (error_plain sloc "GCCIF condition not a list of strings"))
	 (if (filtergccversion curstr)
	     (setq ok :true))
	 )
	(if ok
	  (let ( (exprest (expand_pairlist_as_tuple restpair env mexpander modctx))
		 )
	    (debug "mexpand_gccif return exprest multicond" exprest)
	    (return exprest))
	(progn
	  (debug "mexpand_gccif sexpr gcc version multicond mismatched" sexpr)
	  (return))))

	)
     (:else 
      (error_plain sloc "GCCIF bad condition, should be a string or a list of strings")
      (return)
     ))))

(install_initial_macro 'gccif mexpand_gccif)
(export_macro gccif mexpand_gccif
 :doc #{The $GCCIF macro expands the rest of the expression if the
version string of the GCC translating this MELT expression matches
the condition. Syntax is ($GCCIF condition expr...), where the
condition is a string such as "4.7." or a list of strings.}#)


;;;; obsolete CONTAINER same as REFERENCE

(defun mexpandobsolete_container (sexpr env mexpander modctx)
  (debug "mexpandobsolete_container sexpr=" sexpr)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr) sexpr)
  (warning_plain (get_field :loca_location sexpr)
		 "obsolete use of CONTAINER in expression; use REFERENCE instead")
  (mexpand_reference sexpr env mexpander modctx))

(defun patexpandobsolete_container (sexpr env pctx)
  (debug "patexpandobsolete_container sexpr=" sexpr)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr) sexpr)
  (warning_plain (get_field :loca_location sexpr)
		 "obsolete use of CONTAINER in pattern; use REFERENCE instead")
  (patexpand_reference sexpr env pctx))
  
(install_initial_patmacro 'container patexpandobsolete_container mexpandobsolete_container)
(export_patmacro container patexpandobsolete_container mexpandobsolete_container
 :doc #{The $CONTAINER syntax for expressions or patterns is obsolete. Use $REFERENCE instead}#)


;; eof warmelt-moremacro.melt
