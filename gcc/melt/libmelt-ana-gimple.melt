;; -*- Lisp -*-
;; file libmelt-ana-gimple.melt
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(comment "***
    Copyright 2008 - 2016  Free Software Foundation, Inc.
    Contributed by Basile Starynkevitch <basile@starynkevitch.net>
                and Jeremie Salvucci  <jeremie.salvucci@free.fr>
                and Pierre Vittet  <piervit@pvittet.com>
                and Romain Geissler  <romain.geissler@gmail.com>

    This file libmelt-ana-gimple.{melt,cc} is part of GCC.

    GCC is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.

    GCC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.
***")

;; the copyright notice above apply both to libmelt-ana-gimple.melt and 
;; to the generated file  libmelt-ana-gimple*.c

;; This MELT module is GPL compatible since it is GPLv3+ licensed.
(module_is_gpl_compatible "GPLv3+")


;;;****************************************************************
;; list of still unhandled GIMPLE codes from gimple.def
;; GIMPLE_OMP_ATOMIC_LOAD
;; GIMPLE_OMP_ATOMIC_STORE
;; GIMPLE_OMP_CONTINUE
;; GIMPLE_OMP_CRITICAL
;; GIMPLE_OMP_FOR
;; GIMPLE_OMP_MASTER
;; GIMPLE_OMP_TASKGROUP
;; GIMPLE_OMP_ORDERED
;; GIMPLE_OMP_PARALLEL
;; GIMPLE_OMP_TASK
;; GIMPLE_OMP_RETURN
;; GIMPLE_OMP_SECTION
;; GIMPLE_OMP_SECTIONS
;; GIMPLE_OMP_SECTIONS_SWITCH
;; GIMPLE_OMP_SINGLE
;; GIMPLE_OMP_TARGET
;; GIMPLE_OMP_TEAMS
;;;****************************************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; gimple related primitives

(defprimitive is_gimple (v) :long
   :doc #{Test if value $V is a boxed gimple.}#
   #{(melt_magic_discr((melt_ptr_t)($v)) == MELTOBMAG_GIMPLE)}# )

(defprimitive make_gimple (discr :gimple g) :value
  :doc #{Make a boxed gimple of given $DISCR and gimple $G.}#
  #{(meltgc_new_gimple((meltobject_ptr_t)($discr),($g)))}# )

(defprimitive gimple_content (v) :gimple
  :doc #{Retrieve the gimple stuff inside boxed gimple $V or else NULL}#
  #{(melt_gimple_content((melt_ptr_t)($v)))}# )

(defprimitive ==g (:gimple g1 g2) :long
  :doc #{Equality of gimples $G1 & $G2}#
  #{(($g1) == ($g2))}#)

(defprimitive null_gimple () 
  :gimple 
  :doc #{The null gimple.}#
   #{((melt_gimpleptr_t)NULL)}#)

(defprimitive gimple_seq_of_basic_block (:basic_block bb) :gimple_seq
  :doc #{Retrieve the gimple seq inside basic block $BB or null.}#
  #{(($bb)?bb_seq(($bb)):NULL)}#)

(defprimitive gimple_seq_first_stmt (:gimple_seq gs) :gimple
  :doc #{Retrieve the first gimple inside basic block $BB or null.}#
  #{(($GS)?gimple_seq_first_stmt(($GS)):NULL)}#)

(defprimitive gimple_seq_last_stmt (:gimple_seq gs) :gimple
  :doc #{Retrieve the last gimple inside basic block $BB or null.}#
  #{(($GS)?gimple_seq_last_stmt(($GS)):NULL)}#)

;;; copy an unboxed gimple_copy
(defprimitive gimple_copy (:gimple g) :gimple
  :doc #{Copy gimple stuff $G.}#
  #{ (($g)?gimple_copy($g):NULL) }#)

;;;;;;;;;;;;;;;; map associating GCC gimple-s to non-null MELT values
(defprimitive is_mapgimple (map) :long
  :doc #{Test if $MAP is a map of gimples.}#
  #{ (melt_magic_discr((melt_ptr_t)($map)) == MELTOBMAG_MAPGIMPLES) }#)
(defprimitive mapgimple_size (map) :long
  :doc #{Give the allocated size of a map of gimples $MAP.}#
 #{ (melt_size_mapgimples((struct meltmapgimples_st*)($map))) }#)
;; primitive to get the attribute count of a mapgimple
(defprimitive mapgimple_count (map) :long
  :doc #{Give the used count of a map of gimples $MAP.}#
  #{ (melt_count_mapgimples((struct meltmapgimples_st*)($map))) }# )
;; get an entry in a mapgimple from a C gimple
(defprimitive mapgimple_get (map :gimple g) :value
  :doc #{Safely get the value associated to gimple $G in map of gimples $MAP.}#
  #{(melt_get_mapgimples((melt_ptr_t) ($MAP), ($G)))}#)
;; primitive for making a new map of gimples
(defprimitive make_mapgimple (discr :long len) :value
  :doc #{Make a map of gimple keys of given $DISCR and $LEN.}#
 #{(meltgc_new_mapgimples((meltobject_ptr_t) ($discr), ($len)))}#)
;; primitive for putting into a map of gimples
(defprimitive mapgimple_put (map :gimple gkey :value val) :void
  :doc #{Safely put in map of gimple $MAP the gimple key $GKEY associated to $VAL.}#
  #{melt_put_mapgimples((melt_ptr_t) ($MAP), 
			($GKEY), (melt_ptr_t) ($VAL))}#)

;; primitive for removing from a map of gimples
(defprimitive mapgimple_remove (map :gimple gkey) :void
  :doc #{Safely remove in map of gimple $MAP the entry for gimple key $GKEY.}#
  #{melt_remove_mapgimples((melt_ptr_t)($MAP), ($GKEY))}#)

;; get the auxiliary data from map of gimples
(defprimitive mapgimple_aux (map) :value
  :doc #{Safely retrieve the auxiliary data of map of gimples $MAP.}#
  #{melt_auxdata_mapgimples((melt_ptr_t)$MAP)}#)

;; put the auxiliary data in map of gimples
(defprimitive mapgimple_auxput (map aux) :void
  :doc #{Safely put the auxiliary data of map of gimples $MAP as $AUX.}#
  #{melt_auxput_mapgimples((melt_ptr_t)$MAP,(melt_ptr_t)$AUX)}#)

;; primitive to get the nth gimple of a mapgimple
(defprimitive mapgimple_nth_attr (map :long n) :gimple
  #{(melt_nthattr_mapgimples((struct meltmapgimples_st*)($map), (int)($n)))}#)

;; primitive to get the nth value of a mapobject
(defprimitive mapgimple_nth_val (map :long n) :value
  #{(melt_nthval_mapgimples((struct meltmapgimples_st*)($map), (int)($n)))}# )
;; iterator inside mapgimple
(defciterator foreach_mapgimple 
  (gimap)				; startformals
  eachgimap 				;state symbol
  (:gimple att :value val)	;local formals
  :doc #{Iterate inside the $GIMAP value -a map from gimples to values- for each gimple $ATT and value $VAL.}#
  ;; before expansion
  #{
   /* foreach_mapgimple $EACHGIMAP*/ int $EACHGIMAP#_rk=0;
   for ($EACHGIMAP#_rk=0;
        $EACHGIMAP#_rk < (int)melt_size_mapgimples((struct meltmapgimples_st*)($GIMAP));
	$EACHGIMAP#_rk++) {
   $ATT = (melt_gimpleptr_t) NULL;
   $VAL = NULL;
   melt_gimpleptr_t $EACHGIMAP#_gi = ((struct meltmapgimples_st*)($GIMAP))->entab[$EACHGIMAP#_rk].e_at;
   if (!$EACHGIMAP#_gi 
       || (void*) $EACHGIMAP#_gi ==  (void*) HTAB_DELETED_ENTRY) continue;
   $ATT = $EACHGIMAP#_gi;
   $VAL = ((struct meltmapgimples_st*)($GIMAP))->entab[$EACHGIMAP#_rk].e_va;
   }#
  ;;after expansion
   #{
   } /*end  foreach_mapgimple $EACHGIMAP*/
   $ATT = (melt_gimpleptr_t) NULL;
   $VAL = NULL;
   }#
  )


;; match a gimple value & extract the gimple of it
(defcmatcher gimpleval
  (gv)					;match & no ins
  (:gimple g) 				;outs
  gimpsta				;statesymb
  :doc #{Match a gimple boxed value $GV and extract its gimple stuff $G.
 As operator, build a boxed gimple from $G.}#
  ;; test expansion
  #{ (melt_magic_discr((melt_ptr_t)($gv)) == MELTOBMAG_GIMPLE) }#
  ;; fill expansion
  #{ $g = melt_gimple_content(((melt_ptr_t)($gv)));
  }#
  ;; operator expansion
  #{ (meltgc_new_gimple((meltobject_ptr_t)NULL, ($g))) }#
)

;; match a gimple at a known location and extract its location 
(defcmatcher gimple_at_source_location 
  (:gimple g)
  (:value filepathv
   :long line
   :long col)
  gimpleatloc
  :doc #{$GIMPLE_AT_SOURCE_LOCATION match a gimple with a known source
  location, extracting the cached $FILEPATHV string value and the
  $LINE and $COL info.}#
  ;; test expander
  #{/* gimple_at_source_location $GIMPLEATLOC ? */ (($G) 
    && gimple_has_location(($G))) }#
  ;; test filler 
  #{/* gimple_at_source_location $GIMPLEATLOC ! */ {
    source_location $GIMPLEATLOC#_sloc = gimple_location ($G);
     $FILEPATHV =
         meltgc_cached_string_path_of_source_location ($GIMPLEATLOC#_sloc);
     $LINE = LOCATION_LINE ($GIMPLEATLOC#_sloc);
     $COL = LOCATION_COLUMN ($GIMPLEATLOC#_sloc);
  } /* end gimple_at_source_location $GIMPLEATLOC ! */}#)

  


;; match a gimple assign to something
(defcmatcher gimple_assign_to 
  (:gimple ga)				;match
  ;; outputs
  (:tree lhs				;left hand side
	 )
  gimpassto
  :doc #{Match gimple $GA as some kind of assignment to $LHS.}#
  ;; test expansion
  #{/* gimple_assign_to $GIMPASSTO ?*/ ($GA && is_gimple_assign($GA)) }#
  ;; fill expansion
  #{/* gimple_assign_to $GIMPASSTO !*/ $LHS = gimple_assign_lhs ($GA);
  }#
  ;; no operator expansion
)

  

;; match or build a gimple single assign
(defcmatcher gimple_assign_single
  (:gimple ga)				;match
  ;; outputs
  (:tree lhs				;left hand side
   :tree rhs				;first right operand
  )
  gimpassi
  :doc #{Match gimple $GA as a single assign into tree $LHS of tree $RHS, or build such an assign.}#
  ;; test expansion
  #{/* gimple_assign_single $gimpassi test*/ ($ga && gimple_assign_single_p ($ga))}#
  ;;fill expansion
  #{/* gimple_assign_single $gimpassi fill*/
   $lhs = gimple_assign_lhs($ga);
   $rhs = gimple_assign_rhs1($ga);
   }#
  ;; operator expansion
  #{/* gimple_assign_single:*/ ($LHS != NULL_TREE && $RHS != NULL_TREE)?gimple_build_assign(($LHS),($RHS)):((melt_gimpleptr_t)0)}#
)


;; match a gimple cast assign
(defcmatcher gimple_assign_cast
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs				;first right operand
  )					;outs
  gimpascs
  :doc #{Match gimple $GA as a casting assign into tree $LHS of tree $RHS. 
See also $GIMPLE_BUILD_ASSIGN_CONVERT, $GIMPLE_BUILD_ASSIGN_VIEW_CONVERT, $GIMPLE_BUILD_ASSIGN_FLOAT.}#
  ;;test expansion
  #{/* gimple_assign_cast $GIMPASCS test*/($ga && gimple_assign_cast_p ($ga))}#
  ;;fill expansion
  #{/* gimple_assign_cast $GIMPASCS fill*/
   $lhs = gimple_assign_lhs($ga);
   $rhs = gimple_assign_rhs1($ga);
  }#
)

(defprimitive gimple_build_assign_convert (:tree tlhs trhs) :gimple
  :doc #{Build a gimple to assign and convert to $TLHS the tree $TRHS, if both are non-null.}#
  #{ /*gimple_build_assign_convert*/ ($TLHS != (tree)0 
					    && $TRHS != (tree)0)
  ?
   gimple_build_assign (($TLHS), CONVERT_EXPR, $(TRHS))
  :((melt_gimpleptr_t)0)
  }#
)

(defprimitive gimple_build_assign_view_convert (:tree tlhs trhs) :gimple
  :doc #{Build a gimple to assign and view convert to $TLHS the tree $TRHS, if both are non-null.}#
  #{/*gimple_build_assign_view_convert*/ ($TLHS != (tree)0 
						&& $TRHS != (tree)0)
  ?
  gimple_build_assign (($TLHS), VIEW_CONVERT_EXPR, ($TRHS))
  :((melt_gimpleptr_t)0)}#
)

(defprimitive gimple_build_assign_fix_trunc (:tree tlhs trhs) :gimple
  :doc #{Build a gimple to assign and fixed truncation to $TLHS the tree $TRHS, if both are non-null.}#
  #{/*gimple_build_assign_fix_trunc*/ ($TLHS != (tree)0
					     && $TRHS != (tree)0)
  ?
  gimple_build_assign (($TLHS), FIX_TRUNC_EXPR, ($TRHS))
  :((melt_gimpleptr_t)0)}#
)


(defprimitive gimple_build_assign_float (:tree tlhs trhs) :gimple
  :doc #{Build a gimple to assign the conversion to float $TLHS the tree $TRHS, if both are non-null.}#
  #{/*gimple_build_assign_float:*/ ($TLHS != (tree)0 
					  && $TRHS != (tree)0)
  ?
  gimple_build_assign (($TLHS), FLOAT_EXPR, ($TRHS))
  :((melt_gimpleptr_t)0)}#
)

;; match a gimple copy assign
(defcmatcher gimple_assign_copy
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs				;first right operand
  )					;outs
  gimpasscopy
  :doc #{$GIMPLE_ASSIGN_COPY match a copy assignment into $LHS or $RHS.}#
  ;;test expansion
  #{/*gimple_assign_copy $GIMPASSCOPY ? */ ($GA && gimple_assign_copy_p ($GA))}#
  ;;fill expansion
  #{/*gimple_assign_copy $GIMPASSCOPY ! */ 
   $lhs = gimple_assign_lhs($GA);
   $rhs = gimple_assign_rhs1($GA);
  }#
)

;; match a gimple copy assign with ssa name
(defcmatcher gimple_assign_ssa_name_copy
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs				;first right operand
  )					;outs
  gimpasssacopy
  :doc #{$GIMPLE_ASSIGN_SSA_NAME_COPY match a copy assignment with both $LHS and $RHS being SSA.}#
  ;;test expansion
   #{/*gimple_assign_ssa_name_copy $GIMPASSSACOPY ? */ ($GA 
      && gimple_assign_ssa_name_copy_p ($GA))}#
  ;;fill expansion
   #{/*gimple_assign_ssa_name_copy $GIMPASSSACOPY ! */ 
   $LHS = gimple_assign_lhs($GA);
   $RHS = gimple_assign_rhs1($GA);
   }#
)

;; match a gimple unary nop assign
(defcmatcher gimple_assign_unary_nop
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs				;first right operand
  )					;outs
  gimpasg
  :doc #{$GIMPLE_ASSIGN_UNARY_NOP match or build an unary nop assign into $LHS of $RHS.}# 
  ;;test expansion
  #{/*gimple_assign_unary_nop $GIMPASG ?*/ ($GA
     && gimple_assign_unary_nop_p ($GA))}#
  ;;fill expansion
  #{/*gimple_assign_unary_nop $GIMPASG !*/ 
   $lhs = gimple_assign_lhs($ga);
   $rhs = gimple_assign_rhs1($ga);
  }#
  ;; operator expansion
  #{ /* gimple_assign_unary_nop: */
  gimple_build_assign (($LHS), NOP_EXPR, ($RHS))
  }#
)

;;; match a gimple assign with unary negation X = -Y
(defcmatcher gimple_assign_negate
  (:gimple ga)
  (:tree lhs
   :tree rhs)
  gaum
  :doc #{$GIMPLE_ASSIGN_NEGATE match or build an unary negate assign into $LHS of $RHS.}# 
  ;; test
  #{ /* gimple_assign_negate $GAUM ? */ ($GA 
     && gimple_expr_code ($GA) == NEGATE_EXPR)
  }#
  ;; fill
  #{ /* gimple_assign_negate $GAUM ! */
       $LHS = gimple_assign_lhs ($GA);
       $RHS = gimple_assign_rhs1 ($GA);
  }#
  ;; operator expansion
  #{/*gimple_assign_negate:*/
  gimple_build_assign (($LHS), NEGATE_EXPR, ($RHS))
  }#
  )

;;; match a gimple assign with unary float conversion X = (float)Y
(defcmatcher gimple_assign_float
  (:gimple ga)
  (:tree lhs
   :tree rhs)
  gauf
  :doc #{$GIMPLE_ASSIGN_FLOAT match or build an unary float conversion assign into $LHS of $RHS.}# 
  ;; test
  #{ /* gimple_assign_float $GAUF ? */ ($GA 
     && gimple_expr_code ($GA) == FLOAT_EXPR)
  }#
  ;; fill
  #{ /* gimple_assign_float $GAUF ! */
       $LHS = gimple_assign_lhs ($GA);
       $RHS = gimple_assign_rhs1 ($GA);
  }#
  ;; operator expansion
  #{/*gimple_assign_float:*/
  gimple_build_assign (($LHS), FLOAT_EXPR, ($RHS))
  }#
  )

;;; match a gimple assign absolute value X = abs(Y)
(defcmatcher gimple_assign_abs
  (:gimple ga)
  (:tree lhs
   :tree rhs)
  gaua
  :doc #{$GIMPLE_ASSIGN_ABS match or build an unary float conversion assign into $LHS of $RHS.}# 
  ;; test
  #{ /* gimple_assign_abs $GAUA ? */ ($GA 
                  && gimple_expr_code ($GA) == ABS_EXPR)
  }#
  ;; fill
  #{ /* gimple_assign_abs $GAUA ! */
       $LHS = gimple_assign_lhs ($GA);
       $RHS = gimple_assign_rhs1 ($GA);
  }#
  ;; operator expansion
  #{/*gimple_assign_abs:*/
  gimple_build_assign (($LHS), ABS_EXPR, ($RHS))
  }#
  )

;;; match a gimple assign with barrier parenthesis X = (Y)
(defcmatcher gimple_assign_paren
  (:gimple ga)
  (:tree lhs
   :tree rhs)
  gaup
  :doc #{$GIMPLE_ASSIGN_PAREN match or build a barrier parenthesis assign into $LHS of $RHS.}# 
  ;; test
  #{ /* gimple_assign_paren $GAUP ? */ ($GA 
                  && gimple_expr_code ($GA) == PAREN_EXPR)
  }#
  ;; fill
  #{ /* gimple_assign_paren $GAUP ! */
       $LHS = gimple_assign_lhs ($GA);
       $RHS = gimple_assign_rhs1 ($GA);
  }#
  ;; operator expansion
  #{/*gimple_assign_paren:*/
  gimple_build_assign (($LHS), PAREN_EXPR, ($RHS))
  }#
  )

;;; match a gimple assign with conversion X = convert(Y)
(defcmatcher gimple_assign_convert
  (:gimple ga)
  (:tree lhs
   :tree rhs)
  gauc
  :doc #{$GIMPLE_ASSIGN_CONVERT match or build a conversion assign into $LHS of $RHS.}# 
  ;; test
  #{ /* gimple_assign_convert $GAUC ? */ ($GA 
                  && gimple_expr_code ($GA) == CONVERT_EXPR)
  }#
  ;; fill
  #{ /* gimple_assign_convert $GAUC ! */
       $LHS = gimple_assign_lhs ($GA);
       $RHS = gimple_assign_rhs1 ($GA);
  }#
  ;; operator expansion
  #{/*gimple_assign_convert:*/
  gimple_build_assign (($LHS), CONVERT_EXPR, ($RHS))
  }#
  )

;;; match a gimple assign with address space conversion X = adconvert(Y)
(defcmatcher gimple_assign_addr_space_convert
  (:gimple ga)
  (:tree lhs
   :tree rhs)
  gauc
  :doc #{$GIMPLE_ASSIGN_ADDR_SPACE_CONVERT match or build an address space conversion assign into $LHS of $RHS.}# 
  ;; test
  #{ /* gimple_assign_addr_space_convert $GAUC ? */ ($GA 
                  && gimple_expr_code ($GA) == ADDR_SPACE_CONVERT_EXPR)
  }#
  ;; fill
  #{ /* gimple_assign_addr_space_convert $GAUC ! */
       $LHS = gimple_assign_lhs ($GA);
       $RHS = gimple_assign_rhs1 ($GA);
  }#
  ;; operator expansion
  #{/*gimple_assign_addr_space_convert:*/
  gimple_build_assign (($LHS), ADDR_SPACE_CONVERT_EXPR, ($RHS))
  }#
  )

;;; match a gimple assign with fixedpoint conversion X = fixconvert(Y)
(defcmatcher gimple_assign_fixed_convert
  (:gimple ga)
  (:tree lhs
   :tree rhs)
  gauc
  :doc #{$GIMPLE_ASSIGN_FIXED_CONVERT match or build a fixed-point conversion assign into $LHS of $RHS.}# 
  ;; test
  #{ /* gimple_assign_fixed_convert $GAUC ? */ ($GA 
                  && gimple_expr_code ($GA) == FIXED_CONVERT_EXPR)
  }#
  ;; fill
  #{ /* gimple_assign_fixed_convert $GAUC ! */
       $LHS = gimple_assign_lhs ($GA);
       $RHS = gimple_assign_rhs1 ($GA);
  }#
  ;; operator expansion
  #{/*gimple_assign_fixed_convert:*/
  gimple_build_assign (($LHS), FIXED_CONVERT_EXPR, ($RHS))
  }#
  )


;;; match a gimple assign with nop conversion X = nopconvert(Y)
(defcmatcher gimple_assign_nop
  (:gimple ga)
  (:tree lhs
   :tree rhs)
  gauc
  :doc #{$GIMPLE_ASSIGN_NOP match or build a no-op conversion assign into $LHS of $RHS.}# 
  ;; test
  #{ /* gimple_assign_nop $GAUC ? */ ($GA 
                  && gimple_expr_code ($GA) == NOP_EXPR)
  }#
  ;; fill
  #{ /* gimple_assign_nop $GAUC ! */
       $LHS = gimple_assign_lhs ($GA);
       $RHS = gimple_assign_rhs1 ($GA);
  }#
  ;; operator expansion
  #{/*gimple_assign_nop:*/
  gimple_build_assign (($LHS), NOP_EXPR, ($RHS))
  }#
  )

;;; match a gimple assign with bitwise not X = ~Y
(defcmatcher gimple_assign_bit_not
  (:gimple ga)
  (:tree lhs
   :tree rhs)
  gabnot
  :doc #{$GIMPLE_ASSIGN_BIT_NOT match or build an unary bitwise not assign into $LHS of $RHS.}# 
  ;; test
  #{ /* gimple_assign_unary_bit_not $GABNOT ? */ ($GA 
     && gimple_expr_code ($GA) == BIT_NOT_EXPR)
  }#
  ;; fill
  #{ /* gimple_assign_bit_not $GABNOT ! */
       $LHS = gimple_assign_lhs ($GA);
       $RHS = gimple_assign_rhs1 ($GA);
  }#
  ;; operator expansion
  #{/*gimple_assign_bit_not:*/
  gimple_build_assign (($LHS), BIT_NOT_EXPR, ($RHS))
  }#
  )

;;;; match a gimple assign with addition ie X = Y + Z
(defcmatcher gimple_assign_plus
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gasplus
  :doc #{$GIMPLE_ASSIGN_PLUS match or build addition into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{/*gimple_assign_plus $GASPLUS ?*/ ($GA
     && is_gimple_assign($GA) && gimple_expr_code($GA) == PLUS_EXPR)}#
  ;; fill
  #{/*gimple_assign_plus $GASPLUS !*/ 
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
   #{/*gimple_assign_plus:*/
  gimple_build_assign (($LHS), PLUS_EXPR, ($RHS1), ($RHS2))
   }#
)


;;;; match a gimple assign with substraction ie X = Y - Z
(defcmatcher gimple_assign_minus
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gasminus
  :doc #{$GIMPLE_ASSIGN_MINUS match or build substraction into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{/*gimple_assign_minus $GASMINUS ?*/ ($ga && is_gimple_assign($ga) 
     && gimple_expr_code($ga) == MINUS_EXPR)}#
  ;; fill
  #{/*gimple_assign_minus $GASMINUS !*/ 
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
   #{/*gimple_assign_minus:*/
  gimple_build_assign (($LHS), MINUS_EXPR, ($RHS1), ($RHS2))
}#
)


;;;; match a gimple assign with minimum ie X = MIN(Y,  Z)
(defcmatcher gimple_assign_min
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gasmin
  :doc #{$GIMPLE_ASSIGN_MIN match or build minimum into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{/*gimple_assign_min $GASMIN ?*/ ($ga && is_gimple_assign($ga) 
     && gimple_expr_code($ga) == MIN_EXPR)}#
  ;; fill
  #{/*gimple_assign_min $GASMIN !*/ 
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
   #{/*gimple_assign_min:*/
  gimple_build_assign (($LHS), MIN_EXPR, ($RHS1), ($RHS2))
   }#
)

;;;; match a gimple assign with maximum ie X = MAX(Y,  Z)
(defcmatcher gimple_assign_max
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gasmax
  :doc #{$GIMPLE_ASSIGN_MAX match or build maximum into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{/*gimple_assign_max $GASMAX ?*/ ($ga && is_gimple_assign($ga) 
     && gimple_expr_code($ga) == MAX_EXPR)}#
  ;; fill
  #{/*gimple_assign_max $GASMAX !*/ 
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
   #{/*gimple_assign_max:*/
  gimple_build_assign (($LHS), MAX_EXPR, ($RHS1), ($RHS2))
   }#
)


;;bitwise shift
;;;; match a gimple assign with leftshift ie X = Y lshift Z 
(defcmatcher gimple_assign_lshift
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gaslsh
  :doc #{$GIMPLE_ASSIGN_LSHIFT match or build bitwise leftshift into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{/*gimple_assign_lshift $GASLSH ?*/ ($ga && is_gimple_assign($ga) 
     && gimple_expr_code($ga) == LSHIFT_EXPR)}#
  ;; fill
  #{/*gimple_assign_lshift $GASLSH !*/ 
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
   #{/*gimple_assign_lshift:*/
  gimple_build_assign (($LHS), LSHIFT_EXPR, ($RHS1), ($RHS2))
   }#
)


;;;; match a gimple assign with rightshift ie X = Y lshift Z 
(defcmatcher gimple_assign_rshift
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gasrsh
  :doc #{$GIMPLE_ASSIGN_RSHIFT match or build bitwise rightshift into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{/*gimple_assign_rshift $GASRSH ?*/ ($ga && is_gimple_assign($ga) 
     && gimple_expr_code($ga) == RSHIFT_EXPR)}#
  ;; fill
  #{/*gimple_assign_rshift $GASRSH !*/ 
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
   #{/*gimple_assign_rshift:*/
  gimple_build_assign (($LHS), RSHIFT_EXPR, ($RHS1), ($RHS2))
   }#
)


;; bitwise rotation
;;;; match a gimple assign with leftrotation ie X = Y lrotate Z 
(defcmatcher gimple_assign_lrotate
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gaslro
  :doc #{$GIMPLE_ASSIGN_LROTATE match or build bitwise leftrotate into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{/*gimple_assign_lrotate $GASLRO ?*/ ($ga && is_gimple_assign($ga) 
     && gimple_expr_code($ga) == LROTATE_EXPR)}#
  ;; fill
  #{/*gimple_assign_lrotate $GASLRO !*/ 
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
   #{/*gimple_assign_lrotate:*/
  gimple_build_assign (($LHS), LROTATE_EXPR, ($RHS1), ($RHS2))
   }#
)


;;;; match a gimple assign with rightshift ie X = Y lshift Z 
(defcmatcher gimple_assign_rrotate
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gasrro
  :doc #{$GIMPLE_ASSIGN_RROTATE match or build bitwise rightrotate into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{/*gimple_assign_rrotate $GASRRO ?*/ ($ga && is_gimple_assign($ga) 
     && gimple_expr_code($ga) == RROTATE_EXPR)}#
  ;; fill
  #{/*gimple_assign_rrotate $GASRRO !*/ 
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
   #{/*gimple_assign_rrotate:*/
  gimple_build_assign (($LHS), RROTATE_EXPR, ($RHS1), ($RHS2))
 }#
)

;; bitwise and, or, xor

(defcmatcher gimple_assign_bit_ior
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gasbior
  :doc #{$GIMPLE_ASSIGN_BIT_IOR match or build bitwise inclusive-or into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{/*gimple_assign_bit_ior $GASBIOR ?*/ ($ga && is_gimple_assign($ga) 
     && gimple_expr_code($ga) == BIT_IOR_EXPR)}#
  ;; fill
  #{/*gimple_assign_bit_ior $GASBIOR !*/ 
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
   #{/*gimple_assign_bit_ior:*/
  gimple_build_assign (($LHS), BIT_IOR_EXPR, ($RHS1), ($RHS2))
   }#
)

(defcmatcher gimple_assign_bit_xor
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gasbxor
  :doc #{$GIMPLE_ASSIGN_BIT_XOR match or build bitwise exclusive-or into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{/*gimple_assign_bit_xor $GASBXOR ?*/ ($ga && is_gimple_assign($ga) 
     && gimple_expr_code($ga) == BIT_XOR_EXPR)}#
  ;; fill
  #{/*gimple_assign_bit_xor $GASBXOR !*/ 
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
   #{/*gimple_assign_bit_xor:*/
  gimple_build_assign (($LHS), BIT_XOR_EXPR, ($RHS1), ($RHS2))
   }#
)

(defcmatcher gimple_assign_bit_and
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gasband
  :doc #{$GIMPLE_ASSIGN_BIT_AND match or build bitwise and into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{/*gimple_assign_bit_and $GASBAND ?*/ ($ga && is_gimple_assign($ga) 
     && gimple_expr_code($ga) == BIT_AND_EXPR)}#
  ;; fill
  #{/*gimple_assign_bit_and $GASBAND !*/ 
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
   #{/*gimple_assign_bit_and:*/
  gimple_build_assign (($LHS), BIT_AND_EXPR, ($RHS1), ($RHS2))
  }#
)

;; pointer arithmetic
(defcmatcher gimple_assign_pointer_plus
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gaspplus
  :doc #{$GIMPLE_ASSIGN_POINTER_MINUS match or build pointer addition into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{/*gimple_assign_pointer_plus $GASPPLUS ?*/  $ga && is_gimple_assign($ga) 
     && gimple_expr_code($ga) == POINTER_PLUS_EXPR }#
  ;; fill
  #{/*gimple_assign_pointer_plus $GASPPLUS !*/  
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
  }# 
  ;; operator expansion
  #{/*gimple_assign_pointer_plus:*/
  gimple_build_assign (($LHS), POINTER_PLUS_EXPR, ($RHS1), ($RHS2))
  }#
)


;;;; match a gimple assign with multiplication ie X = Y * Z

(defcmatcher gimple_assign_mult
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gasmult
  :doc #{$GIMPLE_ASSIGN_MULT match or build multiplication into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{/*gimple_assign_mult $GASMULT ?*/ ($ga && is_gimple_assign($ga) 
     && gimple_expr_code($ga) == MULT_EXPR)}#
  ;; fill
  #{/*gimple_assign_mult $GASMULT !*/ 
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
   #{/*gimple_assign_mult:*/
  gimple_build_assign (($LHS), MULT_EXPR, ($RHS1), ($RHS2))
   }#
)

;;;; match a gimple assign with highpart multiplication ie X = HIGHPART(Y * Z)
(defcmatcher gimple_assign_mult_highpart
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gasmult
  :doc #{$GIMPLE_ASSIGN_MULT_HIGHPART match or build multiplication into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{/*gimple_assign_mult_highpart $GASMULT ?*/ ($ga && is_gimple_assign($ga) 
     && gimple_expr_code($ga) == MULT_EXPR)}#
  ;; fill
  #{/*gimple_assign_mult_highpart $GASMULT !*/ 
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
   #{/*gimple_assign_mult_highpart:*/
  gimple_build_assign (($LHS), MULT_HIGHPART_EXPR, ($RHS1), ($RHS2))
   }#
)

(defcmatcher gimple_assign_widen_mult
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gasmult
  :doc #{$GIMPLE_ASSIGN_WIDEN_MULT match or build a widening multiplication into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{/*gimple_assign_widen_mult $GASMULT ?*/ ($ga && is_gimple_assign($ga) 
     && gimple_expr_code($ga) == WIDEN_MULT_EXPR)}#
  ;; fill
  #{/*gimple_assign_widen_mult $GASMULT !*/ 
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
   #{/*gimple_assign_widen_mult:*/
  gimple_build_assign (($LHS), WIDEN_MULT_EXPR, ($RHS1), ($RHS2))
   }#
)



;;;; match a gimple assign with trunc division ie X = Y /trunc Z
(defcmatcher gimple_assign_trunc_div
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gastdiv
  :doc #{$GIMPLE_ASSIGN_TRUNC_DIV match or build truncated division into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{/*gimple_assign_trunc_div $GASTDIV ?*/ ($GA && is_gimple_assign($GA) && gimple_expr_code($GA) == TRUNC_DIV_EXPR)}#
  ;; fill
  #{/*gimple_assign_trunc_div $GASTDIV ?*/ 
   $LHS = gimple_assign_lhs($GA);
   $RHS1 = gimple_assign_rhs1($GA);
   $RHS2 = gimple_assign_rhs2($GA);
   }# 
  ;; operator expansion
   #{/*gimple_assign_trunc_div:*/
  gimple_build_assign (($LHS), TRUNC_DIV_EXPR, ($RHS1), ($RHS2))
   }#
)

;;;; match a gimple assign with ceil division ie X = Y /ceil Z
(defcmatcher gimple_assign_ceil_div
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gascdiv
  :doc #{$GIMPLE_ASSIGN_CEIL_DIV match or build ceiling division into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{/*gimple_assign_ceil_div $GASCDIV ?*/ ($GA && is_gimple_assign($GA) 
    && gimple_expr_code($GA) == CEIL_DIV_EXPR)}#
  ;; fill
  #{/*gimple_assign_ceil_div $GASCDIV !*/ 
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
   #{/*gimple_assign_ceil_div:*/
  gimple_build_assign (($LHS), CEIL_DIV_EXPR, ($RHS1), ($RHS2))
   }#
)

;;;; match a gimple assign with floor division ie X = Y /floor Z
(defcmatcher gimple_assign_floor_div
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gasfdiv
  :doc #{$GIMPLE_ASSIGN_FLOOR_DIV match or build floor division into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{/*gimple_assign_floor_div $GASFDIV ?*/ ($ga && is_gimple_assign($ga)
     && gimple_expr_code($ga) == FLOOR_DIV_EXPR)}#
  ;; fill
  #{/*gimple_assign_floor_div $GASFDIV !*/
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
   #{/*gimple_assign_floor_div: */
  gimple_build_assign (($LHS), FLOOR_DIV_EXPR, ($RHS1), ($RHS2))
   }#
)


;;;; match a gimple assign with round division ie X = Y /round Z
(defcmatcher gimple_assign_round_div
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gasrdiv
  :doc #{$GIMPLE_ASSIGN_ROUND_DIV match or build rounding division into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{/*gimple_assign_round_div $GASRDIV ?*/ ($ga && is_gimple_assign($ga) && gimple_expr_code($ga) == ROUND_DIV_EXPR)}#
  ;; fill
  #{/*gimple_assign_round_div $GASRDIV !*/ 
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
   #{/*gimple_assign_round_div:*/
  gimple_build_assign (($LHS), ROUND_DIV_EXPR, ($RHS1), ($RHS2))
   }#
)

;;;; match a gimple assign with real division ie X = Y /real Z
(defcmatcher gimple_assign_rdiv
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gasrediv
  :doc #{$GIMPLE_ASSIGN_RDIV match or build reaol division into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{/*gimple_assign_rdiv $GASREDIV ?*/ ($GA && is_gimple_assign($GA) 
    && gimple_expr_code($GA) == RDIV_EXPR)}#
  ;; fill
  #{/*gimple_assign_rdiv $GASREDIV !*/
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
   #{/*gimple_assign_rdiv:*/
  gimple_build_assign (($LHS), RDIV_EXPR, ($RHS1), ($RHS2))
   }#
)

;;;; match a gimple assign with exact division ie X = Y /exact Z
(defcmatcher gimple_assign_exact_div
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gasxdiv
  :doc #{$GIMPLE_ASSIGN_EXACT_DIV match or build exact division into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{/* gimple_assign_exact_div $GASXDIV ? */ ($ga &&
	 is_gimple_assign($ga) && gimple_expr_code($ga) == EXACT_DIV_EXPR)}#
  ;; fill
  #{/* gimple_assign_exact_div $GASXDIV ! */ 
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
   #{/*gimple_assign_exact_div:*/
  gimple_build_assign (($LHS), EXACT_DIV_EXPR, ($RHS1), ($RHS2))
   }#
)


;;;;;;;;;;;;;;;;
;;;; match a gimple assign with trunc remainder ie X = Y %trunc Z
(defcmatcher gimple_assign_trunc_mod
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gastmod
  :doc #{$GIMPLE_ASSIGN_TRUNC_MOD match or build truncated modulus into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{/*gimple_assign_trunc_mod $GASTMOD ?*/ ($GA && is_gimple_assign($GA) 
    && gimple_expr_code($GA) == TRUNC_MOD_EXPR)}#
  ;; fill
  #{/*gimple_assign_trunc_mod $GASTMOD !*/ 
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
   #{/*gimple_assign_trunc_mod:*/
  gimple_build_assign (($LHS), TRUNC_MOD_EXPR, ($RHS1), ($RHS2))
   }#
)

;;;; match a gimple assign with ceil remainder ie X = Y %ceil Z
(defcmatcher gimple_assign_ceil_mod
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gascmod
  :doc #{$GIMPLE_ASSIGN_CEIL_MOD match or build ceil modulus into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{/*gimple_assign_ceil_mod $GASCMOD ?*/ ($GA && is_gimple_assign($GA) 
    && gimple_expr_code($GA) == CEIL_MOD_EXPR)}#
  ;; fill
  #{/*gimple_assign_ceil_mod $GASCMOD !*/ 
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
   #{/*gimple_assign_ceil_mod:*/
  gimple_build_assign (($LHS), CEIL_MOD_EXPR, ($RHS1), ($RHS2))
}#
)

;;;; match a gimple assign with floor remainder ie X = Y %floor Z
(defcmatcher gimple_assign_floor_mod
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gasflomod
  :doc #{$GIMPLE_ASSIGN_FLOOR_MOD match or build floor modulus into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{/*gimple_assign_floor_mod $GASFLOMOD ?*/ ($ga && is_gimple_assign($ga)
     && gimple_expr_code($ga) == FLOOR_MOD_EXPR)}#
  ;; fill
  #{/*gimple_assign_floor_mod $GASFLOMOD !*/
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
   #{/*gimple_assign_floor_mod:*/
  gimple_build_assign (($LHS), FLOOR_MOD_EXPR, ($RHS1), ($RHS2))
   }#
)


;;;; match a gimple assign with round remainder ie X = Y %round Z
(defcmatcher gimple_assign_round_mod
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   )
  gasrmod
  :doc #{$GIMPLE_ASSIGN_ROUND_MOD match or build rounded modulus into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{/*gimple_assign_round_mod $GASRMOD ?*/ ($ga && is_gimple_assign($ga) 
   && gimple_expr_code($ga) == ROUND_MOD_EXPR)}#
  ;; fill
  #{/*gimple_assign_round_mod $GASRMOD !*/ 
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   }# 
  ;; operator expansion
   #{/*gimple_assign_round_mod:*/
  gimple_build_assign (($LHS), ROUND_MOD_EXPR, ($RHS1), ($RHS2))
   }#
)



;;; match a gimple assign binary op
(defcmatcher gimple_assign_binaryop
  (:gimple ga)				;match
  (:tree lhs				;left hand side
   :tree rhs1
   :tree rhs2
   :long opcode
   )
  gasbinop
  :doc #{$GIMPLE_ASSIGN_BINARYOP match or build a binary operator of $OPCODE into $LHS of $RHS1 and $RHS2.}#
  ;; test
  #{/* gimple_assign_binaryop $GASBINOP ?*/ ($ga
    && is_gimple_assign($ga) && gimple_num_ops($ga) >= 3)}#
  ;; fill
  #{/* gimple_assign_binaryop $GASBINOP !*/ 
   $lhs = gimple_assign_lhs($ga);
   $rhs1 = gimple_assign_rhs1($ga);
   $rhs2 = gimple_assign_rhs2($ga);
   $opcode = gimple_assign_rhs_code($ga);
   }# 
  ;; operator expansion
   #{/* gimple_assign_binaryop: */ 
  gimple_build_assign (($LHS), (enum tree_code) $OPCODE, ($RHS1), ($RHS2))
   }#
)


;;;;;;;;;;;;;;;;
;;; match any kind of gimple cond
(defcmatcher gimple_cond
  (:gimple gc)
  (:tree lhs rhs :long condcode)
  gimpcond
  :doc #{$GIMPLE_COND match a GIMPLE condition between $LHS and $RHS with the $CONDCODE long.}#
  ;; test
  #{/*gimple_cond $GIMPCOND ?*/ ($GC && (long)gimple_code($GC) == GIMPLE_COND) }#
  ;; fill
  #{/*gimple_cond $GIMPCOND !*/  $LHS = gimple_cond_lhs($GC);
   $RHS = gimple_cond_rhs($GC);
   $CONDCODE = gimple_cond_code($GC);
   }#
  ;; operator expansion
  #{/*gimple_cond:*/ ($CONDCODE>0 && $CONDCODE<(long)MAX_TREE_CODES
				  && TREE_CODE_CLASS($CONDCODE)== tcc_comparison)
  ? gimple_build_cond((enum tree_code)$CONDCODE, $LHS, $RHS, 
				       /*nolabels*/ NULL_TREE, NULL_TREE): (melt_gimpleptr_t) NULL}#)
  
	 
;;;;;;;;;;;;;;;;
;;; match a gimple cond less or equal
(defcmatcher gimple_cond_lessequal
  (:gimple gc)
  (:tree lhs 
   :tree rhs
   )
  gimpcondle
  :doc #{$GIMPLE_COND_LESSEQUAL match or build a <= condition between $LHS and $RHS.}#
  ;; test expansion
  #{/*gimple_cond_lessequal $GIMPCONDLE ? */ ($gc && gimple_code($gc)==GIMPLE_COND 
     && gimple_cond_code($gc)==LE_EXPR)}#
  ;; fill expansion
  #{/*gimple_cond_lessequal $GIMPCONDLE ! */ 
   $lhs = gimple_cond_lhs($gc);
   $rhs = gimple_cond_rhs($gc);
  }# 
  ;; operator expansion
  #{/*gimple_cond_lessequal:*/ gimple_build_cond(LE_EXPR, $LHS, $RHS, /*nolabels*/ NULL_TREE, NULL_TREE)}#
  )

;;; match a gimple cond less 
(defcmatcher gimple_cond_less
  (:gimple gc)
  (:tree lhs 
   :tree rhs
   )
  gimpcondle
  :doc #{$GIMPLE_COND_LESS match or build a < condition between $LHS and $RHS.}#
  ; test expansion
  #{/*gimple_cond_less $GIMPCONDLE ?*/ ($gc && gimple_code($gc)==GIMPLE_COND
     && gimple_cond_code($gc)==LT_EXPR)}#
  ;; fill expansion
  #{/*gimple_cond_less $GIMPCONDLE ! */
   $lhs = gimple_cond_lhs($gc);
   $rhs = gimple_cond_rhs($gc);
  }# 
  ;; operator expansion
  #{/*gimple_cond_less:*/ gimple_build_cond(LT_EXPR, $LHS, $RHS, /*nolabels*/ NULL_TREE, NULL_TREE)}#
)

;;;;;;;;;;;;;;;;
;;; match a gimple cond not equal
(defcmatcher gimple_cond_notequal
  (:gimple gc)
  (:tree lhs 
   :tree rhs
   )
  gimpcondne
  :doc #{$GIMPLE_COND_NOTEQUAL match or build a != condition between $LHS and $RHS.}#
  ;; test expansion
  #{/*gimple_cond_notequal $GIMPCONDNE ?*/ ($GC && gimple_code($GC)==GIMPLE_COND 
     && gimple_cond_code($GC)==NE_EXPR)}#
  ;; fill expansion
  #{/*gimple_cond_notequal $GIMPCONDNE !*/
   $LHS = gimple_cond_lhs($GC);
   $RHS = gimple_cond_rhs($GC);
  }#
  ;; operator expansion
  #{/*gimple_cond_notequal:*/ gimple_build_cond(NE_EXPR, $LHS, 
  $RHS, /*nolabels*/ NULL_TREE, NULL_TREE)}#
)

;;; match a gimple_cond equal
(defcmatcher gimple_cond_equal
  (:gimple gc)
  (:tree lhs
   :tree rhs)
  gimpcondeq
  :doc #{$GIMPLE_COND_EQUAL match or build a == condition between $LHS and $RHS.}#
  ;; test expansion
  #{/*gimple_cond_equal $GIMPCONDEQ ?*/  ($GC &&
	gimple_code ($GC) == GIMPLE_COND &&
	gimple_cond_code ($GC) == EQ_EXPR)
  }#
  ;; fill expansion
  #{/*gimple_cond_equal $GIMPCONDEQ !*/ 
       $lhs = gimple_cond_lhs ($gc);
       $rhs = gimple_cond_rhs ($gc);
  }#
  ;; operator expansion
  #{/*gimple_cond_equal:*/ gimple_build_cond(EQ_EXPR, $LHS, $RHS, 
    /*nolabels*/ NULL_TREE, NULL_TREE)}#
)

;;; match a gimple cond greater
(defcmatcher gimple_cond_greater
  (:gimple gc)
  (:tree lhs 
   :tree rhs
   )
  gimpcondgt
  :doc #{$GIMPLE_COND_GREATER match or build a > condition between $LHS and $RHS.}#
  ;; test expansion
  #{/*gimple_cond_greater $GIMPCONDGT ?*/ ($GC && gimple_code($GC)==GIMPLE_COND 
      && gimple_cond_code($GC)==GT_EXPR)}#
  ;; fill expansion
  #{/*gimple_cond_greater $GIMPCONDGT !*/ 
   $LHS = gimple_cond_lhs($GC);
   $RHS = gimple_cond_rhs($GC);
  }# 
  ;; operator expansion
  #{/*gimple_cond_greater:*/ gimple_build_cond(GT_EXPR, $LHS, $RHS, /*nolabels*/ NULL_TREE, NULL_TREE)}#
)

;;; match a gimple_cond greater or equal
(defcmatcher gimple_cond_greater_or_equal
  (:gimple gc)
  (:tree lhs
   :tree rhs)
  gimpcondge
  :doc #{$GIMPLE_COND_GREATER_OR_EQUAL match or build a >= condition between $LHS and $RHS.}#
  ;; test
  #{ /*gimple_cond_greater_or_equal $GIMPCONDGE ? */ ($GC && 
        gimple_code ($GC) == GIMPLE_COND && 
        gimple_cond_code ($GC) == GE_EXPR)
  }#
  ;; fill
  #{ /*gimple_cond_greater_or_equal $GIMPCONDGE ! */
       $lhs = gimple_cond_lhs ($GC);
       $rhs = gimple_cond_rhs ($GC);
  }#
  ;; operator expansion
  #{/*gimple_cond_greater_or_equal:*/ gimple_build_cond(GE_EXPR, $LHS, $RHS, /*nolabels*/ NULL_TREE, NULL_TREE)}#
)

;;;;;;;;;;;;;;;;
;;; match a gimple cond unordered
(defcmatcher gimple_cond_unordered
  (:gimple gc)
  (:tree lhs 
   :tree rhs
   )
  gimpcondunord
  :doc #{$GIMPLE_COND_UNORDERED match or build a unordered floating point condition between $LHS and $RHS.}#
  ;; test expansion
  #{/*gimple_cond_unordered $GIMPCONDUNORD ? */ ($GC && gimple_code($GC)==GIMPLE_COND 
     && gimple_cond_code($GC)==UNORDERED_EXPR)}#
  ;; fill expansion
  #{/*gimple_cond_unordered $GIMPCONDUNORD ! */ 
   $lhs = gimple_cond_lhs($GC);
   $rhs = gimple_cond_rhs($GC);
  }# 
  ;; operator expansion
  #{/*gimple_cond_unordered:*/ gimple_build_cond(UNORDERED_EXPR, $LHS, $RHS, /*nolabels*/ NULL_TREE, NULL_TREE)}#
  )

;;;;;;;;;;;;;;;;
;;; match a gimple cond ordered
(defcmatcher gimple_cond_ordered
  (:gimple gc)
  (:tree lhs 
   :tree rhs
   )
  gimpcondord
  :doc #{$GIMPLE_COND_ORDERED match or build a unordered floating point condition between $LHS and $RHS.}#
  ;; test expansion
  #{/*gimple_cond_unordered $GIMPCONDORD ? */ ($GC && gimple_code($GC)==GIMPLE_COND 
     && gimple_cond_code($GC)==ORDERED_EXPR)}#
  ;; fill expansion
  #{/*gimple_cond_unordered $GIMPCONDORD ! */ 
   $lhs = gimple_cond_lhs($GC);
   $rhs = gimple_cond_rhs($GC);
  }# 
  ;; operator expansion
  #{/*gimple_cond_ordered:*/ gimple_build_cond(ORDERED_EXPR, $LHS, $RHS, /*nolabels*/ NULL_TREE, NULL_TREE)}#
  )

;;;;;;;;;;;;;;;;
;;; match a gimple cond unlt
(defcmatcher gimple_cond_unlt
  (:gimple gc)
  (:tree lhs 
   :tree rhs
   )
  gimpcondunlt
  :doc #{$GIMPLE_COND_UNLT match or build a unordered or less than floating point condition between $LHS and $RHS.}#
  ;; test expansion
  #{/*gimple_cond_unlt $GIMPCONDUNLT ? */ ($GC && gimple_code($GC)==GIMPLE_COND 
     && gimple_cond_code($GC)==UNLT_EXPR)}#
  ;; fill expansion
  #{/*gimple_cond_unlt $GIMPCONDUNLT ! */ 
   $lhs = gimple_cond_lhs($GC);
   $rhs = gimple_cond_rhs($GC);
  }# 
  ;; operator expansion
  #{/*gimple_cond_unlt:*/ gimple_build_cond(UNLT_EXPR, $LHS, $RHS, 
   /*nolabels*/ NULL_TREE, NULL_TREE)}#
  )

;;;;;;;;;;;;;;;;
;;; match a gimple cond unle
(defcmatcher gimple_cond_unle
  (:gimple gc)
  (:tree lhs 
   :tree rhs
   )
  gimpcondunle
  :doc #{$GIMPLE_COND_UNLE match or build a unordered or less or equal floating point condition between $LHS and $RHS.}#
  ;; test expansion
  #{/*gimple_cond_unle $GIMPCONDUNLE ? */ ($GC && gimple_code($GC)==GIMPLE_COND 
     && gimple_cond_code($GC)==UNLE_EXPR)}#
  ;; fill expansion
  #{/*gimple_cond_unle $GIMPCONDUNLE ! */ 
   $lhs = gimple_cond_lhs($GC);
   $rhs = gimple_cond_rhs($GC);
  }# 
  ;; operator expansion
  #{/*gimple_cond_unle:*/ gimple_build_cond(UNLE_EXPR, $LHS, $RHS, 
    /*nolabels*/ NULL_TREE, NULL_TREE)}#
  )


;;;;;;;;;;;;;;;;
;;; match a gimple cond ungt
(defcmatcher gimple_cond_ungt
  (:gimple gc)
  (:tree lhs 
   :tree rhs
   )
  gimpcondungt
  :doc #{$GIMPLE_COND_UNGT match or build a unordered or greater than floating point condition between $LHS and $RHS.}#
  ;; test expansion
  #{/*gimple_cond_ungt $GIMPCONDUNGT ? */ ($GC && gimple_code($GC)==GIMPLE_COND 
     && gimple_cond_code($GC)==UNGT_EXPR)}#
  ;; fill expansion
  #{/*gimple_cond_ungt $GIMPCONDUNGT ! */ 
   $lhs = gimple_cond_lhs($GC);
   $rhs = gimple_cond_rhs($GC);
  }# 
  ;; operator expansion
  #{/*gimple_cond_ungt:*/ gimple_build_cond(UNGT_EXPR, $LHS, $RHS, 
    /*nolabels*/ NULL_TREE, NULL_TREE)}#
  )

;;;;;;;;;;;;;;;;
;;; match a gimple cond unge
(defcmatcher gimple_cond_unge
  (:gimple gc)
  (:tree lhs 
   :tree rhs
   )
  gimpcondunge
  :doc #{$GIMPLE_COND_UNGE match or build a unordered or greater or equal floating point condition between $LHS and $RHS.}#
  ;; test expansion
  #{/*gimple_cond_unge $GIMPCONDUNGE ? */ ($GC && gimple_code($GC)==GIMPLE_COND 
     && gimple_cond_code($GC)==UNGE_EXPR)}#
  ;; fill expansion
  #{/*gimple_cond_unge $GIMPCONDUNGE ! */ 
   $LHS = gimple_cond_lhs($GC);
   $RHS = gimple_cond_rhs($GC);
  }# 
  ;; operator expansion
  #{/*gimple_cond_unge:*/ gimple_build_cond(UNGE_EXPR, $LHS, $RHS, 
    /*nolabels*/ NULL_TREE, NULL_TREE)}#
  )


;;;;;;;;;;;;;;;;
;;; match a gimple cond uneq
(defcmatcher gimple_cond_uneq
  (:gimple gc)
  (:tree lhs 
   :tree rhs
   )
  gimpconduneq
  :doc #{$GIMPLE_COND_UNEQ match or build a unordered or unequal floating point
  condition between $LHS and $RHS.}#
  ;; test expansion
  #{/*gimple_cond_uneq $GIMPCONDUNEQ ? */ ($GC && gimple_code($GC)==GIMPLE_COND 
     && gimple_cond_code($GC)==UNEQ_EXPR)}#
  ;; fill expansion
  #{/*gimple_cond_uneq $GIMPCONDUNEQ ! */ 
   $LHS = gimple_cond_lhs($GC);
   $RHS = gimple_cond_rhs($GC);
  }# 
  ;; operator expansion
  #{/*gimple_cond_uneq:*/ gimple_build_cond(UNEQ_EXPR, $LHS, $RHS, /*nolabels*/ NULL_TREE, NULL_TREE)}#
  )

;;;;;;;;;;;;;;;;
;;; match a gimple cond ltgt
(defcmatcher gimple_cond_ltgt
  (:gimple gc)
  (:tree lhs 
   :tree rhs
   )
  gimpcondltgt
  :doc #{$GIMPLE_COND_LTGT match or build a less than or greater than floating point 
  condition reverse of $GIMPLE_COND_UNEQ between $LHS and $RHS.}#
  ;; test expansion
  #{/*gimple_cond_ltgt $GIMPCONDLTGT ? */ ($GC && gimple_code($GC)==GIMPLE_COND 
     && gimple_cond_code($GC) == LTGT_EXPR)}#
  ;; fill expansion
  #{/*gimple_cond_ltgt $GIMPCONDLTGT ! */ 
   $LHS = gimple_cond_lhs($GC);
   $RHS = gimple_cond_rhs($GC);
  }# 
  ;; operator expansion
  #{/*gimple_cond_ltgt:*/
  gimple_build_cond(LTGT_EXPR, $LHS, $RHS, /*nolabels*/ NULL_TREE, NULL_TREE)}#
  )



;; match a gimple cond true
(defcmatcher gimple_cond_true
  (:gimple gc)
  ()
  gimpcondtr
  :doc #{$GIMPLE_COND_TRUE match a gimple conditional $GC with an always true condition.}#
  ;;test
  #{/* gimple_cond_true $GIMPCONDTR ? */ ($GC && gimple_code($GC) == GIMPLE_COND 
    && gimple_cond_true_p
       (
	    static_cast <const gcond*>
	    ($GC)
       ))
  }#
  ;;fill
  #{ /* gimple_cond_true $GIMPCONDTR !*/
  }# )


;; match a gimple cond false
(defcmatcher gimple_cond_false
  (:gimple gc)
  ()
  gimpcondfa
  :doc #{$GIMPLE_COND_TRUE match a gimple conditional $GC with an always false condition.}#
  ;;test
  #{/*fimple_cond_false $gimpcondfa ?*/
  ($GC && gimple_code($GC)==GIMPLE_COND
       && gimple_cond_false_p
       (
	    static_cast <const gcond*> ($GC)
       ))
  }# )


;; rarely used pattern to extract the true & false labels. These are
;; often null!
(defcmatcher gimple_cond_with_true_false_labels
  (:gimple gc)
  (:tree truelab falselab)
  gimpcondtrlab
  :doc #{$GIMPLE_COND_WITH_TRUE_FALSE_LABELS match a gimple conditional $GC and
  extracts its true label $TRUELAB and false label $FALSELAB.}#
  ;; test
  #{/* gimple_cond_with_true_false_labels $gimpcondtrlab ?*/ ($gc && gimple_code($gc)==GIMPLE_COND)}#
  ;;fill
  #{/* gimple_cond_with_true_false_labels $gimpcondtrlab !*/
  $truelab = gimple_cond_true_label(
	    static_cast <const gcond*> ($GC)
				    );
  $falselab = gimple_cond_false_label(
	    static_cast <const gcond*> ($GC)
				      );
   }#
)

;; pattern to extract the true & false edges of a gimple_cond.
(defcmatcher gimple_cond_with_edges
  (:gimple gc)
  (:edge truedge falsedge)
  gimpcondtredges
  :doc #{$GIMPLE_COND_WITH_EDGES match a gimple conditional $GC and extracts 
  its true edge $TRUEDGE and false edge $FALSEDGE }#
  ;; test
  #{/*$gimpcondtredges ?*/  ($gc && gimple_code($gc)==GIMPLE_COND)}#
  ;;fill
  #{ /*$gimpcondtredges !*/
  extract_cond_bb_edges ((gimple_bb ($gc)), &($truedge), &($falsedge));
  }#)

;;; iterate on each argument of a call function
(defciterator foreach_argument_of_gimple_call
  (:gimple gcall)
  eaocf
  (:tree argument)
  :doc #{ $FOREACH_ARGUMENT_OF_GIMPLE_CALL iterates on each $ARGUMENT of gimple call $GCALL.}#
  #{
       /* foreach_argument_of_gimple_call before $EAOCF */
       int $EAOCF#_i = 0;
       $ARGUMENT = (tree)NULL;

       if ($GCALL &&  gimple_code($GCALL) == GIMPLE_CALL)
       {
           int $EAOCF#_n = gimple_call_num_args ($gcall);

           for ($EAOCF#_i = 0; 
		$EAOCF#_i < $EAOCF#_n; 
                $EAOCF#_i++)
           {
               $ARGUMENT = gimple_call_arg ($gcall, $EAOCF#_i);
  }#

  #{
        /* foreach_argument_of_gimple_call after $EAOCF */
              $ARGUMENT = (tree)NULL;
           }
        }
  }#)


;;; match a gimple call to a direct function of any matched arity
(defcmatcher gimple_call
  (:gimple gc)
  (:tree lhs
	 fndecl
   :long nbargs
   )
  gimpcall
  :doc #{$GIMPLE_CALL match a gimple $GC if it is a call extracting result
  $LHS to function decl $FNDECL with $NBARGS.}#
  ;; test 
  #{/* gimple_call $gimpcall ?*/($gc && gimple_code($gc)==GIMPLE_CALL)}#
  ;; fill
  #{ /* gimple_call $gimpcall !*/
   $lhs  = gimple_call_lhs($gc);
   $fndecl = gimple_call_fndecl($gc);
   $nbargs = gimple_call_num_args($gc);
   }# )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; add pattern matching ?(gimple_call_args ?lhs ?fndecl ?arg0 ?arg1 ... ?argn)

(defvar gimple_call_args_cmatcher_cache_tuple)
(setq gimple_call_args_cmatcher_cache_tuple (make_multiple discr_multiple 32))
(defun patexpand_gimple_call_args (sexpr env pctx)
  (debug "patexpand_gimple_call_args" "; sexpr=" sexpr  "\n.. env=" env "\n.. pctx=" pctx)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr) sexpr)
  (assert_msg "check env" (is_a env class_environment) env)
  (assert_msg "check pctx" (is_a pctx class_pattern_expansion_context) pctx)
  (let (
	(cont (unsafe_get_field :sexp_contents sexpr))
	(loc  (unsafe_get_field :loca_location sexpr))
	(curpair (pair_tail (list_first cont)))
	(argsp (patternexpand_pairlist_as_tuple curpair env pctx loc))
	(nbargs (multiple_length argsp))
	(nbcallargs (-i nbargs 2))
	)
    (debug "patexpand_gimple_call_args" "; loc=" loc "; cont=" cont
	   "\n.. argsp=" argsp)
    (when (<i nbargs 2)
      (error_at loc
		"pattern ?(GIMPLE_CALL_ARGS <lhs> <fun> [<arg0>...]) with too few #$1 arguments"
		nbargs)
      (return))
    (let (
	  (cachelen (multiple_length gimple_call_args_cmatcher_cache_tuple))
	  (cmat (if (<i nbcallargs cachelen)
		    (multiple_nth gimple_call_args_cmatcher_cache_tuple nbcallargs)
		  ()))
	  )
      (if (>=i nbcallargs cachelen)
	  (let ( (newcachelen (+i 1 (ori 0xf (+i 5 (*i 3 (/iraw nbcallargs 2))))))
		 (newtup (make_multiple discr_multiple newcachelen))
		 )
	    (foreach_long_upto
	     (0 (-i cachelen 1))
	     (:long hix)
	     (multiple_put_nth newtup hix (multiple_nth gimple_call_args_cmatcher_cache_tuple hix)))
	    (setq gimple_call_args_cmatcher_cache_tuple newtup)))
      (let (
	    (argsymblist (list 'tr_lhs 'tr_fun))
	    )
	(foreach_long_upto
	 (0 (-i nbcallargs 1))
	 (:long cix)
	 (let ( (curargname (string4out discr_string "TR_ARG_" cix))
		(curargsymb (create_symbolstr curargname))
		)
	   (debug "patexpand_gimple_call_args" "; curargsymb=" curargsymb)
	   (list_append argsymblist curargsymb)
	   )
	 )
	(debug "patexpand_gimple_call_args" "; loc=" loc
	       " argssymblist=" argsymblist)
	(let ( (tupargsymb (list_to_multiple argsymblist discr_multiple))
	       (cmatname (string4out discr_string "GIMPLE_CALL_ARGS_" nbcallargs))
	       (cmatsymb (create_symbolstr cmatname))
	       )
	  (debug "patexpand_gimple_call_args" "; loc=" loc
		 " tupargsymb=" tupargsymb
		 "\n.. cmatsymb=" cmatsymb)
	  (let (
		(gibind (instance class_formal_binding
				  :binder 'gi
				  :fbind_type ctype_gimple))
		(tupargbind (multiple_map
			     tupargsymb
			     (lambda (tsymb)
			       (instance class_formal_binding
					 :binder tsymb
					 :fbind_type ctype_tree))))
		(cmtest
		 (let
		     ( (cmt (make_list discr_list))
		       (gimplecallstate 'gimplecallstate)
		       (gi 'gi)
		       )
		   (add2list
		    cmt
		    ##{ /* $CMATNAME $GIMPLECALLSTATE generated test for gimple_call_args ? */
		    ($GI && gimple_code($GI)==GIMPLE_CALL && gimple_call_num_args($GI)== $NBCALLARGS)
		    }#
		    )
		   (debug "patexpand_gimple_call_args" "; loc=" loc "; cmtest=" cmt)
		   cmt))
		(cmfill
		 (let ( (cmf (make_list discr_list))
			(gimplecallstate 'gimplecallstate)
			(gi 'gi)
			(tr_lhs 'tr_lhs)
			(tr_fun 'tr_fun)
			)
		   (add2list
		    cmf
		    ##{ /* $CMATNAME $GIMPLECALLSTATE generated fill for gimple_call_args ! */
		    $TR_LHS = gimple_call_lhs ($GI)    ;
		    $TR_FUN = gimple_call_fndecl ($GI) ;
		    }#)
		   (foreach_in_multiple
		    (tupargsymb)
		    (curargsymb :long aix)
		    (if (>=i aix 2)
			(let ( (nix (-i aix 2))
			       )
			  (add2list cmf
				    ##{ $CURARGSYMB = gimple_call_args ($GI, $NIX) ;
				    }#)))
		    )
		   (debug "patexpand_gimple_call_args"  "; loc=" loc "; cmfill=" cmf)
		   cmf
		   ))
		(newcmat
		 (instance class_cmatcher
			   :named_name cmatsymb
			   :amatch_matchbind gibind
			   :amatch_out tupargbind ;; tuple of formals
			   :cmatch_state 'gimplecallstate ;; symbol
			   :cmatch_exptest (list_to_multiple cmtest discr_multiple)
			   :cmatch_expfill (list_to_multiple cmfill discr_multiple)
			   ))
		)
	    (debug "patexpand_gimple_call_args" "; loc=" loc "\n.. newcmat=" newcmat)
	    (multiple_put_nth  gimple_call_args_cmatcher_cache_tuple nbcallargs newcmat)
	    (setq cmat newcmat)
	    (debug "patexpand_gimple_call_args" "; loc=" loc "; nbcallargs=" nbcallargs
		   "\n.. updated cachetuple=" 
		   "\n.. cmat=" cmat)
	    )
	  )
	)
      (debug "patexpand_gimple_call_args" "; loc=" loc "; cmat=" cmat)
      (assert_msg "check cmat" (is_a class_cmatcher cmat) cmat)
      (multicall
       (args pats)
       (patmacexpand_for_matcher curpair cmat env loc pctx)
       (debug "patexpand_gimple_call_args" "; loc=" loc " args=" args " pats=" pats)
       (multicall
	(subpatw :long imax imin isum)
	(pattern_weight_tuple pats)
	(debug "patexpand_gimple_call_args" "; loc=" loc " subpatw=" subpatw
	       "\n.. imax=" imax " imin=" imin " isum=" isum)
	(let (
	      (cmatsymb (get_field :named_name cmat))
	      ;;; notice that we are embedding the binding in the
	      ;;; result, but not putting the binding in the
	      ;;; environment. See comment about 'mv is not bound' in
	      ;;; file warmelt-normatch.melt function
	      ;;; normpat_anymatchpat...
	      (cmabind (instance class_cmatcher_binding
				 :binder cmatsymb
				 :cmbind_matcher cmat))
	      (res
	       (instance class_source_pattern_c_match
			 :loca_location loc
			 :pat_weight (constant_box (+i 1 isum))
			 :spac_operator cmat
			 :spac_operbind cmabind
			 :spac_inargs args
			 :spac_outargs pats)
	       )
	      )
	  (debug "patexpand_gimple_call_args" "; loc=" loc "\n.. cmabind=" cmabind
		 "\n.. res=" res)
	  (return res)
	  )
	)
       )
      )
    )
  )

;; pseudo primitive gimple_call_args
;; expanded using gimple_build_call 
(defvar gimple_call_args_primitive_cache_tuple)
(setq gimple_call_args_primitive_cache_tuple (make_multiple discr_multiple 32))
(defun mexpand_gimple_call_args (sexpr env mexpander modctx)
  (debug "mexpand_gimple_call_args" "; sexpr=" sexpr "\n.. env=" env "\n.. modctx=" modctx)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr) sexpr)
  (assert_msg "check env" (is_a env class_environment) env)
  (let (
	(cont (unsafe_get_field :sexp_contents sexpr))
	(loc  (unsafe_get_field :loca_location sexpr))
	(xargtup (expand_restlist_as_tuple cont env mexpander modctx))
	(nbargs (multiple_length xargtup))
	(nbcallargs (-i nbargs 2))
	)
    (debug "mexpand_gimple_call_args" "; loc=" loc "; cont=" cont
	   "\n.. xargtup=" xargtup)
    (when (<i nbargs 2)
      (error_at loc "pseudo-primitive (GIMPLE_CALL_ARGS <lhs> <funtree> <args>...) with too few $1 arguments"
		nbargs)
      (return))
    (let (
	  (cachelen (multiple_length gimple_call_args_primitive_cache_tuple))
	  (cprim (if (<i nbcallargs cachelen)
		     (multiple_nth gimple_call_args_primitive_cache_tuple nbcallargs)
		   ()))
	  )
      (unless cprim
	;; grow the cache if needed
	(if (>=i nbcallargs cachelen)
	    (let ( (newcachelen (+i 1 (ori 0xf (+i 5 (*i 3 (/iraw nbcallargs 2))))))
		   (newtup (make_multiple discr_multiple newcachelen))
		   )
	      (foreach_long_upto
	       (0 (-i cachelen 1))
	       (:long hix)
	       (multiple_put_nth newtup hix (multiple_nth gimple_call_args_primitive_cache_tuple hix)))
	      (setq gimple_call_args_primitive_cache_tuple newtup)))
	(let (
	      (primname (string4out discr_string "GIMPLE_CALL_" nbcallargs))
	      (primsymb (create_symbolstr primname))
	      (tupformsymbs
	       (let ( (symlist (list 'tr_lhs 'tr_cfun))
		      )
		 (foreach_long_upto
		  (0 nbcallargs)
		  (:long fix)
		  (list_append symlist
			       (create_symbolstr  (string4out discr_string "TR_ARG_" fix))))
		 (list_to_multiple symlist discr_multiple)))
	      (primfortup (multiple_map
			   tupformsymbs
			   (lambda (tsymb)
			     (instance class_formal_binding
				       :binder tsymb :fbind_type ctype_tree))))
	      (primexptup
	       (let ( (pxl (make_list discr_list))
		      (tr_cfun 'tr_cfun)
		      (tr_lhs 'tr_lhs)
		      )
		 (add2list pxl ##{/* gimple_call_args quasiprimitive $PRIMNAME */ melt_gimple_call_set_lhs}#
			   " (" ##{ gimple_build_call }# "("
			   ##{$TR_CFUN, $NBCALLARGS}#)
		 (foreach_in_multiple
		  (tupformsymbs)
		  (curform :long fix)
		  (if fix (add2list pxl ##{, $CURFORM}#)))
		 (add2list pxl ")" ##{, $TR_LHS}# ")")
		 (list_to_multiple pxl discr_multiple)
		 ))
	      (newprim (instance class_primitive
				 :named_name primsymb
				 :prim_formals primfortup
				 :prim_type ctype_tree
				 :prim_expansion primexptup))
	      )
	  (debug "mexpand_gimple_call_args" "; loc=" loc "; newprim= " newprim)
	  (setq cprim newprim)
	  ))
      (assert_msg "check cprim" (is_a cprim class_primitive))
      (let ( (res (instance class_source_primitive
			    :loca_location loc
			    :sprim_oper cprim
			    :sargop_args xargtup))
	     )
	(debug "mexpand_gimple_call_args" "; loc=" loc "; res=" res)
	(return res)
	)
      )
    )
  )

;;
(export_patmacro gimple_call_args patexpand_gimple_call_args mexpand_gimple_call_args
                 :doc #{The $GIMPLE_CALL_ARGS is for patterns or expressions
                 for  @code{GIMPLE_CALL}. Usage is @code{?(GIMPLE_CALL_ARGS
                  @var{<lhs>} @var{<fndecl>} @var{<args>...})}.}#)


(defun make_gimple_call (tlhs tfunv args)
  :doc #{The function $MAKE_GIMPLE_CALL build a boxed gimple_call with lefthandside $TLHS for
  function tree boxed in $TFUNV and arguments boxed in list or
  multiple $ARGS.}#
  (debug "make_gimple_call tlhs=" tlhs "\n.. tfunv=" tfunv "\n.. args=" args)
  (let (
	(tr_lhs (unbox :tree tlhs))
	(tr_fun (unbox :tree tfunv))
	 )
    (if (expr_chunk testfun_chk :long
		    #{/*make_gimple_call $TESTFUN_CHK*/ ($TR_FUN
		       && (TREE_CODE ($TR_FUN) == FUNCTION_DECL || is_gimple_call_addr ($TR_FUN)))}#)
	(let ( (arglist (make_list discr_list))
	       )
	  (cond
	   ( (is_list args)
	     (each_component_in_list
	      args curarg
	      (let ( (t_curarg (unbox :tree curarg))
		     )
		(if t_curarg (list_append args curarg)))
	      ))
	   ( (is_multiple args)
	     (foreach_in_multiple
	      (args)
	      (curarg :long aix)
	      (let ( (t_curarg (unbox :tree curarg))
		     )
		(if t_curarg (list_append args curarg)))))
	   (:else
	    (void))
	   )
	  (let ( (argtup (list_to_multiple arglist discr_multiple))
		 (nbargs (multiple_length argtup))
		 (gr (null_gimple))
		 (t_curarg (null_tree))
		 )
	    (code_chunk
	     makecall_chk #{ /*make_gimple_call $MAKECALL_CHK */
	     /* special cases for small calls */
	     switch ($NBARGS) {
	     case 0:
	       $GR = gimple_build_call ($TR_FUN, 0);
	       break;
	     case 1:
	       $GR = gimple_build_call ($TR_FUN, 1,
					melt_tree_content(melt_multiple_nth($ARGTUP, 0))
					);
	       break;
	     case 2:
	       $GR = gimple_build_call ($TR_FUN, 2,
					melt_tree_content(melt_multiple_nth($ARGTUP, 0)),
					melt_tree_content(melt_multiple_nth($ARGTUP, 1))
					);
	       break;
	     case 3:
	       $GR = gimple_build_call ($TR_FUN, 3,
					melt_tree_content(melt_multiple_nth($ARGTUP, 0)),
					melt_tree_content(melt_multiple_nth($ARGTUP, 1)),
					melt_tree_content(melt_multiple_nth($ARGTUP, 2))
					);
	       break;
	     case 4:
	       $GR = gimple_build_call ($TR_FUN, 4,
					melt_tree_content(melt_multiple_nth($ARGTUP, 0)),
					melt_tree_content(melt_multiple_nth($ARGTUP, 1)),
					melt_tree_content(melt_multiple_nth($ARGTUP, 2)),
					melt_tree_content(melt_multiple_nth($ARGTUP, 3))
					);
	       break;
	     case 5:
	       $GR = gimple_build_call ($TR_FUN, 5,
					melt_tree_content(melt_multiple_nth($ARGTUP, 0)),
					melt_tree_content(melt_multiple_nth($ARGTUP, 1)),
					melt_tree_content(melt_multiple_nth($ARGTUP, 2)),
					melt_tree_content(melt_multiple_nth($ARGTUP, 3)),
					melt_tree_content(melt_multiple_nth($ARGTUP, 4))
					);
	       break;
	     default:
	     {
               auto_vec<tree> $MAKECALL_CHK#_vargs;
	       $MAKECALL_CHK#_vargs.reserve($NBARGS);
	       for (int ix_$MAKECALL_CHK=0;
			ix_$MAKECALL_CHK < (int) $NBARGS;
			ix_$MAKECALL_CHK++) {
		 $T_CURARG = melt_tree_content(melt_multiple_nth($ARGTUP, ix_$MAKECALL_CHK));
		 $MAKECALL_CHK#_vargs.quick_push($T_CURARG);
	         $T_CURARG = NULL_TREE;
	       }
	       $GR = gimple_build_call_vec ($TR_FUN, $MAKECALL_CHK#_vargs);	 
	     }
	     break;
	     } /* end switch */
	    if ($TR_LHS) gimple_call_set_lhs($GR, $TR_LHS);
	    /*end make_gimple_call $MAKECALL_CHK */
	    }#)
	    (let ( (res (constant_box gr))
		   )
	      (debug "make_gimple_call res=" res)
	      (return res)
	    ))))))
	      
		
    
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; add pattern matching ?(gimple_call_more_args ?lhs ?fndecl ?arg0 ?arg1 ... ?argn)

(defvar gimple_call_more_args_cmatcher_cache_tuple)
(setq gimple_call_more_args_cmatcher_cache_tuple (make_multiple discr_multiple 32))
(defun patexpand_gimple_call_more_args (sexpr env pctx)
  (debug "patexpand_gimple_call_more_args" "; sexpr=" sexpr  "\n.. env=" env "\n.. pctx=" pctx)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr) sexpr)
  (assert_msg "check env" (is_a env class_environment) env)
  (assert_msg "check pctx" (is_a pctx class_pattern_expansion_context) pctx)
  (let (
	(cont (unsafe_get_field :sexp_contents sexpr))
	(loc  (unsafe_get_field :loca_location sexpr))
	(curpair (pair_tail (list_first cont)))
	(argsp (patternexpand_pairlist_as_tuple curpair env pctx loc))
	(nbargs (multiple_length argsp))
	(nbcallargs (-i nbargs 2))
	)
    (debug "patexpand_gimple_call_more_args" "; loc=" loc "; cont=" cont
	   "\n.. argsp=" argsp)
    (when (<i nbargs 2)
      (error_at loc
		"pattern ?(GIMPLE_CALL_MORE_ARGS <lhs> <fun> [<arg0>...]) with too few #$1 arguments"
		nbargs)
      (return))
    (let (
	  (cachelen (multiple_length gimple_call_more_args_cmatcher_cache_tuple))
	  (cmat (if (<i nbcallargs cachelen)
		    (multiple_nth gimple_call_more_args_cmatcher_cache_tuple nbcallargs)
		  ()))
	  )
      (if (>=i nbcallargs cachelen)
	  (let ( (newcachelen (+i 1 (ori 0xf (+i 5 (*i 3 (/iraw nbcallargs 2))))))
		 (newtup (make_multiple discr_multiple newcachelen))
		 )
	    (foreach_long_upto
	     (0 (-i cachelen 1))
	     (:long hix)
	     (multiple_put_nth newtup hix (multiple_nth gimple_call_more_args_cmatcher_cache_tuple hix)))
	    (setq gimple_call_more_args_cmatcher_cache_tuple newtup)))
      (let (
	    (argsymblist (list 'tr_lhs 'tr_fun))
	    )
	(foreach_long_upto
	 (0 (-i nbcallargs 1))
	 (:long cix)
	 (let ( (curargname (string4out discr_string "TR_ARG_" cix))
		(curargsymb (create_symbolstr curargname))
		)
	   (debug "patexpand_gimple_call_more_args" "; curargsymb=" curargsymb)
	   (list_append argsymblist curargsymb)
	   )
	 )
	(debug "patexpand_gimple_call_more_args" "; loc=" loc
	       " argssymblist=" argsymblist)
	(let ( (tupargsymb (list_to_multiple argsymblist discr_multiple))
	       (cmatname (string4out discr_string "GIMPLE_CALL_MORE_ARGS_" nbcallargs))
	       (cmatsymb (create_symbolstr cmatname))
	       )
	  (debug "patexpand_gimple_call_more_args" "; loc=" loc
		 " tupargsymb=" tupargsymb
		 "\n.. cmatsymb=" cmatsymb)
	  (let (
		(gibind (instance class_formal_binding
				  :binder 'gi
				  :fbind_type ctype_gimple))
		(tupargbind (multiple_map
			     tupargsymb
			     (lambda (tsymb)
			       (instance class_formal_binding
					 :binder tsymb
					 :fbind_type ctype_tree))))
		(cmtest
		 (let
		     ( (cmt (make_list discr_list))
		       (gimplecallstate 'gimplecallstate)
		       (gi 'gi)
		       )
		   (add2list
		    cmt
		    ##{ /* $CMATNAME $GIMPLECALLSTATE generated test for gimple_call_more_args ? */
		    ($GI && gimple_code($GI)==GIMPLE_CALL && gimple_call_num_args($GI) >= $NBCALLARGS)
		    }#
		    )
		   (debug "patexpand_gimple_call_more_args" "; loc=" loc "; cmtest=" cmt)
		   cmt))
		(cmfill
		 (let ( (cmf (make_list discr_list))
			(gimplecallstate 'gimplecallstate)
			(gi 'gi)
			(tr_lhs 'tr_lhs)
			(tr_fun 'tr_fun)
			)
		   (add2list
		    cmf
		    ##{ /* $CMATNAME $GIMPLECALLSTATE generated fill for gimple_call_more_args ! */
		    $TR_LHS = gimple_call_lhs ($GI)    ;
		    $TR_FUN = gimple_call_fndecl ($GI) ;
		    }#)
		   (foreach_in_multiple
		    (tupargsymb)
		    (curargsymb :long aix)
		    (if (>=i aix 2)
			(let ( (nix (-i aix 2))
			       )
			  (add2list cmf
				    ##{ $CURARGSYMB = gimple_call_args ($GI, $NIX) ;
				    }#)))
		    )
		   (debug "patexpand_gimple_call_more_args"  "; loc=" loc "; cmfill=" cmf)
		   cmf
		   ))
		(newcmat
		 (instance class_cmatcher
			   :named_name cmatsymb
			   :amatch_matchbind gibind
			   :amatch_out tupargbind ;; tuple of formals
			   :cmatch_state 'gimplecallstate ;; symbol
			   :cmatch_exptest (list_to_multiple cmtest discr_multiple)
			   :cmatch_expfill (list_to_multiple cmfill discr_multiple)
			   ))
		)
	    (debug "patexpand_gimple_call_more_args" "; loc=" loc "\n.. newcmat=" newcmat)
	    (multiple_put_nth  gimple_call_more_args_cmatcher_cache_tuple nbcallargs newcmat)
	    (setq cmat newcmat)
	    (debug "patexpand_gimple_call_more_args" "; loc=" loc "; nbcallargs=" nbcallargs
		   "\n.. updated cachetuple=" 
		   "\n.. cmat=" cmat)
	    )
	  )
	)
      (debug "patexpand_gimple_call_more_args" "; loc=" loc "; cmat=" cmat)
      (assert_msg "check cmat" (is_a class_cmatcher cmat) cmat)
      (multicall
       (args pats)
       (patmacexpand_for_matcher curpair cmat env loc pctx)
       (debug "patexpand_gimple_call_more_args" "; loc=" loc " args=" args " pats=" pats)
       (multicall
	(subpatw :long imax imin isum)
	(pattern_weight_tuple pats)
	(debug "patexpand_gimple_call_more_args" "; loc=" loc " subpatw=" subpatw
	       "\n.. imax=" imax " imin=" imin " isum=" isum)
	(let (
	      (cmatsymb (get_field :named_name cmat))
	      ;;; notice that we are embedding the binding in the
	      ;;; result, but not putting the binding in the
	      ;;; environment. See comment about 'mv is not bound' in
	      ;;; file warmelt-normatch.melt function
	      ;;; normpat_anymatchpat...
	      (cmabind (instance class_cmatcher_binding
				 :binder cmatsymb
				 :cmbind_matcher cmat))
	      (res
	       (instance class_source_pattern_c_match
			 :loca_location loc
			 :pat_weight (constant_box (+i 1 isum))
			 :spac_operator cmat
			 :spac_operbind cmabind
			 :spac_inargs args
			 :spac_outargs pats)
	       )
	      )
	  (debug "patexpand_gimple_call_more_args" "; loc=" loc "\n.. cmabind=" cmabind
		 "\n.. res=" res)
	  (return res)
	  )
	)
       )
      )
    )
  )

(defun mexpand_gimple_call_more_args (sexpr env mexpander modctx)
  (debug "mexpand_gimple_call_more_args" "; sexpr=" sexpr "\n.. env=" env "\n.. modctx=" modctx)
  (assert_msg "check sexpr" (is_a sexpr class_sexpr) sexpr)
  (assert_msg "check env" (is_a env class_environment) env)
  (let (
	(cont (unsafe_get_field :sexp_contents sexpr))
	(loc  (unsafe_get_field :loca_location sexpr))
	(xargtup (expand_restlist_as_tuple cont env mexpander modctx))
	(nbargs (multiple_length xargtup))
	(nbcallargs (-i nbargs 2))
	)
    (debug "mexpand_gimple_call_more_args" "; loc=" loc "; cont=" cont
	   "\n.. xargtup=" xargtup)
    (error_at loc "GIMPLE_CALL_MORE_ARGS cannot be used in expressions...")
    (return)))


(export_patmacro gimple_call_more_args patexpand_gimple_call_more_args mexpand_gimple_call_more_args
                 :doc #{The $GIMPLE_CALL_MORE_ARGS is for patterns but not expressions
                 for  @code{GIMPLE_CALL}, with at least the given arguments and possibly some more.
		 Usage is @code{?(GIMPLE_CALL_MORE_ARGS
                  @var{<lhs>} @var{<fndecl>} @var{<args>...})}.}#)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; match a gimple call to a direct function of arity 1 exactly
(defcmatcher gimple_call_1
  (:gimple gc)
  (:tree lhs 
	 fndecl
	 arg0)
  gimp1call
  :doc #{$GIMPLE_CALL_1 match a gimple $GC call of arity 1, extracting result $LHD function decl $FNDECL and $ARG0.}#
  ;; test
  #{/* gimple_call_1 $gimp1call ?*/ ($gc && gimple_code($gc)==GIMPLE_CALL && gimple_call_num_args($gc)==1)}#
  ;; fill
  #{ /* gimple_call_1 $gimp1call !*/
   $lhs  = gimple_call_lhs($gc);
   $fndecl = gimple_call_fndecl($gc);
   $arg0 = gimple_call_arg(($gc), 0);
   }#)

;; match a gimple call to a direct function of arity 1 or more
(defcmatcher gimple_call_1_more
  (:gimple gc)
  (:tree lhs 
	 fndecl
	 arg0
   :long nbargs)
  gimp1calm
  :doc #{$GIMPLE_CALL_1_MORE match a gimple $GC call of arity 1 or more, extracting result $LHD function decl $FNDECL and $ARG0 and number of arguments $NBARGS.}#
  ;; test
  #{/* gimple_call_1_more $gimp1calm ?*/ ($gc && gimple_code($gc)==GIMPLE_CALL && gimple_call_num_args($gc)>=1)}#
  ;; fill
  #{ /* gimple_call_1_more $gimp1calm !*/
   $lhs  = gimple_call_lhs($gc);
   $fndecl = gimple_call_fndecl($gc);
   $arg0 = gimple_call_arg(($gc), 0);
   $nbargs = gimple_call_num_args($gc);
   }#)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; match a gimple call to a direct function of arity 2 exactly
(defcmatcher gimple_call_2
  (:gimple gc)
  (:tree lhs 
	 fndecl
	 arg0
	 arg1)
  gimp2call
  :doc #{$GIMPLE_CALL_2 match a gimple $GC call of arity 2, extracting result $LHD function decl $FNDECL and arguments $ARG0 & $ARG1.}#
  ;; test
  #{/* gimple_call_2 $gimp2call ?*/ ($gc && gimple_code($gc)==GIMPLE_CALL && gimple_call_num_args($gc)==2)}#
  ;; fill
  #{ /* gimple_call_2 $gimp2call !*/
   $lhs  = gimple_call_lhs($gc);
   $fndecl = gimple_call_fndecl($gc);
   $arg0 = gimple_call_arg(($gc), 0);
   $arg1 = gimple_call_arg(($gc), 1);
   }#)

;; match a gimple call to a direct function of arity 2 or more
(defcmatcher gimple_call_2_more
  (:gimple gc)
  (:tree lhs 
	 fndecl
	 arg0
	 arg1
   :long nbargs)
  gimp2calm
  :doc #{$GIMPLE_CALL_2_MORE match a gimple $GC call of arity 2 or more, extracting result $LHD function decl $FNDECL and arguments $ARG0 & $ARG1 and number of arguments $NBARGS.}#
  ;; test
  #{/* gimple_call_2_more $gimp2calm ?*/ ($gc && gimple_code($gc)==GIMPLE_CALL && gimple_call_num_args($gc)>=2)}#
  ;; fill
  #{ /* gimple_call_2_more $gimp2calm !*/
   $lhs  = gimple_call_lhs($gc);
   $fndecl = gimple_call_fndecl($gc);
   $arg0 = gimple_call_arg(($gc), 0);
   $arg1 = gimple_call_arg(($gc), 1);
   $nbargs = gimple_call_num_args($gc);
   }#)
  

;; match a gimple call to a direct function of arity 3 exactly
(defcmatcher gimple_call_3
  (:gimple gc)
  (:tree lhs 
	 fndecl
	 arg0
	 arg1
	 arg2)
  gimp3call
  :doc #{$GIMPLE_CALL_3 match a gimple $GC call of arity 3, extracting result $LHD function decl $FNDECL and arguments $ARG0 & $ARG1 & $ARG2.}#
  ;; test
  #{/* gimple_call_3 $gimp3call ?*/ ($gc && gimple_code($gc)==GIMPLE_CALL && gimple_call_num_args($gc)==3)}#
  ;; fill
  #{ /* gimple_call_3 $gimp3call !*/
   $lhs  = gimple_call_lhs($gc);
   $fndecl = gimple_call_fndecl($gc);
   $arg0 = gimple_call_arg(($gc), 0);
   $arg1 = gimple_call_arg(($gc), 1);
   $arg2 = gimple_call_arg(($gc), 2);
   }#)

;; match a gimple call to a direct function of arity 3 or more
(defcmatcher gimple_call_3_more
  (:gimple gc)
  (:tree lhs 
	 fndecl
	 arg0
	 arg1
	 arg2
   :long nbargs
	 )
  gimp3calm
  :doc #{$GIMPLE_CALL_3_MORE match a gimple $GC call of arity 3 or more, extracting result $LHD function decl $FNDECL and arguments $ARG0 & $ARG1 & $ARG2 & number of args $NBARGS.}#
  ;; test
  #{/* gimple_call_3_more $gimp3calm ?*/ ($gc && gimple_code($gc)==GIMPLE_CALL && gimple_call_num_args($gc)>=3)}#
  ;; fill
  #{ /* gimple_call_3_more $gimp3calm !*/
   $lhs  = gimple_call_lhs($gc);
   $fndecl = gimple_call_fndecl($gc);
   $arg0 = gimple_call_arg(($gc), 0);
   $arg1 = gimple_call_arg(($gc), 1);
   $arg2 = gimple_call_arg(($gc), 2);
   $nbargs = gimple_call_num_args($gc);
   }#)
  

;; match a gimple call to a direct function of arity 4 exactly
(defcmatcher gimple_call_4
  (:gimple gc)
  (:tree lhs 
	 fndecl
	 arg0
	 arg1
	 arg2
	 arg3)
  gimp4call
  :doc #{$GIMPLE_CALL_4 match a gimple $GC call of arity 4, extracting result $LHD function decl $FNDECL and arguments $ARG0 & $ARG1 & $ARG2 & $ARG3.}#
  ;; test
  #{/* gimple_call_4 $gimp4call ?*/ ($gc && gimple_code($gc)==GIMPLE_CALL && gimple_call_num_args($gc)==4)}#
  ;; fill
  #{ /* gimple_call_4 $gimp4call !*/
   $lhs  = gimple_call_lhs($gc);
   $fndecl = gimple_call_fndecl($gc);
   $arg0 = gimple_call_arg(($gc), 0);
   $arg1 = gimple_call_arg(($gc), 1);
   $arg2 = gimple_call_arg(($gc), 2);
   $arg3 = gimple_call_arg(($gc), 3);
   }#)

;; match a gimple call to a direct function of arity 4 or more
(defcmatcher gimple_call_4_more
  (:gimple gc)
  (:tree lhs 
	 fndecl
	 arg0
	 arg1
	 arg2
	 arg3
   :long nbargs
	 )
  gimp4calm
  :doc #{$GIMPLE_CALL_4_MORE match a gimple $GC call of arity 4 or more, 
extracting result $LHD function decl $FNDECL and 
arguments $ARG0 & $ARG1 & $ARG2 & $ARG3 and number of arguments $NBARGS.}#
  ;; test
  #{/* gimple_call_4_more $gimp4calm ?*/ ($gc && gimple_code($gc)==GIMPLE_CALL
   && gimple_call_num_args($gc)>=4)}#
  ;; fill
  #{ /* gimple_call_4_more $gimp4calm !*/
   $lhs  = gimple_call_lhs($gc);
   $fndecl = gimple_call_fndecl($gc);
   $arg0 = gimple_call_arg(($gc), 0);
   $arg1 = gimple_call_arg(($gc), 1);
   $arg2 = gimple_call_arg(($gc), 2);
   $arg3 = gimple_call_arg(($gc), 3);
   $nbargs = gimple_call_num_args($gc);
   }#)
  
;;;;
;; match a gimple call to a direct function of arity 5 exactly
(defcmatcher gimple_call_5
  (:gimple gc)
  (:tree lhs 
	 fndecl
	 arg0
	 arg1
	 arg2
	 arg3
	 arg4)
  gimp5call
  :doc #{$GIMPLE_CALL_5 match a gimple $GC call of arity 5, extracting 
result $LHD function decl $FNDECL and arguments $ARG0 & $ARG1 & $ARG2 & $ARG3 & $ARG4.}#
  ;; test
  #{/* gimple_call_5 $gimp5call ?*/ ($gc && gimple_code($gc)==GIMPLE_CALL && gimple_call_num_args($gc)==5)}#
  ;; fill
  #{ /* gimple_call_5 $gimp5call !*/
   $lhs  = gimple_call_lhs($gc);
   $fndecl = gimple_call_fndecl($gc);
   $arg0 = gimple_call_arg(($gc), 0);
   $arg1 = gimple_call_arg(($gc), 1);
   $arg2 = gimple_call_arg(($gc), 2);
   $arg3 = gimple_call_arg(($gc), 3);
   $arg4 = gimple_call_arg(($gc), 4);
   }#)

;; match a gimple call to a direct function of arity 5 or more
(defcmatcher gimple_call_5_more
  (:gimple gc)
  (:tree lhs 
	 fndecl
	 arg0
	 arg1
	 arg2
	 arg3
	 arg4
   :long nbargs
	 )
  gimp5calm
  :doc #{$GIMPLE_CALL_5_MORE match a gimple $GC call of arity 5 or more, 
extracting result $LHD function decl $FNDECL and 
arguments $ARG0 & $ARG1 & $ARG2 & $ARG3 & $ARG4 and number of arguments $NBARGS.}#
  ;; test
  #{/* gimple_call_5_more $gimp5calm ?*/ ($gc && gimple_code($gc)==GIMPLE_CALL && gimple_call_num_args($gc)>=5)}#
  ;; fill
  #{ /* gimple_call_5_more $gimp5calm !*/
   $lhs  = gimple_call_lhs($gc);
   $fndecl = gimple_call_fndecl($gc);
   $arg0 = gimple_call_arg(($gc), 0);
   $arg1 = gimple_call_arg(($gc), 1);
   $arg2 = gimple_call_arg(($gc), 2);
   $arg3 = gimple_call_arg(($gc), 3);
   $arg4 = gimple_call_arg(($gc), 4);
   $nbargs = gimple_call_num_args($gc);
   }#)
  

;;;;
;; match a gimple call to a direct function of arity 6 exactly
(defcmatcher gimple_call_6
  (:gimple gc)
  (:tree lhs 
	 fndecl
	 arg0
	 arg1
	 arg2
	 arg3
	 arg4
	 arg5)
  gimp6call
  :doc #{$GIMPLE_CALL_6 match a gimple $GC call of arity 6, extracting 
result $LHD function decl $FNDECL and arguments $ARG0 & $ARG1 & $ARG2 & $ARG3 & $ARG4 & $ARG5.}#
  ;; test
  #{/* gimple_call_6 $gimp6call ?*/ ($gc && gimple_code($gc)==GIMPLE_CALL && gimple_call_num_args($gc)==6)}#
  ;; fill
  #{ /* gimple_call_6 $gimp6call !*/
   $lhs  = gimple_call_lhs($gc);
   $fndecl = gimple_call_fndecl($gc);
   $arg0 = gimple_call_arg(($gc), 0);
   $arg1 = gimple_call_arg(($gc), 1);
   $arg2 = gimple_call_arg(($gc), 2);
   $arg3 = gimple_call_arg(($gc), 3);
   $arg4 = gimple_call_arg(($gc), 4);
   $arg5 = gimple_call_arg(($gc), 5);
   }#)

;; match a gimple call to a direct function of arity 6 or more
(defcmatcher gimple_call_6_more
  (:gimple gc)
  (:tree lhs 
	 fndecl
	 arg0
	 arg1
	 arg2
	 arg3
	 arg4
	 arg5
   :long nbargs
	 )
  gimp6calm
  :doc #{$GIMPLE_CALL_6_MORE match a gimple $GC call of arity 6 or more, 
extracting result $LHD function decl $FNDECL and 
arguments $ARG0 & $ARG1 & $ARG2 & $ARG3 & $ARG4 & $ARG5 and number of arguments $NBARGS.}#
  ;; test
  #{/* gimple_call_6_more $gimp6calm ?*/ ($gc && gimple_code($gc)==GIMPLE_CALL && gimple_call_num_args($gc)>=6)}#
  ;; fill
  #{ /* gimple_call_6_more $gimp6calm !*/
   $lhs  = gimple_call_lhs($gc);
   $fndecl = gimple_call_fndecl($gc);
   $arg0 = gimple_call_arg(($gc), 0);
   $arg1 = gimple_call_arg(($gc), 1);
   $arg2 = gimple_call_arg(($gc), 2);
   $arg3 = gimple_call_arg(($gc), 3);
   $arg4 = gimple_call_arg(($gc), 4);
   $arg5 = gimple_call_arg(($gc), 5);
   $nbargs = gimple_call_num_args($gc);
   }#)
  

;;;;
;; match a gimple call to a direct function of arity 7 exactly
(defcmatcher gimple_call_7
  (:gimple gc)
  (:tree lhs 
	 fndecl
	 arg0
	 arg1
	 arg2
	 arg3
	 arg4
	 arg5
	 arg6)
  gimp7call
  :doc #{$GIMPLE_CALL_7 match a gimple $GC call of arity 7, extracting 
result $LHD function decl $FNDECL and arguments $ARG0 & $ARG1 & $ARG2 & $ARG3 & $ARG4 & $ARG5 & $ARG6.}#
  ;; test
  #{/* gimple_call_7 $gimp7call ?*/ ($gc && gimple_code($gc)==GIMPLE_CALL && gimple_call_num_args($gc)==7)}#
  ;; fill
  #{ /* gimple_call_7 $gimp7call !*/
   $lhs  = gimple_call_lhs($gc);
   $fndecl = gimple_call_fndecl($gc);
   $arg0 = gimple_call_arg(($gc), 0);
   $arg1 = gimple_call_arg(($gc), 1);
   $arg2 = gimple_call_arg(($gc), 2);
   $arg3 = gimple_call_arg(($gc), 3);
   $arg4 = gimple_call_arg(($gc), 4);
   $arg5 = gimple_call_arg(($gc), 5);
   $arg6 = gimple_call_arg(($gc), 6);
   }#)

;; match a gimple call to a direct function of arity 7 or more
(defcmatcher gimple_call_7_more
  (:gimple gc)
  (:tree lhs 
	 fndecl
	 arg0
	 arg1
	 arg2
	 arg3
	 arg4
	 arg5
	 arg6
   :long nbargs
	 )
  gimp7calm
  :doc #{$GIMPLE_CALL_7_MORE match a gimple $GC call of arity 7 or more, 
extracting result $LHD function decl $FNDECL and 
arguments $ARG0 & $ARG1 & $ARG2 & $ARG3 & $ARG4 & $ARG5 & $ARG6 and number of arguments $NBARGS.}#
  ;; test
  #{/* gimple_call_7_more $gimp7calm ?*/ ($gc && gimple_code($gc)==GIMPLE_CALL && gimple_call_num_args($gc)>=7)}#
  ;; fill
  #{ /* gimple_call_7_more $gimp7calm !*/
   $lhs  = gimple_call_lhs($gc);
   $fndecl = gimple_call_fndecl($gc);
   $arg0 = gimple_call_arg(($gc), 0);
   $arg1 = gimple_call_arg(($gc), 1);
   $arg2 = gimple_call_arg(($gc), 2);
   $arg3 = gimple_call_arg(($gc), 3);
   $arg4 = gimple_call_arg(($gc), 4);
   $arg5 = gimple_call_arg(($gc), 5);
   $arg6 = gimple_call_arg(($gc), 6);
   $nbargs = gimple_call_num_args($gc);
   }#)
  

;;;; fetch the nth argument inside a call
(defprimitive gimple_call_nth_arg (:gimple gc :long n) :tree
  :doc #{Safely retrieve in gimple call $GC its $N-th argument.}#
  #{(($gc && gimple_code($gc) == GIMPLE_CALL && ($n)>=0 
      && ($n) < gimple_call_num_args($gc)) 
     ? gimple_call_arg(($gc), ($n)) : NULL_TREE)}# )



;;;;;;;;;;;;;;;;
;;;;  match a gimple return
(defcmatcher gimple_return
  (:gimple gr)
  (:tree retval
   )
  gimpret
  :doc #{$GIMPLE_RETURN match or build a gimple return extracting the returned treee $RETVAL.}#
  ;; test 
  #{/* gimple_return $GIMPRET ? */ ($gr && gimple_code($gr)==GIMPLE_RETURN)}#
  ;; fill
  #{/* gimple_return $GIMPRET ! */ 
  $retval = gimple_return_retval(
	    static_cast <const greturn*> ($GR)
				 );
  }# 
  ;; operate
  #{/* gimple_return: */ gimple_build_return($RETVAL) }#
)
 


;;;;;;;;;;;;;;;;
;;;; match a goto [to a label or var for indirect goto]
(defcmatcher gimple_goto
  (:gimple gr)
  (:tree tlabeld)
  gimpgoto
  :doc #{$GIMPLE_GOTO match or build a gimple goto to label destination tree $tLABELD}#
  ;; test
  #{ /*  gimple_goto $gimpgoto ? */ ($gr && gimple_code($gr) == GIMPLE_GOTO) }#
  ;; fill
  #{ /*  gimple_goto $gimpgoto ! */ 
  $tlabeld = gimple_goto_dest(
			      ($GR)
			      );
  }# 
  ;; operate
  #{ /*  gimple_goto: */ gimple_build_goto($TLABELD) }#
)


;;;;;;;;;;;;;;;;

;;; match a gimple error mark or a nil; probably not very useful!
(defcmatcher gimple_error_mark_or_nil
  (:gimple gr)
  ()
  gimperrnil
  :doc #{$GIMPLE_ERROR_MARK_OR_NIL match a nil Gimple or an error mark.}#
  ;; test
  #{ /*gimple_error_mark_or_nil $GIMPERRNIL ? */ (!$GR 
						  ||  gimple_code($GR) == GIMPLE_ERROR_MARK) }#
  ;; no fill
)

;;; match a gimple error mark
(defcmatcher gimple_error_mark
  (:gimple gr)
  ()
  gimperr
  :doc #{$GIMPLE_ERROR_MARK match a Gimple error mark.}#
  #{ /*gimple_error_mark $GIMPERR ? */ ($GR && gimple_code($GR) == GIMPLE_ERROR_MARK) }#
)

;; match any gimple_debug 
(defcmatcher gimple_debug
  (:gimple gr)
  ()
  gimpdbg
  :doc #{$GIMPLE_DEBUG match a Gimple debug.}#
  ;; test
  #{ /* gimple_debug $GIMPDBG ? */ (($gr) && is_gimple_debug(($gr))) }#
  ;; no fill
)


;; match a gimple_debug_bind
(defcmatcher gimple_debug_bind
  (:gimple gr)
  (:tree tvar tval)
  gimpdbgbind
  :doc #{$GIMPLE_DEBUG_BIND match a Gimple debug bind extracting tree var $TVAR and value $TVALUE.}#
  ;; test
  #{ /* gimple_debug_bind $gimpdbgbind ? */ (($GR) && gimple_debug_bind_p (($GR))) }#
  ;; fill
  #{ /*  gimple_debug_bind  $gimpdbgbind ! */ 
  $TVAR = gimple_debug_bind_get_var ($GR);
  $TVAL = gimple_debug_bind_get_value ($GR);
  }#
  ;; oper
  #{/* gimple_debug_bind oper */ gimple_build_debug_bind (($TVAR), ($TVAL), NULL)}#
)

;;; match a label
(defcmatcher gimple_label
  (:gimple gr)
  (:tree tlabel)
  gimplab
  :doc #{$GIMPLE_LABEL match or build a gimple label extracting the label tree $TLABEL}#
  ;; test
  #{ /* gimple_label $gimplab ? */ ($gr && gimple_code($gr) == GIMPLE_LABEL) }#
  ;; fill
  #{ /* gimple_label $gimplab ! */ 
  $tlabel = gimple_label_label(
	    static_cast <const glabel*>  ($GR));
  }# 
  ;; operate
  #{ /* gimple_label: */
  gimple_build_label ($TLABEL)
  }#
)


(cheader
 #{ /* GCC 6.0 has a simpler transaction builder, so */
#if GCCPLUGIN_VERSION >= 6000 /* GCC 6 */
 static inline gtransaction*
 melt_build_transaction_with_label_norm(melt_gimpleseqptr_t gs, melt_treeptr_t tr)
 {
   if (!gs) return NULL;
   gtransaction* gt = gimple_build_transaction(gs);
   if (gt && tr)
     gimple_transaction_set_label_norm (gt, tr);
   return gt;
   } /* end of melt_build_transaction_with_label_norm */
#endif /* GCC 6 */
 }#)
		
;;; match a transaction 
(defcmatcher gimple_transaction
  (:gimple gr)
  (:gimple_seq gsbody
	       :tree tlab)
  gimptrans
  :doc #{$GIMPLE_TRANSACTION match or build a transaction block gimple. 
  $GSBODY is the gimple_seq of the body, $TLAB is the label tree.}#
  ;; test
  #{/*gimple_transaction $GIMPTRANS ?*/ ($GR && gimple_code($GR) == GIMPLE_TRANSACTION) }#
  ;; fill
  #{/*gimple_transaction $GIMPTRANS !*/
  $GSBODY = gimple_transaction_body (
	    static_cast <gtransaction*>
				     ($GR)) ;
#if GCCPLUGIN_VERSION >= 6000 /* GCC 6.0 */
  $TLAB = gimple_transaction_label_norm (
	    static_cast <gtransaction*>
				    ($GR))  ;
#elif   GCCPLUGIN_VERSION >= 5000 /* GCC 5.0 */
  $TLAB = gimple_transaction_label (
	    static_cast <gtransaction*>
				    ($GR))  ;
#endif /* GCC 5 or 6 */
  }#
  ;; operator expansion
  #{
  #if GCCPLUGIN_VERSION >= 6000 /* GCC 6.0 */
  /*gimple_transaction:*/
  melt_build_transaction_with_label_norm($GSBODY, $TLAB)
  #else /* GCC 5.0 */
  /*gimple_transaction:*/ gimple_build_transaction($GSBODY,$TLAB)
  #endif /* GCC 5 or 6 */
  }#
  )

 ;; match a gimple exception else
(defcmatcher gimple_eh_else
   (:gimple gi)
   (:gimple_seq gsnormbody gsexcbody)
   gimpehels
   :doc #{$GIMPLE_EH_ELSE match or build an exception else, sole
   content of GIMPLE_TRY_FINALLY node. $GDNORMBODY is the normal exit
   body, and $GSEXCBODY is the exceptional exit body.}#
   ;; test
   #{ /* gimple_eh_else $GIMPEHELS ? */ ($GI && gimple_code($GI) == GIMPLE_EH_ELSE) }#
   ;; fill
   #{ /* gimple_eh_else $GIMPEHELS ! */
   $GSNORMBODY = gimple_eh_else_n_body(
	    static_cast <geh_else*> ($GI)) ;
   $GSEXCBODY = gimple_eh_else_e_body(
	    static_cast <geh_else*> ($GI))  ;
   }#
   ;; operate
   #{ /*gimple_eh_else: */ gimple_build_eh_else ($GSNORMBODY, $GSEXCBODY) }#
   )

 (export_values gimple_transaction gimple_eh_else)
;;;;;;;;;;;;;;;;
(defcmatcher gimple_eh_dispatch
 (:gimple gi)
 (:long regnum)
 gimpehdis
 :doc #{$GIMPLE_EH_DISPATCH match or build an exception dispatch. $REGNUM is the region number.}#
 ;; test
 #{ /* gimple_eh_dispatch $GIMPEHDIS ? */ ($GI && gimple_code($GI) == GIMPLE_EH_DISPATCH) }#
 ;; fill
 #{ /* gimple_eh_dispatch  $GIMPEHDIS ! */
 $REGNUM = gimple_eh_dispatch_region (
	    static_cast <const geh_dispatch*>  ($GI));
 }#
 ;; operate
 #{ /* gimple_eh_dispatch: */ gimple_build_eh_dispatch($REGNUM) }#
)

;;; match a nop
(defcmatcher gimple_nop
  (:gimple gr)
  ()
  gimpnop
  :doc #{$GIMPLE_NOP match or build a nop gimple}#
  ;; test
  #{ /* gimple_nop $gimpnop ?*/ ($gr && gimple_code($gr) == GIMPLE_NOP) }#
  ;; no fill
  #{ /* gimple_nop $gimpnop ! */ }#
  ;; operator
  #{ /*gimple_nop:*/ gimple_build_nop() }#
  )

;;; match a gimple exception catcher
(defcmatcher gimple_catch
  (:gimple gi)
  (:tree textype
   :gimple_seq gshandler)
  gimpcatch
  :doc #{$GIMPLE_CATCH match or build a typed exception handler with $TEXTYPE
  being the type[s] of exceptions, and $GSHANDLER being the handler
  body gimpleseq.}#
  ;; test
  #{ /*gimple_catch $GIMPCATCH ? */ ($GI && gimple_code($GI) == GIMPLE_CATCH) }#
  ;; fill
  #{ /*gimple_catch $GIMPCATCH ! */
  $TEXTYPE = gimple_catch_types (  static_cast <const gcatch*>	 ($GI));
  // for some reason, in GCC 6, gimple_catch_handler wants a non-const
  $GSHANDLER = gimple_catch_handler (  static_cast <gcatch*> ($GI));
  }#
  ;; operator
  #{ /*gimple_catch:*/ gimple_build_catch($TEXTYPE,$GSHANDLER) }#
)


;; match a gimple exception filter
(defcmatcher gimple_eh_filter
  (:gimple gi)
  (:tree textype
   :gimple_seq gsfail)
   gimpehfilt
   :doc #{$GIMPLE_EH_FILTER match or build a gimple exception
   specification. $TEXTYPE is the list of exception types and $GDFAIL
   is the sequence to execute on failure.}#
   ;; test
   #{ /*gimple_eh_filter $GIMPEHFILT ?*/ ($GI && gimple_code($GI) == GIMPLE_EH_FILTER) }#
   ;; fill
   #{ /*gimple_eh_filter $GIMPEHFILT !*/ 
   $TEXTYPE = gimple_eh_filter_types (($GI));
   $GSFAIL = gimple_eh_filter_failure (($GI));
   }#
   ;; operate
   #{ /*gimple_eh_filter:*/ gimple_build_eh_filter($TEXTYPE,$GSFAIL) }#
)

;; match a gimple_eh_must_not_throw
(defcmatcher gimple_eh_must_not_throw
  (:gimple gi)
  (:tree tfndecl)
  gimpnthr
  :doc #{$GIMPLE_EH_MUST_NOT_THROW match or build an exception
  barrier, with a non-returning function decl invoked when exception
  propagates to this point.}#
  ;; test
  #{ /* gimple_eh_must_not_throw $GIMPNTHR ? */ ($GI && gimple_code($GI) == GIMPLE_EH_MUST_NOT_THROW) }#
  ;; fill
  #{ /* gimple_eh_must_not_throw $GIMPNTHR ! */
  $TFNDECL = gimple_eh_must_not_throw_fndecl(
	    static_cast <geh_mnt*>     ($GI));
  }#
  ;; operate
  #{ /* gimple_eh_must_not_throw: */ gimple_build_eh_must_not_throw ($TFNDECL) }#
)


;; match a gimple exception resume
(defcmatcher gimple_resx
  (:gimple gi)
  (:long regnum)
  gimpresx
  :doc #{$GIMPLE_RESX match or build a gimple exception resume. $REGNUM is the exception region number.}#
  ;; test
  #{ /* gimple_resx $GIMPRESX ? */ ($GI && gimple_code($GI) == GIMPLE_RESX) }#
  ;; fill
  #{ /* gimple_resx $GIMPRESX ! */
  $REGNUM = gimple_resx_region(
	    static_cast <const gresx*>  ($GI));
  }#
  ;; operate
  #{ /* gimple_resx: */ gimple_build_resx((int) $REGNUM) }#
)


;;;;;;;;;;;;;;;;
(defcmatcher gimple_try
  (:gimple gi)
  (:gimple_seq gseval gscleanup
   :long kind)
  gimptry
  :doc #{$GIMPLE_TRY match a GIMPLE_TRY statement. $GSEVAL is the gimple seq to evaluate, GSCLEANUP is the cleanup.}#
  ;; test
  #{ /* gimple_try $GIMPTRY ? */ ($GI && gimple_code($GI) == GIMPLE_TRY) }#
  ;; fill
  #{ /* gimple_try $GIMPTRY ! */ 
   $GSEVAL = gimple_try_eval ($GI);
   $GSCLEANUP = gimple_try_cleanup ($GI);
   $KIND = (long) gimple_try_kind ($GI);
  }#
)


;;;;;;;;;;;;;;;;
(defcmatcher gimple_try_catch
  (:gimple gi)
  (:gimple_seq gseval gscleanup)
  gimptry
  :doc #{$GIMPLE_TRY_CATCH match or build a GIMPLE_TRY_CATCH statement. $GSEVAL is the gimple seq to evaluate, GSCLEANUP is the cleanup.}#
  ;; test
  #{ /* gimple_try_catch $GIMPTRY ? */ ($GI && gimple_code($GI) == GIMPLE_TRY && gimple_try_kind($GI) == GIMPLE_TRY_CATCH) }#
  ;; fill
  #{ /* gimple_try_catch $GIMPTRY ! */ 
   $GSEVAL = gimple_try_eval ($GI);
   $GSCLEANUP = gimple_try_cleanup ($GI);
  }#
  ;; operate
  #{ /* gimple_try_catch: */ gimple_build_try ($GSEVAL, $GSCLEANUP, GIMPLE_TRY_CATCH) }#
)

(defcmatcher gimple_try_finally
  (:gimple gi)
  (:gimple_seq gseval gscleanup)
  gimptry
  :doc #{$GIMPLE_TRY_FINALLY match or build a GIMPLE_TRY_FINALLY statement. $GSEVAL is the gimple seq to evaluate, GSCLEANUP is the cleanup.}#
  ;; test
  #{ /* gimple_try_finally $GIMPTRY ? */ ($GI && gimple_code($GI) == GIMPLE_TRY && gimple_try_kind($GI) == GIMPLE_TRY_FINALLY) }#
  ;; fill
  #{ /* gimple_try_finally $GIMPTRY ! */ 
   $GSEVAL = gimple_try_eval ($GI);
   $GSCLEANUP = gimple_try_cleanup ($GI);
  }#
  ;; operate
  #{ /* gimple_try_finally: */ gimple_build_try ($GSEVAL, $GSCLEANUP, GIMPLE_TRY_FINALLY) }#
)

;;; match a gimple bind
(defcmatcher gimple_bind
  (:gimple gr)
  (:tree tvars tblock
  :gimple_seq gbody
	 )
  gimpbind
  :doc #{$GIMPLE_BIND match or build a local bind gimple with $TVARS locals and $TBLOCK block symbol and $GBODY body gimple_seq. }#
  ;; test
  #{ /* gimple_bind $GIMPBIND ? */ ($GR && gimple_code($GR) == GIMPLE_BIND) }#
  ;; fill
  #{ /* gimple_bind $GIMPBIND ! */
  $TVARS = gimple_bind_vars(
	    static_cast <const gbind*>  ($GR));
  $TBLOCK = gimple_bind_block(
	    static_cast <const gbind*>  ($GR));
  $GBODY = gimple_bind_body(
	    static_cast <gbind*> ($GR));
  }# 
  ;; operator
  #{ /*gimple_bind:*/ gimple_build_bind($TVARS,$GBODY,$TBLOCK)}#
 )

;;; match a with cleanup expr, which is only inside the gimplifier
(defcmatcher gimple_with_cleanup_expr
  (:gimple gr)
  (:long cleanupflag)
  gimpclx
  :doc #{The $GIMPLE_WITH_CLEANUP_EXPR matches a cleanup expression, and sets the boolean $CLEANUPFLAG}#
  ;; test
  #{ /* gimple_with_cleanup_expr ? */ ($GR && gimple_code($GR) == GIMPLE_WITH_CLEANUP_EXPR) }#
  ;; fill
  #{ /* gimple_with_cleanup_expr ! */
  $CLEANUPFLAG = gimple_wce_cleanup_eh_only($GR);
  }#)

;;; match a gimple asm
(defcmatcher gimple_asm
  (:gimple gr)
  (:cstring asmstr
   :long ninputs noutputs nclobbers)
  gimpasm
  :doc #{$GIMPLE_ASM match a gimple ASM statement of string $ASMSTR with $NINPUTS $NOUTPUTS $NCLUBBERS}#
  ;; test
  #{ /*  gimple_asm $gimpasm ? */ ($gr &&  gimple_code($gr) == GIMPLE_ASM) }#
  ;; fill
  #{ /*  gimple_asm $gimpasm ! */
  $asmstr = gimple_asm_string (
	    static_cast <const gasm*>  ($GR));
  $ninputs = gimple_asm_ninputs ( static_cast <const gasm*> ($GR));
  $noutputs = gimple_asm_noutputs (
	    static_cast <const gasm*> ($GR));
  $nclobbers = gimple_asm_nclobbers (
	    static_cast <const gasm*>  ($GR));
  }# )

;;;;;;;;;;;;;;;;
;;; match a gimple switch
(defcmatcher gimple_switch
  (:gimple gr)
  (:tree tindex 
         tdeflab
   :long numlabels)
  gimpswitch
  :doc #{$GIMPLE_SWITCH match or build a gimple SWITCH statement indexed by $TINDEX and with $NUMLABELS labels, with default label tree $TDEFLAB}#
  ;; test
  #{ /* gimple_switch $gimpswitch ? */ ($gr &&  gimple_code($gr) == GIMPLE_SWITCH) }#
  ;; fill
  #{ /* gimple_switch $gimpswitch ! */
  $tindex = gimple_switch_index (
	    static_cast <const gswitch*>	 ($GR));
  $numlabels = gimple_switch_num_labels (
	    static_cast <const gswitch*> ($GR));
  $tdeflab = gimple_switch_default_label (
	    static_cast <const gswitch*> ($GR));
  }#
  ;; operate
  #{ /* gimple_switch: */
  gimple_build_switch_nlabels($NUMLABELS, $TINDEX, $TDEFLAB) }#
)

;;; return the index of a switch
(defprimitive gimple_switch_index (:gimple gs) :tree
  :doc #{Retrieve the index of gimple switch $GS.}#
  #{ (($GS) && gimple_code($GS) == GIMPLE_SWITCH) ? 
  gimple_switch_index( static_cast <const gswitch*>  ($GS)) : (tree) NULL
  }#)

;;; set the index of a switch
(defprimitive gimple_switch_set_index (:gimple gs :tree trix) :void
  :doc #{In gimple switch $GS set the index to $TRIX.}#
  #{ if (($GS) && gimple_code($GS) == GIMPLE_SWITCH && ($TRIX) && (SSA_VAR_P ($TRIX) || CONSTANT_CLASS_P ($TRIX)))
  { gimple_switch_set_index (
	    static_cast <gswitch*>  ($GS), $TRIX);
  }
  }#)

;;; return a tree label in a switch
(defprimitive gimple_switch_label (:gimple gs :long n) :tree
  :doc #{Safely retrieve in gimple switch $GS the $N-th label -with $N positive or zero-.}#
  #{ (($GS) && gimple_code($GS) == GIMPLE_SWITCH
      &&  $N >= 0 &&  $N < gimple_switch_num_labels(
	    static_cast <const gswitch*>    ($GS))) ?
  gimple_switch_label(  static_cast <const gswitch*>    ($GS), $N)
              : NULL_TREE
}#)

;;; set the tree label in a switch
(defprimitive gimple_switch_set_label (:gimple gs :long n :tree tlab) :void
  :doc  #{Safely set in gimple switch $GS the $N-th label -with $N positive or zero- to tree case label $TLAB.}#
  #{ /* gimple_switch_set_label */
  if (($GS) && gimple_code($GS) == GIMPLE_SWITCH
      &&  $N >= 0 &&  $N < gimple_switch_num_labels(
	    static_cast <const gswitch*>  ($GS))
      && ($TLAB == NULL_TREE || TREE_CODE($TLAB) == CASE_LABEL_EXPR))
     gimple_switch_set_label (
	    static_cast <gswitch*> ($GS), (unsigned)$N, $TLAB);
  }#)

(defun make_gimple_switch (indexv defcasev cases)
  :doc #{the $MAKE_GIMPLE_SWITCH function make a boxed gimple switch
  with index in boxed tree $INDEXV, default case in boxed tree
  $DEFCASEV, and cases in $CASES which is a list or tuple of boxed case label trees.}#
  (debug "make_gimple_switch" " indexv=" indexv " defcasev=" defcasev " cases=" cases)
  (let ( (tr_index (unbox :tree indexv))
	 (tr_defcase (unbox :tree defcasev))
	 )
    (if (expr_chunk test_chk :long #{ /* make_gimple_switch $TEST_CHK */
		    (!$TR_INDEX || EXPR_P($TR_INDEX))
		    && (!$TR_DEFCASE || TREE_CODE($TR_DEFCASE) == CASE_LABEL_EXPR) }#)
	(let ( (caselist (make_list discr_list))
	       )
	  (cond
	   ( (is_list cases)
	     (each_component_in_list
	      cases curcasev
	      (let ( (tr_curcase (unbox :tree curcasev))
		     )
		(if (expr_chunk testcurcasel_chk :long #{ /* make_gimple_switch $TESTCURCASEL_CHK */
				($TR_CURCASE
				 && TREE_CODE($TR_CURCASE) == CASE_LABEL_EXPR)
				}#
				 )
		    (list_append caselist curcasev)))
	      )
	     )
	   ( (is_multiple cases)
	     (foreach_in_multiple
	      (cases)
	      (curcasev :long cix)
	      (let ( (tr_curcase (unbox :tree curcasev))
		     )
		(if (expr_chunk testcurcaset_chk :long #{ /* make_gimple_switch $TESTCURCASET_CHK */
				($TR_CURCASE
				 && TREE_CODE($TR_CURCASE) == CASE_LABEL_EXPR)
				}#
				 )
		    (list_append caselist curcasev)))
	      )
	     )
	   (:else (void)))
	  (let ( (casetup (list_to_multiple caselist discr_multiple))
		 (nbcases (multiple_length casetup))
		 (:gimple gr (null_gimple))
		 (:tree t_curcase (null_tree))
		 )
	    (code_chunk makegr_chk #{
			/* make_gimple_switch $MAKEGR_CHK */
			$GR = gimple_build_switch_nlabels ($NBCASES, $TR_INDEX, $TR_DEFCASE);
			for (int ix_$MAKEGR_CHK = 0;
				 ix_$MAKEGR_CHK < (int) $NBCASES;
				 ix_$MAKEGR_CHK ++) {
			    $T_CURCASE = melt_tree_content(melt_multiple_nth($CASETUP, ix_$MAKEGR_CHK));
			    gimple_switch_set_label
			    (
			     static_cast<gswitch*> ($GR),
				   (unsigned)ix_$MAKEGR_CHK, $T_CURCASE);
			    $T_CURCASE = NULL_TREE;
			} /* end for ix_$MAKEGR_CHK */
			}#)
	    (if gr
		(let ( (res (constant_box gr))
		       )
		  (debug "make_gimple_switch" " res=" res)
		  (return res)
		  )
	      )
	    )
	  )
      )
    )
  )

;;; iterator on switch cases
(defciterator foreach_case_of_gimple_switch
  (:gimple gs)
  ecos
  (:tree tcase :long caseix)
  :doc #{$FOREACH_CASE_OF_GIMPLE_SWITCH iterate on each tree case $TCASE and index $CASEIX of gimple switch $GS}#
  #{
      /* foreach_case_of_gimple_switch before $ECOS */
      int $ECOS#_i = 0;
      $TCASE = (tree) NULL;
      $CASEIX = 0L;
      if ($GS &&  gimple_code($GS) == GIMPLE_SWITCH)
      {
      int $ECOS#_n = gimple_switch_num_labels
      (
	    static_cast <const gswitch*>   ($GS));

          for ($ECOS#_i = 0; 
	       $ECOS#_i < $ECOS#_n; 
               $ECOS#_i++)
          {
              $TCASE = gimple_switch_label ( static_cast<const gswitch*>($GS),
					     $ECOS#_i);
              $CASEIX = $ECOS#_i;
  }#

  #{
      /*  foreach_case_of_gimple_switch after $ECOS */
              $TCASE = (tree) NULL;
              $CASEIX = 0;
          }
      }
  }#
)

;;;;;;;;;;;;;;;;
;;; match a phi node

(defcmatcher gimple_phi
  (:gimple gr)
  (:tree lhs				;left hand result
   :long numargs)
  gimphi
  :doc #{$GIMPLE_PHI match a PHI node with $LHS being the result and $NUMARGS being the number of arguments}#
  ;; test
  #{ /*  gimple_phi $GIMPHI ? */ ($GR && gimple_code ($GR) == GIMPLE_PHI) }#
  ;; fill
  #{ /*  gimple_phi $GIMPHI ! */
  $LHS = gimple_phi_result ($gr);
  $NUMARGS = gimple_phi_num_args ($gr);
  }# )

;;; safely retrieve the N-th argdeftree of a gimple phinode
(defprimitive gimple_phi_nth_arg_def (:gimple g :long n) :tree
  :doc #{$GIMPLE_PHI_NTH_ARG_DEF safely retrieve from gimple $G 
the $N-th argdef of a gimple phinode.}#
  #{ ( ($g && gimple_code($G) == GIMPLE_PHI && $N >= 0 
	   && $N < gimple_phi_num_args ($G)) 
       ? gimple_phi_arg_def($G, $N) : NULL) }#)

;;; safely retrieve the N-th argedge of a gimple phinode
(defprimitive gimple_phi_nth_arg_edge (:gimple g :long n) :edge
  :doc #{$GIMPLE_PHI_NTH_ARG_EDGE safely retrieve from gimple $G 
the $N-th edge of a gimple phinode.}#
  #{ ( ($G && gimple_code($G) == GIMPLE_PHI 
	   && $N >= 0 && $N < gimple_phi_num_args
	                         ( static_cast <const gphi*> ($G))) 
       ? gimple_phi_arg_edge( static_cast <gphi*>  ($G), $N) : (edge) NULL)
  }#)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; notice that GCC 5 plugin support don't give gimple-predict.h
(defcmatcher gimple_predict 
  (:gimple gr)
  (:long predictor outcome)
  gimpredi
  :doc #{$GIMPLE_PREDICT match a GIMPLE_PREDICT statement, filling $PREDICTOR and $OUTCOME.}#
  ;; test
  #{ /* gimple_predict $GIMPREDI ? */ ($GR && gimple_code($GR) == GIMPLE_PREDICT) }#
  ;; fill
  #{ /* gimple_predict $GIMPREDI ! */
  /* notice for GCC 5. The gimple-predict.h is not public;
     we are stealing code from gimple-predict.h; not sure it is a good idea! */
   $PREDICTOR = (long)  (($GR)->subcode & ~GF_PREDICT_TAKEN);
   $OUTCOME = (long) ((($GR)->subcode & GF_PREDICT_TAKEN) ? TAKEN : NOT_TAKEN);
  }#)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; issue a notice or a warning at a gimple location
(defprimitive inform_at_gimple (:gimple g :cstring msg) :void
  :doc #{$INFORM_AT_GIMPLE issue a notice at location of gimple $G with string $MSG.}#
  #{ inform (($g ? gimple_location($g) : UNKNOWN_LOCATION), $msg); }#
)

(defprimitive warning_at_gimple (:gimple g :cstring msg) :void
  :doc #{$WARNING_AT_GIMPLE issue a warning at location of gimple $G with string $MSG.}#
   #{ warning_at(($g ? gimple_location($g) : UNKNOWN_LOCATION), 0, "MELT WARNING @Gimple: %s", $MSG); }#
)

(defprimitive warning_at_gimple_strbuf (:gimple g :value msg) :void
  :doc #{$WARNING_AT_GIMPLE_STRBUF issue a warning at location of gimple $G with strbuf $MSG.}#
   #{ melt_warning_at_strbuf(($g ? gimple_location($g) : UNKNOWN_LOCATION)
    , $msg); }#
)

(defprimitive error_at_gimple (:gimple g :cstring msg) :void
  :doc #{$ERROR_AT_GIMPLE issue a warning at location of gimple $G with string $MSG.}#
   #{ error_at(($g ? gimple_location($g) : UNKNOWN_LOCATION), "MELT ERROR @Gimple: %s", $msg); }#
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defprimitive is_gimpleseq (v) :long
  :doc #{$IS_GIMPLESEQ test if value $V is a boxed gimpleseq}#
  #{(melt_magic_discr((melt_ptr_t)($v)) == MELTOBMAG_GIMPLESEQ)}# )

(defprimitive make_gimpleseq (discr :gimple_seq gs) :value
  :doc #{$MAKE_GIMPLESEQ build a boxed gimpleseq of given $DISCR and gimpleseq $GS}#
  #{(meltgc_new_gimpleseq((meltobject_ptr_t)($DISCR),($GS)))}# )

(defprimitive gimpleseq_content (v) :gimple_seq
  :doc #{$GIMPLESEQ_CONTENT safely retrieve the gimpleseq inside boxed value $V}#
  #{/*gimpleseq_content*/ (melt_gimpleseq_content((melt_ptr_t)($v)))}# )

;;;;
(defprimitive null_gimpleseq () :gimple_seq #{((gimple_seq)NULL)}#)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; GIMPLE DEBUG OUTPUT 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;; boxed gimple debug
(defun dbgout_boxgimple_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debug_information))
  (let ( (dis (discrim self)) 
	 (out (unsafe_get_field :dbgi_out dbgi)) ) 
    (add2out_strconst out " ?/")
    (if (is_a dis class_named) (add2out_string out (unsafe_get_field :named_name dis)))
    (add2out_strconst out "/{")
    (ppstrbuf_gimple out depth (gimple_content self))
    (add2out_strconst out "}/ ")
    )
  )
(install_method discr_gimple dbg_output dbgout_boxgimple_method)

(defun output_gimple (out :gimple g)
  (if (is_out out)
      (if g
	  (code_chunk outgimplechk
	   #{ /* output_gimple $OUTGIMPLECHK */ meltgc_ppout_gimple((melt_ptr_t)$OUT, 0, $G) }#)
	(add2out_strconst out "*nullgimple*")
      )))

(defun dbgout_mapgimple_method (self dbgi :long depth)
  (assert_msg "check dbgi" (is_a dbgi class_debug_information))
  (let ( (dis (discrim self)) 
	 (:long mapcount (mapgimple_count self))
	 (aux (mapgimple_aux self))
	 (out (unsafe_get_field :dbgi_out dbgi)) 
	 ) 
    (add2out_strconst out " !gimplemap.")
    (if (is_a dis class_named) (add2out_string out (unsafe_get_field :named_name dis)))
    (add2out_strconst out "/")
    (add2out_longdec out mapcount)
    (add2out_strconst out "!{ ")
    (if (and (<=i depth 1)
	     aux)
	(progn
	  (add2out out " aux:")
	  (dbg_out aux dbgi (+i depth 3))
	  ))
    (foreach_mapgimple
     (self)
     (:gimple g :value val)
     (add2out_indentnl out (+i depth 1))
     (add2out out "*")
     (output_gimple out g)
     (add2out_strconst out " == ")
     (dbg_out val dbgi (+i depth 2))
     )
    (add2out_strconst out " }!")
    (add2out_indentnl out depth)
))
(install_method discr_map_gimples dbg_output dbgout_mapgimple_method)


;;;; boxed gimple seq debug
(defun dbgout_boxgimpleseq_method (self dbgi :long depth)
  (assert_msg "check self" (is_a self discr_gimple_seq))
  (assert_msg "check dbgi" (is_a dbgi class_debug_information))
  (let ( (dis (discrim self)) 
	 (out  (unsafe_get_field :dbgi_out dbgi)) ) 
    (add2out_strconst out " ?/")
    (if (is_a dis class_named) (add2out_string out (unsafe_get_field :named_name dis)))
    (add2out_strconst out "/{")
    (add2out_indentnl out (+i 1 depth))
    (ppstrbuf_gimple_seq out (+i 1 depth) (gimpleseq_content self))
    (add2out_indentnl out (+i 1 depth))
    (add2out_strconst out "}/")
    (add2out_indentnl out depth)
    )
  )
(install_method discr_gimple_seq dbg_output dbgout_boxgimpleseq_method)



;;;;;;;;;;;;;;;;
(defprimitive make_gimple_mixloc (:gimple g :long num :value val dis) :value
:doc #{Make a mixed location for the location of gimple $G with value $VAL 
and discriminant $DIS, usually $DISCR_MIXED_LOCATION.}#
#{ (($g && gimple_location($g))?
    meltgc_new_mixloc((meltobject_ptr_t)($dis), (melt_ptr_t)($val), 
		      ($num), (location_t)gimple_location(($g))):NULL) }#)


;;;;;;;;;;;;;;;;
(defprimitive gimple_seq_add_stmt (:gimple_seq gs :gimple g) :void
 :doc #{Add to gimple seq $GS the gimple $G. May change and allocate $GS if it was NULL.}#
 #{/*gimple_seq_add_stmt:*/ do {if ($G) gimple_seq_add_stmt (&$GS, $G);
}while(0)}#)

(defprimitive gimple_seq_add_seq (:gimple_seq gsdst gssrc) :void
  :doc #{Append to gimple seq $GSDST the elements of gimple seq $GSSRC. May change and allocate $GSDST if it was null.}#
 #{/*gimple_seq_add_seq:*/ gimple_seq_add_seq(&$GSDST, $GSSRC);
}#)


(defprimitive gimple_seq_copy (:gimple_seq gs) :gimple_seq 
  :doc #{Return a deep copy of gimple_seq $GS.}#
  #{(($GS)?gimple_seq_copy(($GS)):((gimple_seq)0))}#
)

(defprimitive gimple_seq_alloc_with_stmt (:gimple g) :gimple_seq
  :doc #{Allocate a new raw gimple sequence containing the gimple statement $G.
  GCC may use cached free gimple sequences.}#
 #{/*gimple_seq_alloc_with_stmt:*/ (($G)?gimple_seq_alloc_with_stmt(($G)):((melt_gimpleptr_t)NULL))}#)


(defprimitive gimple_seq_boxed_add_stmt (bgs :gimple g) :void
  :doc #{Add to end of boxed gimple_seq $BGS the gimple $G. May fill $BGS if it contained a null gimple_seq.}#
  #{/*gimple_seq_boxed_add_stmt:*/ if (melt_magic_discr ((melt_ptr_t)($BGS))
					   == MELTOBMAG_GIMPLESEQ 
				      && $G != (melt_gimpleptr_t)NULL) 
     gimple_seq_add_stmt (&(((struct meltgimpleseq_st*)($BGS))->val), ($G));}#
)


(defprimitive gimple_seq_boxed_add_seq  (bgs :gimple_seq gs) :void
  :doc #{Add to end of boxed gimple_seq $BGS the gimple_seq $GS. May fill $BGS if it contained a null gimple_seq.}#
  #{/*gimple_seq_boxed_add_seq:*/ if (melt_magic_discr((melt_ptr_t)($BGS))
                                          == MELTOBMAG_GIMPLESEQ 
                                      && $GS != (gimple_seq)NULL) 
     gimple_seq_add_seq (&(((struct meltgimpleseq_st*)($BGS))->val), ($GS));}#
)


(defun gimple_seq_boxed_make_fill (discr :rest) 
  :doc #{Variadic function to make a boxed gimple seq of given
  $DISCR -or $DISCR_GIMPLE_SEQ if null- and fill it with the given raw
  gimples or gimpleseqs or boxed gimple values or boxed gimpleseq
  values. A closure variadic argument is applied to the boxed
  gimple_seq so may change it.}#
  (if (null discr) (setq discr discr_gimple_seq))
  (let ( (boxgs (make_gimpleseq discr (null_gimpleseq)))
	 )
    ;; boxgs can be null if discr was bad
    (if (null boxgs) 
	(progn 
	  (debug "gimple_seq_boxed_make_fill fail")
	  (return ())))
    ;; loop on variadic arguments
    (forever 
     argloop
     (variadic 
      ( () (exit argloop))
      ( (:gimple g) 
	(gimple_seq_boxed_add_stmt boxgs g))
      ( (:gimple_seq gs)
	(gimple_seq_boxed_add_seq boxgs gs))
      ( (:value v)
	(cond
	 ( (is_gimpleseq v)
	   (gimple_seq_boxed_add_seq boxgs (gimpleseq_content v)))
	 ( (is_gimple v)
	   (gimple_seq_boxed_add_stmt boxgs (gimple_content v)))
	 ( (is_closure v)
	   (v boxgs))
	 (:else
	  (debug "gimple_seq_boxed_make_fill ignoring v=" v)
	  ()))
	)
      )
     )
    (debug "gimple_seq_boxed_make_fill return boxgs=" boxgs)
    (return boxgs)
    )
  )

;;;;;;;;;;;;;;;;
(defprimitive gimple_build_return (:tree tr) :gimple
  :doc #{Build a gimple to return $TR, if non-null.}#
  #{($TR)?gimple_build_return(($TR)):((melt_gimpleptr_t)0)}#
)



;;;;;;;;;;;;;;;;;;;;;;;;;;;; gimpleseq iteration
;;;; iterate on a gimpleseq
(defciterator each_in_gimpleseq
  (:gimple_seq gseq)			;start formals
  eachgimplseq
  (:gimple g)				;local formals
  ;;; before expansion
  #{ /* each_in_gimpleseq $EACHGIMPLSEQ + */
   gimple_stmt_iterator gsi_$eachgimplseq;
   if ($gseq) 
     for (gsi_$eachgimplseq = gsi_start ($gseq);
	  !gsi_end_p (gsi_$eachgimplseq);
	  gsi_next (&gsi_$eachgimplseq)) {
    $g  = gsi_stmt (gsi_$eachgimplseq);
   }#
  ;;; after expansion
  #{ } /* each_in_gimpleseq $EACHGIMPLSEQ - */ }# )


;;;; reverseiterate on a gimpleseq
(defciterator reveach_in_gimpleseq
  (:gimple_seq gseq)			;start formals
  eachgimplseq
  (:gimple g)				;local formals
  ;;; before expansion
  #{ /* reveach_in_gimpleseq $EACHGIMPLSEQ + */
   gimple_stmt_iterator gsi_$eachgimplseq;
   if ($gseq) 
     for (gsi_$eachgimplseq = gsi_last ($gseq); 
          !gsi_end_p (gsi_$eachgimplseq);
	  gsi_prev (&gsi_$eachgimplseq)) {
    $g = gsi_stmt (gsi_$eachgimplseq);
  }#
  ;;; after expansion
  #{ }  /* reveach_in_gimpleseq $EACHGIMPLSEQ - */ }# )

;; apply a function to each boxed gimple in a gimple seq
(defun do_each_gimpleseq (f :gimple_seq gseq)
  (each_in_gimpleseq 
   (gseq) (:gimple g)
   (let ( (gplval (make_gimple discr_gimple g)) )
     (f gplval)))
)


;; apply a function to each boxed gimple in a gimple seq
(defun do_reveach_gimpleseq (f :gimple_seq gseq)
  (reveach_in_gimpleseq 
   (gseq) (:gimple g)
   (let ( (gplval (make_gimple discr_gimple g)) )
     (f gplval)))
)


;;; gimple iterator
(defun gimple_iterator (f data :gimple g)
  (each_bb_cfun
   ()
   (:basic_block body :tree header)
   (let ((:gimple_seq instructions (gimple_seq_of_basic_block body)))
     (each_in_gimpleseq
      (instructions)
      (:gimple instruction)
      (f data instruction))))
)

(defprimitive cfun_gimple_body () :gimple_seq 
  #{ (cfun?(cfun->gimple_body):NULL) }#)


;;;;;;;;;;;;;;;;
;; debug & output functions for gimple
(defun debugfun_gimple (dbgi :gimple g)
  (assert_msg "check dbgi" (is_a dbgi class_debug_information))
  (let ( (out (get_field :dbgi_out dbgi))
	 )
    (if g
	(code_chunk 
	 outgimplechk
	 #{/*$OUTGIMPLECHK*/ meltgc_ppout_gimple ((melt_ptr_t)$OUT, 0, $G);}#
	 )
      (add2out_strconst out "*nullgimple*")
      )))
(register_gimple_debug_fun debugfun_gimple)



(defun diag_gimple (diagstate :gimple g)
  (debug "diag_gimple start diagstate=" diagstate " g=" g)
  (assert_msg "check diagstate" (is_a diagstate class_diagnostic_state))
  (let ( (outbuf (make_strbuf discr_strbuf))
	 )
    (output_gimple outbuf g)
    (debug "diag_gimple outbuf=" outbuf)
    (strbuf2string discr_string outbuf)))
(register_diag_gimple diag_gimple)


;;;;;;;;;;;;;;;;
;; debug & output functions for gimpleseq
(defun debugfun_gimpleseq (dbgi :gimple_seq gs)
  (assert_msg "check dbgi" (is_a dbgi class_debug_information))
  (let ( (out (get_field :dbgi_out dbgi))
	 )
    (if gs
	(code_chunk
	 outgimpleseqchk
	 #{ /*debugfun_gimpleseq $OUTGIMPLESEQCHK*/ meltgc_ppout_gimple_seq ((melt_ptr_t)$OUT, 0, $GS);}#
	 )
      (add2out_strconst out "*nullgimpleseq*")
      )))
(register_gimpleseq_debug_fun debugfun_gimpleseq)


(defun output_gimpleseq (out :gimple_seq gs)
  (if (is_out out)
      (if gs
	(code_chunk
	 outgimpleseqchk
	 #{ /* output_gimpleseq $OUTGIMPLESEQCHK*/ meltgc_ppout_gimple_seq ((melt_ptr_t)$OUT, 0, $GS);}#
	 )
      (add2out_strconst out "*nullgimpleseq*")
      )))


(defun diag_gimpleseq (diagstate :gimple_seq gs)
  (debug "diag_gimpleseq start diagstate=" diagstate " gs=" gs)
  (assert_msg "check diagstate" (is_a diagstate class_diagnostic_state))
  (let ( (outbuf (make_strbuf discr_strbuf))
	 )
    (output_gimpleseq outbuf gs)
    (strbuf2string discr_string outbuf)))
(register_diag_gimple_seq diag_gimpleseq)



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; USE-DEF tree walking
;;;



 ;;; FOR_EACH_SSA_TREE* macros from ssa-iterators.h
 ;;
 ;; the cheader below should be emitted once. If emitted twice,
 ;; trigger an error...
 (cheader
	#{ /* GCC 5 or 6 walk_use_def utilities declaration */
	#ifdef MELT_WITHOUT_WALK_USE_DEF_CHAINS
	#error got  MELT_WITHOUT_WALK_USE_DEF_CHAINS
	#endif /* MELT_WITHOUT_WALK_USE_DEF_CHAINS */
	#define MELT_WITHOUT_WALK_USE_DEF_CHAINS

	// header tree-ssa-operands.h defines USE_STMT
	#include "tree-ssa-operands.h"
	// header tree-phinodes.h defines gimple_vuse_op
	#include "tree-phinodes.h"
	// header gimple-ssa.h defines gimple_vuse_op
	#include "gimple-ssa.h"
	// header ssa-iterators.h defines FOR_EACH_SSA_TREE_OPERAND
	#include "ssa-iterators.h"
	}#)
 ;;
 (defun melt_walk_use_def_chains (:value clos val :tree trvar)
	 :doc #{Walk in an unspecified order the use-def chain of SSA
	 variable $TRVAR; apply the $CLOS closure to the $VAL value and to the
	 current :tree and :gimple. Stop walking if the closure gives null.}#
	 (debug "melt_walk_use_def_chains clos=" clos "\n..val=" val "\n..trvar=" trvar)
	 (match
	  trvar
	  (?(tree_simple_ssa_name ?_ ?_)
	    (void))
	  (?_
	    (debug "melt_walk_use_def_chains not-ssa trvar=" trvar)
	    (return))
	  )
	 (if (is_closure clos)
	     (let ( (trmap (make_maptree discr_map_trees 43))
		    (:gimple gdef (expr_chunk gdefstmt_chk :gimple
					      #{ /*melt_walk_use_def_chains $GDEFSTMT_CHK */
					      SSA_NAME_DEF_STMT ($TRVAR) }#))
		    )
	       (debug "melt_walk_use_def_chains gdef=" gdef)
	       (letrec ( (internalwalker
			  (lambda (val :tree tr :gimple g)
			    (debug "melt_walk_use_def_chains/internalwalker val=" val
				   "\n.. tr=" tr "\n.. g=" g)
			    (assert_msg "melt_walk_use_def_chains/internalwalker tr" tr)
			    (assert_msg "melt_walk_use_def_chains/internalwalker g" g)
			    (if (maptree_get trmap tr)
				(return))
			    (maptree_put trmap tr :true)
			    (debug "melt_walk_use_def_chains/internalwalker before call val=" val
				   "\n.. tr=" tr "\n.. g=" g)
			    (let ( (res (clos val tr g))
				   (:tree trwalked (null_tree))
				   (:gimple giwalked (null_gimple))
				   (:long stop 0)
				   )
			    (debug "melt_walk_use_def_chains/internalwalker after call res=" res
				   "\n.. tr=" tr "\n.. g=" g)
			    (when (null res)
				(return))
			    (code_chunk
			     walkeruse_chk
			     #{ /* melt_walk_use_def_chains $WALKERUSE_CHK start */
			     tree tr_$WALKERUSE_CHK = NULL_TREE;
			     ssa_op_iter sit_$WALKERUSE_CHK;
			     memset (& sit_$WALKERUSE_CHK, 0, sizeof(ssa_op_iter));
			     FOR_EACH_SSA_TREE_OPERAND (tr_$WALKERUSE_CHK, $G,
							sit_$WALKERUSE_CHK, SSA_OP_ALL_OPERANDS)
			       {
			         $TRWALKED = tr_$WALKERUSE_CHK;
			         $(debug "melt_walk_use_def_chains/internalwalker trwalked=" trwalked)
			         if ($TRWALKED && TREE_CODE($TRWALKED) == SSA_NAME) {
				   $GIWALKED = SSA_NAME_DEF_STMT($TRWALKED);
				   $(progn
				      (debug "melt_walk_use_def_chains/internalwalker recurring val=" val
					   "\n.. trwalked=" trwalked "\n.. giwalked=" giwalked)
				      (setq res (internalwalker val trwalked giwalked))
				      (debug "melt_walk_use_def_chains/internalwalker recurred val=" val
					     "\n.. trwalked=" trwalked "\n.. giwalked=" giwalked)
				      (void))
				   $GIWALKED = (melt_gimpleptr_t) NULL;
				   if (!$RES)
				     clear_and_done_ssa_iter(& sit_$WALKERUSE_CHK);
				 }
				 $TRWALKED = NULL_TREE;
                         }
			     /* melt_walk_use_def_chains $WALKERUSE_CHK end */
			     }#)
			    (return res)
			    )
			    )
			  )
			 )
		 (debug "melt_walk_use_def_chains recurring walker internalwalker=" internalwalker
			"\n.. on val=" val
			"\n.. trvar=" trvar "\n.. gdef=" gdef)
		 (let ( (resw (internalwalker val trvar gdef))
			)
		   (debug "melt_walk_use_def_chains after recurring walker resw=" resw)
		 )))
	   )
	 )				;end melt_walk_use_def_chains
 (export_values melt_walk_use_def_chains)


  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(export_values
 ;; alphanumerical order
 ==g  
 cfun_gimple_body 
 do_each_gimpleseq 
 do_reveach_gimpleseq 
 each_in_gimpleseq
 error_at_gimple
 foreach_argument_of_gimple_call
 foreach_case_of_gimple_switch
 foreach_mapgimple 
 gimple_asm
 gimple_assign_abs
 gimple_assign_addr_space_convert
 gimple_assign_binaryop
 gimple_assign_bit_and
 gimple_assign_bit_ior
 gimple_assign_bit_not
 gimple_assign_bit_xor
 gimple_assign_cast
 gimple_assign_ceil_div 
 gimple_assign_ceil_mod
 gimple_assign_convert
 gimple_assign_copy
 gimple_assign_exact_div
 gimple_assign_fixed_convert
 gimple_assign_float
 gimple_assign_floor_div
 gimple_assign_floor_mod
 gimple_assign_lrotate
 gimple_assign_lshift
 gimple_assign_max
 gimple_assign_min
 gimple_assign_minus
 gimple_assign_mult_highpart
 gimple_assign_mult
 gimple_assign_nop
 gimple_assign_paren
 gimple_assign_plus
 gimple_assign_pointer_plus
 gimple_assign_rdiv
 gimple_assign_round_div
 gimple_assign_round_mod 
 gimple_assign_rrotate
 gimple_assign_rshift
 gimple_assign_single
 gimple_assign_ssa_name_copy 
 gimple_assign_to 
 gimple_assign_trunc_div
 gimple_assign_trunc_mod
 gimple_assign_negate
 gimple_assign_unary_nop
 gimple_assign_widen_mult
 gimple_at_source_location 
 gimple_bind
 gimple_build_assign_convert 
 gimple_build_assign_fix_trunc 
 gimple_build_assign_float 
 gimple_build_assign_view_convert
 gimple_build_return 
 gimple_call
 gimple_call_1 
 gimple_call_1_more
 gimple_call_2
 gimple_call_2_more
 gimple_call_3
 gimple_call_3_more
 gimple_call_4
 gimple_call_4_more
 gimple_call_5
 gimple_call_5_more
 gimple_call_6
 gimple_call_6_more
 gimple_call_7
 gimple_call_7_more
 gimple_call_nth_arg 
 gimple_catch
 gimple_cond
 gimple_cond_equal
 gimple_cond_false
 gimple_cond_greater
 gimple_cond_greater_or_equal
 gimple_cond_less
 gimple_cond_lessequal
 gimple_cond_ltgt 
 gimple_cond_notequal
 gimple_cond_ordered
 gimple_cond_true 
 gimple_cond_uneq
 gimple_cond_unge
 gimple_cond_ungt
 gimple_cond_unle
 gimple_cond_unlt
 gimple_cond_unordered 
 gimple_cond_with_edges
 gimple_cond_with_true_false_labels
 gimple_content 
 gimple_copy 
 gimple_debug
 gimple_debug_bind
 gimple_eh_dispatch
 gimple_eh_filter
 gimple_eh_must_not_throw
 gimple_error_mark
 gimple_goto
 gimple_iterator 
 gimple_label
 gimple_nop
 gimple_phi
 gimple_phi_nth_arg_def  
 gimple_phi_nth_arg_edge
 gimple_predict 
 gimple_resx
 gimple_return
 gimple_seq_add_seq
 gimple_seq_add_stmt 
 gimple_seq_alloc_with_stmt
 gimple_seq_boxed_add_seq 
 gimple_seq_boxed_add_stmt 
 gimple_seq_boxed_make_fill 
 gimple_seq_copy 
 gimple_seq_first_stmt 
 gimple_seq_last_stmt 
 gimple_seq_of_basic_block 
 gimple_switch
 gimple_switch_index
 gimple_switch_label
 gimple_switch_set_index
 gimple_switch_set_label
 gimple_try 
 gimple_try_catch
 gimple_try_finally
 gimple_with_cleanup_expr
 gimpleseq_content 
 gimpleval
 inform_at_gimple
 is_gimple
 is_gimpleseq
 is_mapgimple 
 make_gimple
 make_gimple_call
 make_gimple_mixloc
 make_gimple_switch
 make_gimpleseq 
 make_mapgimple 
 mapgimple_aux 
 mapgimple_auxput 
 mapgimple_count 
 mapgimple_get 
 mapgimple_nth_attr 
 mapgimple_nth_val 
 mapgimple_put 
 mapgimple_remove 
 mapgimple_size
 null_gimple 
 null_gimpleseq
 output_gimple
 output_gimpleseq
 reveach_in_gimpleseq
 warning_at_gimple
 warning_at_gimple_strbuf
 )

;; eof libmelt-ana-gimple.melt
