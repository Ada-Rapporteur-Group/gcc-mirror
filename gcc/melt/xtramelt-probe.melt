;; -*- Lisp -*-
;; file xtramelt-probe.melt
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(comment "***
    Copyright 2012 Free Software Foundation, Inc.
    Contributed by Basile Starynkevitch <basile@starynkevitch.net>

    This file is part of GCC.

    GCC is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.

    GCC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.

   This file interacts with the simple GTK probe (a graphical user
   interface program to show compiled source files and information
   attached to locations in them). See file
   simplemelt-gtkmm-probe.cc (in contrib/ directory of the MELT
   branch). 

 ***")


(defselector send_object_to_probe class_selector
  :doc #{The selector $SEND_OBJECT_TO_PROBE is used for sending
 arbitrary object receivers $RECV to the MELT probe. $SBUF is the
 internal buffer. $VALSENDER is the closure to send values, and $DEPTH is the current depth}#
  :formals (recv sbuf valsender :long depth)
)

(defun send_command_to_probe (symcmd :rest)
  :doc #{Utility to send a command to the MELT probe}#
  (debug "send_command_to_probe symcmd=" symcmd)
  (assert_msg "check symcmd" (is_a symcmd class_symbol))
  (shortbacktrace_dbg "send_command_to_probe" 12)
  (let ( (outsbuf (make_strbuf discr_strbuf))
	 )
    (letrec 
	(
	 (a+num 
	  (lambda (out :long n) (add2out out n)))
	 (a+str 
	  (lambda (out :cstring s) 
	    (add2out out " \"")
	    (add2out_cenconst out s)
	    (add2out out "\" ")
	    ))
	 (a+val 
	  (lambda (out val :long depth)
	    (let ( (:long sucdepth (+i depth 1))
		   )
	      (cond 
	       ;;
	       ((null val) 
		(add2out out " () "))
	       ;;
	       ((is_integerbox val) 
		(add2out out (get_int val)))
	       ;;
	       ((is_string val)
		(add2out out " \"")
		(add2out_cencstring out val)
		(add2out out "\" ")
		)
	       ;;
	       ((is_multiple val)
		(add2out out "(")
		(foreach_in_multiple 
		 (val)
		 (comp :long ix)
		 (if (>i ix 0) (add2out out " "))
		 (a+val out val sucdepth))
		(add2out out ")")
		)
	       ;;
	       ((is_list val)
		(add2out out "(")
		(let ( (:long cnt 0)
		       )
		  (foreach_in_list
		   (val)
		   (curpair curcomp)
		   (if cnt (add2out out " "))
		   (setq cnt (+i cnt 1))
		   (a+val out curcomp sucdepth)
		   )
		  (add2out out ")")
		  )
		)
	       ;;
	       ((is_closure val)
		(val out))
	       ((is_a val class_named)
		(add2out out (get_field :named_name val))
		)
	       ((is_object val)
		(send_object_to_probe val out a+val sucdepth))
	       )
	      )
	    )
	  )
	 )				;end letrec bindings
      (a+val outsbuf symcmd)
      (forever 
       argloop
       (add2out outsbuf " ")
       (variadic 
	( ()
	  (exit argloop))
	( (:long l)
	  (a+num outsbuf l))
	( (:cstring s)
	  (a+str outsbuf s))
	( (:value v)
	  (a+val outsbuf v 0))
	( :else
	  (assert_msg "invalid variadic in send_command_to_probe" ()))))
      (add2out outsbuf "\n\n")		;to terminate the command
      (debug "send_command_to_probe outsbuf=" outsbuf)
      (code_chunk sendcmd  #{ /* $SENDCMD send command to probe */ 
                  melt_send_command_strbuf_to_probe ($OUTSBUF)}#)
      )    
    )
  )


(defclass class_probed_file
  :doc #{$CLASS_PROBED_FILE describes a source file known to the
  probe. $PROBEDFILE_RANK is its unique rank inside $CLASS_PROBE_DATA,
  $PROBEDFILE_PATH is the given -perhaps relative- path,
  $PROBEDFILE_REALPATH is the real absolute file path, and
  $PROBEDFILE_DATA is available to clients.}#
  :super class_proped
  :fields (
	   probedfile_rank		;the rank
	   probedfile_path		;the first given path
	   probedfile_realpath		;the real path
	   probedfile_data		;supplementary client data
	   )
)
  
(defclass class_probe_data 
  :doc #{Singleton $CLASS_PROBE_DATA for probe related
  data. $PROBEDATA_FILESVEC is a tuple of $CLASS_PROBED_FILE-s, and
  $PROBEDATA_FILEDICT is a dictionnary mapping given and real paths to
  them. $PROBEDATA_AUX is an auxiliary data. $PROBEDATA_CMDTOPROBEFD
  and $PROBEDATA_REQFROMPROBEFD gives the boxed integers for command &
  request file descriptors to & from the probe.}#
  :super class_proped
  :fields 
  (
   ;; bijective association of file real paths and indexes
   probedata_filesvec 			;;the vector of real probed files
   probedata_filedict			;;the dictionnary of real probed files
   ;; dictionnary of request handlers
   probedata_reqhdict			;;dictionnary of request handlers
   ;; boxed file descriptor for commands to probe
   probedata_cmdtoprobefd
   ;; boxed file descriptor for requests from probe
   probedata_reqfromprobefd
   ;; auxiliary data
   probedata_aux
))


(definstance probe_data_container class_container)

(defun probe_get_data ()
  :doc #{function to retrieve the probe data, or null.}#
  !probe_data_container)


(defun probe_register_request_verb (symb clos)
  :doc #{Register into probe for verb named by $SYMB the closure $CLOS to handle request.}#
  (debug "probe_register_request_verb symb=" symb " clos=" clos)
  (let ( (probdata (probe_get_data))
	 )
    (if (is_a probdata class_probe_data)
	(let ( (reqhdict (get_field :probedata_reqhdict probdata))
	       )
	  (if (is_a symb class_named)
	      (if (is_closure clos)
		  (let ( (symbnam (get_field :named_name symb))
			 )
		    (mapstring_putstr reqhdict symbnam clos)
		    (debug "probe_register_request_verb updated reqhdict=" reqhdict)
		    )))))))



(defun probe_get_file_of_name (probedata name)
  :doc #{Given a source file $NAME, gives its corresponding
  $CLASS_PROBED_FILE, perhaps creating it and displaying it in the
  probe}#
  (debug "probe_get_file_of_name probedata=" probedata " name=" name)
  (assert_msg "check probedata" (is_a probedata class_probe_data))
  (assert_msg "check name" (is_string name))
  (let (
	(realpath (make_string_real_access_path_value discr_string name))
	(filesvec (get_field :probedata_filesvec probedata))
	(filedict (get_field :probedata_filedict probedata))
	(:long veclen (multiple_length filesvec))
	(:long pos 0)
	)
    (debug "probe_get_file_of_name realpath=" realpath " filedict=" filedict)
    (assert_msg "check realpath" realpath)
    ;;
    (let ( (probfil (mapstring_getstr filedict realpath))
	   )
      (when probfil
	(debug "probe_get_file_of_name return found probfil=" probfil)
	(assert_msg "check probfil" (is_a probfil class_probed_file))
	(return probfil)
	)
      ;; grow filesvec if needed, i.e. if filesvec's last slot is filled
      (if (multiple_nth filesvec -1)
	  (let ( (:long newlen (+i 10 (/i (*i veclen 3) 2)))
		 (newvec (make_multiple discr_multiple newlen))
		 )
	    (foreach_in_multiple
	     (filesvec)
	     (curfil :long fix)
	     (multiple_put_nth newvec fix curfil))
	    (setq filesvec newvec)
	    (put_fields probedata :probedata_filesvec newvec)))
      ;; find a position in pos, fill and return it
      (foreach_in_multiple
       (filesvec)
       (curfil :long filix)
       (if filix			;skip slot 0
	   (unless curfil
	     (let ( 
		   (newfil
		    (instance class_probed_file
			      :probedfile_rank (make_integerbox discr_constant_integer
								filix)
			      :probedfile_path name
			      :probedfile_realpath realpath
			      :probedfile_data ()
			      ))
		   )
	       (multiple_put_nth filesvec filix newfil)
	       (mapstring_putstr filedict name newfil)
	       (mapstring_putstr filedict realpath newfil)
	       (put_int newfil filix)
	       (debug "probe_get_file_of_name made newfil=" newfil)
	       (send_command_to_probe 'showfile_pcd name filix)
	       (return newfil)
	       ))
	 )))))


;; the internal request processor
(defun probe_request_processor (inch inlist)
  (debug "probe_request_processor start inch=" inch " inlist=" inlist)
  (shortbacktrace_dbg "probe_request_processor" 9)
  (assert_msg "check inch" (is_a inch class_input_channel_handler))
  (let ( (probedata (get_field :inch_data inch))
	 (:long probereqfd (get_int inch))
	 (intup (if inlist (list_to_multiple inlist discr_multiple)))
	 (reqverb (multiple_nth intup 0))
	 )
    (assert_msg "check probedata" (is_a probedata class_probe_data))
    (unless inlist
      (debug "probe_request_processor end of input probereqfd=" probereqfd)
      (set_content probe_data_container ())
      (put_fields probedata 
		  :probedata_cmdtoprobefd ()
		  :probedata_reqfromprobefd ())
      (code_chunk probestop_chk #{ /* probe_request_processor $PROBESTOP_CHK */ 
		  melt_probe_stop ()	;
		  }#)
      (debug "probe_request_processor stopped probe")
      (return)
      )
    (debug "probe_request_processor reqverb=" reqverb " intup=" intup)
    ;; the quit_prq verb is deeply wired in
    (when (== reqverb 'quit_prq)
      (set_content probe_data_container ())
      (debug "probe_request_processor quitting probe")
      (return)
      )
    (let ( (reqdict (get_field :probedata_reqhdict probedata))
	   (verbname (get_field :named_name reqverb))
	   (reqclos (mapstring_getstr reqdict verbname))
	   )
      (when (is_closure reqclos)
	(debug "probe_request_processor running closure for reqverb=" reqverb " intup=" intup)
	(reqclos intup)
	(debug "probe_request_processor done reqverb=" reqverb)
	(return))
      (warningmsg_strv "unknown probe request verb" verbname)
      )))



(defun probe_at_exit (res que)
  (debug "probe_at_exit res=" res " que=" que)
  (shortbacktrace_dbg "probe_at_exit" 10)
  (let ( (:long loopcnt 0) 
	 )
    (forever probendloop
	     (increment loopcnt 1)
	     (let ( (probedata (probe_get_data))
		    )
	       (debug "probe_at_exit loop probedata=" probedata
		      " loopcnt=" loopcnt)
	       (unless probedata (exit probendloop))
	       (poll_all_inputs 5000)
	       ))
    (debug "probe_at_exit ended loopcnt=" loopcnt)
    ))

(defun show_version_probe (tup)
  (debug "show_version_probe tup=" tup)
  (let ( (sbuf (make_strbuf discr_strbuf))
	 )
    (add2out sbuf "MELT version=" (melt_version_str))
    (send_command_to_probe 'STATUS_pcd (strbuf2string discr_string sbuf))))


(defun probe_docmd (cmd moduldata)
  (debug "probe_docmd cmd=" cmd " moduldata=" moduldata)
  (let (
        (mainfilename (make_string_real_access_path discr_string (main_input_filename)))
        (filesvec  (make_multiple discr_multiple 10))
        (filedict (make_mapstring discr_map_strings 17))
        (probedata (instance class_probe_data
                             :probedata_filesvec filesvec
                             :probedata_filedict filedict))
	(:long toprobenumfd -1)
	(:long fromprobenumfd -1)
        )
    (debug "probe_docmd probedata=" probedata " maininput=" (main_input_filename))
    (code_chunk probestart_chk #{ /* probe_docmd $PROBESTART_CHK */
		int $PROBESTART_CHK#_toprobefd = -1, $PROBESTART_CHK#_fromprobefd = -1 ;
		melt_probe_start (NULL, &$PROBESTART_CHK#_toprobefd, &$PROBESTART_CHK#_fromprobefd) ;
		if ($PROBESTART_CHK#_toprobefd > 0) 
		  $TOPROBENUMFD = (long) $PROBESTART_CHK#_toprobefd ;
		if ($PROBESTART_CHK#_fromprobefd > 0)
		  $FROMPROBENUMFD = (long) $PROBESTART_CHK#_fromprobefd ;
		}#)
    (when (<i fromprobenumfd 0)
      (debug "probe_docmd failed to start probe fromprobenumfd=" fromprobenumfd
	     " toprobenumfd=" toprobenumfd)
      (return))
    (put_fields probedata
	       :probedata_cmdtoprobefd (make_integerbox discr_constant_integer toprobenumfd)
	       :probedata_reqfromprobefd (make_integerbox discr_constant_integer fromprobenumfd))
    (set_content probe_data_container probedata)
    (register_input_channel_handler probe_request_processor probedata fromprobenumfd)
    (probe_register_request_verb 'VERSION_prq  show_version_probe)
    (debug "probe_docmd registered probe_request_processor=" probe_request_processor 
	   " with probedata=" probedata " fromprobenumfd=" fromprobenumfd)
    (let ( (mainprfil (probe_get_file_of_name probedata mainfilename))
	   )
      (debug "probe_docmd mainprfil=" mainprfil)
      (at_exit_last probe_at_exit)
      (return :true)
      )))


(definstance probe_mode
  class_melt_mode
  :named_name '"probe"
  :meltmode_help '"enable the simple interactive probe; see also the @code{-f[plugin-arg-]melt-probe} argument"
  :meltmode_fun probe_docmd
)
(install_melt_mode probe_mode)

(export_class class_probed_file class_probe_data)

(export_values 
 probe_get_data
 probe_get_file_of_name
 probe_register_request_verb
 send_command_to_probe
 send_object_to_probe 
)
;; eof xtramelt-probe.melt
