;; -*- Lisp -*-
;; file xtramelt-probe.melt
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(comment "***
    Copyright 2012 Free Software Foundation, Inc.
    Contributed by Basile Starynkevitch <basile@starynkevitch.net>

    This file is part of GCC.

    GCC is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.

    GCC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.

   This file interacts with the simple GTK probe (a graphical user
   interface program to show compiled source files and information
   attached to locations in them). See file
   simplemelt-gtkmm-probe.cc (in contrib/ directory of the MELT
   branch). 

 ***")


(defselector send_object_to_probe class_selector
  :doc #{The selector $SEND_OBJECT_TO_PROBE is used for sending
 arbitrary object receivers $RECV to the MELT probe. $SBUF is the
 internal buffer. $VALSENDER is the closure to send values, and $DEPTH is the current depth}#
  :formals (recv sbuf valsender :long depth)
)

(defun send_command_to_probe (symcmd :rest)
  :doc #{Utility to send a command to the MELT probe}#
  (debug "send_command_to_probe symcmd=" symcmd)
  (assert_msg "check symcmd" (is_a symcmd class_symbol))
  (let ( (outsbuf (make_strbuf discr_strbuf))
	 )
    (letrec 
	(
	 (a+num 
	  (lambda (out :long n) (add2out out n)))
	 (a+str 
	  (lambda (out :cstring s) (add2out_cenconst out s)))
	 (a+val 
	  (lambda (out val :long depth)
	    (let ( (:long sucdepth (+i depth 1))
		   )
	      (cond 
	       ;;
	       ((null val) 
		(add2out out " () "))
	       ;;
	       ((is_integerbox val) 
		(add2out out (get_int val)))
	       ;;
	       ((is_string val)
		(add2out_cencstring out val))
	       ;;
	       ((is_multiple val)
		(add2out out "(")
		(foreach_in_multiple 
		 (val)
		 (comp :long ix)
		 (if (>i ix 0) (add2out out " "))
		 (a+val out val sucdepth))
		(add2out out ")")
		)
	       ;;
	       ((is_list val)
		(add2out out "(")
		(let ( (:long cnt 0)
		       )
		  (foreach_in_list
		   (val)
		   (curpair curcomp)
		   (if cnt (add2out out " "))
		   (setq cnt (+i cnt 1))
		   (a+val out curcomp sucdepth)
		   )
		  (add2out out ")")
		  )
		)
	       ;;
	       ((is_closure val)
		(val out))
	       ((is_a val class_named)
		(add2out out (get_field :named_name val))
		)
	       ((is_object val)
		(send_object_to_probe val out a+val sucdepth))
	       )
	      )
	    )
	  )
	 )				;end letrec bindings
      (a+val outsbuf symcmd)
      (forever 
       argloop
       (add2out outsbuf " ")
       (variadic 
	( ()
	  (exit argloop))
	( (:long l)
	  (a+num outsbuf l))
	( (:cstring s)
	  (a+str outsbuf s))
	( (:value v)
	  (a+val outsbuf v 0))
	( :else
	  (assert_msg "invalid variadic in send_command_to_probe" ()))))
      (add2out outsbuf "\n\n")		;to terminate the command
      (code_chunk sendcmd  #{ /* $SENDCMD send command to probe */ 
                  melt_send_command_strbuf_to_probe ($OUTSBUF)}#)
      )    
    )
  )


(defclass class_probed_file
  :doc #{$CLASS_PROBED_FILE describes a source file known to the
  probe. $PROBEDFILE_RANK is its unique rank inside $CLASS_PROBE_DATA,
  $PROBEDFILE_PATH is the given -perhaps relative- path,
  $PROBEDFILE_REALPATH is the real absolute file path, and
  $PROBEDFILE_DATA is available to clients.}#
  :super class_proped
  :fields (
	   probedfile_rank		;the rank
	   probedfile_path		;the first given path
	   probedfile_realpath		;the real path
	   probedfile_data		;supplementary client data
	   )
)
  
(defclass class_probe_data 
  :doc #{Singleton $CLASS_PROBE_DATA for probe related
  data. $PROBEDATA_FILESVEC is a tuple of $CLASS_PROBED_FILE-s, and
  $PROBEDATA_FILEDICT is a dictionnary mapping given and real paths to
  them.}#
  :super class_proped
  :fields 
  (
   ;; bijective association of file real paths and indexes
   probedata_filesvec 			;;the vector of real probed files
   probedata_filedict			;;the dictionnary of real probed files
))



(defun probe_get_file_of_name (probedata name)
  :doc #{Given a source file $NAME, gives its corresponding
  $CLASS_PROBED_FILE, perhaps creating it and displaying it in the
  probe}#
  (debug "probe_get_file_of_name probedata=" probedata " name=" name)
  (assert_msg "check probedata" (is_a probedata class_probe_data))
  (assert_msg "check name" (is_string name))
  (let (
	(realpath (make_string_real_access_path_value discr_string name))
	(filesvec (get_field :probedata_filesvec probedata))
	(filedict (get_field :probedata_filedict probedata))
	(:long veclen (multiple_length filesvec))
	(:long pos 0)
	)
    (debug "probe_get_file_of_name realpath=" realpath)
    (assert_msg "check realpath" realpath)
    ;;
    (let ( (probfil (mapstring_getstr filedict realpath))
	   )
      (when probfil
	(debug "probe_get_file_of_name return found probfil=" probfil)
	(assert_msg "check probfil" (is_a probfil class_probed_file))
	(return probfil)
	)
      ;; grow filesvec if needed, i.e. if filesvec's last slot is filled
      (if (multiple_nth filesvec -1)
	  (let ( (:long newlen (+i 10 (/i (*i veclen 3) 2)))
		 (newvec (make_multiple discr_multiple newlen))
		 )
	    (foreach_in_multiple
	     (filesvec)
	     (curfil :long fix)
	     (multiple_put_nth newvec fix curfil))
	    (setq filesvec newvec)
	    (put_fields probedata :probedata_filesvec newvec)))
      ;; find a position in pos, fill and return it
      (foreach_in_multiple
       (filesvec)
       (curfil :long filix)
       (if filix			;skip slot 0
	   (unless curfil
	     (let ( 
		   (newfil
		    (instance class_probed_file
			      :probedfile_rank (make_integerbox discr_constant_integer
								filix)
			      :probedfile_path name
			      :probedfile_realpath realpath
			      :probedfile_data ()
			      ))
		   )
	       (multiple_put_nth filesvec filix newfil)
	       (mapstring_putstr filedict name newfil)
	       (mapstring_putstr filedict realpath newfil)
	       (put_int newfil filix)
	       (debug "probe_get_file_of_name made newfil=" newfil)
	       (send_command_to_probe 'showfile_pcd name filix)
	       ))
	 )))))



(defun probe_docmd  (cmd moduldata)
  (debug "probe_docmd cmd=" cmd " moduldata=" moduldata)
  (let (
        (mainfilename (make_string_real_access_path discr_string (main_input_filename)))
        (filesvec  (make_multiple discr_multiple 10))
        (filedict (make_mapstring discr_map_strings 17))
        (probedata (instance class_probe_data
                             :probedata_filesvec filesvec
                             :probedata_filedict filedict))
        )
    (debug "probe_docmd probedata=" probedata " maininput=" (main_input_filename))
    (let ( (mainprfil (probe_get_file_of_name probedata mainfilename))
          )
    (debug "probe_docmd mainprfil=" mainprfil)
  (assert_msg "$@$unimplemented probe_docmd" ())
)))


(definstance probe_mode
  class_melt_mode
  :named_name '"probe"
  :meltmode_help '"enable the simple interactive probe"
  :meltmode_fun probe_docmd
)
(install_melt_mode probe_mode)

(export_class class_probed_file class_probe_data)

(export_values 
 probe_get_file_of_name
 send_command_to_probe
 send_object_to_probe 
)
;; eof xtramelt-probe.melt
