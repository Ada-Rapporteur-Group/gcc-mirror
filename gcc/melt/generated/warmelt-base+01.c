/* GCC MELT GENERATED FILE warmelt-base+01.c - DO NOT EDIT */
/* secondary MELT generated C file of rank #1 */
#include "melt-run.h"


/* used hash from melt-run.h when compiling this file: */
const char used_meltrun_md5_melt_f1[] =
  MELT_RUN_HASHMD5 /* from melt-run.h */ ;


/**** warmelt-base+01.c declarations ****/
#define MELT_HAS_INITIAL_ENVIRONMENT 1

struct melt_callframe_st;	/*defined in melt-runtime.h */


/**!!** ***
    Copyright 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
    Contributed by Basile Starynkevitch <basile@starynkevitch.net>
               and Pierre Vittet  <piervit@pvittet.com>

    This file is part of GCC.

    GCC is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.

    GCC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.
*****!!**/




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_1_warmelt_base_IV (meltclosure_ptr_t closp_, melt_ptr_t firstargp_,
			    const melt_argdescr_cell_t xargdescr_[],
			    union meltparam_un *xargtab_,
			    const melt_argdescr_cell_t xresdescr_[],
			    union meltparam_un *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_2_warmelt_base_IV (meltclosure_ptr_t closp_, melt_ptr_t firstargp_,
			    const melt_argdescr_cell_t xargdescr_[],
			    union meltparam_un *xargtab_,
			    const melt_argdescr_cell_t xresdescr_[],
			    union meltparam_un *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_3_warmelt_base_IV (meltclosure_ptr_t closp_, melt_ptr_t firstargp_,
			    const melt_argdescr_cell_t xargdescr_[],
			    union meltparam_un *xargtab_,
			    const melt_argdescr_cell_t xresdescr_[],
			    union meltparam_un *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_4_warmelt_base_IV (meltclosure_ptr_t closp_, melt_ptr_t firstargp_,
			    const melt_argdescr_cell_t xargdescr_[],
			    union meltparam_un *xargtab_,
			    const melt_argdescr_cell_t xresdescr_[],
			    union meltparam_un *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_5_warmelt_base_IV (meltclosure_ptr_t closp_, melt_ptr_t firstargp_,
			    const melt_argdescr_cell_t xargdescr_[],
			    union meltparam_un *xargtab_,
			    const melt_argdescr_cell_t xresdescr_[],
			    union meltparam_un *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_6_warmelt_base_COMPARE_NAMED_ALPHA (meltclosure_ptr_t closp_,
					     melt_ptr_t firstargp_,
					     const melt_argdescr_cell_t
					     xargdescr_[],
					     union meltparam_un *xargtab_,
					     const melt_argdescr_cell_t
					     xresdescr_[],
					     union meltparam_un *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_7_warmelt_base_MAPSTRING_EVERY (meltclosure_ptr_t closp_,
					 melt_ptr_t firstargp_,
					 const melt_argdescr_cell_t
					 xargdescr_[],
					 union meltparam_un *xargtab_,
					 const melt_argdescr_cell_t
					 xresdescr_[],
					 union meltparam_un *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_8_warmelt_base_MAPSTRING_ITERATE_TEST (meltclosure_ptr_t closp_,
						melt_ptr_t firstargp_,
						const melt_argdescr_cell_t
						xargdescr_[],
						union meltparam_un *xargtab_,
						const melt_argdescr_cell_t
						xresdescr_[],
						union meltparam_un *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_9_warmelt_base_MULTIPLE_EVERY (meltclosure_ptr_t closp_,
					melt_ptr_t firstargp_,
					const melt_argdescr_cell_t
					xargdescr_[],
					union meltparam_un *xargtab_,
					const melt_argdescr_cell_t
					xresdescr_[],
					union meltparam_un *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_10_warmelt_base_MULTIPLE_BACKWARD_EVERY (meltclosure_ptr_t closp_,
						  melt_ptr_t firstargp_,
						  const melt_argdescr_cell_t
						  xargdescr_[],
						  union meltparam_un
						  *xargtab_,
						  const melt_argdescr_cell_t
						  xresdescr_[],
						  union meltparam_un
						  *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_11_warmelt_base_MULTIPLE_EVERY_BOTH (meltclosure_ptr_t closp_,
					      melt_ptr_t firstargp_,
					      const melt_argdescr_cell_t
					      xargdescr_[],
					      union meltparam_un *xargtab_,
					      const melt_argdescr_cell_t
					      xresdescr_[],
					      union meltparam_un *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_12_warmelt_base_RUN_ALL_PASS_EXECUTION_HOOKS (meltclosure_ptr_t
						       closp_,
						       melt_ptr_t firstargp_,
						       const
						       melt_argdescr_cell_t
						       xargdescr_[],
						       union meltparam_un
						       *xargtab_,
						       const
						       melt_argdescr_cell_t
						       xresdescr_[],
						       union meltparam_un
						       *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_13_warmelt_base_REGISTER_PASS_EXECUTION_HOOK (meltclosure_ptr_t
						       closp_,
						       melt_ptr_t firstargp_,
						       const
						       melt_argdescr_cell_t
						       xargdescr_[],
						       union meltparam_un
						       *xargtab_,
						       const
						       melt_argdescr_cell_t
						       xresdescr_[],
						       union meltparam_un
						       *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_14_warmelt_base_LAMBDA___1__ (meltclosure_ptr_t closp_,
				       melt_ptr_t firstargp_,
				       const melt_argdescr_cell_t
				       xargdescr_[],
				       union meltparam_un *xargtab_,
				       const melt_argdescr_cell_t
				       xresdescr_[],
				       union meltparam_un *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_15_warmelt_base_UNREGISTER_PASS_EXECUTION_HOOK (meltclosure_ptr_t
							 closp_,
							 melt_ptr_t
							 firstargp_,
							 const
							 melt_argdescr_cell_t
							 xargdescr_[],
							 union meltparam_un
							 *xargtab_,
							 const
							 melt_argdescr_cell_t
							 xresdescr_[],
							 union meltparam_un
							 *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_16_warmelt_base_LAMBDA___2__ (meltclosure_ptr_t closp_,
				       melt_ptr_t firstargp_,
				       const melt_argdescr_cell_t
				       xargdescr_[],
				       union meltparam_un *xargtab_,
				       const melt_argdescr_cell_t
				       xresdescr_[],
				       union meltparam_un *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_17_warmelt_base_REGISTER_PRAGMA_HANDLER (meltclosure_ptr_t closp_,
						  melt_ptr_t firstargp_,
						  const melt_argdescr_cell_t
						  xargdescr_[],
						  union meltparam_un
						  *xargtab_,
						  const melt_argdescr_cell_t
						  xresdescr_[],
						  union meltparam_un
						  *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_18_warmelt_base_REGISTER_PRE_GENERICIZE_HOOK_FIRST (meltclosure_ptr_t
							     closp_,
							     melt_ptr_t
							     firstargp_,
							     const
							     melt_argdescr_cell_t
							     xargdescr_[],
							     union
							     meltparam_un
							     *xargtab_,
							     const
							     melt_argdescr_cell_t
							     xresdescr_[],
							     union
							     meltparam_un
							     *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_19_warmelt_base_REGISTER_PRE_GENERICIZE_HOOK_LAST (meltclosure_ptr_t
							    closp_,
							    melt_ptr_t
							    firstargp_,
							    const
							    melt_argdescr_cell_t
							    xargdescr_[],
							    union meltparam_un
							    *xargtab_,
							    const
							    melt_argdescr_cell_t
							    xresdescr_[],
							    union meltparam_un
							    *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_20_warmelt_base_PRE_GENERICIZE_HOOK_RUNNER (meltclosure_ptr_t closp_,
						     melt_ptr_t firstargp_,
						     const
						     melt_argdescr_cell_t
						     xargdescr_[],
						     union meltparam_un
						     *xargtab_,
						     const
						     melt_argdescr_cell_t
						     xresdescr_[],
						     union meltparam_un
						     *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_21_warmelt_base_LAMBDA___3__ (meltclosure_ptr_t closp_,
				       melt_ptr_t firstargp_,
				       const melt_argdescr_cell_t
				       xargdescr_[],
				       union meltparam_un *xargtab_,
				       const melt_argdescr_cell_t
				       xresdescr_[],
				       union meltparam_un *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_22_warmelt_base_LAMBDA___4__ (meltclosure_ptr_t closp_,
				       melt_ptr_t firstargp_,
				       const melt_argdescr_cell_t
				       xargdescr_[],
				       union meltparam_un *xargtab_,
				       const melt_argdescr_cell_t
				       xresdescr_[],
				       union meltparam_un *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_23_warmelt_base_LAMBDA___5__ (meltclosure_ptr_t closp_,
				       melt_ptr_t firstargp_,
				       const melt_argdescr_cell_t
				       xargdescr_[],
				       union meltparam_un *xargtab_,
				       const melt_argdescr_cell_t
				       xresdescr_[],
				       union meltparam_un *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_24_warmelt_base_SET_CONTENT (meltclosure_ptr_t closp_,
				      melt_ptr_t firstargp_,
				      const melt_argdescr_cell_t xargdescr_[],
				      union meltparam_un *xargtab_,
				      const melt_argdescr_cell_t xresdescr_[],
				      union meltparam_un *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_25_warmelt_base_INSTALL_VALUE_DESCRIPTOR (meltclosure_ptr_t closp_,
						   melt_ptr_t firstargp_,
						   const melt_argdescr_cell_t
						   xargdescr_[],
						   union meltparam_un
						   *xargtab_,
						   const melt_argdescr_cell_t
						   xresdescr_[],
						   union meltparam_un
						   *xrestab_);




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_26_warmelt_base_RETRIEVE_VALUE_DESCRIPTOR_LIST (meltclosure_ptr_t
							 closp_,
							 melt_ptr_t
							 firstargp_,
							 const
							 melt_argdescr_cell_t
							 xargdescr_[],
							 union meltparam_un
							 *xargtab_,
							 const
							 melt_argdescr_cell_t
							 xresdescr_[],
							 union meltparam_un
							 *xrestab_);


void *start_module_melt (void *);

/* define different names when debugging or not */
#if MELT_HAVE_DEBUG
extern const char meltmodule_warmelt_base__melt_have_debug_enabled[];
#define melt_have_debug_string meltmodule_warmelt_base__melt_have_debug_enabled
#else /*!MELT_HAVE_DEBUG */
extern const char meltmodule_warmelt_base__melt_have_debug_disabled[];
#define melt_have_debug_string meltmodule_warmelt_base__melt_have_debug_disabled
#endif /*!MELT_HAVE_DEBUG */


struct frame_start_module_melt_st;
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_0 (struct
							     frame_start_module_melt_st
							     *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_1 (struct
							     frame_start_module_melt_st
							     *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_2 (struct
							     frame_start_module_melt_st
							     *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_3 (struct
							     frame_start_module_melt_st
							     *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_4 (struct
							     frame_start_module_melt_st
							     *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_5 (struct
							     frame_start_module_melt_st
							     *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_6 (struct
							     frame_start_module_melt_st
							     *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_7 (struct
							     frame_start_module_melt_st
							     *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_8 (struct
							     frame_start_module_melt_st
							     *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_9 (struct
							     frame_start_module_melt_st
							     *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_10 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_11 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_12 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_13 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_14 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_15 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_16 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_17 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_18 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_19 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_20 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_21 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_22 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_23 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_24 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_25 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_26 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_27 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_28 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_29 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_30 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_31 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_32 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_33 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_34 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_35 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_36 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_37 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_38 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_39 (struct
							      frame_start_module_melt_st
							      *, char *);
void MELT_MODULE_VISIBILITY warmelt_base_initialmeltchunk_40 (struct
							      frame_start_module_melt_st
							      *, char *);
static void forward_or_mark_module_start_frame_warmelt_base (struct
							     melt_callframe_st
							     *fp,
							     int marking);


/**** warmelt-base+01.c implementations ****/




melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_5_warmelt_base_IV (meltclosure_ptr_t closp_, melt_ptr_t firstargp_,
			    const melt_argdescr_cell_t xargdescr_[],
			    union meltparam_un *xargtab_,
			    const melt_argdescr_cell_t xresdescr_[],
			    union meltparam_un *xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_5_warmelt_base_IV_st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 8
    void *mcfr_varptr[8];
#define MELTFRAM_NBVARNUM 5
    long mcfr_varnum[5];
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 8; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 8;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("%IV", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:195:/ getarg");
 /*_.A__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;

  /*getarg#1 */
  /*^getarg */
  if (xargdescr_[0] != MELTBPAR_PTR)
    goto lab_endgetargs;
 /*_.B__V3*/ meltfptr[2] =
    (xargtab_[0].meltbp_aptr) ? (*(xargtab_[0].meltbp_aptr)) : NULL;
  gcc_assert (melt_discr ((melt_ptr_t) ( /*_.B__V3*/ meltfptr[2])) != NULL);

  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {

 /*_#IS_INTEGERBOX__L1*/ meltfnum[0] =
      (melt_magic_discr ((melt_ptr_t) ( /*_.A__V2*/ meltfptr[1])) ==
       MELTOBMAG_INT);;
    MELT_LOCATION ("warmelt-base.melt:198:/ cond");
    /*cond */ if ( /*_#IS_INTEGERBOX__L1*/ meltfnum[0])	/*then */
      {
	/*^cond.then */
	/*^block */
	/*anyblock */
	{

   /*_#IS_INTEGERBOX__L2*/ meltfnum[1] =
	    (melt_magic_discr ((melt_ptr_t) ( /*_.B__V3*/ meltfptr[2])) ==
	     MELTOBMAG_INT);;
	  MELT_LOCATION ("warmelt-base.melt:199:/ cond");
	  /*cond */ if ( /*_#IS_INTEGERBOX__L2*/ meltfnum[1])	/*then */
	    {
	      /*^cond.then */
	      /*^block */
	      /*anyblock */
	      {

		MELT_LOCATION ("warmelt-base.melt:200:/ quasiblock");


     /*_#IB__L3*/ meltfnum[2] =
		  (melt_get_int ((melt_ptr_t) ( /*_.B__V3*/ meltfptr[2])));;
		MELT_LOCATION ("warmelt-base.melt:201:/ cond");
		/*cond */ if ( /*_#IB__L3*/ meltfnum[2])	/*then */
		  {
		    /*^cond.then */
		    /*^block */
		    /*anyblock */
		    {

       /*_#GET_INT__L4*/ meltfnum[3] =
			(melt_get_int
			 ((melt_ptr_t) ( /*_.A__V2*/ meltfptr[1])));;
		      /*^compute */

       /*_#I__L5*/ meltfnum[4] =
			(melt_imod
			 (( /*_#GET_INT__L4*/ meltfnum[3]),
			  ( /*_#IB__L3*/ meltfnum[2])));;
		      /*^compute */

       /*_.MAKE_INTEGERBOX__V8*/ meltfptr[7] =
			(meltgc_new_int
			 ((meltobject_ptr_t)
			  (( /*!DISCR_CONSTANT_INTEGER */ meltfrout->
			    tabval[0])), ( /*_#I__L5*/ meltfnum[4])));;
		      /*^compute */

		      /*_.IF___V7*/ meltfptr[6] =
			/*_.MAKE_INTEGERBOX__V8*/ meltfptr[7];;
		      /*epilog */

		      MELT_LOCATION ("warmelt-base.melt:201:/ clear");
		 /*clear *//*_#GET_INT__L4*/ meltfnum[3] = 0;
		      /*^clear */
		 /*clear *//*_#I__L5*/ meltfnum[4] = 0;
		      /*^clear */
		 /*clear *//*_.MAKE_INTEGERBOX__V8*/ meltfptr[7] = 0;
		    }
		    ;
		  }
		else
		  {		/*^cond.else */

      /*_.IF___V7*/ meltfptr[6] = NULL;;
		  }
		;
		/*^compute */

		/*_.LET___V6*/ meltfptr[5] = /*_.IF___V7*/ meltfptr[6];;

		MELT_LOCATION ("warmelt-base.melt:200:/ clear");
	       /*clear *//*_#IB__L3*/ meltfnum[2] = 0;
		/*^clear */
	       /*clear *//*_.IF___V7*/ meltfptr[6] = 0;
		/*_.IF___V5*/ meltfptr[4] = /*_.LET___V6*/ meltfptr[5];;
		/*epilog */

		MELT_LOCATION ("warmelt-base.melt:199:/ clear");
	       /*clear *//*_.LET___V6*/ meltfptr[5] = 0;
	      }
	      ;
	    }
	  else
	    {			/*^cond.else */

    /*_.IF___V5*/ meltfptr[4] = NULL;;
	    }
	  ;
	  /*^compute */

	  /*_.IF___V4*/ meltfptr[3] = /*_.IF___V5*/ meltfptr[4];;
	  /*epilog */

	  MELT_LOCATION ("warmelt-base.melt:198:/ clear");
	     /*clear *//*_#IS_INTEGERBOX__L2*/ meltfnum[1] = 0;
	  /*^clear */
	     /*clear *//*_.IF___V5*/ meltfptr[4] = 0;
	}
	;
      }
    else
      {				/*^cond.else */

  /*_.IF___V4*/ meltfptr[3] = NULL;;
      }
    ;
    MELT_LOCATION ("warmelt-base.melt:195:/ quasiblock");


    /*_.RETVAL___V1*/ meltfptr[0] = /*_.IF___V4*/ meltfptr[3];;
    MELT_LOCATION ("warmelt-base.melt:195:/ finalreturn");
    ;
    /*finalret */ goto labend_rout;
    /*epilog */

    /*^clear */
	   /*clear *//*_#IS_INTEGERBOX__L1*/ meltfnum[0] = 0;
    /*^clear */
	   /*clear *//*_.IF___V4*/ meltfptr[3] = 0;
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("%IV", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*_.RETVAL___V1*/ meltfptr[0]);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_5_warmelt_base_IV */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_6_warmelt_base_COMPARE_NAMED_ALPHA (meltclosure_ptr_t closp_,
					     melt_ptr_t firstargp_,
					     const melt_argdescr_cell_t
					     xargdescr_[],
					     union meltparam_un * xargtab_,
					     const melt_argdescr_cell_t
					     xresdescr_[],
					     union meltparam_un * xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_6_warmelt_base_COMPARE_NAMED_ALPHA_st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 13
    void *mcfr_varptr[13];
#define MELTFRAM_NBVARNUM 5
    long mcfr_varnum[5];
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 13; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 13;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("COMPARE_NAMED_ALPHA", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:914:/ getarg");
 /*_.N1__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;

  /*getarg#1 */
  /*^getarg */
  if (xargdescr_[0] != MELTBPAR_PTR)
    goto lab_endgetargs;
 /*_.N2__V3*/ meltfptr[2] =
    (xargtab_[0].meltbp_aptr) ? (*(xargtab_[0].meltbp_aptr)) : NULL;
  gcc_assert (melt_discr ((melt_ptr_t) ( /*_.N2__V3*/ meltfptr[2])) != NULL);

  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {

 /*_#__L1*/ meltfnum[0] =
      (( /*_.N1__V2*/ meltfptr[1]) == ( /*_.N2__V3*/ meltfptr[2]));;
    MELT_LOCATION ("warmelt-base.melt:918:/ cond");
    /*cond */ if ( /*_#__L1*/ meltfnum[0])	/*then */
      {
	/*^cond.then */
	/*_.IFELSE___V4*/ meltfptr[3] =
	  ( /*!konst_0 */ meltfrout->tabval[0]);;
      }
    else
      {
	MELT_LOCATION ("warmelt-base.melt:918:/ cond.else");

	/*^block */
	/*anyblock */
	{

   /*_#IS_NOT_A__L2*/ meltfnum[1] =
	    !melt_is_instance_of ((melt_ptr_t) ( /*_.N1__V2*/ meltfptr[1]),
				  (melt_ptr_t) (( /*!CLASS_NAMED */
						 meltfrout->tabval[1])));;
	  MELT_LOCATION ("warmelt-base.melt:919:/ cond");
	  /*cond */ if ( /*_#IS_NOT_A__L2*/ meltfnum[1])	/*then */
	    {
	      /*^cond.then */
	      /*_.IFELSE___V5*/ meltfptr[4] =
		( /*!konst_2 */ meltfrout->tabval[2]);;
	    }
	  else
	    {
	      MELT_LOCATION ("warmelt-base.melt:919:/ cond.else");

	      /*^block */
	      /*anyblock */
	      {

     /*_#IS_NOT_A__L3*/ meltfnum[2] =
		  !melt_is_instance_of ((melt_ptr_t)
					( /*_.N2__V3*/ meltfptr[2]),
					(melt_ptr_t) (( /*!CLASS_NAMED */
						       meltfrout->
						       tabval[1])));;
		MELT_LOCATION ("warmelt-base.melt:921:/ cond");
		/*cond */ if ( /*_#IS_NOT_A__L3*/ meltfnum[2])	/*then */
		  {
		    /*^cond.then */
		    /*_.IFELSE___V6*/ meltfptr[5] =
		      ( /*!konst_3 */ meltfrout->tabval[3]);;
		  }
		else
		  {
		    MELT_LOCATION ("warmelt-base.melt:921:/ cond.else");

		    /*^block */
		    /*anyblock */
		    {

		      MELT_LOCATION ("warmelt-base.melt:924:/ quasiblock");


		      /*^getslot */
		      {
			melt_ptr_t slot = 0;
			melt_object_get_field (slot, (melt_ptr_t) ( /*_.N1__V2*/ meltfptr[1]), 1, "NAMED_NAME");
											    /*_.SN1__V8*/
			meltfptr[7] = slot;
		      };
		      ;
		      MELT_LOCATION ("warmelt-base.melt:925:/ getslot");
		      {
			melt_ptr_t slot = 0;
			melt_object_get_field (slot, (melt_ptr_t) ( /*_.N2__V3*/ meltfptr[2]), 1, "NAMED_NAME");
											    /*_.SN2__V9*/
			meltfptr[8] = slot;
		      };
		      ;
       /*_#STRING___L4*/ meltfnum[3] =
			melt_string_less ((melt_ptr_t)
					  ( /*_.SN1__V8*/ meltfptr[7]),
					  (melt_ptr_t) ( /*_.SN2__V9*/
							meltfptr[8]));;
		      MELT_LOCATION ("warmelt-base.melt:927:/ cond");
		      /*cond */ if ( /*_#STRING___L4*/ meltfnum[3])	/*then */
			{
			  /*^cond.then */
			  /*_.IFELSE___V10*/ meltfptr[9] =
			    ( /*!konst_4 */ meltfrout->tabval[4]);;
			}
		      else
			{
			  MELT_LOCATION ("warmelt-base.melt:927:/ cond.else");

			  /*^block */
			  /*anyblock */
			  {

	 /*_#STRING___L5*/ meltfnum[4] =
			      melt_string_less ((melt_ptr_t)
						( /*_.SN2__V9*/ meltfptr[8]),
						(melt_ptr_t) ( /*_.SN1__V8*/
							      meltfptr[7]));;
			    MELT_LOCATION ("warmelt-base.melt:929:/ cond");
			    /*cond */ if ( /*_#STRING___L5*/ meltfnum[4])	/*then */
			      {
				/*^cond.then */
				/*_.IFELSE___V11*/ meltfptr[10] =
				  ( /*!konst_5 */ meltfrout->tabval[5]);;
			      }
			    else
			      {
				MELT_LOCATION
				  ("warmelt-base.melt:929:/ cond.else");

				/*^block */
				/*anyblock */
				{

				  MELT_LOCATION
				    ("warmelt-base.melt:931:/ quasiblock");


				  /*_.PROGN___V12*/ meltfptr[11] =
				    ( /*!konst_6 */ meltfrout->tabval[6]);;
				  /*^compute */

				  /*_.IFELSE___V11*/ meltfptr[10] =
				    /*_.PROGN___V12*/ meltfptr[11];;
				  /*epilog */

				  MELT_LOCATION
				    ("warmelt-base.melt:929:/ clear");
		     /*clear *//*_.PROGN___V12*/ meltfptr[11] =
				    0;
				}
				;
			      }
			    ;
			    /*_.IFELSE___V10*/ meltfptr[9] =
			      /*_.IFELSE___V11*/ meltfptr[10];;
			    /*epilog */

			    MELT_LOCATION ("warmelt-base.melt:927:/ clear");
		   /*clear *//*_#STRING___L5*/ meltfnum[4] = 0;
			    /*^clear */
		   /*clear *//*_.IFELSE___V11*/ meltfptr[10] = 0;
			  }
			  ;
			}
		      ;
		      /*_.LET___V7*/ meltfptr[6] =
			/*_.IFELSE___V10*/ meltfptr[9];;

		      MELT_LOCATION ("warmelt-base.melt:924:/ clear");
		 /*clear *//*_.SN1__V8*/ meltfptr[7] = 0;
		      /*^clear */
		 /*clear *//*_.SN2__V9*/ meltfptr[8] = 0;
		      /*^clear */
		 /*clear *//*_#STRING___L4*/ meltfnum[3] = 0;
		      /*^clear */
		 /*clear *//*_.IFELSE___V10*/ meltfptr[9] = 0;
		      MELT_LOCATION ("warmelt-base.melt:923:/ quasiblock");


		      /*_.PROGN___V13*/ meltfptr[11] =
			/*_.LET___V7*/ meltfptr[6];;
		      /*^compute */

		      /*_.IFELSE___V6*/ meltfptr[5] =
			/*_.PROGN___V13*/ meltfptr[11];;
		      /*epilog */

		      MELT_LOCATION ("warmelt-base.melt:921:/ clear");
		 /*clear *//*_.LET___V7*/ meltfptr[6] = 0;
		      /*^clear */
		 /*clear *//*_.PROGN___V13*/ meltfptr[11] = 0;
		    }
		    ;
		  }
		;
		/*_.IFELSE___V5*/ meltfptr[4] =
		  /*_.IFELSE___V6*/ meltfptr[5];;
		/*epilog */

		MELT_LOCATION ("warmelt-base.melt:919:/ clear");
	       /*clear *//*_#IS_NOT_A__L3*/ meltfnum[2] = 0;
		/*^clear */
	       /*clear *//*_.IFELSE___V6*/ meltfptr[5] = 0;
	      }
	      ;
	    }
	  ;
	  /*_.IFELSE___V4*/ meltfptr[3] = /*_.IFELSE___V5*/ meltfptr[4];;
	  /*epilog */

	  MELT_LOCATION ("warmelt-base.melt:918:/ clear");
	     /*clear *//*_#IS_NOT_A__L2*/ meltfnum[1] = 0;
	  /*^clear */
	     /*clear *//*_.IFELSE___V5*/ meltfptr[4] = 0;
	}
	;
      }
    ;
    MELT_LOCATION ("warmelt-base.melt:914:/ quasiblock");


    /*_.RETVAL___V1*/ meltfptr[0] = /*_.IFELSE___V4*/ meltfptr[3];;
    MELT_LOCATION ("warmelt-base.melt:914:/ finalreturn");
    ;
    /*finalret */ goto labend_rout;
    /*epilog */

    /*^clear */
	   /*clear *//*_#__L1*/ meltfnum[0] = 0;
    /*^clear */
	   /*clear *//*_.IFELSE___V4*/ meltfptr[3] = 0;
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("COMPARE_NAMED_ALPHA", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*_.RETVAL___V1*/ meltfptr[0]);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_6_warmelt_base_COMPARE_NAMED_ALPHA */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_7_warmelt_base_MAPSTRING_EVERY (meltclosure_ptr_t closp_,
					 melt_ptr_t firstargp_,
					 const melt_argdescr_cell_t
					 xargdescr_[],
					 union meltparam_un * xargtab_,
					 const melt_argdescr_cell_t
					 xresdescr_[],
					 union meltparam_un * xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_7_warmelt_base_MAPSTRING_EVERY_st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 6
    void *mcfr_varptr[6];
#define MELTFRAM_NBVARNUM 2
    long mcfr_varnum[2];
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 6; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 6;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("MAPSTRING_EVERY", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1221:/ getarg");
 /*_.MAP__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;

  /*getarg#1 */
  /*^getarg */
  if (xargdescr_[0] != MELTBPAR_PTR)
    goto lab_endgetargs;
 /*_.F__V3*/ meltfptr[2] =
    (xargtab_[0].meltbp_aptr) ? (*(xargtab_[0].meltbp_aptr)) : NULL;
  gcc_assert (melt_discr ((melt_ptr_t) ( /*_.F__V3*/ meltfptr[2])) != NULL);

  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {

 /*_#IS_MAPSTRING__L1*/ meltfnum[0] =
      (melt_magic_discr ((melt_ptr_t) ( /*_.MAP__V2*/ meltfptr[1])) ==
       MELTOBMAG_MAPSTRINGS);;
    MELT_LOCATION ("warmelt-base.melt:1225:/ cond");
    /*cond */ if ( /*_#IS_MAPSTRING__L1*/ meltfnum[0])	/*then */
      {
	/*^cond.then */
	/*^block */
	/*anyblock */
	{

   /*_#IS_CLOSURE__L2*/ meltfnum[1] =
	    (melt_magic_discr ((melt_ptr_t) ( /*_.F__V3*/ meltfptr[2])) ==
	     MELTOBMAG_CLOSURE);;
	  MELT_LOCATION ("warmelt-base.melt:1226:/ cond");
	  /*cond */ if ( /*_#IS_CLOSURE__L2*/ meltfnum[1])	/*then */
	    {
	      /*^cond.then */
	      /*^block */
	      /*anyblock */
	      {

		/*citerblock FOREACH_IN_MAPSTRING */
		{
		  /*cit1__EACHSTRMAP : */ int cit1__EACHSTRMAP_ix =
		    0, cit1__EACHSTRMAP_siz = 0;
		  for (cit1__EACHSTRMAP_ix = 0;
		       /* we retrieve in cit1__EACHSTRMAP_siz the size at each iteration since it could change. */
		       cit1__EACHSTRMAP_ix >= 0
		       && (cit1__EACHSTRMAP_siz =
			   melt_size_mapstrings ( /*_.MAP__V2*/ meltfptr[1]))
		       > 0
		       && cit1__EACHSTRMAP_ix < cit1__EACHSTRMAP_siz;
		       cit1__EACHSTRMAP_ix++)
		    {
		      const char *cit1__EACHSTRMAP_str = NULL;
		      const char *cit1__EACHSTRMAP_nam = NULL;
    /*_.CURAT__V4*/ meltfptr[3] = NULL;
    /*_.CURVAL__V5*/ meltfptr[4] = NULL;
		      cit1__EACHSTRMAP_str =
			((struct meltmapstrings_st *) /*_.MAP__V2*/
			 meltfptr[1])->entab[cit1__EACHSTRMAP_ix].e_at;
		      if (cit1__EACHSTRMAP_str == HTAB_DELETED_ENTRY)
			{			      /*_.CURAT__V4*/
			  meltfptr[3] = NULL;
			  continue;
			};
		      if (!cit1__EACHSTRMAP_str)
			continue;
		      /*_.CURVAL__V5*/ meltfptr[4] =
			((struct meltmapstrings_st *) /*_.MAP__V2*/
			 meltfptr[1])->entab[cit1__EACHSTRMAP_ix].e_va;
		      if (! /*_.CURVAL__V5*/ meltfptr[4])
			continue;
		      if (melt_is_instance_of
			  ( /*_.CURVAL__V5*/ meltfptr[4],
			   MELT_PREDEF (CLASS_NAMED))
			  && ( /*_.CURAT__V4*/ meltfptr[3] =
			      melt_object_nth_field ((melt_ptr_t)
						     /*_.CURVAL__V5*/
						     meltfptr[4],
						     FNAMED_NAME)) != NULL
			  && (cit1__EACHSTRMAP_nam =
			      melt_string_str ((melt_ptr_t) /*_.CURAT__V4*/
					       meltfptr[3])) != (char *) 0
			  && !strcmp (cit1__EACHSTRMAP_nam,
				      cit1__EACHSTRMAP_str))
			/*_.CURAT__V4*/ meltfptr[3] =
			  /*_.CURAT__V4*/ meltfptr[3];
		      else
			{
      /*_.CURAT__V4*/ meltfptr[3] = NULL;
      /*_.CURAT__V4*/ meltfptr[3] =
			    meltgc_new_stringdup ((meltobject_ptr_t) MELT_PREDEF (DISCR_STRING), cit1__EACHSTRMAP_str);
			}
		      cit1__EACHSTRMAP_str = (const char *) 0;
		      cit1__EACHSTRMAP_nam = (const char *) 0;



		      MELT_LOCATION ("warmelt-base.melt:1230:/ apply");
		      /*apply */
		      {
			union meltparam_un argtab[1];
			memset (&argtab, 0, sizeof (argtab));
			/*^apply.arg */
			argtab[0].meltbp_aptr =
			  (melt_ptr_t *) & /*_.CURVAL__V5*/ meltfptr[4];
			/*_.F__V6*/ meltfptr[5] =
			  melt_apply ((meltclosure_ptr_t)
				      ( /*_.F__V3*/ meltfptr[2]),
				      (melt_ptr_t) ( /*_.CURAT__V4*/
						    meltfptr[3]),
				      (MELTBPARSTR_PTR ""), argtab, "",
				      (union meltparam_un *) 0);
		      }
		      ;
		      /* end cit1__EACHSTRMAP */
    /*_.CURAT__V4*/ meltfptr[3] = NULL;
    /*_.CURVAL__V5*/ meltfptr[4] = NULL;
		    }


		  /*citerepilog */

		  MELT_LOCATION ("warmelt-base.melt:1227:/ clear");
		/*clear *//*_.CURAT__V4*/ meltfptr[3] = 0;
		  /*^clear */
		/*clear *//*_.CURVAL__V5*/ meltfptr[4] = 0;
		  /*^clear */
		/*clear *//*_.F__V6*/ meltfptr[5] = 0;
		}		/*endciterblock FOREACH_IN_MAPSTRING */
		;
		/*epilog */
	      }
	      ;
	    }			/*noelse */
	  ;
	  /*epilog */

	  MELT_LOCATION ("warmelt-base.melt:1225:/ clear");
	     /*clear *//*_#IS_CLOSURE__L2*/ meltfnum[1] = 0;
	}
	;
      }				/*noelse */
    ;
    /*epilog */

    MELT_LOCATION ("warmelt-base.melt:1221:/ clear");
	   /*clear *//*_#IS_MAPSTRING__L1*/ meltfnum[0] = 0;
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("MAPSTRING_EVERY", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*noretval */ NULL);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_7_warmelt_base_MAPSTRING_EVERY */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_8_warmelt_base_MAPSTRING_ITERATE_TEST (meltclosure_ptr_t closp_,
						melt_ptr_t firstargp_,
						const melt_argdescr_cell_t
						xargdescr_[],
						union meltparam_un * xargtab_,
						const melt_argdescr_cell_t
						xresdescr_[],
						union meltparam_un * xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_8_warmelt_base_MAPSTRING_ITERATE_TEST_st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 10
    void *mcfr_varptr[10];
#define MELTFRAM_NBVARNUM 3
    long mcfr_varnum[3];
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 10; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 10;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("MAPSTRING_ITERATE_TEST", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1234:/ getarg");
 /*_.MAP__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;

  /*getarg#1 */
  /*^getarg */
  if (xargdescr_[0] != MELTBPAR_PTR)
    goto lab_endgetargs;
 /*_.F__V3*/ meltfptr[2] =
    (xargtab_[0].meltbp_aptr) ? (*(xargtab_[0].meltbp_aptr)) : NULL;
  gcc_assert (melt_discr ((melt_ptr_t) ( /*_.F__V3*/ meltfptr[2])) != NULL);

  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {

 /*_#IS_MAPSTRING__L1*/ meltfnum[0] =
      (melt_magic_discr ((melt_ptr_t) ( /*_.MAP__V2*/ meltfptr[1])) ==
       MELTOBMAG_MAPSTRINGS);;
    MELT_LOCATION ("warmelt-base.melt:1239:/ cond");
    /*cond */ if ( /*_#IS_MAPSTRING__L1*/ meltfnum[0])	/*then */
      {
	/*^cond.then */
	/*^block */
	/*anyblock */
	{

   /*_#IS_CLOSURE__L2*/ meltfnum[1] =
	    (melt_magic_discr ((melt_ptr_t) ( /*_.F__V3*/ meltfptr[2])) ==
	     MELTOBMAG_CLOSURE);;
	  MELT_LOCATION ("warmelt-base.melt:1240:/ cond");
	  /*cond */ if ( /*_#IS_CLOSURE__L2*/ meltfnum[1])	/*then */
	    {
	      /*^cond.then */
	      /*^block */
	      /*anyblock */
	      {

		/*citerblock FOREACH_IN_MAPSTRING */
		{
		  /*cit1__EACHSTRMAP : */ int cit1__EACHSTRMAP_ix =
		    0, cit1__EACHSTRMAP_siz = 0;
		  for (cit1__EACHSTRMAP_ix = 0;
		       /* we retrieve in cit1__EACHSTRMAP_siz the size at each iteration since it could change. */
		       cit1__EACHSTRMAP_ix >= 0
		       && (cit1__EACHSTRMAP_siz =
			   melt_size_mapstrings ( /*_.MAP__V2*/ meltfptr[1]))
		       > 0
		       && cit1__EACHSTRMAP_ix < cit1__EACHSTRMAP_siz;
		       cit1__EACHSTRMAP_ix++)
		    {
		      const char *cit1__EACHSTRMAP_str = NULL;
		      const char *cit1__EACHSTRMAP_nam = NULL;
    /*_.CURAT__V4*/ meltfptr[3] = NULL;
    /*_.CURVAL__V5*/ meltfptr[4] = NULL;
		      cit1__EACHSTRMAP_str =
			((struct meltmapstrings_st *) /*_.MAP__V2*/
			 meltfptr[1])->entab[cit1__EACHSTRMAP_ix].e_at;
		      if (cit1__EACHSTRMAP_str == HTAB_DELETED_ENTRY)
			{			      /*_.CURAT__V4*/
			  meltfptr[3] = NULL;
			  continue;
			};
		      if (!cit1__EACHSTRMAP_str)
			continue;
		      /*_.CURVAL__V5*/ meltfptr[4] =
			((struct meltmapstrings_st *) /*_.MAP__V2*/
			 meltfptr[1])->entab[cit1__EACHSTRMAP_ix].e_va;
		      if (! /*_.CURVAL__V5*/ meltfptr[4])
			continue;
		      if (melt_is_instance_of
			  ( /*_.CURVAL__V5*/ meltfptr[4],
			   MELT_PREDEF (CLASS_NAMED))
			  && ( /*_.CURAT__V4*/ meltfptr[3] =
			      melt_object_nth_field ((melt_ptr_t)
						     /*_.CURVAL__V5*/
						     meltfptr[4],
						     FNAMED_NAME)) != NULL
			  && (cit1__EACHSTRMAP_nam =
			      melt_string_str ((melt_ptr_t) /*_.CURAT__V4*/
					       meltfptr[3])) != (char *) 0
			  && !strcmp (cit1__EACHSTRMAP_nam,
				      cit1__EACHSTRMAP_str))
			/*_.CURAT__V4*/ meltfptr[3] =
			  /*_.CURAT__V4*/ meltfptr[3];
		      else
			{
      /*_.CURAT__V4*/ meltfptr[3] = NULL;
      /*_.CURAT__V4*/ meltfptr[3] =
			    meltgc_new_stringdup ((meltobject_ptr_t) MELT_PREDEF (DISCR_STRING), cit1__EACHSTRMAP_str);
			}
		      cit1__EACHSTRMAP_str = (const char *) 0;
		      cit1__EACHSTRMAP_nam = (const char *) 0;



		      MELT_LOCATION ("warmelt-base.melt:1244:/ quasiblock");


		      /*^multiapply */
		      /*multiapply 2args, 1x.res */
		      {
			union meltparam_un argtab[1];

			union meltparam_un restab[1];
			memset (&restab, 0, sizeof (restab));
			memset (&argtab, 0, sizeof (argtab));
			/*^multiapply.arg */
			argtab[0].meltbp_aptr =
			  (melt_ptr_t *) & /*_.CURVAL__V5*/ meltfptr[4];
			/*^multiapply.xres */
			restab[0].meltbp_aptr =
			  (melt_ptr_t *) & /*_.OTHER__V8*/ meltfptr[7];
			/*^multiapply.appl */
			/*_.TEST__V7*/ meltfptr[6] =
			  melt_apply ((meltclosure_ptr_t)
				      ( /*_.F__V3*/ meltfptr[2]),
				      (melt_ptr_t) ( /*_.CURAT__V4*/
						    meltfptr[3]),
				      (MELTBPARSTR_PTR ""), argtab,
				      (MELTBPARSTR_PTR ""), restab);
		      }
		      ;
		      /*^quasiblock */


      /*_#NULL__L3*/ meltfnum[2] =
			(( /*_.TEST__V7*/ meltfptr[6]) == NULL);;
		      MELT_LOCATION ("warmelt-base.melt:1247:/ cond");
		      /*cond */ if ( /*_#NULL__L3*/ meltfnum[2])	/*then */
			{
			  /*^cond.then */
			  /*^block */
			  /*anyblock */
			  {

			    MELT_LOCATION
			      ("warmelt-base.melt:1248:/ quasiblock");


			    /*_.RETVAL___V1*/ meltfptr[0] =
			      /*_.CURAT__V4*/ meltfptr[3];;
			    MELT_LOCATION
			      ("warmelt-base.melt:1248:/ putxtraresult");
			    if (!xrestab_ || !xresdescr_)
			      goto labend_rout;
			    if (xresdescr_[0] != MELTBPAR_PTR)
			      goto labend_rout;
			    if (xrestab_[0].meltbp_aptr)
			      *(xrestab_[0].meltbp_aptr) =
				(melt_ptr_t) ( /*_.CURVAL__V5*/ meltfptr[4]);
			    ;
			    /*^putxtraresult */
			    if (!xrestab_ || !xresdescr_)
			      goto labend_rout;
			    if (xresdescr_[1] != MELTBPAR_PTR)
			      goto labend_rout;
			    if (xrestab_[1].meltbp_aptr)
			      *(xrestab_[1].meltbp_aptr) =
				(melt_ptr_t) ( /*_.OTHER__V8*/ meltfptr[7]);
			    ;
			    /*^finalreturn */
			    ;
			    /*finalret */ goto labend_rout;
			    /*_.IF___V9*/ meltfptr[8] =
			      /*_.RETURN___V10*/ meltfptr[9];;
			    /*epilog */

			    MELT_LOCATION ("warmelt-base.melt:1247:/ clear");
		  /*clear *//*_.RETURN___V10*/ meltfptr[9] = 0;
			  }
			  ;
			}
		      else
			{	/*^cond.else */

       /*_.IF___V9*/ meltfptr[8] = NULL;;
			}
		      ;
		      /*^compute */

		      /*_.MULTI___V6*/ meltfptr[5] =
			/*_.IF___V9*/ meltfptr[8];;

		      MELT_LOCATION ("warmelt-base.melt:1244:/ clear");
		/*clear *//*_#NULL__L3*/ meltfnum[2] = 0;
		      /*^clear */
		/*clear *//*_.IF___V9*/ meltfptr[8] = 0;

		      /*^clear */
		/*clear *//*_.OTHER__V8*/ meltfptr[7] = 0;
		      /* end cit1__EACHSTRMAP */
    /*_.CURAT__V4*/ meltfptr[3] = NULL;
    /*_.CURVAL__V5*/ meltfptr[4] = NULL;
		    }


		  /*citerepilog */

		  MELT_LOCATION ("warmelt-base.melt:1241:/ clear");
		/*clear *//*_.CURAT__V4*/ meltfptr[3] = 0;
		  /*^clear */
		/*clear *//*_.CURVAL__V5*/ meltfptr[4] = 0;
		  /*^clear */
		/*clear *//*_.MULTI___V6*/ meltfptr[5] = 0;
		}		/*endciterblock FOREACH_IN_MAPSTRING */
		;
		/*epilog */
	      }
	      ;
	    }			/*noelse */
	  ;
	  /*epilog */

	  MELT_LOCATION ("warmelt-base.melt:1239:/ clear");
	     /*clear *//*_#IS_CLOSURE__L2*/ meltfnum[1] = 0;
	}
	;
      }				/*noelse */
    ;
    /*epilog */

    MELT_LOCATION ("warmelt-base.melt:1234:/ clear");
	   /*clear *//*_#IS_MAPSTRING__L1*/ meltfnum[0] = 0;
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("MAPSTRING_ITERATE_TEST", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*_.RETVAL___V1*/ meltfptr[0]);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_8_warmelt_base_MAPSTRING_ITERATE_TEST */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_9_warmelt_base_MULTIPLE_EVERY (meltclosure_ptr_t closp_,
					melt_ptr_t firstargp_,
					const melt_argdescr_cell_t
					xargdescr_[],
					union meltparam_un * xargtab_,
					const melt_argdescr_cell_t
					xresdescr_[],
					union meltparam_un * xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_9_warmelt_base_MULTIPLE_EVERY_st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 5
    void *mcfr_varptr[5];
#define MELTFRAM_NBVARNUM 3
    long mcfr_varnum[3];
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 5; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 5;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("MULTIPLE_EVERY", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1283:/ getarg");
 /*_.TUP__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;

  /*getarg#1 */
  /*^getarg */
  if (xargdescr_[0] != MELTBPAR_PTR)
    goto lab_endgetargs;
 /*_.F__V3*/ meltfptr[2] =
    (xargtab_[0].meltbp_aptr) ? (*(xargtab_[0].meltbp_aptr)) : NULL;
  gcc_assert (melt_discr ((melt_ptr_t) ( /*_.F__V3*/ meltfptr[2])) != NULL);

  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {

 /*_#IS_MULTIPLE__L1*/ meltfnum[0] =
      (melt_magic_discr ((melt_ptr_t) ( /*_.TUP__V2*/ meltfptr[1])) ==
       MELTOBMAG_MULTIPLE);;
    MELT_LOCATION ("warmelt-base.melt:1286:/ cond");
    /*cond */ if ( /*_#IS_MULTIPLE__L1*/ meltfnum[0])	/*then */
      {
	/*^cond.then */
	/*^block */
	/*anyblock */
	{

   /*_#IS_CLOSURE__L2*/ meltfnum[1] =
	    (melt_magic_discr ((melt_ptr_t) ( /*_.F__V3*/ meltfptr[2])) ==
	     MELTOBMAG_CLOSURE);;
	  MELT_LOCATION ("warmelt-base.melt:1287:/ cond");
	  /*cond */ if ( /*_#IS_CLOSURE__L2*/ meltfnum[1])	/*then */
	    {
	      /*^cond.then */
	      /*^block */
	      /*anyblock */
	      {

		/*citerblock FOREACH_IN_MULTIPLE */
		{
		  /* start cit1__EACHTUP: */
		  long cit1__EACHTUP_ln =
		    melt_multiple_length ((melt_ptr_t) /*_.TUP__V2*/
					  meltfptr[1]);
		  for ( /*_#IX__L3*/ meltfnum[2] = 0;
		       ( /*_#IX__L3*/ meltfnum[2] >= 0)
		       && ( /*_#IX__L3*/ meltfnum[2] < cit1__EACHTUP_ln);
	/*_#IX__L3*/ meltfnum[2]++)
		    {
		      /*_.COMP__V4*/ meltfptr[3] =
			melt_multiple_nth ((melt_ptr_t)
					   ( /*_.TUP__V2*/ meltfptr[1]),
					   /*_#IX__L3*/ meltfnum[2]);



		      MELT_LOCATION ("warmelt-base.melt:1291:/ apply");
		      /*apply */
		      {
			union meltparam_un argtab[1];
			memset (&argtab, 0, sizeof (argtab));
			/*^apply.arg */
			argtab[0].meltbp_long = /*_#IX__L3*/ meltfnum[2];
			/*_.F__V5*/ meltfptr[4] =
			  melt_apply ((meltclosure_ptr_t)
				      ( /*_.F__V3*/ meltfptr[2]),
				      (melt_ptr_t) ( /*_.COMP__V4*/
						    meltfptr[3]),
				      (MELTBPARSTR_LONG ""), argtab, "",
				      (union meltparam_un *) 0);
		      }
		      ;
		      if ( /*_#IX__L3*/ meltfnum[2] < 0)
			break;
		    }		/* end cit1__EACHTUP */

		  /*citerepilog */

		  MELT_LOCATION ("warmelt-base.melt:1288:/ clear");
		/*clear *//*_.COMP__V4*/ meltfptr[3] = 0;
		  /*^clear */
		/*clear *//*_#IX__L3*/ meltfnum[2] = 0;
		  /*^clear */
		/*clear *//*_.F__V5*/ meltfptr[4] = 0;
		}		/*endciterblock FOREACH_IN_MULTIPLE */
		;
		/*epilog */
	      }
	      ;
	    }			/*noelse */
	  ;
	  /*epilog */

	  MELT_LOCATION ("warmelt-base.melt:1286:/ clear");
	     /*clear *//*_#IS_CLOSURE__L2*/ meltfnum[1] = 0;
	}
	;
      }				/*noelse */
    ;
    /*epilog */

    MELT_LOCATION ("warmelt-base.melt:1283:/ clear");
	   /*clear *//*_#IS_MULTIPLE__L1*/ meltfnum[0] = 0;
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("MULTIPLE_EVERY", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*noretval */ NULL);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_9_warmelt_base_MULTIPLE_EVERY */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_10_warmelt_base_MULTIPLE_BACKWARD_EVERY (meltclosure_ptr_t closp_,
						  melt_ptr_t firstargp_,
						  const melt_argdescr_cell_t
						  xargdescr_[],
						  union meltparam_un *
						  xargtab_,
						  const melt_argdescr_cell_t
						  xresdescr_[],
						  union meltparam_un *
						  xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_10_warmelt_base_MULTIPLE_BACKWARD_EVERY_st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 5
    void *mcfr_varptr[5];
#define MELTFRAM_NBVARNUM 3
    long mcfr_varnum[3];
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 5; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 5;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("MULTIPLE_BACKWARD_EVERY", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1294:/ getarg");
 /*_.TUP__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;

  /*getarg#1 */
  /*^getarg */
  if (xargdescr_[0] != MELTBPAR_PTR)
    goto lab_endgetargs;
 /*_.F__V3*/ meltfptr[2] =
    (xargtab_[0].meltbp_aptr) ? (*(xargtab_[0].meltbp_aptr)) : NULL;
  gcc_assert (melt_discr ((melt_ptr_t) ( /*_.F__V3*/ meltfptr[2])) != NULL);

  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {

 /*_#IS_MULTIPLE__L1*/ meltfnum[0] =
      (melt_magic_discr ((melt_ptr_t) ( /*_.TUP__V2*/ meltfptr[1])) ==
       MELTOBMAG_MULTIPLE);;
    MELT_LOCATION ("warmelt-base.melt:1297:/ cond");
    /*cond */ if ( /*_#IS_MULTIPLE__L1*/ meltfnum[0])	/*then */
      {
	/*^cond.then */
	/*^block */
	/*anyblock */
	{

   /*_#IS_CLOSURE__L2*/ meltfnum[1] =
	    (melt_magic_discr ((melt_ptr_t) ( /*_.F__V3*/ meltfptr[2])) ==
	     MELTOBMAG_CLOSURE);;
	  MELT_LOCATION ("warmelt-base.melt:1298:/ cond");
	  /*cond */ if ( /*_#IS_CLOSURE__L2*/ meltfnum[1])	/*then */
	    {
	      /*^cond.then */
	      /*^block */
	      /*anyblock */
	      {

		/*citerblock FOREACH_IN_MULTIPLE_BACKWARD */
		{
		  /* start cit1__EACHTUPBACK: */
		  long cit1__EACHTUPBACK_ln =
		    melt_multiple_length ((melt_ptr_t) /*_.TUP__V2*/
					  meltfptr[1]);
		  long cit1__EACHTUPBACK_ix = 0;
		  for (cit1__EACHTUPBACK_ix = cit1__EACHTUPBACK_ln - 1;
		       cit1__EACHTUPBACK_ix >= 0; cit1__EACHTUPBACK_ix--)
		    {
		      /*_.COMP__V4*/ meltfptr[3] =
			melt_multiple_nth ((melt_ptr_t)
					   ( /*_.TUP__V2*/ meltfptr[1]),
					   cit1__EACHTUPBACK_ix);
   /*_#IX__L3*/ meltfnum[2] = cit1__EACHTUPBACK_ix;


		      MELT_LOCATION ("warmelt-base.melt:1302:/ apply");
		      /*apply */
		      {
			union meltparam_un argtab[1];
			memset (&argtab, 0, sizeof (argtab));
			/*^apply.arg */
			argtab[0].meltbp_long = /*_#IX__L3*/ meltfnum[2];
			/*_.F__V5*/ meltfptr[4] =
			  melt_apply ((meltclosure_ptr_t)
				      ( /*_.F__V3*/ meltfptr[2]),
				      (melt_ptr_t) ( /*_.COMP__V4*/
						    meltfptr[3]),
				      (MELTBPARSTR_LONG ""), argtab, "",
				      (union meltparam_un *) 0);
		      }
		      ;
		    }		/* end cit1__EACHTUPBACK */

		  /*citerepilog */

		  MELT_LOCATION ("warmelt-base.melt:1299:/ clear");
		/*clear *//*_.COMP__V4*/ meltfptr[3] = 0;
		  /*^clear */
		/*clear *//*_#IX__L3*/ meltfnum[2] = 0;
		  /*^clear */
		/*clear *//*_.F__V5*/ meltfptr[4] = 0;
		}		/*endciterblock FOREACH_IN_MULTIPLE_BACKWARD */
		;
		/*epilog */
	      }
	      ;
	    }			/*noelse */
	  ;
	  /*epilog */

	  MELT_LOCATION ("warmelt-base.melt:1297:/ clear");
	     /*clear *//*_#IS_CLOSURE__L2*/ meltfnum[1] = 0;
	}
	;
      }				/*noelse */
    ;
    /*epilog */

    MELT_LOCATION ("warmelt-base.melt:1294:/ clear");
	   /*clear *//*_#IS_MULTIPLE__L1*/ meltfnum[0] = 0;
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("MULTIPLE_BACKWARD_EVERY", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*noretval */ NULL);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_10_warmelt_base_MULTIPLE_BACKWARD_EVERY */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_11_warmelt_base_MULTIPLE_EVERY_BOTH (meltclosure_ptr_t closp_,
					      melt_ptr_t firstargp_,
					      const melt_argdescr_cell_t
					      xargdescr_[],
					      union meltparam_un * xargtab_,
					      const melt_argdescr_cell_t
					      xresdescr_[],
					      union meltparam_un * xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_11_warmelt_base_MULTIPLE_EVERY_BOTH_st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 13
    void *mcfr_varptr[13];
#define MELTFRAM_NBVARNUM 10
    long mcfr_varnum[10];
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 13; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 13;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("MULTIPLE_EVERY_BOTH", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1306:/ getarg");
 /*_.TUP1__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;

  /*getarg#1 */
  /*^getarg */
  if (xargdescr_[0] != MELTBPAR_PTR)
    goto lab_endgetargs;
 /*_.TUP2__V3*/ meltfptr[2] =
    (xargtab_[0].meltbp_aptr) ? (*(xargtab_[0].meltbp_aptr)) : NULL;
  gcc_assert (melt_discr ((melt_ptr_t) ( /*_.TUP2__V3*/ meltfptr[2])) !=
	      NULL);


  /*getarg#2 */
  /*^getarg */
  if (xargdescr_[1] != MELTBPAR_PTR)
    goto lab_endgetargs;
 /*_.F__V4*/ meltfptr[3] =
    (xargtab_[1].meltbp_aptr) ? (*(xargtab_[1].meltbp_aptr)) : NULL;
  gcc_assert (melt_discr ((melt_ptr_t) ( /*_.F__V4*/ meltfptr[3])) != NULL);

  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {

 /*_#IS_MULTIPLE__L1*/ meltfnum[0] =
      (melt_magic_discr ((melt_ptr_t) ( /*_.TUP1__V2*/ meltfptr[1])) ==
       MELTOBMAG_MULTIPLE);;
    MELT_LOCATION ("warmelt-base.melt:1309:/ cond");
    /*cond */ if ( /*_#IS_MULTIPLE__L1*/ meltfnum[0])	/*then */
      {
	/*^cond.then */
	/*^block */
	/*anyblock */
	{

   /*_#IS_MULTIPLE__L2*/ meltfnum[1] =
	    (melt_magic_discr ((melt_ptr_t) ( /*_.TUP2__V3*/ meltfptr[2])) ==
	     MELTOBMAG_MULTIPLE);;
	  MELT_LOCATION ("warmelt-base.melt:1310:/ cond");
	  /*cond */ if ( /*_#IS_MULTIPLE__L2*/ meltfnum[1])	/*then */
	    {
	      /*^cond.then */
	      /*^block */
	      /*anyblock */
	      {

     /*_#IS_CLOSURE__L3*/ meltfnum[2] =
		  (melt_magic_discr ((melt_ptr_t) ( /*_.F__V4*/ meltfptr[3]))
		   == MELTOBMAG_CLOSURE);;
		MELT_LOCATION ("warmelt-base.melt:1311:/ cond");
		/*cond */ if ( /*_#IS_CLOSURE__L3*/ meltfnum[2])	/*then */
		  {
		    /*^cond.then */
		    /*^block */
		    /*anyblock */
		    {

		      MELT_LOCATION ("warmelt-base.melt:1312:/ quasiblock");


       /*_#LN1__L4*/ meltfnum[3] =
			(melt_multiple_length
			 ((melt_ptr_t) ( /*_.TUP1__V2*/ meltfptr[1])));;
		      /*^compute */

       /*_#LN2__L5*/ meltfnum[4] =
			(melt_multiple_length
			 ((melt_ptr_t) ( /*_.TUP2__V3*/ meltfptr[2])));;
		      /*^compute */

       /*_#IX__L6*/ meltfnum[5] = 0;;
		      MELT_LOCATION ("warmelt-base.melt:1315:/ loop");
		      /*loop */
		      {
		      labloop_TUPLOOP_1:;
				/*^loopbody */

			/*^block */
			/*anyblock */
			{

	 /*_#I__L7*/ meltfnum[6] =
			    (( /*_#IX__L6*/ meltfnum[5]) >=
			     ( /*_#LN1__L4*/ meltfnum[3]));;
			  MELT_LOCATION ("warmelt-base.melt:1316:/ cond");
			  /*cond */ if ( /*_#I__L7*/ meltfnum[6])	/*then */
			    {
			      /*^cond.then */
			      /*^block */
			      /*anyblock */
			      {

				/*^quasiblock */


				/*^compute */
	   /*_.TUPLOOP__V10*/ meltfptr[9] = NULL;;

				/*^exit */
				/*exit */
				{
				  goto labexit_TUPLOOP_1;
				}
				;
				/*epilog */
			      }
			      ;
			    }	/*noelse */
			  ;
	 /*_#I__L8*/ meltfnum[7] =
			    (( /*_#IX__L6*/ meltfnum[5]) >=
			     ( /*_#LN2__L5*/ meltfnum[4]));;
			  MELT_LOCATION ("warmelt-base.melt:1317:/ cond");
			  /*cond */ if ( /*_#I__L8*/ meltfnum[7])	/*then */
			    {
			      /*^cond.then */
			      /*^block */
			      /*anyblock */
			      {

				/*^quasiblock */


				/*^compute */
	   /*_.TUPLOOP__V10*/ meltfptr[9] = NULL;;

				/*^exit */
				/*exit */
				{
				  goto labexit_TUPLOOP_1;
				}
				;
				/*epilog */
			      }
			      ;
			    }	/*noelse */
			  ;
	 /*_.MULTIPLE_NTH__V11*/ meltfptr[10] =
			    (melt_multiple_nth
			     ((melt_ptr_t) ( /*_.TUP1__V2*/ meltfptr[1]),
			      ( /*_#IX__L6*/ meltfnum[5])));;
			  /*^compute */

	 /*_.MULTIPLE_NTH__V12*/ meltfptr[11] =
			    (melt_multiple_nth
			     ((melt_ptr_t) ( /*_.TUP2__V3*/ meltfptr[2]),
			      ( /*_#IX__L6*/ meltfnum[5])));;
			  MELT_LOCATION ("warmelt-base.melt:1318:/ apply");
			  /*apply */
			  {
			    union meltparam_un argtab[2];
			    memset (&argtab, 0, sizeof (argtab));
			    /*^apply.arg */
			    argtab[0].meltbp_aptr =
			      (melt_ptr_t *) & /*_.MULTIPLE_NTH__V12*/
			      meltfptr[11];
			    /*^apply.arg */
			    argtab[1].meltbp_long = /*_#IX__L6*/ meltfnum[5];
			    /*_.F__V13*/ meltfptr[12] =
			      melt_apply ((meltclosure_ptr_t)
					  ( /*_.F__V4*/ meltfptr[3]),
					  (melt_ptr_t) ( /*_.MULTIPLE_NTH__V11*/ meltfptr[10]), (MELTBPARSTR_PTR MELTBPARSTR_LONG ""), argtab, "", (union meltparam_un *) 0);
			  }
			  ;
	 /*_#I__L9*/ meltfnum[8] =
			    (( /*_#IX__L6*/ meltfnum[5]) + (1));;
			  MELT_LOCATION ("warmelt-base.melt:1319:/ compute");
			  /*_#IX__L6*/ meltfnum[5] =
			    /*_#SETQ___L10*/ meltfnum[9] =
			    /*_#I__L9*/ meltfnum[8];;
			  /*epilog */

			  MELT_LOCATION ("warmelt-base.melt:1315:/ clear");
		   /*clear *//*_#I__L7*/ meltfnum[6] = 0;
			  /*^clear */
		   /*clear *//*_#I__L8*/ meltfnum[7] = 0;
			  /*^clear */
		   /*clear *//*_.MULTIPLE_NTH__V11*/ meltfptr[10] = 0;
			  /*^clear */
		   /*clear *//*_.MULTIPLE_NTH__V12*/ meltfptr[11] = 0;
			  /*^clear */
		   /*clear *//*_.F__V13*/ meltfptr[12] = 0;
			  /*^clear */
		   /*clear *//*_#I__L9*/ meltfnum[8] = 0;
			  /*^clear */
		   /*clear *//*_#SETQ___L10*/ meltfnum[9] = 0;
			}
			;
			;
			goto labloop_TUPLOOP_1;
		      labexit_TUPLOOP_1:;
				/*^loopepilog */
			/*loopepilog */
			/*_.FOREVER___V9*/ meltfptr[8] =
			  /*_.TUPLOOP__V10*/ meltfptr[9];;
		      }
		      ;
		      /*^compute */

		      /*_.LET___V8*/ meltfptr[7] =
			/*_.FOREVER___V9*/ meltfptr[8];;

		      MELT_LOCATION ("warmelt-base.melt:1312:/ clear");
		 /*clear *//*_#LN1__L4*/ meltfnum[3] = 0;
		      /*^clear */
		 /*clear *//*_#LN2__L5*/ meltfnum[4] = 0;
		      /*^clear */
		 /*clear *//*_#IX__L6*/ meltfnum[5] = 0;
		      /*^clear */
		 /*clear *//*_.FOREVER___V9*/ meltfptr[8] = 0;
		      /*_.IF___V7*/ meltfptr[6] = /*_.LET___V8*/ meltfptr[7];;
		      /*epilog */

		      MELT_LOCATION ("warmelt-base.melt:1311:/ clear");
		 /*clear *//*_.LET___V8*/ meltfptr[7] = 0;
		    }
		    ;
		  }
		else
		  {		/*^cond.else */

      /*_.IF___V7*/ meltfptr[6] = NULL;;
		  }
		;
		/*^compute */

		/*_.IF___V6*/ meltfptr[5] = /*_.IF___V7*/ meltfptr[6];;
		/*epilog */

		MELT_LOCATION ("warmelt-base.melt:1310:/ clear");
	       /*clear *//*_#IS_CLOSURE__L3*/ meltfnum[2] = 0;
		/*^clear */
	       /*clear *//*_.IF___V7*/ meltfptr[6] = 0;
	      }
	      ;
	    }
	  else
	    {			/*^cond.else */

    /*_.IF___V6*/ meltfptr[5] = NULL;;
	    }
	  ;
	  /*^compute */

	  /*_.IF___V5*/ meltfptr[4] = /*_.IF___V6*/ meltfptr[5];;
	  /*epilog */

	  MELT_LOCATION ("warmelt-base.melt:1309:/ clear");
	     /*clear *//*_#IS_MULTIPLE__L2*/ meltfnum[1] = 0;
	  /*^clear */
	     /*clear *//*_.IF___V6*/ meltfptr[5] = 0;
	}
	;
      }
    else
      {				/*^cond.else */

  /*_.IF___V5*/ meltfptr[4] = NULL;;
      }
    ;
    MELT_LOCATION ("warmelt-base.melt:1306:/ quasiblock");


    /*_.RETVAL___V1*/ meltfptr[0] = /*_.IF___V5*/ meltfptr[4];;
    MELT_LOCATION ("warmelt-base.melt:1306:/ finalreturn");
    ;
    /*finalret */ goto labend_rout;
    /*epilog */

    /*^clear */
	   /*clear *//*_#IS_MULTIPLE__L1*/ meltfnum[0] = 0;
    /*^clear */
	   /*clear *//*_.IF___V5*/ meltfptr[4] = 0;
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("MULTIPLE_EVERY_BOTH", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*_.RETVAL___V1*/ meltfptr[0]);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_11_warmelt_base_MULTIPLE_EVERY_BOTH */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_12_warmelt_base_RUN_ALL_PASS_EXECUTION_HOOKS (meltclosure_ptr_t
						       closp_,
						       melt_ptr_t firstargp_,
						       const
						       melt_argdescr_cell_t
						       xargdescr_[],
						       union meltparam_un *
						       xargtab_,
						       const
						       melt_argdescr_cell_t
						       xresdescr_[],
						       union meltparam_un *
						       xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_12_warmelt_base_RUN_ALL_PASS_EXECUTION_HOOKS_st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 7
    void *mcfr_varptr[7];
#define MELTFRAM_NBVARNUM 1
    long mcfr_varnum[1];
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 7; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 7;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("RUN_ALL_PASS_EXECUTION_HOOKS", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1346:/ getarg");
 /*_.HOOKLIST__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;

  /*getarg#1 */
  /*^getarg */
  if (xargdescr_[0] != MELTBPAR_PTR)
    goto lab_endgetargs;
 /*_.PASSNAME__V3*/ meltfptr[2] =
    (xargtab_[0].meltbp_aptr) ? (*(xargtab_[0].meltbp_aptr)) : NULL;
  gcc_assert (melt_discr ((melt_ptr_t) ( /*_.PASSNAME__V3*/ meltfptr[2])) !=
	      NULL);


  /*getarg#2 */
  /*^getarg */
  if (xargdescr_[1] != MELTBPAR_LONG)
    goto lab_endgetargs;
 /*_#PASSNUM__L1*/ meltfnum[0] = xargtab_[1].meltbp_long;
  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {

    /*citerblock FOREACH_IN_LIST */
    {
      /* start cit1__EACHLIST */
      for ( /*_.CURPAIR__V4*/ meltfptr[3] =
	   melt_list_first ( /*_.HOOKLIST__V2*/ meltfptr[1]);
	   melt_magic_discr ( /*_.CURPAIR__V4*/ meltfptr[3]) ==
	   MELTOBMAG_PAIR;
	   /*_.CURPAIR__V4*/ meltfptr[3] =
	   melt_pair_tail ( /*_.CURPAIR__V4*/ meltfptr[3]))
	{
	  /*_.CURHOOK__V5*/ meltfptr[4] =
	    melt_pair_head ( /*_.CURPAIR__V4*/ meltfptr[3]);


	  MELT_LOCATION ("warmelt-base.melt:1351:/ apply");
	  /*apply */
	  {
	    union meltparam_un argtab[1];
	    memset (&argtab, 0, sizeof (argtab));
	    /*^apply.arg */
	    argtab[0].meltbp_long = /*_#PASSNUM__L1*/ meltfnum[0];
	    /*_.CURHOOK__V6*/ meltfptr[5] =
	      melt_apply ((meltclosure_ptr_t)
			  ( /*_.CURHOOK__V5*/ meltfptr[4]),
			  (melt_ptr_t) ( /*_.PASSNAME__V3*/ meltfptr[2]),
			  (MELTBPARSTR_LONG ""), argtab, "",
			  (union meltparam_un *) 0);
	  }
	  ;
	}			/* end cit1__EACHLIST */

      /*citerepilog */

      MELT_LOCATION ("warmelt-base.melt:1348:/ clear");
	    /*clear *//*_.CURPAIR__V4*/ meltfptr[3] = 0;
      /*^clear */
	    /*clear *//*_.CURHOOK__V5*/ meltfptr[4] = 0;
      /*^clear */
	    /*clear *//*_.CURHOOK__V6*/ meltfptr[5] = 0;
    }				/*endciterblock FOREACH_IN_LIST */
    ;
    MELT_LOCATION ("warmelt-base.melt:1353:/ quasiblock");


 /*_.RETVAL___V1*/ meltfptr[0] = NULL;;
    MELT_LOCATION ("warmelt-base.melt:1353:/ finalreturn");
    ;
    /*finalret */ goto labend_rout;
    MELT_LOCATION ("warmelt-base.melt:1346:/ quasiblock");


    /*_.RETVAL___V1*/ meltfptr[0] = /*_.RETURN___V7*/ meltfptr[6];;
    MELT_LOCATION ("warmelt-base.melt:1346:/ finalreturn");
    ;
    /*finalret */ goto labend_rout;
    /*epilog */

    /*^clear */
	   /*clear *//*_.RETURN___V7*/ meltfptr[6] = 0;
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("RUN_ALL_PASS_EXECUTION_HOOKS", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*_.RETVAL___V1*/ meltfptr[0]);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_12_warmelt_base_RUN_ALL_PASS_EXECUTION_HOOKS */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_13_warmelt_base_REGISTER_PASS_EXECUTION_HOOK (meltclosure_ptr_t
						       closp_,
						       melt_ptr_t firstargp_,
						       const
						       melt_argdescr_cell_t
						       xargdescr_[],
						       union meltparam_un *
						       xargtab_,
						       const
						       melt_argdescr_cell_t
						       xresdescr_[],
						       union meltparam_un *
						       xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_13_warmelt_base_REGISTER_PASS_EXECUTION_HOOK_st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 17
    void *mcfr_varptr[17];
#define MELTFRAM_NBVARNUM 4
    long mcfr_varnum[4];
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 17; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 17;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("REGISTER_PASS_EXECUTION_HOOK", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1357:/ getarg");
 /*_.FUN__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;
  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {

 /*_#IS_CLOSURE__L1*/ meltfnum[0] =
      (melt_magic_discr ((melt_ptr_t) ( /*_.FUN__V2*/ meltfptr[1])) ==
       MELTOBMAG_CLOSURE);;
    MELT_LOCATION ("warmelt-base.melt:1363:/ cond");
    /*cond */ if ( /*_#IS_CLOSURE__L1*/ meltfnum[0])	/*then */
      {
	/*^cond.then */
	/*^block */
	/*anyblock */
	{

	  MELT_LOCATION ("warmelt-base.melt:1364:/ quasiblock");


	  /*^getslot */
	  {
	    melt_ptr_t slot = 0;
	    melt_object_get_field (slot, (melt_ptr_t) (( /*!PASS_EXECUTION_CONTAINER */ meltfrout->tabval[0])), 0, "CONTAINER_VALUE");
															 /*_.HOOKLIST__V5*/
	    meltfptr[4] = slot;
	  };
	  ;
   /*_#NULL__L2*/ meltfnum[1] =
	    (( /*_.HOOKLIST__V5*/ meltfptr[4]) == NULL);;
	  MELT_LOCATION ("warmelt-base.melt:1367:/ cond");
	  /*cond */ if ( /*_#NULL__L2*/ meltfnum[1])	/*then */
	    {
	      /*^cond.then */
	      /*^block */
	      /*anyblock */
	      {

		MELT_LOCATION ("warmelt-base.melt:1369:/ blockmultialloc");
		/*multiallocblock */
		{
		  struct meltletrec_1_st
		  {
		    struct meltlist_st rlist_0__LIST_;
		    long meltletrec_1_endgap;
		  } *meltletrec_1_ptr = 0;
		  meltletrec_1_ptr =
		    (struct meltletrec_1_st *)
		    meltgc_allocate (sizeof (struct meltletrec_1_st), 0);
		  /*^blockmultialloc.initfill */
		  /*inilist rlist_0__LIST_ */
       /*_.LIST___V7*/ meltfptr[6] =
		    (void *) &meltletrec_1_ptr->rlist_0__LIST_;
		  meltletrec_1_ptr->rlist_0__LIST_.discr =
		    (meltobject_ptr_t) (((void
					  *) (MELT_PREDEF (DISCR_LIST))));



		  /*_.LIST___V6*/ meltfptr[5] = /*_.LIST___V7*/ meltfptr[6];;
		  /*epilog */

		  MELT_LOCATION ("warmelt-base.melt:1369:/ clear");
		/*clear *//*_.LIST___V7*/ meltfptr[6] = 0;
		  /*^clear */
		/*clear *//*_.LIST___V7*/ meltfptr[6] = 0;
		}		/*end multiallocblock */
		;
		/*^compute */
		/*_.HOOKLIST__V5*/ meltfptr[4] = /*_.SETQ___V8*/ meltfptr[6] =
		  /*_.LIST___V6*/ meltfptr[5];;
		MELT_LOCATION ("warmelt-base.melt:1370:/ cond");
		/*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) (( /*!PASS_EXECUTION_CONTAINER */ meltfrout->tabval[0])), (melt_ptr_t) (( /*!CLASS_CONTAINER */ meltfrout->tabval[1]))))	/*then */
		  {
		    /*^cond.then */
		    /*^block */
		    /*anyblock */
		    {

		      /*^putslot */
		      /*putslot */
		      melt_assertmsg ("putslot checkobj @CONTAINER_VALUE",
				      melt_magic_discr ((melt_ptr_t)
							(( /*!PASS_EXECUTION_CONTAINER */ meltfrout->tabval[0]))) == MELTOBMAG_OBJECT);
		      melt_putfield_object ((( /*!PASS_EXECUTION_CONTAINER */
					      meltfrout->tabval[0])), (0),
					    ( /*_.HOOKLIST__V5*/ meltfptr[4]),
					    "CONTAINER_VALUE");
		      ;
		      /*^touch */
		      meltgc_touch (( /*!PASS_EXECUTION_CONTAINER */
				     meltfrout->tabval[0]));
		      ;
		      /*epilog */
		    }
		    ;
		  }		/*noelse */
		;
		MELT_LOCATION ("warmelt-base.melt:1368:/ quasiblock");


		/*epilog */

		MELT_LOCATION ("warmelt-base.melt:1367:/ clear");
	       /*clear *//*_.LIST___V6*/ meltfptr[5] = 0;
		/*^clear */
	       /*clear *//*_.SETQ___V8*/ meltfptr[6] = 0;
	      }
	      ;
	    }			/*noelse */
	  ;

#if MELT_HAVE_DEBUG
	  MELT_LOCATION ("warmelt-base.melt:1371:/ cppif.then");
	  /*^block */
	  /*anyblock */
	  {

     /*_#IS_LIST__L3*/ meltfnum[2] =
	      (melt_magic_discr
	       ((melt_ptr_t) ( /*_.HOOKLIST__V5*/ meltfptr[4])) ==
	       MELTOBMAG_LIST);;
	    MELT_LOCATION ("warmelt-base.melt:1371:/ cond");
	    /*cond */ if ( /*_#IS_LIST__L3*/ meltfnum[2])	/*then */
	      {
		/*^cond.then */
		/*_.IFELSE___V10*/ meltfptr[6] = ( /*nil */ NULL);;
	      }
	    else
	      {
		MELT_LOCATION ("warmelt-base.melt:1371:/ cond.else");

		/*^block */
		/*anyblock */
		{




		  {
		    /*^locexp */
		    melt_assert_failed (("check hooklist"),
					("warmelt-base.melt")
					? ("warmelt-base.melt") : __FILE__,
					(1371) ? (1371) : __LINE__,
					__FUNCTION__);
		    ;
		  }
		  ;
		 /*clear *//*_.IFELSE___V10*/ meltfptr[6] = 0;
		  /*epilog */
		}
		;
	      }
	    ;
	    /*^compute */

	    /*_.IFCPP___V9*/ meltfptr[5] = /*_.IFELSE___V10*/ meltfptr[6];;
	    /*epilog */

	    MELT_LOCATION ("warmelt-base.melt:1371:/ clear");
	       /*clear *//*_#IS_LIST__L3*/ meltfnum[2] = 0;
	    /*^clear */
	       /*clear *//*_.IFELSE___V10*/ meltfptr[6] = 0;
	  }

#else /*MELT_HAVE_DEBUG */
	  /*^cppif.else */
	  /*_.IFCPP___V9*/ meltfptr[5] = ( /*nil */ NULL);
#endif /*MELT_HAVE_DEBUG */
	  ;
	  /*citerblock FOREACH_IN_LIST */
	  {
	    /* start cit1__EACHLIST */
	    for ( /*_.CURPAIR__V11*/ meltfptr[6] =
		 melt_list_first ( /*_.HOOKLIST__V5*/ meltfptr[4]);
		 melt_magic_discr ( /*_.CURPAIR__V11*/ meltfptr[6]) ==
		 MELTOBMAG_PAIR;
		 /*_.CURPAIR__V11*/ meltfptr[6] =
		 melt_pair_tail ( /*_.CURPAIR__V11*/ meltfptr[6]))
	      {
		/*_.CURHOOK__V12*/ meltfptr[11] =
		  melt_pair_head ( /*_.CURPAIR__V11*/ meltfptr[6]);


    /*_#__L4*/ meltfnum[2] =
		  (( /*_.CURHOOK__V12*/ meltfptr[11]) ==
		   ( /*_.FUN__V2*/ meltfptr[1]));;
		MELT_LOCATION ("warmelt-base.melt:1376:/ cond");
		/*cond */ if ( /*_#__L4*/ meltfnum[2])	/*then */
		  {
		    /*^cond.then */
		    /*^block */
		    /*anyblock */
		    {

		      MELT_LOCATION ("warmelt-base.melt:1377:/ quasiblock");


      /*_.RETVAL___V1*/ meltfptr[0] = NULL;;
		      MELT_LOCATION ("warmelt-base.melt:1377:/ finalreturn");
		      ;
		      /*finalret */ goto labend_rout;
		      /*_.IF___V13*/ meltfptr[12] =
			/*_.RETURN___V14*/ meltfptr[13];;
		      /*epilog */

		      MELT_LOCATION ("warmelt-base.melt:1376:/ clear");
		/*clear *//*_.RETURN___V14*/ meltfptr[13] = 0;
		    }
		    ;
		  }
		else
		  {		/*^cond.else */

     /*_.IF___V13*/ meltfptr[12] = NULL;;
		  }
		;
	      }			/* end cit1__EACHLIST */

	    /*citerepilog */

	    MELT_LOCATION ("warmelt-base.melt:1373:/ clear");
	      /*clear *//*_.CURPAIR__V11*/ meltfptr[6] = 0;
	    /*^clear */
	      /*clear *//*_.CURHOOK__V12*/ meltfptr[11] = 0;
	    /*^clear */
	      /*clear *//*_#__L4*/ meltfnum[2] = 0;
	    /*^clear */
	      /*clear *//*_.IF___V13*/ meltfptr[12] = 0;
	  }			/*endciterblock FOREACH_IN_LIST */
	  ;

	  {
	    MELT_LOCATION ("warmelt-base.melt:1379:/ locexp");
	    meltgc_append_list ((melt_ptr_t)
				( /*_.HOOKLIST__V5*/ meltfptr[4]),
				(melt_ptr_t) ( /*_.FUN__V2*/ meltfptr[1]));
	  }
	  ;
	  MELT_LOCATION ("warmelt-base.melt:1382:/ quasiblock");


	  /*^newclosure */
		   /*newclosure *//*_.LAMBDA___V16*/ meltfptr[15] =
	    meltgc_new_closure ((meltobject_ptr_t)
				(((void *) (MELT_PREDEF (DISCR_CLOSURE)))),
				(meltroutine_ptr_t) (( /*!konst_4 */
						      meltfrout->tabval[4])),
				(1));
	  ;
	  /*^putclosedv */
	  /*putclosv */
	  melt_assertmsg ("putclosv checkclo",
			  melt_magic_discr ((melt_ptr_t)
					    ( /*_.LAMBDA___V16*/
					     meltfptr[15])) ==
			  MELTOBMAG_CLOSURE);
	  melt_assertmsg ("putclosv checkoff", 0 >= 0
			  && 0 <
			  melt_closure_size ((melt_ptr_t)
					     ( /*_.LAMBDA___V16*/
					      meltfptr[15])));
	  ((meltclosure_ptr_t) /*_.LAMBDA___V16*/ meltfptr[15])->tabval[0] =
	    (melt_ptr_t) ( /*_.HOOKLIST__V5*/ meltfptr[4]);
	  ;
	  /*_.LAMBDA___V15*/ meltfptr[13] = /*_.LAMBDA___V16*/ meltfptr[15];;
	  MELT_LOCATION ("warmelt-base.melt:1380:/ cond");
	  /*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) (( /*!INITIAL_SYSTEM_DATA */ meltfrout->tabval[2])), (melt_ptr_t) (( /*!CLASS_SYSTEM_DATA */ meltfrout->tabval[5]))))	/*then */
	    {
	      /*^cond.then */
	      /*^block */
	      /*anyblock */
	      {

		/*^putslot */
		/*putslot */
		melt_assertmsg ("putslot checkobj @SYSDATA_PASSEXEC_HOOK",
				melt_magic_discr ((melt_ptr_t)
						  (( /*!INITIAL_SYSTEM_DATA */
						    meltfrout->tabval[2]))) ==
				MELTOBMAG_OBJECT);
		melt_putfield_object ((( /*!INITIAL_SYSTEM_DATA */ meltfrout->
					tabval[2])), (25),
				      ( /*_.LAMBDA___V15*/ meltfptr[13]),
				      "SYSDATA_PASSEXEC_HOOK");
		;
		/*^touch */
		meltgc_touch (( /*!INITIAL_SYSTEM_DATA */ meltfrout->
			       tabval[2]));
		;
		/*epilog */
	      }
	      ;
	    }			/*noelse */
	  ;

	  {
	    MELT_LOCATION ("warmelt-base.melt:1385:/ locexp");
	    /*REGPASSXECHOOK__1 */
	    meltgc_notify_sysdata_passexec_hook ();
	    ;
	  }
	  ;
	  MELT_LOCATION ("warmelt-base.melt:1388:/ quasiblock");


   /*_.RETVAL___V1*/ meltfptr[0] = NULL;;
	  MELT_LOCATION ("warmelt-base.melt:1388:/ finalreturn");
	  ;
	  /*finalret */ goto labend_rout;
	  /*_.LET___V4*/ meltfptr[3] = /*_.RETURN___V17*/ meltfptr[16];;

	  MELT_LOCATION ("warmelt-base.melt:1364:/ clear");
	     /*clear *//*_.HOOKLIST__V5*/ meltfptr[4] = 0;
	  /*^clear */
	     /*clear *//*_#NULL__L2*/ meltfnum[1] = 0;
	  /*^clear */
	     /*clear *//*_.IFCPP___V9*/ meltfptr[5] = 0;
	  /*^clear */
	     /*clear *//*_.LAMBDA___V15*/ meltfptr[13] = 0;
	  /*^clear */
	     /*clear *//*_.RETURN___V17*/ meltfptr[16] = 0;
	  /*_.IF___V3*/ meltfptr[2] = /*_.LET___V4*/ meltfptr[3];;
	  /*epilog */

	  MELT_LOCATION ("warmelt-base.melt:1363:/ clear");
	     /*clear *//*_.LET___V4*/ meltfptr[3] = 0;
	}
	;
      }
    else
      {				/*^cond.else */

  /*_.IF___V3*/ meltfptr[2] = NULL;;
      }
    ;
    MELT_LOCATION ("warmelt-base.melt:1357:/ quasiblock");


    /*_.RETVAL___V1*/ meltfptr[0] = /*_.IF___V3*/ meltfptr[2];;
    MELT_LOCATION ("warmelt-base.melt:1357:/ finalreturn");
    ;
    /*finalret */ goto labend_rout;
    /*epilog */

    /*^clear */
	   /*clear *//*_#IS_CLOSURE__L1*/ meltfnum[0] = 0;
    /*^clear */
	   /*clear *//*_.IF___V3*/ meltfptr[2] = 0;
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("REGISTER_PASS_EXECUTION_HOOK", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*_.RETVAL___V1*/ meltfptr[0]);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_13_warmelt_base_REGISTER_PASS_EXECUTION_HOOK */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_14_warmelt_base_LAMBDA___1__ (meltclosure_ptr_t closp_,
				       melt_ptr_t firstargp_,
				       const melt_argdescr_cell_t
				       xargdescr_[],
				       union meltparam_un * xargtab_,
				       const melt_argdescr_cell_t
				       xresdescr_[],
				       union meltparam_un * xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_14_warmelt_base_LAMBDA___1___st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 3
    void *mcfr_varptr[3];
#define MELTFRAM_NBVARNUM 1
    long mcfr_varnum[1];
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 3; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 3;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("LAMBDA_", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1382:/ getarg");
 /*_.PASSNAME__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;

  /*getarg#1 */
  /*^getarg */
  if (xargdescr_[0] != MELTBPAR_LONG)
    goto lab_endgetargs;
 /*_#PASSNUM__L1*/ meltfnum[0] = xargtab_[0].meltbp_long;
  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {

    MELT_LOCATION ("warmelt-base.melt:1383:/ apply");
    /*apply */
    {
      union meltparam_un argtab[2];
      memset (&argtab, 0, sizeof (argtab));
      /*^apply.arg */
      argtab[0].meltbp_aptr = (melt_ptr_t *) & /*_.PASSNAME__V2*/ meltfptr[1];
      /*^apply.arg */
      argtab[1].meltbp_long = /*_#PASSNUM__L1*/ meltfnum[0];
      /*_.RUN_ALL_PASS_EXECUTION_HOOKS__V3*/ meltfptr[2] =
	melt_apply ((meltclosure_ptr_t)
		    (( /*!RUN_ALL_PASS_EXECUTION_HOOKS */ meltfrout->
		      tabval[0])),
		    (melt_ptr_t) (( /*~HOOKLIST */ meltfclos->tabval[0])),
		    (MELTBPARSTR_PTR MELTBPARSTR_LONG ""), argtab, "",
		    (union meltparam_un *) 0);
    }
    ;
    MELT_LOCATION ("warmelt-base.melt:1382:/ quasiblock");


    /*_.RETVAL___V1*/ meltfptr[0] =
      /*_.RUN_ALL_PASS_EXECUTION_HOOKS__V3*/ meltfptr[2];;
    MELT_LOCATION ("warmelt-base.melt:1382:/ finalreturn");
    ;
    /*finalret */ goto labend_rout;
    /*epilog */

    /*^clear */
	   /*clear *//*_.RUN_ALL_PASS_EXECUTION_HOOKS__V3*/ meltfptr[2] = 0;
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("LAMBDA_", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*_.RETVAL___V1*/ meltfptr[0]);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_14_warmelt_base_LAMBDA___1__ */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_15_warmelt_base_UNREGISTER_PASS_EXECUTION_HOOK (meltclosure_ptr_t
							 closp_,
							 melt_ptr_t
							 firstargp_,
							 const
							 melt_argdescr_cell_t
							 xargdescr_[],
							 union meltparam_un *
							 xargtab_,
							 const
							 melt_argdescr_cell_t
							 xresdescr_[],
							 union meltparam_un *
							 xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_15_warmelt_base_UNREGISTER_PASS_EXECUTION_HOOK_st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 9
    void *mcfr_varptr[9];
#define MELTFRAM_NBVARNUM 3
    long mcfr_varnum[3];
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 9; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 9;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("UNREGISTER_PASS_EXECUTION_HOOK", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1392:/ getarg");
 /*_.FUN__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;
  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {

 /*_#IS_CLOSURE__L1*/ meltfnum[0] =
      (melt_magic_discr ((melt_ptr_t) ( /*_.FUN__V2*/ meltfptr[1])) ==
       MELTOBMAG_CLOSURE);;
    MELT_LOCATION ("warmelt-base.melt:1395:/ cond");
    /*cond */ if ( /*_#IS_CLOSURE__L1*/ meltfnum[0])	/*then */
      {
	/*^cond.then */
	/*^block */
	/*anyblock */
	{

	  MELT_LOCATION ("warmelt-base.melt:1396:/ quasiblock");


	  /*^getslot */
	  {
	    melt_ptr_t slot = 0;
	    melt_object_get_field (slot, (melt_ptr_t) (( /*!PASS_EXECUTION_CONTAINER */ meltfrout->tabval[0])), 0, "CONTAINER_VALUE");
															 /*_.OLDHOOKLIST__V3*/
	    meltfptr[2] = slot;
	  };
	  ;
	  MELT_LOCATION ("warmelt-base.melt:1398:/ blockmultialloc");
	  /*multiallocblock */
	  {
	    struct meltletrec_1_st
	    {
	      struct meltlist_st rlist_0__LIST_;
	      long meltletrec_1_endgap;
	    } *meltletrec_1_ptr = 0;
	    meltletrec_1_ptr =
	      (struct meltletrec_1_st *)
	      meltgc_allocate (sizeof (struct meltletrec_1_st), 0);
	    /*^blockmultialloc.initfill */
	    /*inilist rlist_0__LIST_ */
     /*_.LIST___V5*/ meltfptr[4] =
	      (void *) &meltletrec_1_ptr->rlist_0__LIST_;
	    meltletrec_1_ptr->rlist_0__LIST_.discr =
	      (meltobject_ptr_t) (((void *) (MELT_PREDEF (DISCR_LIST))));



	    /*_.NEWHOOKLIST__V4*/ meltfptr[3] = /*_.LIST___V5*/ meltfptr[4];;
	    /*epilog */

	    MELT_LOCATION ("warmelt-base.melt:1398:/ clear");
	      /*clear *//*_.LIST___V5*/ meltfptr[4] = 0;
	    /*^clear */
	      /*clear *//*_.LIST___V5*/ meltfptr[4] = 0;
	  }			/*end multiallocblock */
	  ;
	  /*citerblock FOREACH_IN_LIST */
	  {
	    /* start cit1__EACHLIST */
	    for ( /*_.CURPAIR__V6*/ meltfptr[4] =
		 melt_list_first ( /*_.OLDHOOKLIST__V3*/ meltfptr[2]);
		 melt_magic_discr ( /*_.CURPAIR__V6*/ meltfptr[4]) ==
		 MELTOBMAG_PAIR;
		 /*_.CURPAIR__V6*/ meltfptr[4] =
		 melt_pair_tail ( /*_.CURPAIR__V6*/ meltfptr[4]))
	      {
		/*_.CURHOOK__V7*/ meltfptr[6] =
		  melt_pair_head ( /*_.CURPAIR__V6*/ meltfptr[4]);


    /*_#__L2*/ meltfnum[1] =
		  (( /*_.CURHOOK__V7*/ meltfptr[6]) !=
		   ( /*_.FUN__V2*/ meltfptr[1]));;
		MELT_LOCATION ("warmelt-base.melt:1403:/ cond");
		/*cond */ if ( /*_#__L2*/ meltfnum[1])	/*then */
		  {
		    /*^cond.then */
		    /*^block */
		    /*anyblock */
		    {


		      {
			MELT_LOCATION ("warmelt-base.melt:1404:/ locexp");
			meltgc_append_list ((melt_ptr_t)
					    ( /*_.NEWHOOKLIST__V4*/
					     meltfptr[3]),
					    (melt_ptr_t) ( /*_.CURHOOK__V7*/
							  meltfptr[6]));
		      }
		      ;
		      /*epilog */
		    }
		    ;
		  }		/*noelse */
		;
	      }			/* end cit1__EACHLIST */

	    /*citerepilog */

	    MELT_LOCATION ("warmelt-base.melt:1400:/ clear");
	      /*clear *//*_.CURPAIR__V6*/ meltfptr[4] = 0;
	    /*^clear */
	      /*clear *//*_.CURHOOK__V7*/ meltfptr[6] = 0;
	    /*^clear */
	      /*clear *//*_#__L2*/ meltfnum[1] = 0;
	  }			/*endciterblock FOREACH_IN_LIST */
	  ;
   /*_#IS_NON_EMPTY_LIST__L3*/ meltfnum[2] =
	    (melt_magic_discr
	     ((melt_ptr_t) ( /*_.NEWHOOKLIST__V4*/ meltfptr[3])) ==
	     MELTOBMAG_LIST
	     && NULL !=
	     melt_list_first ((melt_ptr_t)
			      ( /*_.NEWHOOKLIST__V4*/ meltfptr[3])));;
	  MELT_LOCATION ("warmelt-base.melt:1406:/ cond");
	  /*cond */ if ( /*_#IS_NON_EMPTY_LIST__L3*/ meltfnum[2])	/*then */
	    {
	      /*^cond.then */
	      /*^block */
	      /*anyblock */
	      {

		MELT_LOCATION ("warmelt-base.melt:1407:/ cond");
		/*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) (( /*!INITIAL_SYSTEM_DATA */ meltfrout->tabval[1])), (melt_ptr_t) (( /*!CLASS_SYSTEM_DATA */ meltfrout->tabval[2]))))	/*then */
		  {
		    /*^cond.then */
		    /*^block */
		    /*anyblock */
		    {

		      /*^putslot */
		      /*putslot */
		      melt_assertmsg
			("putslot checkobj @SYSDATA_PASSEXEC_HOOK",
			 melt_magic_discr ((melt_ptr_t)
					   (( /*!INITIAL_SYSTEM_DATA */
					     meltfrout->tabval[1]))) ==
			 MELTOBMAG_OBJECT);
		      melt_putfield_object ((( /*!INITIAL_SYSTEM_DATA */
					      meltfrout->tabval[1])), (25),
					    (( /*nil */ NULL)),
					    "SYSDATA_PASSEXEC_HOOK");
		      ;
		      /*^touch */
		      meltgc_touch (( /*!INITIAL_SYSTEM_DATA */ meltfrout->
				     tabval[1]));
		      ;
		      /*epilog */
		    }
		    ;
		  }		/*noelse */
		;
		/*epilog */
	      }
	      ;
	    }
	  else
	    {
	      MELT_LOCATION ("warmelt-base.melt:1406:/ cond.else");

	      /*^block */
	      /*anyblock */
	      {

		MELT_LOCATION ("warmelt-base.melt:1411:/ quasiblock");


		/*^newclosure */
		     /*newclosure *//*_.LAMBDA___V9*/ meltfptr[8] =
		  meltgc_new_closure ((meltobject_ptr_t)
				      (((void
					 *) (MELT_PREDEF (DISCR_CLOSURE)))),
				      (meltroutine_ptr_t) (( /*!konst_4 */
							    meltfrout->
							    tabval[4])), (1));
		;
		/*^putclosedv */
		/*putclosv */
		melt_assertmsg ("putclosv checkclo",
				melt_magic_discr ((melt_ptr_t)
						  ( /*_.LAMBDA___V9*/
						   meltfptr[8])) ==
				MELTOBMAG_CLOSURE);
		melt_assertmsg ("putclosv checkoff", 0 >= 0
				&& 0 <
				melt_closure_size ((melt_ptr_t)
						   ( /*_.LAMBDA___V9*/
						    meltfptr[8])));
		((meltclosure_ptr_t) /*_.LAMBDA___V9*/ meltfptr[8])->
		  tabval[0] =
		  (melt_ptr_t) ( /*_.NEWHOOKLIST__V4*/ meltfptr[3]);
		;
		/*_.LAMBDA___V8*/ meltfptr[7] =
		  /*_.LAMBDA___V9*/ meltfptr[8];;
		MELT_LOCATION ("warmelt-base.melt:1409:/ cond");
		/*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) (( /*!INITIAL_SYSTEM_DATA */ meltfrout->tabval[1])), (melt_ptr_t) (( /*!CLASS_SYSTEM_DATA */ meltfrout->tabval[2]))))	/*then */
		  {
		    /*^cond.then */
		    /*^block */
		    /*anyblock */
		    {

		      /*^putslot */
		      /*putslot */
		      melt_assertmsg
			("putslot checkobj @SYSDATA_PASSEXEC_HOOK",
			 melt_magic_discr ((melt_ptr_t)
					   (( /*!INITIAL_SYSTEM_DATA */
					     meltfrout->tabval[1]))) ==
			 MELTOBMAG_OBJECT);
		      melt_putfield_object ((( /*!INITIAL_SYSTEM_DATA */
					      meltfrout->tabval[1])), (25),
					    ( /*_.LAMBDA___V8*/ meltfptr[7]),
					    "SYSDATA_PASSEXEC_HOOK");
		      ;
		      /*^touch */
		      meltgc_touch (( /*!INITIAL_SYSTEM_DATA */ meltfrout->
				     tabval[1]));
		      ;
		      /*epilog */
		    }
		    ;
		  }		/*noelse */
		;
		/*epilog */

		MELT_LOCATION ("warmelt-base.melt:1406:/ clear");
	       /*clear *//*_.LAMBDA___V8*/ meltfptr[7] = 0;
	      }
	      ;
	    }
	  ;

	  {
	    MELT_LOCATION ("warmelt-base.melt:1414:/ locexp");
	    /*UNREGPASSXECHOOK__1 */
	    meltgc_notify_sysdata_passexec_hook ();
	    ;
	  }
	  ;

	  MELT_LOCATION ("warmelt-base.melt:1396:/ clear");
	     /*clear *//*_.OLDHOOKLIST__V3*/ meltfptr[2] = 0;
	  /*^clear */
	     /*clear *//*_.NEWHOOKLIST__V4*/ meltfptr[3] = 0;
	  /*^clear */
	     /*clear *//*_#IS_NON_EMPTY_LIST__L3*/ meltfnum[2] = 0;
	  /*epilog */
	}
	;
      }				/*noelse */
    ;
    /*epilog */

    MELT_LOCATION ("warmelt-base.melt:1392:/ clear");
	   /*clear *//*_#IS_CLOSURE__L1*/ meltfnum[0] = 0;
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("UNREGISTER_PASS_EXECUTION_HOOK", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*noretval */ NULL);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_15_warmelt_base_UNREGISTER_PASS_EXECUTION_HOOK */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_16_warmelt_base_LAMBDA___2__ (meltclosure_ptr_t closp_,
				       melt_ptr_t firstargp_,
				       const melt_argdescr_cell_t
				       xargdescr_[],
				       union meltparam_un * xargtab_,
				       const melt_argdescr_cell_t
				       xresdescr_[],
				       union meltparam_un * xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_16_warmelt_base_LAMBDA___2___st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 3
    void *mcfr_varptr[3];
#define MELTFRAM_NBVARNUM 1
    long mcfr_varnum[1];
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 3; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 3;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("LAMBDA_", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1411:/ getarg");
 /*_.PASSNAME__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;

  /*getarg#1 */
  /*^getarg */
  if (xargdescr_[0] != MELTBPAR_LONG)
    goto lab_endgetargs;
 /*_#PASSNUM__L1*/ meltfnum[0] = xargtab_[0].meltbp_long;
  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {

    MELT_LOCATION ("warmelt-base.melt:1412:/ apply");
    /*apply */
    {
      union meltparam_un argtab[2];
      memset (&argtab, 0, sizeof (argtab));
      /*^apply.arg */
      argtab[0].meltbp_aptr = (melt_ptr_t *) & /*_.PASSNAME__V2*/ meltfptr[1];
      /*^apply.arg */
      argtab[1].meltbp_long = /*_#PASSNUM__L1*/ meltfnum[0];
      /*_.RUN_ALL_PASS_EXECUTION_HOOKS__V3*/ meltfptr[2] =
	melt_apply ((meltclosure_ptr_t)
		    (( /*!RUN_ALL_PASS_EXECUTION_HOOKS */ meltfrout->
		      tabval[0])),
		    (melt_ptr_t) (( /*~NEWHOOKLIST */ meltfclos->tabval[0])),
		    (MELTBPARSTR_PTR MELTBPARSTR_LONG ""), argtab, "",
		    (union meltparam_un *) 0);
    }
    ;
    MELT_LOCATION ("warmelt-base.melt:1411:/ quasiblock");


    /*_.RETVAL___V1*/ meltfptr[0] =
      /*_.RUN_ALL_PASS_EXECUTION_HOOKS__V3*/ meltfptr[2];;
    MELT_LOCATION ("warmelt-base.melt:1411:/ finalreturn");
    ;
    /*finalret */ goto labend_rout;
    /*epilog */

    /*^clear */
	   /*clear *//*_.RUN_ALL_PASS_EXECUTION_HOOKS__V3*/ meltfptr[2] = 0;
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("LAMBDA_", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*_.RETVAL___V1*/ meltfptr[0]);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_16_warmelt_base_LAMBDA___2__ */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_17_warmelt_base_REGISTER_PRAGMA_HANDLER (meltclosure_ptr_t closp_,
						  melt_ptr_t firstargp_,
						  const melt_argdescr_cell_t
						  xargdescr_[],
						  union meltparam_un *
						  xargtab_,
						  const melt_argdescr_cell_t
						  xresdescr_[],
						  union meltparam_un *
						  xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_17_warmelt_base_REGISTER_PRAGMA_HANDLER_st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 12
    void *mcfr_varptr[12];
#define MELTFRAM_NBVARNUM 14
    long mcfr_varnum[14];
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 12; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 12;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("REGISTER_PRAGMA_HANDLER", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1420:/ getarg");
 /*_.LSTHANDLER__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;
  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {


#if MELT_HAVE_DEBUG
    MELT_LOCATION ("warmelt-base.melt:1425:/ cppif.then");
    /*^block */
    /*anyblock */
    {

   /*_#IS_LIST__L1*/ meltfnum[0] =
	(melt_magic_discr ((melt_ptr_t) ( /*_.LSTHANDLER__V2*/ meltfptr[1]))
	 == MELTOBMAG_LIST);;
      MELT_LOCATION ("warmelt-base.melt:1425:/ cond");
      /*cond */ if ( /*_#IS_LIST__L1*/ meltfnum[0])	/*then */
	{
	  /*^cond.then */
	  /*_.IFELSE___V4*/ meltfptr[3] = ( /*nil */ NULL);;
	}
      else
	{
	  MELT_LOCATION ("warmelt-base.melt:1425:/ cond.else");

	  /*^block */
	  /*anyblock */
	  {




	    {
	      /*^locexp */
	      melt_assert_failed (("register_pragma_handler takes a list as argument."), ("warmelt-base.melt") ? ("warmelt-base.melt") : __FILE__, (1425) ? (1425) : __LINE__, __FUNCTION__);
	      ;
	    }
	    ;
	       /*clear *//*_.IFELSE___V4*/ meltfptr[3] = 0;
	    /*epilog */
	  }
	  ;
	}
      ;
      /*^compute */

      /*_.IFCPP___V3*/ meltfptr[2] = /*_.IFELSE___V4*/ meltfptr[3];;
      /*epilog */

      MELT_LOCATION ("warmelt-base.melt:1425:/ clear");
	     /*clear *//*_#IS_LIST__L1*/ meltfnum[0] = 0;
      /*^clear */
	     /*clear *//*_.IFELSE___V4*/ meltfptr[3] = 0;
    }

#else /*MELT_HAVE_DEBUG */
    /*^cppif.else */
    /*_.IFCPP___V3*/ meltfptr[2] = ( /*nil */ NULL);
#endif /*MELT_HAVE_DEBUG */
    ;
    MELT_LOCATION ("warmelt-base.melt:1427:/ quasiblock");


    /*^cond */
    /*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) (( /*!INITIAL_SYSTEM_DATA */ meltfrout->tabval[0])), (melt_ptr_t) (( /*!CLASS_SYSTEM_DATA */ meltfrout->tabval[1]))))	/*then */
      {
	/*^cond.then */
	/*^getslot */
	{
	  melt_ptr_t slot = 0;
	  melt_object_get_field (slot, (melt_ptr_t) (( /*!INITIAL_SYSTEM_DATA */ meltfrout->tabval[0])), 27, "SYSDATA_MELTPRAGMAS");
															/*_.OLDTUPLE__V5*/
	  meltfptr[3] = slot;
	};
	;
      }
    else
      {				/*^cond.else */

  /*_.OLDTUPLE__V5*/ meltfptr[3] = NULL;;
      }
    ;
    /*^compute */

 /*_#OLDSIZE__L2*/ meltfnum[0] = 0;;
    MELT_LOCATION ("warmelt-base.melt:1429:/ cond");
    /*cond */ if (( /*!NOTNULL */ meltfrout->tabval[2]))	/*then */
      {
	/*^cond.then */
	/*_.IF___V6*/ meltfptr[5] = /*_.OLDTUPLE__V5*/ meltfptr[3];;
      }
    else
      {
	MELT_LOCATION ("warmelt-base.melt:1429:/ cond.else");

  /*_.IF___V6*/ meltfptr[5] = NULL;;
      }
    ;
    /*^compute */

 /*_#MULTIPLE_LENGTH__L3*/ meltfnum[2] =
      (melt_multiple_length
       ((melt_ptr_t) ( /*_.OLDTUPLE__V5*/ meltfptr[3])));;
    MELT_LOCATION ("warmelt-base.melt:1430:/ compute");
    /*_#OLDSIZE__L2*/ meltfnum[0] = /*_#SETQ___L4*/ meltfnum[3] =
      /*_#MULTIPLE_LENGTH__L3*/ meltfnum[2];;
    MELT_LOCATION ("warmelt-base.melt:1431:/ quasiblock");


 /*_#MULTIPLE_LENGTH__L5*/ meltfnum[4] =
      (melt_multiple_length
       ((melt_ptr_t) ( /*_.OLDTUPLE__V5*/ meltfptr[3])));;
    /*^compute */

 /*_#LIST_LENGTH__L6*/ meltfnum[5] =
      (melt_list_length ((melt_ptr_t) ( /*_.LSTHANDLER__V2*/ meltfptr[1])));;
    /*^compute */

 /*_#NEWSIZE__L7*/ meltfnum[6] =
      (( /*_#MULTIPLE_LENGTH__L5*/ meltfnum[4]) +
       ( /*_#LIST_LENGTH__L6*/ meltfnum[5]));;
    /*^compute */

 /*_.NEWTUPLE__V7*/ meltfptr[6] =
      (meltgc_new_multiple
       ((meltobject_ptr_t) (( /*!DISCR_MULTIPLE */ meltfrout->tabval[3])),
	( /*_#NEWSIZE__L7*/ meltfnum[6])));;
    /*^compute */

 /*_#I__L8*/ meltfnum[7] = 0;;
    /*citerblock FOREACH_IN_MULTIPLE */
    {
      /* start cit1__EACHTUP: */
      long cit1__EACHTUP_ln =
	melt_multiple_length ((melt_ptr_t) /*_.OLDTUPLE__V5*/ meltfptr[3]);
      for ( /*_#IUNUSED__L9*/ meltfnum[8] = 0;
	   ( /*_#IUNUSED__L9*/ meltfnum[8] >= 0)
	   && ( /*_#IUNUSED__L9*/ meltfnum[8] < cit1__EACHTUP_ln);
	/*_#IUNUSED__L9*/ meltfnum[8]++)
	{
	  /*_.CURHANDER__V8*/ meltfptr[7] =
	    melt_multiple_nth ((melt_ptr_t) ( /*_.OLDTUPLE__V5*/ meltfptr[3]),
			       /*_#IUNUSED__L9*/ meltfnum[8]);




	  {
	    MELT_LOCATION ("warmelt-base.melt:1439:/ locexp");
	    meltgc_multiple_put_nth ((melt_ptr_t)
				     ( /*_.NEWTUPLE__V7*/ meltfptr[6]),
				     ( /*_#I__L8*/ meltfnum[7]),
				     (melt_ptr_t) ( /*_.CURHANDER__V8*/
						   meltfptr[7]));
	  }
	  ;
  /*_#I__L10*/ meltfnum[9] =
	    (( /*_#I__L8*/ meltfnum[7]) + (1));;
	  MELT_LOCATION ("warmelt-base.melt:1440:/ compute");
	  /*_#I__L8*/ meltfnum[7] = /*_#SETQ___L11*/ meltfnum[10] =
	    /*_#I__L10*/ meltfnum[9];;
	  if ( /*_#IUNUSED__L9*/ meltfnum[8] < 0)
	    break;
	}			/* end cit1__EACHTUP */

      /*citerepilog */

      MELT_LOCATION ("warmelt-base.melt:1436:/ clear");
	    /*clear *//*_.CURHANDER__V8*/ meltfptr[7] = 0;
      /*^clear */
	    /*clear *//*_#IUNUSED__L9*/ meltfnum[8] = 0;
      /*^clear */
	    /*clear *//*_#I__L10*/ meltfnum[9] = 0;
      /*^clear */
	    /*clear *//*_#SETQ___L11*/ meltfnum[10] = 0;
    }				/*endciterblock FOREACH_IN_MULTIPLE */
    ;
    /*citerblock FOREACH_IN_LIST */
    {
      /* start cit2__EACHLIST */
      for ( /*_.CURPAIR__V9*/ meltfptr[8] =
	   melt_list_first ( /*_.LSTHANDLER__V2*/ meltfptr[1]);
	   melt_magic_discr ( /*_.CURPAIR__V9*/ meltfptr[8]) ==
	   MELTOBMAG_PAIR;
	   /*_.CURPAIR__V9*/ meltfptr[8] =
	   melt_pair_tail ( /*_.CURPAIR__V9*/ meltfptr[8]))
	{
	  /*_.CURHANDLER__V10*/ meltfptr[9] =
	    melt_pair_head ( /*_.CURPAIR__V9*/ meltfptr[8]);



#if MELT_HAVE_DEBUG
	  MELT_LOCATION ("warmelt-base.melt:1446:/ cppif.then");
	  /*^block */
	  /*anyblock */
	  {

    /*_#IS_A__L12*/ meltfnum[11] =
	      melt_is_instance_of ((melt_ptr_t)
				   ( /*_.CURHANDLER__V10*/ meltfptr[9]),
				   (melt_ptr_t) (( /*!CLASS_GCC_PRAGMA */
						  meltfrout->tabval[4])));;
	    MELT_LOCATION ("warmelt-base.melt:1446:/ cond");
	    /*cond */ if ( /*_#IS_A__L12*/ meltfnum[11])	/*then */
	      {
		/*^cond.then */
		/*_.IFELSE___V12*/ meltfptr[11] = ( /*nil */ NULL);;
	      }
	    else
	      {
		MELT_LOCATION ("warmelt-base.melt:1446:/ cond.else");

		/*^block */
		/*anyblock */
		{




		  {
		    /*^locexp */
		    melt_assert_failed (("register_pragma_handler must be a list of class_gcc_pragma."), ("warmelt-base.melt") ? ("warmelt-base.melt") : __FILE__, (1446) ? (1446) : __LINE__, __FUNCTION__);
		    ;
		  }
		  ;
		/*clear *//*_.IFELSE___V12*/ meltfptr[11] = 0;
		  /*epilog */
		}
		;
	      }
	    ;
	    /*^compute */

	    /*_.IFCPP___V11*/ meltfptr[10] = /*_.IFELSE___V12*/ meltfptr[11];;
	    /*epilog */

	    MELT_LOCATION ("warmelt-base.melt:1446:/ clear");
	      /*clear *//*_#IS_A__L12*/ meltfnum[11] = 0;
	    /*^clear */
	      /*clear *//*_.IFELSE___V12*/ meltfptr[11] = 0;
	  }

#else /*MELT_HAVE_DEBUG */
	  /*^cppif.else */
	  /*_.IFCPP___V11*/ meltfptr[10] = ( /*nil */ NULL);
#endif /*MELT_HAVE_DEBUG */
	  ;

	  {
	    MELT_LOCATION ("warmelt-base.melt:1448:/ locexp");
	    meltgc_multiple_put_nth ((melt_ptr_t)
				     ( /*_.NEWTUPLE__V7*/ meltfptr[6]),
				     ( /*_#I__L8*/ meltfnum[7]),
				     (melt_ptr_t) ( /*_.CURHANDLER__V10*/
						   meltfptr[9]));
	  }
	  ;
  /*_#I__L13*/ meltfnum[11] =
	    (( /*_#I__L8*/ meltfnum[7]) + (1));;
	  MELT_LOCATION ("warmelt-base.melt:1449:/ compute");
	  /*_#I__L8*/ meltfnum[7] = /*_#SETQ___L14*/ meltfnum[13] =
	    /*_#I__L13*/ meltfnum[11];;
	}			/* end cit2__EACHLIST */

      /*citerepilog */

      MELT_LOCATION ("warmelt-base.melt:1443:/ clear");
	    /*clear *//*_.CURPAIR__V9*/ meltfptr[8] = 0;
      /*^clear */
	    /*clear *//*_.CURHANDLER__V10*/ meltfptr[9] = 0;
      /*^clear */
	    /*clear *//*_.IFCPP___V11*/ meltfptr[10] = 0;
      /*^clear */
	    /*clear *//*_#I__L13*/ meltfnum[11] = 0;
      /*^clear */
	    /*clear *//*_#SETQ___L14*/ meltfnum[13] = 0;
    }				/*endciterblock FOREACH_IN_LIST */
    ;
    MELT_LOCATION ("warmelt-base.melt:1451:/ cond");
    /*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) (( /*!INITIAL_SYSTEM_DATA */ meltfrout->tabval[0])), (melt_ptr_t) (( /*!CLASS_SYSTEM_DATA */ meltfrout->tabval[1]))))	/*then */
      {
	/*^cond.then */
	/*^block */
	/*anyblock */
	{

	  /*^putslot */
	  /*putslot */
	  melt_assertmsg ("putslot checkobj @SYSDATA_MELTPRAGMAS",
			  melt_magic_discr ((melt_ptr_t)
					    (( /*!INITIAL_SYSTEM_DATA */
					      meltfrout->tabval[0]))) ==
			  MELTOBMAG_OBJECT);
	  melt_putfield_object ((( /*!INITIAL_SYSTEM_DATA */ meltfrout->
				  tabval[0])), (27),
				( /*_.NEWTUPLE__V7*/ meltfptr[6]),
				"SYSDATA_MELTPRAGMAS");
	  ;
	  /*^touch */
	  meltgc_touch (( /*!INITIAL_SYSTEM_DATA */ meltfrout->tabval[0]));
	  ;
	  /*epilog */
	}
	;
      }				/*noelse */
    ;

    MELT_LOCATION ("warmelt-base.melt:1431:/ clear");
	   /*clear *//*_#MULTIPLE_LENGTH__L5*/ meltfnum[4] = 0;
    /*^clear */
	   /*clear *//*_#LIST_LENGTH__L6*/ meltfnum[5] = 0;
    /*^clear */
	   /*clear *//*_#NEWSIZE__L7*/ meltfnum[6] = 0;
    /*^clear */
	   /*clear *//*_.NEWTUPLE__V7*/ meltfptr[6] = 0;
    /*^clear */
	   /*clear *//*_#I__L8*/ meltfnum[7] = 0;

    MELT_LOCATION ("warmelt-base.melt:1427:/ clear");
	   /*clear *//*_.OLDTUPLE__V5*/ meltfptr[3] = 0;
    /*^clear */
	   /*clear *//*_#OLDSIZE__L2*/ meltfnum[0] = 0;
    /*^clear */
	   /*clear *//*_.IF___V6*/ meltfptr[5] = 0;
    /*^clear */
	   /*clear *//*_#MULTIPLE_LENGTH__L3*/ meltfnum[2] = 0;
    /*^clear */
	   /*clear *//*_#SETQ___L4*/ meltfnum[3] = 0;
    /*epilog */

    MELT_LOCATION ("warmelt-base.melt:1420:/ clear");
	   /*clear *//*_.IFCPP___V3*/ meltfptr[2] = 0;
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("REGISTER_PRAGMA_HANDLER", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*noretval */ NULL);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_17_warmelt_base_REGISTER_PRAGMA_HANDLER */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_18_warmelt_base_REGISTER_PRE_GENERICIZE_HOOK_FIRST (meltclosure_ptr_t
							     closp_,
							     melt_ptr_t
							     firstargp_,
							     const
							     melt_argdescr_cell_t
							     xargdescr_[],
							     union
							     meltparam_un *
							     xargtab_,
							     const
							     melt_argdescr_cell_t
							     xresdescr_[],
							     union
							     meltparam_un *
							     xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_18_warmelt_base_REGISTER_PRE_GENERICIZE_HOOK_FIRST_st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 6
    void *mcfr_varptr[6];
#define MELTFRAM_NBVARNUM 2
    long mcfr_varnum[2];
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 6; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 6;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("REGISTER_PRE_GENERICIZE_HOOK_FIRST", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1462:/ getarg");
 /*_.FUN__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;
  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {

    MELT_LOCATION ("warmelt-base.melt:1466:/ quasiblock");


    /*^cond */
    /*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) (( /*!PREGENERICIZE_DELAYED_QUEUE */ meltfrout->tabval[0])), (melt_ptr_t) (( /*!CLASS_DELAYED_QUEUE */ meltfrout->tabval[1]))))	/*then */
      {
	/*^cond.then */
	/*^getslot */
	{
	  melt_ptr_t slot = 0;
	  melt_object_get_field (slot, (melt_ptr_t) (( /*!PREGENERICIZE_DELAYED_QUEUE */ meltfrout->tabval[0])), 2, "DELQU_FIRST");
														       /*_.FIRSTLIST__V3*/
	  meltfptr[2] = slot;
	};
	;
      }
    else
      {				/*^cond.else */

  /*_.FIRSTLIST__V3*/ meltfptr[2] = NULL;;
      }
    ;
    /*^compute */

 /*_#NULL__L1*/ meltfnum[0] =
      (( /*_.FIRSTLIST__V3*/ meltfptr[2]) == NULL);;
    MELT_LOCATION ("warmelt-base.melt:1468:/ cond");
    /*cond */ if ( /*_#NULL__L1*/ meltfnum[0])	/*then */
      {
	/*^cond.then */
	/*^block */
	/*anyblock */
	{

   /*_.MAKE_LIST__V4*/ meltfptr[3] =
	    (meltgc_new_list
	     ((meltobject_ptr_t)
	      (( /*!DISCR_LIST */ meltfrout->tabval[2]))));;
	  MELT_LOCATION ("warmelt-base.melt:1470:/ compute");
	  /*_.FIRSTLIST__V3*/ meltfptr[2] = /*_.SETQ___V5*/ meltfptr[4] =
	    /*_.MAKE_LIST__V4*/ meltfptr[3];;
   /*_.MAKE_LIST__V6*/ meltfptr[5] =
	    (meltgc_new_list
	     ((meltobject_ptr_t)
	      (( /*!DISCR_LIST */ meltfrout->tabval[2]))));;
	  MELT_LOCATION ("warmelt-base.melt:1471:/ cond");
	  /*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) (( /*!PREGENERICIZE_DELAYED_QUEUE */ meltfrout->tabval[0])), (melt_ptr_t) (( /*!CLASS_DELAYED_QUEUE */ meltfrout->tabval[1]))))	/*then */
	    {
	      /*^cond.then */
	      /*^block */
	      /*anyblock */
	      {

		/*^putslot */
		/*putslot */
		melt_assertmsg ("putslot checkobj @DELQU_FIRST",
				melt_magic_discr ((melt_ptr_t)
						  (( /*!PREGENERICIZE_DELAYED_QUEUE */ meltfrout->tabval[0]))) == MELTOBMAG_OBJECT);
		melt_putfield_object ((( /*!PREGENERICIZE_DELAYED_QUEUE */
					meltfrout->tabval[0])), (2),
				      ( /*_.FIRSTLIST__V3*/ meltfptr[2]),
				      "DELQU_FIRST");
		;
		/*^putslot */
		/*putslot */
		melt_assertmsg ("putslot checkobj @DELQU_LAST",
				melt_magic_discr ((melt_ptr_t)
						  (( /*!PREGENERICIZE_DELAYED_QUEUE */ meltfrout->tabval[0]))) == MELTOBMAG_OBJECT);
		melt_putfield_object ((( /*!PREGENERICIZE_DELAYED_QUEUE */
					meltfrout->tabval[0])), (3),
				      ( /*_.MAKE_LIST__V6*/ meltfptr[5]),
				      "DELQU_LAST");
		;
		/*^touch */
		meltgc_touch (( /*!PREGENERICIZE_DELAYED_QUEUE */ meltfrout->
			       tabval[0]));
		;
		/*epilog */
	      }
	      ;
	    }			/*noelse */
	  ;
	  MELT_LOCATION ("warmelt-base.melt:1475:/ cond");
	  /*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) (( /*!INITIAL_SYSTEM_DATA */ meltfrout->tabval[3])), (melt_ptr_t) (( /*!CLASS_SYSTEM_DATA */ meltfrout->tabval[5]))))	/*then */
	    {
	      /*^cond.then */
	      /*^block */
	      /*anyblock */
	      {

		/*^putslot */
		/*putslot */
		melt_assertmsg ("putslot checkobj @SYSDATA_PRE_GENERICIZE",
				melt_magic_discr ((melt_ptr_t)
						  (( /*!INITIAL_SYSTEM_DATA */
						    meltfrout->tabval[3]))) ==
				MELTOBMAG_OBJECT);
		melt_putfield_object ((( /*!INITIAL_SYSTEM_DATA */ meltfrout->
					tabval[3])), (21),
				      (( /*!PRE_GENERICIZE_HOOK_RUNNER */
					meltfrout->tabval[4])),
				      "SYSDATA_PRE_GENERICIZE");
		;
		/*^touch */
		meltgc_touch (( /*!INITIAL_SYSTEM_DATA */ meltfrout->
			       tabval[3]));
		;
		/*epilog */
	      }
	      ;
	    }			/*noelse */
	  ;
	  MELT_LOCATION ("warmelt-base.melt:1469:/ quasiblock");


	  /*epilog */

	  MELT_LOCATION ("warmelt-base.melt:1468:/ clear");
	     /*clear *//*_.MAKE_LIST__V4*/ meltfptr[3] = 0;
	  /*^clear */
	     /*clear *//*_.SETQ___V5*/ meltfptr[4] = 0;
	  /*^clear */
	     /*clear *//*_.MAKE_LIST__V6*/ meltfptr[5] = 0;
	}
	;
      }				/*noelse */
    ;
 /*_#IS_CLOSURE__L2*/ meltfnum[1] =
      (melt_magic_discr ((melt_ptr_t) ( /*_.FUN__V2*/ meltfptr[1])) ==
       MELTOBMAG_CLOSURE);;
    MELT_LOCATION ("warmelt-base.melt:1478:/ cond");
    /*cond */ if ( /*_#IS_CLOSURE__L2*/ meltfnum[1])	/*then */
      {
	/*^cond.then */
	/*^block */
	/*anyblock */
	{


	  {
	    MELT_LOCATION ("warmelt-base.melt:1479:/ locexp");
	    meltgc_append_list ((melt_ptr_t)
				( /*_.FIRSTLIST__V3*/ meltfptr[2]),
				(melt_ptr_t) ( /*_.FUN__V2*/ meltfptr[1]));
	  }
	  ;
	  /*epilog */
	}
	;
      }
    else
      {
	MELT_LOCATION ("warmelt-base.melt:1478:/ cond.else");

	/*^block */
	/*anyblock */
	{


	  {
	    MELT_LOCATION ("warmelt-base.melt:1480:/ locexp");
	    error ("MELT ERROR MSG [#%ld]::: %s", melt_dbgcounter,
		   ("Bad hook passed to register_pre_genericize_hook"));
	  }
	  ;
	  /*epilog */
	}
	;
      }
    ;

    MELT_LOCATION ("warmelt-base.melt:1466:/ clear");
	   /*clear *//*_.FIRSTLIST__V3*/ meltfptr[2] = 0;
    /*^clear */
	   /*clear *//*_#NULL__L1*/ meltfnum[0] = 0;
    /*^clear */
	   /*clear *//*_#IS_CLOSURE__L2*/ meltfnum[1] = 0;
    /*epilog */
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("REGISTER_PRE_GENERICIZE_HOOK_FIRST", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*noretval */ NULL);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_18_warmelt_base_REGISTER_PRE_GENERICIZE_HOOK_FIRST */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_19_warmelt_base_REGISTER_PRE_GENERICIZE_HOOK_LAST (meltclosure_ptr_t
							    closp_,
							    melt_ptr_t
							    firstargp_,
							    const
							    melt_argdescr_cell_t
							    xargdescr_[],
							    union meltparam_un
							    * xargtab_,
							    const
							    melt_argdescr_cell_t
							    xresdescr_[],
							    union meltparam_un
							    * xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_19_warmelt_base_REGISTER_PRE_GENERICIZE_HOOK_LAST_st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 6
    void *mcfr_varptr[6];
#define MELTFRAM_NBVARNUM 2
    long mcfr_varnum[2];
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 6; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 6;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("REGISTER_PRE_GENERICIZE_HOOK_LAST", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1485:/ getarg");
 /*_.FUN__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;
  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {

    MELT_LOCATION ("warmelt-base.melt:1489:/ quasiblock");


    /*^cond */
    /*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) (( /*!PREGENERICIZE_DELAYED_QUEUE */ meltfrout->tabval[0])), (melt_ptr_t) (( /*!CLASS_DELAYED_QUEUE */ meltfrout->tabval[1]))))	/*then */
      {
	/*^cond.then */
	/*^getslot */
	{
	  melt_ptr_t slot = 0;
	  melt_object_get_field (slot, (melt_ptr_t) (( /*!PREGENERICIZE_DELAYED_QUEUE */ meltfrout->tabval[0])), 2, "DELQU_FIRST");
														       /*_.LASTLIST__V3*/
	  meltfptr[2] = slot;
	};
	;
      }
    else
      {				/*^cond.else */

  /*_.LASTLIST__V3*/ meltfptr[2] = NULL;;
      }
    ;
    /*^compute */

 /*_#NULL__L1*/ meltfnum[0] =
      (( /*_.LASTLIST__V3*/ meltfptr[2]) == NULL);;
    MELT_LOCATION ("warmelt-base.melt:1491:/ cond");
    /*cond */ if ( /*_#NULL__L1*/ meltfnum[0])	/*then */
      {
	/*^cond.then */
	/*^block */
	/*anyblock */
	{

   /*_.MAKE_LIST__V4*/ meltfptr[3] =
	    (meltgc_new_list
	     ((meltobject_ptr_t)
	      (( /*!DISCR_LIST */ meltfrout->tabval[2]))));;
	  MELT_LOCATION ("warmelt-base.melt:1493:/ compute");
	  /*_.LASTLIST__V3*/ meltfptr[2] = /*_.SETQ___V5*/ meltfptr[4] =
	    /*_.MAKE_LIST__V4*/ meltfptr[3];;
   /*_.MAKE_LIST__V6*/ meltfptr[5] =
	    (meltgc_new_list
	     ((meltobject_ptr_t)
	      (( /*!DISCR_LIST */ meltfrout->tabval[2]))));;
	  MELT_LOCATION ("warmelt-base.melt:1494:/ cond");
	  /*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) (( /*!PREGENERICIZE_DELAYED_QUEUE */ meltfrout->tabval[0])), (melt_ptr_t) (( /*!CLASS_DELAYED_QUEUE */ meltfrout->tabval[1]))))	/*then */
	    {
	      /*^cond.then */
	      /*^block */
	      /*anyblock */
	      {

		/*^putslot */
		/*putslot */
		melt_assertmsg ("putslot checkobj @DELQU_FIRST",
				melt_magic_discr ((melt_ptr_t)
						  (( /*!PREGENERICIZE_DELAYED_QUEUE */ meltfrout->tabval[0]))) == MELTOBMAG_OBJECT);
		melt_putfield_object ((( /*!PREGENERICIZE_DELAYED_QUEUE */
					meltfrout->tabval[0])), (2),
				      ( /*_.LASTLIST__V3*/ meltfptr[2]),
				      "DELQU_FIRST");
		;
		/*^putslot */
		/*putslot */
		melt_assertmsg ("putslot checkobj @DELQU_LAST",
				melt_magic_discr ((melt_ptr_t)
						  (( /*!PREGENERICIZE_DELAYED_QUEUE */ meltfrout->tabval[0]))) == MELTOBMAG_OBJECT);
		melt_putfield_object ((( /*!PREGENERICIZE_DELAYED_QUEUE */
					meltfrout->tabval[0])), (3),
				      ( /*_.MAKE_LIST__V6*/ meltfptr[5]),
				      "DELQU_LAST");
		;
		/*^touch */
		meltgc_touch (( /*!PREGENERICIZE_DELAYED_QUEUE */ meltfrout->
			       tabval[0]));
		;
		/*epilog */
	      }
	      ;
	    }			/*noelse */
	  ;
	  MELT_LOCATION ("warmelt-base.melt:1498:/ cond");
	  /*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) (( /*!INITIAL_SYSTEM_DATA */ meltfrout->tabval[3])), (melt_ptr_t) (( /*!CLASS_SYSTEM_DATA */ meltfrout->tabval[5]))))	/*then */
	    {
	      /*^cond.then */
	      /*^block */
	      /*anyblock */
	      {

		/*^putslot */
		/*putslot */
		melt_assertmsg ("putslot checkobj @SYSDATA_PRE_GENERICIZE",
				melt_magic_discr ((melt_ptr_t)
						  (( /*!INITIAL_SYSTEM_DATA */
						    meltfrout->tabval[3]))) ==
				MELTOBMAG_OBJECT);
		melt_putfield_object ((( /*!INITIAL_SYSTEM_DATA */ meltfrout->
					tabval[3])), (21),
				      (( /*!PRE_GENERICIZE_HOOK_RUNNER */
					meltfrout->tabval[4])),
				      "SYSDATA_PRE_GENERICIZE");
		;
		/*^touch */
		meltgc_touch (( /*!INITIAL_SYSTEM_DATA */ meltfrout->
			       tabval[3]));
		;
		/*epilog */
	      }
	      ;
	    }			/*noelse */
	  ;
	  MELT_LOCATION ("warmelt-base.melt:1492:/ quasiblock");


	  /*epilog */

	  MELT_LOCATION ("warmelt-base.melt:1491:/ clear");
	     /*clear *//*_.MAKE_LIST__V4*/ meltfptr[3] = 0;
	  /*^clear */
	     /*clear *//*_.SETQ___V5*/ meltfptr[4] = 0;
	  /*^clear */
	     /*clear *//*_.MAKE_LIST__V6*/ meltfptr[5] = 0;
	}
	;
      }				/*noelse */
    ;
 /*_#IS_CLOSURE__L2*/ meltfnum[1] =
      (melt_magic_discr ((melt_ptr_t) ( /*_.FUN__V2*/ meltfptr[1])) ==
       MELTOBMAG_CLOSURE);;
    MELT_LOCATION ("warmelt-base.melt:1501:/ cond");
    /*cond */ if ( /*_#IS_CLOSURE__L2*/ meltfnum[1])	/*then */
      {
	/*^cond.then */
	/*^block */
	/*anyblock */
	{


	  {
	    MELT_LOCATION ("warmelt-base.melt:1502:/ locexp");
	    meltgc_append_list ((melt_ptr_t)
				( /*_.LASTLIST__V3*/ meltfptr[2]),
				(melt_ptr_t) ( /*_.FUN__V2*/ meltfptr[1]));
	  }
	  ;
	  /*epilog */
	}
	;
      }
    else
      {
	MELT_LOCATION ("warmelt-base.melt:1501:/ cond.else");

	/*^block */
	/*anyblock */
	{


	  {
	    MELT_LOCATION ("warmelt-base.melt:1503:/ locexp");
	    error ("MELT ERROR MSG [#%ld]::: %s", melt_dbgcounter,
		   ("Bad hook passed to register_pre_genericize_hook"));
	  }
	  ;
	  /*epilog */
	}
	;
      }
    ;

    MELT_LOCATION ("warmelt-base.melt:1489:/ clear");
	   /*clear *//*_.LASTLIST__V3*/ meltfptr[2] = 0;
    /*^clear */
	   /*clear *//*_#NULL__L1*/ meltfnum[0] = 0;
    /*^clear */
	   /*clear *//*_#IS_CLOSURE__L2*/ meltfnum[1] = 0;
    /*epilog */
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("REGISTER_PRE_GENERICIZE_HOOK_LAST", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*noretval */ NULL);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_19_warmelt_base_REGISTER_PRE_GENERICIZE_HOOK_LAST */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_20_warmelt_base_PRE_GENERICIZE_HOOK_RUNNER (meltclosure_ptr_t closp_,
						     melt_ptr_t firstargp_,
						     const
						     melt_argdescr_cell_t
						     xargdescr_[],
						     union meltparam_un *
						     xargtab_,
						     const
						     melt_argdescr_cell_t
						     xresdescr_[],
						     union meltparam_un *
						     xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_20_warmelt_base_PRE_GENERICIZE_HOOK_RUNNER_st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 17
    void *mcfr_varptr[17];
/*no varnum*/
#define MELTFRAM_NBVARNUM /*none*/0
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 17; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 17;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("PRE_GENERICIZE_HOOK_RUNNER", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1508:/ getarg");
 /*_.FNDECLV__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;
  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {

    MELT_LOCATION ("warmelt-base.melt:1513:/ quasiblock");


    /*^cond */
    /*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) (( /*!PREGENERICIZE_DELAYED_QUEUE */ meltfrout->tabval[0])), (melt_ptr_t) (( /*!CLASS_DELAYED_QUEUE */ meltfrout->tabval[1]))))	/*then */
      {
	/*^cond.then */
	/*^getslot */
	{
	  melt_ptr_t slot = 0;
	  melt_object_get_field (slot, (melt_ptr_t) (( /*!PREGENERICIZE_DELAYED_QUEUE */ meltfrout->tabval[0])), 2, "DELQU_FIRST");
														       /*_.FIRSTLIST__V4*/
	  meltfptr[3] = slot;
	};
	;
      }
    else
      {				/*^cond.else */

  /*_.FIRSTLIST__V4*/ meltfptr[3] = NULL;;
      }
    ;
    MELT_LOCATION ("warmelt-base.melt:1514:/ cond");
    /*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) (( /*!PREGENERICIZE_DELAYED_QUEUE */ meltfrout->tabval[0])), (melt_ptr_t) (( /*!CLASS_DELAYED_QUEUE */ meltfrout->tabval[1]))))	/*then */
      {
	/*^cond.then */
	/*^getslot */
	{
	  melt_ptr_t slot = 0;
	  melt_object_get_field (slot, (melt_ptr_t) (( /*!PREGENERICIZE_DELAYED_QUEUE */ meltfrout->tabval[0])), 3, "DELQU_LAST");
														      /*_.LASTLIST__V5*/
	  meltfptr[4] = slot;
	};
	;
      }
    else
      {				/*^cond.else */

  /*_.LASTLIST__V5*/ meltfptr[4] = NULL;;
      }
    ;
    /*^compute */

 /*_.REVLASTLIST__V6*/ meltfptr[5] =
      (meltgc_new_list
       ((meltobject_ptr_t) (( /*!DISCR_LIST */ meltfrout->tabval[2]))));;
    MELT_LOCATION ("warmelt-base.melt:1516:/ quasiblock");


    /*^rawallocobj */
    /*rawallocobj */
    {
      melt_ptr_t newobj = 0;
      melt_raw_object_create (newobj,
			      (melt_ptr_t) (( /*!CLASS_CONTAINER */
					     meltfrout->tabval[3])), (1),
			      "CLASS_CONTAINER");
  /*_.INST__V8*/ meltfptr[7] =
	newobj;
    };
    ;
    /*_.RESCONT__V7*/ meltfptr[6] = /*_.INST__V8*/ meltfptr[7];;
    MELT_LOCATION ("warmelt-base.melt:1521:/ quasiblock");


    /*^newclosure */
		 /*newclosure *//*_.LAMBDA___V10*/ meltfptr[9] =
      meltgc_new_closure ((meltobject_ptr_t)
			  (((void *) (MELT_PREDEF (DISCR_CLOSURE)))),
			  (meltroutine_ptr_t) (( /*!konst_5 */ meltfrout->
						tabval[5])), (1));
    ;
    /*^putclosedv */
    /*putclosv */
    melt_assertmsg ("putclosv checkclo",
		    melt_magic_discr ((melt_ptr_t)
				      ( /*_.LAMBDA___V10*/ meltfptr[9])) ==
		    MELTOBMAG_CLOSURE);
    melt_assertmsg ("putclosv checkoff", 0 >= 0
		    && 0 <
		    melt_closure_size ((melt_ptr_t)
				       ( /*_.LAMBDA___V10*/ meltfptr[9])));
    ((meltclosure_ptr_t) /*_.LAMBDA___V10*/ meltfptr[9])->tabval[0] =
      (melt_ptr_t) ( /*_.FNDECLV__V2*/ meltfptr[1]);
    ;
    /*_.LAMBDA___V9*/ meltfptr[8] = /*_.LAMBDA___V10*/ meltfptr[9];;
    MELT_LOCATION ("warmelt-base.melt:1519:/ apply");
    /*apply */
    {
      union meltparam_un argtab[1];
      memset (&argtab, 0, sizeof (argtab));
      /*^apply.arg */
      argtab[0].meltbp_aptr = (melt_ptr_t *) & /*_.LAMBDA___V9*/ meltfptr[8];
      /*_.LIST_EVERY__V11*/ meltfptr[10] =
	melt_apply ((meltclosure_ptr_t)
		    (( /*!LIST_EVERY */ meltfrout->tabval[4])),
		    (melt_ptr_t) ( /*_.FIRSTLIST__V4*/ meltfptr[3]),
		    (MELTBPARSTR_PTR ""), argtab, "",
		    (union meltparam_un *) 0);
    }
    ;
    MELT_LOCATION ("warmelt-base.melt:1527:/ quasiblock");


    /*^newclosure */
		 /*newclosure *//*_.LAMBDA___V13*/ meltfptr[12] =
      meltgc_new_closure ((meltobject_ptr_t)
			  (((void *) (MELT_PREDEF (DISCR_CLOSURE)))),
			  (meltroutine_ptr_t) (( /*!konst_6 */ meltfrout->
						tabval[6])), (1));
    ;
    /*^putclosedv */
    /*putclosv */
    melt_assertmsg ("putclosv checkclo",
		    melt_magic_discr ((melt_ptr_t)
				      ( /*_.LAMBDA___V13*/ meltfptr[12])) ==
		    MELTOBMAG_CLOSURE);
    melt_assertmsg ("putclosv checkoff", 0 >= 0
		    && 0 <
		    melt_closure_size ((melt_ptr_t)
				       ( /*_.LAMBDA___V13*/ meltfptr[12])));
    ((meltclosure_ptr_t) /*_.LAMBDA___V13*/ meltfptr[12])->tabval[0] =
      (melt_ptr_t) ( /*_.REVLASTLIST__V6*/ meltfptr[5]);
    ;
    /*_.LAMBDA___V12*/ meltfptr[11] = /*_.LAMBDA___V13*/ meltfptr[12];;
    MELT_LOCATION ("warmelt-base.melt:1525:/ apply");
    /*apply */
    {
      union meltparam_un argtab[1];
      memset (&argtab, 0, sizeof (argtab));
      /*^apply.arg */
      argtab[0].meltbp_aptr =
	(melt_ptr_t *) & /*_.LAMBDA___V12*/ meltfptr[11];
      /*_.LIST_EVERY__V14*/ meltfptr[13] =
	melt_apply ((meltclosure_ptr_t)
		    (( /*!LIST_EVERY */ meltfrout->tabval[4])),
		    (melt_ptr_t) ( /*_.LASTLIST__V5*/ meltfptr[4]),
		    (MELTBPARSTR_PTR ""), argtab, "",
		    (union meltparam_un *) 0);
    }
    ;
    MELT_LOCATION ("warmelt-base.melt:1532:/ quasiblock");


    /*^newclosure */
		 /*newclosure *//*_.LAMBDA___V16*/ meltfptr[15] =
      meltgc_new_closure ((meltobject_ptr_t)
			  (((void *) (MELT_PREDEF (DISCR_CLOSURE)))),
			  (meltroutine_ptr_t) (( /*!konst_7 */ meltfrout->
						tabval[7])), (1));
    ;
    /*^putclosedv */
    /*putclosv */
    melt_assertmsg ("putclosv checkclo",
		    melt_magic_discr ((melt_ptr_t)
				      ( /*_.LAMBDA___V16*/ meltfptr[15])) ==
		    MELTOBMAG_CLOSURE);
    melt_assertmsg ("putclosv checkoff", 0 >= 0
		    && 0 <
		    melt_closure_size ((melt_ptr_t)
				       ( /*_.LAMBDA___V16*/ meltfptr[15])));
    ((meltclosure_ptr_t) /*_.LAMBDA___V16*/ meltfptr[15])->tabval[0] =
      (melt_ptr_t) ( /*_.FNDECLV__V2*/ meltfptr[1]);
    ;
    /*_.LAMBDA___V15*/ meltfptr[14] = /*_.LAMBDA___V16*/ meltfptr[15];;
    MELT_LOCATION ("warmelt-base.melt:1530:/ apply");
    /*apply */
    {
      union meltparam_un argtab[1];
      memset (&argtab, 0, sizeof (argtab));
      /*^apply.arg */
      argtab[0].meltbp_aptr =
	(melt_ptr_t *) & /*_.LAMBDA___V15*/ meltfptr[14];
      /*_.LIST_EVERY__V17*/ meltfptr[16] =
	melt_apply ((meltclosure_ptr_t)
		    (( /*!LIST_EVERY */ meltfrout->tabval[4])),
		    (melt_ptr_t) ( /*_.REVLASTLIST__V6*/ meltfptr[5]),
		    (MELTBPARSTR_PTR ""), argtab, "",
		    (union meltparam_un *) 0);
    }
    ;
    /*_.LET___V3*/ meltfptr[2] = /*_.LIST_EVERY__V17*/ meltfptr[16];;

    MELT_LOCATION ("warmelt-base.melt:1513:/ clear");
	   /*clear *//*_.FIRSTLIST__V4*/ meltfptr[3] = 0;
    /*^clear */
	   /*clear *//*_.LASTLIST__V5*/ meltfptr[4] = 0;
    /*^clear */
	   /*clear *//*_.REVLASTLIST__V6*/ meltfptr[5] = 0;
    /*^clear */
	   /*clear *//*_.RESCONT__V7*/ meltfptr[6] = 0;
    /*^clear */
	   /*clear *//*_.LAMBDA___V9*/ meltfptr[8] = 0;
    /*^clear */
	   /*clear *//*_.LIST_EVERY__V11*/ meltfptr[10] = 0;
    /*^clear */
	   /*clear *//*_.LAMBDA___V12*/ meltfptr[11] = 0;
    /*^clear */
	   /*clear *//*_.LIST_EVERY__V14*/ meltfptr[13] = 0;
    /*^clear */
	   /*clear *//*_.LAMBDA___V15*/ meltfptr[14] = 0;
    /*^clear */
	   /*clear *//*_.LIST_EVERY__V17*/ meltfptr[16] = 0;
    MELT_LOCATION ("warmelt-base.melt:1508:/ quasiblock");


    /*_.RETVAL___V1*/ meltfptr[0] = /*_.LET___V3*/ meltfptr[2];;
    MELT_LOCATION ("warmelt-base.melt:1508:/ finalreturn");
    ;
    /*finalret */ goto labend_rout;
    /*epilog */

    /*^clear */
	   /*clear *//*_.LET___V3*/ meltfptr[2] = 0;
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("PRE_GENERICIZE_HOOK_RUNNER", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*_.RETVAL___V1*/ meltfptr[0]);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_20_warmelt_base_PRE_GENERICIZE_HOOK_RUNNER */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_21_warmelt_base_LAMBDA___3__ (meltclosure_ptr_t closp_,
				       melt_ptr_t firstargp_,
				       const melt_argdescr_cell_t
				       xargdescr_[],
				       union meltparam_un * xargtab_,
				       const melt_argdescr_cell_t
				       xresdescr_[],
				       union meltparam_un * xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_21_warmelt_base_LAMBDA___3___st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 3
    void *mcfr_varptr[3];
/*no varnum*/
#define MELTFRAM_NBVARNUM /*none*/0
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 3; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 3;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("LAMBDA_", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1521:/ getarg");
 /*_.FIRSTPROC__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;
  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {

    MELT_LOCATION ("warmelt-base.melt:1522:/ apply");
    /*apply */
    {
      /*_.FIRSTPROC__V3*/ meltfptr[2] =
	melt_apply ((meltclosure_ptr_t) ( /*_.FIRSTPROC__V2*/ meltfptr[1]),
		    (melt_ptr_t) (( /*~FNDECLV */ meltfclos->tabval[0])),
		    (""), (union meltparam_un *) 0, "",
		    (union meltparam_un *) 0);
    }
    ;
    MELT_LOCATION ("warmelt-base.melt:1521:/ quasiblock");


    /*_.RETVAL___V1*/ meltfptr[0] = /*_.FIRSTPROC__V3*/ meltfptr[2];;
    MELT_LOCATION ("warmelt-base.melt:1521:/ finalreturn");
    ;
    /*finalret */ goto labend_rout;
    /*epilog */

    /*^clear */
	   /*clear *//*_.FIRSTPROC__V3*/ meltfptr[2] = 0;
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("LAMBDA_", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*_.RETVAL___V1*/ meltfptr[0]);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_21_warmelt_base_LAMBDA___3__ */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_22_warmelt_base_LAMBDA___4__ (meltclosure_ptr_t closp_,
				       melt_ptr_t firstargp_,
				       const melt_argdescr_cell_t
				       xargdescr_[],
				       union meltparam_un * xargtab_,
				       const melt_argdescr_cell_t
				       xresdescr_[],
				       union meltparam_un * xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_22_warmelt_base_LAMBDA___4___st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 2
    void *mcfr_varptr[2];
#define MELTFRAM_NBVARNUM 1
    long mcfr_varnum[1];
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 2; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 2;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("LAMBDA_", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1527:/ getarg");
 /*_.LASTPROC__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;
  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {

 /*_#IS_CLOSURE__L1*/ meltfnum[0] =
      (melt_magic_discr ((melt_ptr_t) ( /*_.LASTPROC__V2*/ meltfptr[1])) ==
       MELTOBMAG_CLOSURE);;
    MELT_LOCATION ("warmelt-base.melt:1528:/ cond");
    /*cond */ if ( /*_#IS_CLOSURE__L1*/ meltfnum[0])	/*then */
      {
	/*^cond.then */
	/*^block */
	/*anyblock */
	{


	  {
	    /*^locexp */
	    meltgc_prepend_list ((melt_ptr_t)
				 (( /*~REVLASTLIST */ meltfclos->tabval[0])),
				 (melt_ptr_t) ( /*_.LASTPROC__V2*/
					       meltfptr[1]));
	  }
	  ;
	  /*epilog */
	}
	;
      }				/*noelse */
    ;
    /*epilog */

    MELT_LOCATION ("warmelt-base.melt:1527:/ clear");
	   /*clear *//*_#IS_CLOSURE__L1*/ meltfnum[0] = 0;
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("LAMBDA_", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*noretval */ NULL);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_22_warmelt_base_LAMBDA___4__ */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_23_warmelt_base_LAMBDA___5__ (meltclosure_ptr_t closp_,
				       melt_ptr_t firstargp_,
				       const melt_argdescr_cell_t
				       xargdescr_[],
				       union meltparam_un * xargtab_,
				       const melt_argdescr_cell_t
				       xresdescr_[],
				       union meltparam_un * xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_23_warmelt_base_LAMBDA___5___st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 3
    void *mcfr_varptr[3];
/*no varnum*/
#define MELTFRAM_NBVARNUM /*none*/0
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 3; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 3;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("LAMBDA_", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1532:/ getarg");
 /*_.LASTPROC__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;
  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {

    MELT_LOCATION ("warmelt-base.melt:1533:/ apply");
    /*apply */
    {
      /*_.LASTPROC__V3*/ meltfptr[2] =
	melt_apply ((meltclosure_ptr_t) ( /*_.LASTPROC__V2*/ meltfptr[1]),
		    (melt_ptr_t) (( /*~FNDECLV */ meltfclos->tabval[0])),
		    (""), (union meltparam_un *) 0, "",
		    (union meltparam_un *) 0);
    }
    ;
    MELT_LOCATION ("warmelt-base.melt:1532:/ quasiblock");


    /*_.RETVAL___V1*/ meltfptr[0] = /*_.LASTPROC__V3*/ meltfptr[2];;
    MELT_LOCATION ("warmelt-base.melt:1532:/ finalreturn");
    ;
    /*finalret */ goto labend_rout;
    /*epilog */

    /*^clear */
	   /*clear *//*_.LASTPROC__V3*/ meltfptr[2] = 0;
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("LAMBDA_", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*_.RETVAL___V1*/ meltfptr[0]);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_23_warmelt_base_LAMBDA___5__ */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_24_warmelt_base_SET_CONTENT (meltclosure_ptr_t closp_,
				      melt_ptr_t firstargp_,
				      const melt_argdescr_cell_t xargdescr_[],
				      union meltparam_un * xargtab_,
				      const melt_argdescr_cell_t xresdescr_[],
				      union meltparam_un * xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_24_warmelt_base_SET_CONTENT_st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 3
    void *mcfr_varptr[3];
/*no varnum*/
#define MELTFRAM_NBVARNUM /*none*/0
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 3; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 3;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("SET_CONTENT", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1577:/ getarg");
 /*_.C__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;

  /*getarg#1 */
  /*^getarg */
  if (xargdescr_[0] != MELTBPAR_PTR)
    goto lab_endgetargs;
 /*_.V__V3*/ meltfptr[2] =
    (xargtab_[0].meltbp_aptr) ? (*(xargtab_[0].meltbp_aptr)) : NULL;
  gcc_assert (melt_discr ((melt_ptr_t) ( /*_.V__V3*/ meltfptr[2])) != NULL);

  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {

    MELT_LOCATION ("warmelt-base.melt:1580:/ cond");
    /*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) ( /*_.C__V2*/ meltfptr[1]), (melt_ptr_t) (( /*!CLASS_CONTAINER */ meltfrout->tabval[0]))))	/*then */
      {
	/*^cond.then */
	/*^block */
	/*anyblock */
	{

	  /*^putslot */
	  /*putslot */
	  melt_assertmsg ("putslot checkobj @CONTAINER_VALUE",
			  melt_magic_discr ((melt_ptr_t)
					    ( /*_.C__V2*/ meltfptr[1])) ==
			  MELTOBMAG_OBJECT);
	  melt_putfield_object (( /*_.C__V2*/ meltfptr[1]), (0),
				( /*_.V__V3*/ meltfptr[2]),
				"CONTAINER_VALUE");
	  ;
	  /*^touch */
	  meltgc_touch ( /*_.C__V2*/ meltfptr[1]);
	  ;
	  /*epilog */
	}
	;
      }				/*noelse */
    ;
    /*epilog */
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("SET_CONTENT", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*noretval */ NULL);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_24_warmelt_base_SET_CONTENT */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_25_warmelt_base_INSTALL_VALUE_DESCRIPTOR (meltclosure_ptr_t closp_,
						   melt_ptr_t firstargp_,
						   const melt_argdescr_cell_t
						   xargdescr_[],
						   union meltparam_un *
						   xargtab_,
						   const melt_argdescr_cell_t
						   xresdescr_[],
						   union meltparam_un *
						   xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_25_warmelt_base_INSTALL_VALUE_DESCRIPTOR_st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 5
    void *mcfr_varptr[5];
#define MELTFRAM_NBVARNUM 1
    long mcfr_varnum[1];
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 5; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 5;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("INSTALL_VALUE_DESCRIPTOR", meltcallcount);
/*getargs*/

  /*getarg#0 */
  MELT_LOCATION ("warmelt-base.melt:1589:/ getarg");
 /*_.VD__V2*/ meltfptr[1] = (melt_ptr_t) firstargp_;
  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
/*^block*/
/*anyblock*/
  {


#if MELT_HAVE_DEBUG
    MELT_LOCATION ("warmelt-base.melt:1590:/ cppif.then");
    /*^block */
    /*anyblock */
    {

   /*_#IS_A__L1*/ meltfnum[0] =
	melt_is_instance_of ((melt_ptr_t) ( /*_.VD__V2*/ meltfptr[1]),
			     (melt_ptr_t) (( /*!CLASS_VALUE_DESCRIPTOR */
					    meltfrout->tabval[0])));;
      MELT_LOCATION ("warmelt-base.melt:1590:/ cond");
      /*cond */ if ( /*_#IS_A__L1*/ meltfnum[0])	/*then */
	{
	  /*^cond.then */
	  /*_.IFELSE___V4*/ meltfptr[3] = ( /*nil */ NULL);;
	}
      else
	{
	  MELT_LOCATION ("warmelt-base.melt:1590:/ cond.else");

	  /*^block */
	  /*anyblock */
	  {




	    {
	      /*^locexp */
	      melt_assert_failed (("check vd"),
				  ("warmelt-base.melt")
				  ? ("warmelt-base.melt") : __FILE__,
				  (1590) ? (1590) : __LINE__, __FUNCTION__);
	      ;
	    }
	    ;
	       /*clear *//*_.IFELSE___V4*/ meltfptr[3] = 0;
	    /*epilog */
	  }
	  ;
	}
      ;
      /*^compute */

      /*_.IFCPP___V3*/ meltfptr[2] = /*_.IFELSE___V4*/ meltfptr[3];;
      /*epilog */

      MELT_LOCATION ("warmelt-base.melt:1590:/ clear");
	     /*clear *//*_#IS_A__L1*/ meltfnum[0] = 0;
      /*^clear */
	     /*clear *//*_.IFELSE___V4*/ meltfptr[3] = 0;
    }

#else /*MELT_HAVE_DEBUG */
    /*^cppif.else */
    /*_.IFCPP___V3*/ meltfptr[2] = ( /*nil */ NULL);
#endif /*MELT_HAVE_DEBUG */
    ;
    MELT_LOCATION ("warmelt-base.melt:1591:/ cond");
    /*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) (( /*!VALUE_DESCRIPTOR_LIST_CONTAINER */ meltfrout->tabval[1])), (melt_ptr_t) (( /*!CLASS_CONTAINER */ meltfrout->tabval[2]))))	/*then */
      {
	/*^cond.then */
	/*^getslot */
	{
	  melt_ptr_t slot = 0;
	  melt_object_get_field (slot, (melt_ptr_t) (( /*!VALUE_DESCRIPTOR_LIST_CONTAINER */ meltfrout->tabval[1])), 0, "CONTAINER_VALUE");
															       /*_.CONTAINER_VALUE__V5*/
	  meltfptr[3] = slot;
	};
	;
      }
    else
      {				/*^cond.else */

  /*_.CONTAINER_VALUE__V5*/ meltfptr[3] = NULL;;
      }
    ;

    {
      MELT_LOCATION ("warmelt-base.melt:1591:/ locexp");
      meltgc_append_list ((melt_ptr_t)
			  ( /*_.CONTAINER_VALUE__V5*/ meltfptr[3]),
			  (melt_ptr_t) ( /*_.VD__V2*/ meltfptr[1]));
    }
    ;
    /*epilog */

    MELT_LOCATION ("warmelt-base.melt:1589:/ clear");
	   /*clear *//*_.IFCPP___V3*/ meltfptr[2] = 0;
    /*^clear */
	   /*clear *//*_.CONTAINER_VALUE__V5*/ meltfptr[3] = 0;
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("INSTALL_VALUE_DESCRIPTOR", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*noretval */ NULL);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_25_warmelt_base_INSTALL_VALUE_DESCRIPTOR */





melt_ptr_t MELT_MODULE_VISIBILITY
meltrout_26_warmelt_base_RETRIEVE_VALUE_DESCRIPTOR_LIST (meltclosure_ptr_t
							 closp_,
							 melt_ptr_t
							 firstargp_,
							 const
							 melt_argdescr_cell_t
							 xargdescr_[],
							 union meltparam_un *
							 xargtab_,
							 const
							 melt_argdescr_cell_t
							 xresdescr_[],
							 union meltparam_un *
							 xrestab_)
{
#if MELT_HAVE_DEBUG
  static long call_counter__;
  long thiscallcounter__ ATTRIBUTE_UNUSED = ++call_counter__;
#undef meltcallcount
#define meltcallcount thiscallcounter__
#else
#undef meltcallcount
#define meltcallcount 0L
#endif

  struct frame_meltrout_26_warmelt_base_RETRIEVE_VALUE_DESCRIPTOR_LIST_st
  {
    int mcfr_nbvar;
#if MELT_HAVE_DEBUG
    const char *mcfr_flocs;
#else				/*!MELT_HAVE_DEBUG */
    const char *mcfr_unusedflocs;
#endif				/*MELT_HAVE_DEBUG */
    struct meltclosure_st *mcfr_clos;
    struct excepth_melt_st *mcfr_exh;
    struct melt_callframe_st *mcfr_prev;
#define MELTFRAM_NBVARPTR 2
    void *mcfr_varptr[2];
/*no varnum*/
#define MELTFRAM_NBVARNUM /*none*/0
/*others*/
    long _spare_;
  }
   *framptr_ = 0, meltfram__;
#define meltframe meltfram__
  if (MELT_UNLIKELY (xargdescr_ == MELTPAR_MARKGGC))
    {				/*mark for ggc */
      int ix = 0;
      framptr_ = (void *) firstargp_;
      gt_ggc_mx_melt_un (framptr_->mcfr_clos);
      for (ix = 0; ix < 2; ix++)
	if (framptr_->mcfr_varptr[ix])
	  gt_ggc_mx_melt_un (framptr_->mcfr_varptr[ix]);
      return NULL;
    } /*end markggc */ ;
  memset (&meltfram__, 0, sizeof (meltfram__));
  meltfram__.mcfr_nbvar = 2;
  meltfram__.mcfr_clos = closp_;
  meltfram__.mcfr_prev = (struct melt_callframe_st *) melt_topframe;
  melt_topframe = (struct melt_callframe_st *) &meltfram__;
  melt_trace_start ("RETRIEVE_VALUE_DESCRIPTOR_LIST", meltcallcount);
/*getargs*/
  ;
  goto lab_endgetargs;
lab_endgetargs:;
/*body*/
  MELT_LOCATION ("warmelt-base.melt:1594:/ block");
/*anyblock*/
  {

    MELT_LOCATION ("warmelt-base.melt:1595:/ cond");
    /*cond */ if ( /*ifisa */ melt_is_instance_of ((melt_ptr_t) (( /*!VALUE_DESCRIPTOR_LIST_CONTAINER */ meltfrout->tabval[0])), (melt_ptr_t) (( /*!CLASS_CONTAINER */ meltfrout->tabval[1]))))	/*then */
      {
	/*^cond.then */
	/*^getslot */
	{
	  melt_ptr_t slot = 0;
	  melt_object_get_field (slot, (melt_ptr_t) (( /*!VALUE_DESCRIPTOR_LIST_CONTAINER */ meltfrout->tabval[0])), 0, "CONTAINER_VALUE");
															       /*_.CONTAINER_VALUE__V2*/
	  meltfptr[1] = slot;
	};
	;
      }
    else
      {				/*^cond.else */

  /*_.CONTAINER_VALUE__V2*/ meltfptr[1] = NULL;;
      }
    ;
    MELT_LOCATION ("warmelt-base.melt:1594:/ quasiblock");


    /*_.RETVAL___V1*/ meltfptr[0] = /*_.CONTAINER_VALUE__V2*/ meltfptr[1];;
    MELT_LOCATION ("warmelt-base.melt:1594:/ finalreturn");
    ;
    /*finalret */ goto labend_rout;
    /*epilog */

    /*^clear */
	   /*clear *//*_.CONTAINER_VALUE__V2*/ meltfptr[1] = 0;
  }

  ;
  goto labend_rout;
labend_rout:
  melt_trace_end ("RETRIEVE_VALUE_DESCRIPTOR_LIST", meltcallcount);
  melt_topframe = (struct melt_callframe_st *) meltfram__.mcfr_prev;
  return (melt_ptr_t) ( /*_.RETVAL___V1*/ meltfptr[0]);
#undef meltcallcount
#undef meltfram__
#undef MELTFRAM_NBVARNUM
#undef MELTFRAM_NBVARPTR
}				/*end meltrout_26_warmelt_base_RETRIEVE_VALUE_DESCRIPTOR_LIST */



/**** end of warmelt-base+01.c ****/
