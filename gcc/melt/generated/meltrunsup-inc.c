/** Copyright (C) 2013 Free Software Foundation, Inc.
  This generated file meltrunsup-inc.c is part of GCC.

                  [DON'T EDIT THIS GENERATED FILE]

    GCC is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.

    GCC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.
**/




/* start of code generated by generate_runtypesupport_cod2ctype */
melt_ptr_t
melt_code_to_ctype (int code)
{
  switch (code)
    {

      /* #1: CTYPE_BASIC_BLOCK */
    case MELTBPAR_BB:
      return MELT_PREDEF (CTYPE_BASIC_BLOCK);
      /* #2: CTYPE_BITMAP */
    case MELTBPAR_BITMAP:
      return MELT_PREDEF (CTYPE_BITMAP);
      /* #3: CTYPE_CSTRING */
    case MELTBPAR_CSTRING:
      return MELT_PREDEF (CTYPE_CSTRING);
      /* #4: CTYPE_EDGE */
    case MELTBPAR_EDGE:
      return MELT_PREDEF (CTYPE_EDGE);
      /* #5: CTYPE_GIMPLE */
    case MELTBPAR_GIMPLE:
      return MELT_PREDEF (CTYPE_GIMPLE);
      /* #6: CTYPE_GIMPLE_SEQ */
    case MELTBPAR_GIMPLESEQ:
      return MELT_PREDEF (CTYPE_GIMPLE_SEQ);
      /* #7: CTYPE_LONG */
    case MELTBPAR_LONG:
      return MELT_PREDEF (CTYPE_LONG);
      /* #8: CTYPE_LOOP */
    case MELTBPAR_LOOP:
      return MELT_PREDEF (CTYPE_LOOP);
      /* #9: CTYPE_RTVEC */
    case MELTBPAR_RTVEC:
      return MELT_PREDEF (CTYPE_RTVEC);
      /* #10: CTYPE_RTX */
    case MELTBPAR_RTX:
      return MELT_PREDEF (CTYPE_RTX);
      /* #11: CTYPE_TREE */
    case MELTBPAR_TREE:
      return MELT_PREDEF (CTYPE_TREE);
      /* #12: CTYPE_VALUE */
    case MELTBPAR_PTR:
      return MELT_PREDEF (CTYPE_VALUE);
      /* #13: CTYPE_VOID */

    default:
      break;
    }				/*end switch code */
  return NULL;
}				/* end of generated melt_code_to_ctype */



/** start of code generated by generate_runtypesupport_mag2str **/
const char *
melt_obmag_string (int i)
{
#define MELT_MAG2STR_CACHEBUF 17
#define MELT_MAG2STR_MAGLEN   16
  static char melt_cacheobmagbuf[MELT_MAG2STR_CACHEBUF][MELT_MAG2STR_MAGLEN];
  switch (i)
    {
    case 0:
      return "MeltObMag!0";
      /*gtyctype #1 CTYPE_BASIC_BLOCK */
    case MELTOBMAG_BASICBLOCK:
      return "MELTOBMAG_BASICBLOCK";
    case MELTOBMAG_MAPBASICBLOCKS:
      return "MELTOBMAG_MAPBASICBLOCKS";

      /*gtyctype #2 CTYPE_BITMAP */
    case MELTOBMAG_BITMAP:
      return "MELTOBMAG_BITMAP";
    case MELTOBMAG_MAPBITMAPS:
      return "MELTOBMAG_MAPBITMAPS";

      /*gtyctype #3 CTYPE_CSTRING */
      /*runtypesupport_mag2str no boxed magic */
      /*runtypesupport_mag2str no map magic */

      /*gtyctype #4 CTYPE_EDGE */
    case MELTOBMAG_EDGE:
      return "MELTOBMAG_EDGE";
    case MELTOBMAG_MAPEDGES:
      return "MELTOBMAG_MAPEDGES";

      /*gtyctype #5 CTYPE_GIMPLE */
    case MELTOBMAG_GIMPLE:
      return "MELTOBMAG_GIMPLE";
    case MELTOBMAG_MAPGIMPLES:
      return "MELTOBMAG_MAPGIMPLES";

      /*gtyctype #6 CTYPE_GIMPLE_SEQ */
    case MELTOBMAG_GIMPLESEQ:
      return "MELTOBMAG_GIMPLESEQ";
    case MELTOBMAG_MAPGIMPLESEQS:
      return "MELTOBMAG_MAPGIMPLESEQS";

      /*gtyctype #7 CTYPE_LONG */
      /*runtypesupport_mag2str no boxed magic */
      /*runtypesupport_mag2str no map magic */

      /*gtyctype #8 CTYPE_LOOP */
    case MELTOBMAG_LOOP:
      return "MELTOBMAG_LOOP";
    case MELTOBMAG_MAPLOOPS:
      return "MELTOBMAG_MAPLOOPS";

      /*gtyctype #9 CTYPE_RTVEC */
    case MELTOBMAG_RTVEC:
      return "MELTOBMAG_RTVEC";
    case MELTOBMAG_MAPRTVECS:
      return "MELTOBMAG_MAPRTVECS";

      /*gtyctype #10 CTYPE_RTX */
    case MELTOBMAG_RTX:
      return "MELTOBMAG_RTX";
    case MELTOBMAG_MAPRTXS:
      return "MELTOBMAG_MAPRTXS";

      /*gtyctype #11 CTYPE_TREE */
    case MELTOBMAG_TREE:
      return "MELTOBMAG_TREE";
    case MELTOBMAG_MAPTREES:
      return "MELTOBMAG_MAPTREES";

      /*gtyctype #12 CTYPE_VALUE */
      /*runtypesupport_mag2str no boxed magic */
      /*runtypesupport_mag2str no map magic */

      /*gtyctype #13 CTYPE_VOID */
      /*runtypesupport_mag2str no boxed magic */
      /*runtypesupport_mag2str no map magic */


      /*valdesc #1 VALDESC_BUCKETLONGS */
    case MELTOBMAG_BUCKETLONGS:
      return "MELTOBMAG_BUCKETLONGS";

      /*valdesc #2 VALDESC_CLOSURE */
    case MELTOBMAG_CLOSURE:
      return "MELTOBMAG_CLOSURE";

      /*valdesc #3 VALDESC_DECAY */
    case MELTOBMAG_DECAY:
      return "MELTOBMAG_DECAY";

      /*valdesc #4 VALDESC_HOOK */
    case MELTOBMAG_HOOK:
      return "MELTOBMAG_HOOK";

      /*valdesc #5 VALDESC_INT */
    case MELTOBMAG_INT:
      return "MELTOBMAG_INT";

      /*valdesc #6 VALDESC_LIST */
    case MELTOBMAG_LIST:
      return "MELTOBMAG_LIST";

      /*valdesc #7 VALDESC_MAPOBJECTS */
    case MELTOBMAG_MAPOBJECTS:
      return "MELTOBMAG_MAPOBJECTS";

      /*valdesc #8 VALDESC_MAPSTRINGS */
    case MELTOBMAG_MAPSTRINGS:
      return "MELTOBMAG_MAPSTRINGS";

      /*valdesc #9 VALDESC_MIXBIGINT */
    case MELTOBMAG_MIXBIGINT:
      return "MELTOBMAG_MIXBIGINT";

      /*valdesc #10 VALDESC_MIXINT */
    case MELTOBMAG_MIXINT:
      return "MELTOBMAG_MIXINT";

      /*valdesc #11 VALDESC_MIXLOC */
    case MELTOBMAG_MIXLOC:
      return "MELTOBMAG_MIXLOC";

      /*valdesc #12 VALDESC_MULTIPLE */
    case MELTOBMAG_MULTIPLE:
      return "MELTOBMAG_MULTIPLE";

      /*valdesc #13 VALDESC_OBJECT */
    case MELTOBMAG_OBJECT:
      return "MELTOBMAG_OBJECT";

      /*valdesc #14 VALDESC_PAIR */
    case MELTOBMAG_PAIR:
      return "MELTOBMAG_PAIR";

      /*valdesc #15 VALDESC_REAL */
    case MELTOBMAG_REAL:
      return "MELTOBMAG_REAL";

      /*valdesc #16 VALDESC_ROUTINE */
    case MELTOBMAG_ROUTINE:
      return "MELTOBMAG_ROUTINE";

      /*valdesc #17 VALDESC_SPECIAL_DATA */
    case MELTOBMAG_SPECIAL_DATA:
      return "MELTOBMAG_SPECIAL_DATA";

      /*valdesc #18 VALDESC_STRBUF */
    case MELTOBMAG_STRBUF:
      return "MELTOBMAG_STRBUF";

      /*valdesc #19 VALDESC_STRING */
    case MELTOBMAG_STRING:
      return "MELTOBMAG_STRING";
    default:
      {
	int ix = (i & 0x3ffffff) % MELT_MAG2STR_CACHEBUF;
	snprintf (melt_cacheobmagbuf[ix], MELT_MAG2STR_MAGLEN - 1,
		  "?MeltObjMag?%d", i);
	return melt_cacheobmagbuf[ix];
      }
    }				/* end switch */
}				/* end generated melt_obmag_string */

/** end of code generated by generate_runtypesupport_mag2str **/


/** generated by generate_runtypesupport_forwcopy_fun **/

/* cheney like forwarding generated function */
melt_ptr_t
melt_forwarded_copy (melt_ptr_t p)
{				/* header generated by generate_runtypesupport_forwcopy_fun */
  melt_ptr_t n = 0;
  int mag = 0;
  gcc_assert (melt_is_young (p));
  gcc_assert (p->u_discr && p->u_discr != MELT_FORWARDED_DISCR);
  if (p->u_discr->meltobj_class == MELT_FORWARDED_DISCR)
    mag =
      ((meltobject_ptr_t)
       (((struct meltforward_st *) p->u_discr)->forward))->meltobj_magic;
  else
    mag = p->u_discr->meltobj_magic;
  melt_forward_counter++;
  switch (mag)
    {				/* end of generated header */

      /* value descriptor forward copy for melt_forwarded_copy  */

      /*valdesc #1 VALDESC_BUCKETLONGS */
    case MELTOBMAG_BUCKETLONGS:
      {
	struct meltbucketlongs_st *src = (struct meltbucketlongs_st *) p;
	struct meltbucketlongs_st *dst = NULL;
	/* copy chunk from  VALDESC_BUCKETLONGS  in warmelt-base.melt */
	/* ggc_alloc_meltbucketlongs_st should be gengtype generated for VALDESC_BUCKETLONGS */
	unsigned lnix = src->buckl_lenix;
	unsigned len = melt_primtab[lnix];
	unsigned ucnt = 0;
	unsigned ix = 0;
	gcc_assert (lnix > 0);
	gcc_assert (len > 0);
	dst =			/* Don't need a cleared allocation! */
	  ggc_alloc_meltbucketlongs_st (len *
					sizeof (struct
						melt_bucketlongentry_st) +
					offsetof (struct meltbucketlongs_st,
						  buckl_entab));
	dst->discr = src->discr;
	dst->buckl_lenix = src->buckl_lenix;
	dst->buckl_aux = src->buckl_aux;
	dst->buckl_xnum = src->buckl_xnum;
	ucnt = dst->buckl_ucount = src->buckl_ucount;
	for (ix = 0; ix < ucnt; ix++)
	  dst->buckl_entab[ix] = src->buckl_entab[ix];
	for (ix = ucnt; ix < len; ix++)
	  {
	    dst->buckl_entab[ix].ebl_at = 0L;
	    dst->buckl_entab[ix].ebl_va = NULL;
	  }
	/* end copy chunk VALDESC_BUCKETLONGS */

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #2 VALDESC_CLOSURE */
    case MELTOBMAG_CLOSURE:
      {
	struct meltclosure_st *src = (struct meltclosure_st *) p;
	struct meltclosure_st *dst = NULL;
	/* copy VALDESC_CLOSURE in warmelt-base.melt  */
/* ggc_alloc_meltclosure_st should be gengtype generated for VALDESC_CLOSURE */
#ifndef ggc_alloc_meltclosure_st
#define ggc_alloc_meltclosure_st(SIZE) ((struct meltclosure_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif
	int nbv = (int) src->nbval;
	int ix = 0;
	dst =
	  /* Don't need a cleared allocation!  */
	  ggc_alloc_meltclosure_st
	  (nbv * sizeof (void *) + offsetof (struct meltclosure_st, tabval));
	dst->discr = src->discr;
	dst->rout = src->rout;
	dst->nbval = (unsigned) nbv;
	for (ix = 0; ix < nbv; ix++)
	  dst->tabval[ix] = src->tabval[ix];

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #3 VALDESC_DECAY */
    case MELTOBMAG_DECAY:
      {
	struct meltdecay_st *src = (struct meltdecay_st *) p;
	struct meltdecay_st *dst = NULL;
	/* from VALDESC_DECAY */
/* ggc_alloc_meltdecay_st should be gengtype generated for VALDESC_DECAY */
#ifndef ggc_alloc_meltdecay_st
#define ggc_alloc_meltdecay_st() ((struct meltdecay_st *)(ggc_internal_alloc_stat (sizeof (struct meltdecay_st) MEM_STAT_INFO)))
#endif
	dst = ggc_alloc_meltdecay_st ();
	*dst = *src;

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #4 VALDESC_HOOK */
    case MELTOBMAG_HOOK:
      {
	struct melthook_st *src = (struct melthook_st *) p;
	struct melthook_st *dst = NULL;
	/* from VALDESC_HOOK in warmelt-base.melt */
	/* ggc_alloc_melthook_st should be gengtype generated for VALDESC_HOOK */
#ifndef ggc_alloc_melthook_st
#define ggc_alloc_melthook_st(SIZE) ((struct melthook_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif
	int nbv = (int) src->nbval;
	int ix = 0;
	dst =
	  /* Don't need a cleared allocation!  */
	  ggc_alloc_melthook_st
	  (nbv * sizeof (void *) + offsetof (struct melthook_st, tabval));
	dst->discr = src->discr;
	strncpy (dst->hookname, src->hookname, MELT_HOOKNAME_LEN);
	dst->hookname[MELT_HOOKNAME_LEN - 1] = 0;
	dst->nbval = (unsigned) nbv;
	dst->hookad = src->hookad;
	for (ix = 0; ix < nbv; ix++)
	  dst->tabval[ix] = src->tabval[ix];
	dst->hookdata = src->hookdata;

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #5 VALDESC_INT */
    case MELTOBMAG_INT:
      {
	struct meltint_st *src = (struct meltint_st *) p;
	struct meltint_st *dst = NULL;
	/* from VALDESC_INT */
/* ggc_alloc_meltint_st should be gengtype generated for VALDESC_INT */
#ifndef ggc_alloc_meltint_st
#define ggc_alloc_meltint_st() ((struct meltint_st *)(ggc_internal_alloc_stat (sizeof (struct meltint_st) MEM_STAT_INFO)))
#endif
	dst =
	  /* Don't need a cleared allocation.  */
	  ggc_alloc_meltint_st ();
	*dst = *src;

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #6 VALDESC_LIST */
    case MELTOBMAG_LIST:
      {
	struct meltlist_st *src = (struct meltlist_st *) p;
	struct meltlist_st *dst = NULL;
	/* copy chunk from VALDESC_LIST */
/* ggc_alloc_meltlist_st should be gengtype gengtype for VALDESC_LIST */
#ifndef ggc_alloc_meltlist_st
#define ggc_alloc_meltlist_st() ((struct meltlist_st *)(ggc_internal_alloc_stat (sizeof (struct meltlist_st) MEM_STAT_INFO)))
#endif
	dst =
	  /* Don't need a cleared allocation!  */
	  ggc_alloc_meltlist_st ();
	*dst = *src;
	/* end chunk from VALDESC_LIST */

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #7 VALDESC_MAPOBJECTS */
    case MELTOBMAG_MAPOBJECTS:
      {
	struct meltmapobjects_st *src = (struct meltmapobjects_st *) p;
	struct meltmapobjects_st *dst = NULL;
	/* copy VALDESC_MAPOBJECTS in warmelt-base.melt */
/* ggc_alloc_meltmapobjects_st should be gengtype generated for VALDESC_MAPOBJECTS */
#ifndef ggc_alloc_meltmapobjects_st
#define ggc_alloc_meltmapobjects_st() ((struct meltmapobjects_st *)(ggc_internal_alloc_stat (sizeof (struct meltmapobjects_st) MEM_STAT_INFO)))
#endif
#ifndef ggc_alloc_vec_entryobjectsmelt_st
#define ggc_alloc_vec_entryobjectsmelt_st(N) ((struct entryobjectsmelt_st *) (ggc_internal_vec_alloc_stat (sizeof (struct entryobjectsmelt_st), N MEM_STAT_INFO)))
#endif
#ifndef  ggc_alloc_cleared_vec_entryobjectsmelt_st
#define ggc_alloc_cleared_vec_entryobjectsmelt_st(n) ((struct entryobjectsmelt_st *)(ggc_internal_cleared_vec_alloc_stat (sizeof (struct entryobjectsmelt_st), n MEM_STAT_INFO)))
#endif
	int siz = melt_primtab[src->lenix];
	dst =
	  /* Don't need a cleared allocation.  */
	  ggc_alloc_meltmapobjects_st ();
	dst->discr = src->discr;
	dst->count = src->count;
	dst->lenix = src->lenix;
	dst->meltmap_aux = src->meltmap_aux;
	if (siz > 0 && src->entab)
	  {
	    /* Don't need a cleared allocation.  */
	    dst->entab = ggc_alloc_vec_entryobjectsmelt_st (siz);
	    memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
	  }
	else
	  dst->entab = NULL;

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #8 VALDESC_MAPSTRINGS */
    case MELTOBMAG_MAPSTRINGS:
      {
	struct meltmapstrings_st *src = (struct meltmapstrings_st *) p;
	struct meltmapstrings_st *dst = NULL;
	/* copy VALDESC_MAPSTRINGS in warmelt-base.melt */
/* ggc_alloc_meltmapstrings_st should be gengtype generated for VALDESC_MAPSTRINGS */
#ifndef ggc_alloc_meltmapstrings_st
#define ggc_alloc_meltmapstrings_st() ((struct meltmapstrings_st *)(ggc_internal_alloc_stat (sizeof (struct meltmapstrings_st) MEM_STAT_INFO)))
#endif
#ifndef ggc_alloc_vec_entrystringsmelt_st
#define ggc_alloc_vec_entrystringsmelt_st(n) ((struct entrystringsmelt_st *)(ggc_internal_vec_alloc_stat (sizeof (struct entrystringsmelt_st), n MEM_STAT_INFO)))
#endif
#ifndef ggc_alloc_cleared_vec_entrystringsmelt_st
#define ggc_alloc_cleared_vec_entrystringsmelt_st(n) ((struct entrystringsmelt_st *)(ggc_internal_cleared_vec_alloc_stat (sizeof (struct entrystringsmelt_st), n MEM_STAT_INFO)))
#endif
	int siz = melt_primtab[src->lenix];
	dst =
	  /* Don't need a cleared allocation.  */
	  ggc_alloc_meltmapstrings_st ();
	dst->discr = src->discr;
	dst->count = src->count;
	dst->lenix = src->lenix;
	dst->meltmap_aux = src->meltmap_aux;
	if (siz > 0 && src->entab)
	  {
	    /* Don't need a cleared allocation.  */
	    dst->entab = ggc_alloc_vec_entrystringsmelt_st (siz);
	    memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
	  }
	else
	  dst->entab = NULL;

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #9 VALDESC_MIXBIGINT */
    case MELTOBMAG_MIXBIGINT:
      {
	struct meltmixbigint_st *src = (struct meltmixbigint_st *) p;
	struct meltmixbigint_st *dst = NULL;
	/* from VALDESC_MIXBIGINT */
/* ggc_alloc_meltmixbigint_st should be gengtype generated for VALDESC_MIXBIGINT */
#ifndef ggc_alloc_meltmixbigint_st
#define ggc_alloc_meltmixbigint_st(SIZE) ((struct meltmixbigint_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif
	unsigned blen = src->biglen;
	dst =
	  /* Don't need a cleared allocation.  */
	  ggc_alloc_meltmixbigint_st
	  (blen * sizeof (long) + offsetof (struct meltmixbigint_st, tabig));
	dst->discr = src->discr;
	dst->ptrval = src->ptrval;
	dst->negative = src->negative;
	dst->biglen = blen;
	memcpy (dst->tabig, src->tabig, blen * sizeof (dst->tabig[0]));

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #10 VALDESC_MIXINT */
    case MELTOBMAG_MIXINT:
      {
	struct meltmixint_st *src = (struct meltmixint_st *) p;
	struct meltmixint_st *dst = NULL;
	/* from VALDESC_MIXINT */
/* ggc_alloc_meltmixint_st should be gengtype generated for VALDESC_MIXINT */
#ifndef ggc_alloc_meltmixint_st
#define ggc_alloc_meltmixint_st() ((struct meltmixint_st *)(ggc_internal_alloc_stat (sizeof (struct meltmixint_st) MEM_STAT_INFO)))
#endif
	dst =
	  /* Don't need a cleared allocation.  */
	  ggc_alloc_meltmixint_st ();
	*dst = *src;

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #11 VALDESC_MIXLOC */
    case MELTOBMAG_MIXLOC:
      {
	struct meltmixloc_st *src = (struct meltmixloc_st *) p;
	struct meltmixloc_st *dst = NULL;
	/* from VALDESC_MIXLOC */
/* ggc_alloc_meltmixloc_st should be gengtype generated for VALDESC_MIXLOC */
#ifndef ggc_alloc_meltmixloc_st
#define ggc_alloc_meltmixloc_st() ((struct meltmixloc_st *)(ggc_internal_alloc_stat (sizeof (struct meltmixloc_st) MEM_STAT_INFO)))
#endif
	dst =
	  /* Don't need a cleared allocation.  */
	  ggc_alloc_meltmixloc_st ();
	*dst = *src;

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #12 VALDESC_MULTIPLE */
    case MELTOBMAG_MULTIPLE:
      {
	struct meltmultiple_st *src = (struct meltmultiple_st *) p;
	struct meltmultiple_st *dst = NULL;
	/* copy chunk from VALDESC_MULTIPLE */
	/* ggc_alloc_meltmultiple_st should be gengtype generated for VALDESC_MULTIPLE */
#ifndef ggc_alloc_meltmultiple_st
#define ggc_alloc_meltmultiple_st(SIZE) ((struct meltmultiple_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif
	int nbv = (int) src->nbval;
	int ix = 0;
	dst =
	  /* Don't need a cleared allocation!  */
	  ggc_alloc_meltmultiple_st
	  (nbv * sizeof (void *) + offsetof (struct meltmultiple_st, tabval));
	/* we cannot copy the whole src, because MELT_FLEXIBLE_DIM might be
	   1 and nbval could be 0 */
	dst->discr = src->discr;
	dst->nbval = src->nbval;
	for (ix = 0; ix < nbv; ix++)
	  dst->tabval[ix] = src->tabval[ix];
	/* end copy chunk from VALDESC_MULTIPLE */

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #13 VALDESC_OBJECT */
    case MELTOBMAG_OBJECT:
      {
	struct meltobject_st *src = (struct meltobject_st *) p;
	struct meltobject_st *dst = NULL;
	/* from VALDESC_OBJECT */
	/* ggc_alloc_meltobject_st should be gengtype generated for VALDESC_OBJECT */
#ifndef ggc_alloc_meltobject_st
#define ggc_alloc_meltobject_st(SIZE) ((struct meltobject_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif
	int ix = 0;
	int oblen = (int) (src->obj_len);
	/* We don't need to clear at allocation, since the object is
	   explicitly filled here! */
	dst = ggc_alloc_meltobject_st
	  (oblen * sizeof (void *)
	   + offsetof (struct meltobject_st, obj_vartab));
	/* we cannot copy the whole src, because MELT_FLEXIBLE_DIM might be 1 */
	dst->meltobj_class = src->meltobj_class;
	dst->obj_hash = src->obj_hash;
	dst->obj_num = src->obj_num;
	dst->obj_len = oblen;
	for (ix = 0; ix < oblen; ix++)
	  dst->obj_vartab[ix] = src->obj_vartab[ix];
#if ENABLE_CHECKING
	/* for low level debugging with gdb, we may want to catch some copy operations */
	if (melt_alptr_1 && (void *) src == melt_alptr_1)
	  melt_break_alptr_1 ("copyobj src=alptr1");
	if (melt_alptr_2 && (void *) src == melt_alptr_2)
	  melt_break_alptr_2 ("copyobj src=alptr2");
	if (src->obj_hash == melt_objhash_1)
	  melt_break_objhash_1 ("copyobj src with objhash1");
	if (src->obj_hash == melt_objhash_2)
	  melt_break_objhash_2 ("copyobj src with objhash2");
#endif /* ENABLE_CHECKING */

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #14 VALDESC_PAIR */
    case MELTOBMAG_PAIR:
      {
	struct meltpair_st *src = (struct meltpair_st *) p;
	struct meltpair_st *dst = NULL;
	/* copy VALDESC_PAIR in warmelt-base.melt */
	/* ggc_alloc_meltpair_st should be gengtype gengtype for VALDESC_PAIR */
#ifndef ggc_alloc_meltpair_st
#define ggc_alloc_meltpair_st() ((struct meltpair_st *)(ggc_internal_alloc_stat (sizeof (struct meltpair_st) MEM_STAT_INFO)))
#endif
	dst =			/* Don't need a cleared allocation.  */
	  ggc_alloc_meltpair_st ();
	*dst = *src;

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #15 VALDESC_REAL */
    case MELTOBMAG_REAL:
      {
	struct meltreal_st *src = (struct meltreal_st *) p;
	struct meltreal_st *dst = NULL;
	/* from VALDESC_REAL */
/* ggc_alloc_meltreal_st should be gengtype generated for VALDESC_REAL */
#ifndef ggc_alloc_meltreal_st
#define ggc_alloc_meltreal_st() ((struct meltreal_st *)(ggc_internal_alloc_stat (sizeof (struct meltreal_st) MEM_STAT_INFO)))
#endif
	dst =
	  /* Don't need a cleared allocation.  */
	  ggc_alloc_meltreal_st ();
	*dst = *src;

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #16 VALDESC_ROUTINE */
    case MELTOBMAG_ROUTINE:
      {
	struct meltroutine_st *src = (struct meltroutine_st *) p;
	struct meltroutine_st *dst = NULL;
	/* from VALDESC_ROUTINE */
	/* ggc_alloc_meltroutine_st should be gengtype generated for VALDESC_ROUTINE */
#ifndef ggc_alloc_meltroutine_st
#define ggc_alloc_meltroutine_st(SIZE) ((struct meltroutine_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif
	int nbv = (int) src->nbval;
	int ix = 0;
	dst =
	  /* Don't need a cleared allocation!  */
	  ggc_alloc_meltroutine_st
	  (nbv * sizeof (void *) + offsetof (struct meltroutine_st, tabval));
	dst->discr = src->discr;
	strncpy (dst->routdescr, src->routdescr, MELT_ROUTDESCR_LEN);
	dst->routdescr[MELT_ROUTDESCR_LEN - 1] = 0;
	dst->nbval = (unsigned) nbv;
	dst->routfunad = src->routfunad;
	for (ix = 0; ix < nbv; ix++)
	  dst->tabval[ix] = src->tabval[ix];
	dst->routdata = src->routdata;

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #17 VALDESC_SPECIAL_DATA */
    case MELTOBMAG_SPECIAL_DATA:
      {
	struct meltspecialdata_st *src = (struct meltspecialdata_st *) p;
	struct meltspecialdata_st *dst = NULL;
	/* from VALDESC_SPECIAL_DATA */
/* ggc_alloc_meltspecialdata_st should be gengtype generated for VALDESC_SPECIAL_DATA */
#ifndef ggc_alloc_meltspecialdata_st
#define ggc_alloc_meltspecialdata_st() ((struct meltspecialdata_st *)(ggc_internal_alloc_stat (sizeof (struct meltspecialdata_st) MEM_STAT_INFO)))
#endif
	dst = ggc_alloc_meltspecialdata_st ();
	*dst = *src;
	/* mark the new copy! */
	dst->meltspec_mark = 1;
	/* add the new copy to the old (major) special list */
	dst->meltspec_next = melt_oldspecdatalist;
	melt_oldspecdatalist = dst;

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #18 VALDESC_STRBUF */
    case MELTOBMAG_STRBUF:
      {
	struct meltstrbuf_st *src = (struct meltstrbuf_st *) p;
	struct meltstrbuf_st *dst = NULL;
	/* copy chunk from VALDESC_STRBUF */
/* ggc_alloc_meltstrbuf_st should be gengtype gengtype for VALDESC_STRBUF */
#ifndef ggc_alloc_meltstrbuf_st
#define ggc_alloc_meltstrbuf_st() ((struct meltstrbuf_st *)(ggc_internal_alloc_stat (sizeof (struct meltstrbuf_st) MEM_STAT_INFO)))
#endif
	unsigned blen = melt_primtab[src->buflenix];
	dst =
	  /* Don't need a cleared allocation.  */
	  ggc_alloc_meltstrbuf_st ();
	dst->discr = src->discr;
	dst->bufstart = src->bufstart;
	dst->bufend = src->bufend;
	dst->buflenix = src->buflenix;
	if (blen > 0)
	  {
#if BUILDING_GCC_VERSION > 4005 || GCCPLUGIN_VERSION > 4005 || MELT_GCC_VERSION > 4005
	    dst->bufzn =
	      CONST_CAST (char *, ggc_alloc_string (src->bufzn, blen + 1));
#else /*GCC 4.5 */
	    dst->bufzn = (char *) ggc_alloc_cleared (1 + blen);
	    memcpy (dst->bufzn, src->bufzn, blen);
#endif /*!GCC 4.5 */
	    dst->bufzn[blen] = (char) 0;
	  }
	else
	  dst->bufzn = NULL;
	/* end copy chunk from VALDESC_STRBUF */

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #19 VALDESC_STRING */
    case MELTOBMAG_STRING:
      {
	struct meltstring_st *src = (struct meltstring_st *) p;
	struct meltstring_st *dst = NULL;
	/* copy from VALDESC_STRING file warmelt-base.melt */
/* ggc_alloc_meltstring_st should be gengtype generated for VALDESC_STRING */
#ifndef ggc_alloc_meltstring_st
#define ggc_alloc_meltstring_st(SIZE) ((struct meltstring_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif
	int srclen = (src->val) ? strlen (src->val) : 0;
	dst =
	  /* Don't need a cleared allocation.  */
	ggc_alloc_meltstring_st
	  (offsetof (struct meltstring_st, val) + (srclen + 1));
	dst->discr = src->discr;
	memcpy (dst->val, src->val, srclen);
	dst->val[srclen] = (char) 0;
	dst->slen = (unsigned) srclen;
	/* end copy from VALDESC_STRING */

	n = (melt_ptr_t) dst;
	break;
      }


/* gty ctype forward copy for melt_forwarded_copy */
/*forwcopy gtyctype #1 CTYPE_BASIC_BLOCK*/
    case MELTOBMAG_BASICBLOCK:
      {
	/* macro ggc_alloc_meltbasicblock_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltbasicblock_st
#define ggc_alloc_meltbasicblock_st() ((struct meltbasicblock_st*)(ggc_internal_alloc_stat (sizeof (struct meltbasicblock_st) MEM_STAT_INFO)))
#endif
	struct meltbasicblock_st *src = (struct meltbasicblock_st *) p;
	struct meltbasicblock_st *dst = ggc_alloc_meltbasicblock_st ();
	*dst = *src;
	n = (melt_ptr_t) dst;
	break;
      }
    case MELTOBMAG_MAPBASICBLOCKS:
      {
/* ggc_alloc_meltmapbasicblocks_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltmapbasicblocks_st
#define ggc_alloc_meltmapbasicblocks_st() ((struct meltmapbasicblocks_st*) (ggc_internal_alloc_stat (sizeof (struct meltmapbasicblocks_st) MEM_STAT_INFO)))
#endif
/* ggc_alloc_vec_entrybasicblockmelt_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_vec_entrybasicblockmelt_st
#define ggc_alloc_vec_entrybasicblockmelt_st(n) ((struct entrybasicblockmelt_st*) (ggc_internal_vec_alloc_stat (sizeof (struct entrybasicblockmelt_st), n MEM_STAT_INFO)))
#endif
	struct meltmapbasicblocks_st *src =
	  (struct meltmapbasicblocks_st *) p;
	int siz = melt_primtab[src->lenix];
	struct meltmapbasicblocks_st *dst =
	  ggc_alloc_meltmapbasicblocks_st ();
	dst->discr = src->discr;
	dst->count = src->count;
	dst->lenix = src->lenix;
	dst->meltmap_aux = src->meltmap_aux;
	if (siz > 0 && src->entab)
	  {
	    dst->entab = ggc_alloc_vec_entrybasicblockmelt_st (siz);
	    memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
	  }
	else
	  dst->entab = NULL;
	n = (melt_ptr_t) dst;
	break;
      }
      /*forwcopy gtyctype #2 CTYPE_BITMAP */
    case MELTOBMAG_BITMAP:
      {
	/* macro ggc_alloc_meltbitmap_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltbitmap_st
#define ggc_alloc_meltbitmap_st() ((struct meltbitmap_st*)(ggc_internal_alloc_stat (sizeof (struct meltbitmap_st) MEM_STAT_INFO)))
#endif
	struct meltbitmap_st *src = (struct meltbitmap_st *) p;
	struct meltbitmap_st *dst = ggc_alloc_meltbitmap_st ();
	*dst = *src;
	n = (melt_ptr_t) dst;
	break;
      }
    case MELTOBMAG_MAPBITMAPS:
      {
/* ggc_alloc_meltmapbitmaps_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltmapbitmaps_st
#define ggc_alloc_meltmapbitmaps_st() ((struct meltmapbitmaps_st*) (ggc_internal_alloc_stat (sizeof (struct meltmapbitmaps_st) MEM_STAT_INFO)))
#endif
/* ggc_alloc_vec_entrybitmapmelt_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_vec_entrybitmapmelt_st
#define ggc_alloc_vec_entrybitmapmelt_st(n) ((struct entrybitmapmelt_st*) (ggc_internal_vec_alloc_stat (sizeof (struct entrybitmapmelt_st), n MEM_STAT_INFO)))
#endif
	struct meltmapbitmaps_st *src = (struct meltmapbitmaps_st *) p;
	int siz = melt_primtab[src->lenix];
	struct meltmapbitmaps_st *dst = ggc_alloc_meltmapbitmaps_st ();
	dst->discr = src->discr;
	dst->count = src->count;
	dst->lenix = src->lenix;
	dst->meltmap_aux = src->meltmap_aux;
	if (siz > 0 && src->entab)
	  {
	    dst->entab = ggc_alloc_vec_entrybitmapmelt_st (siz);
	    memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
	  }
	else
	  dst->entab = NULL;
	n = (melt_ptr_t) dst;
	break;
      }
      /*forwcopy gtyctype #3 CTYPE_EDGE */
    case MELTOBMAG_EDGE:
      {
	/* macro ggc_alloc_meltedge_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltedge_st
#define ggc_alloc_meltedge_st() ((struct meltedge_st*)(ggc_internal_alloc_stat (sizeof (struct meltedge_st) MEM_STAT_INFO)))
#endif
	struct meltedge_st *src = (struct meltedge_st *) p;
	struct meltedge_st *dst = ggc_alloc_meltedge_st ();
	*dst = *src;
	n = (melt_ptr_t) dst;
	break;
      }
    case MELTOBMAG_MAPEDGES:
      {
/* ggc_alloc_meltmapedges_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltmapedges_st
#define ggc_alloc_meltmapedges_st() ((struct meltmapedges_st*) (ggc_internal_alloc_stat (sizeof (struct meltmapedges_st) MEM_STAT_INFO)))
#endif
/* ggc_alloc_vec_entryedgemelt_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_vec_entryedgemelt_st
#define ggc_alloc_vec_entryedgemelt_st(n) ((struct entryedgemelt_st*) (ggc_internal_vec_alloc_stat (sizeof (struct entryedgemelt_st), n MEM_STAT_INFO)))
#endif
	struct meltmapedges_st *src = (struct meltmapedges_st *) p;
	int siz = melt_primtab[src->lenix];
	struct meltmapedges_st *dst = ggc_alloc_meltmapedges_st ();
	dst->discr = src->discr;
	dst->count = src->count;
	dst->lenix = src->lenix;
	dst->meltmap_aux = src->meltmap_aux;
	if (siz > 0 && src->entab)
	  {
	    dst->entab = ggc_alloc_vec_entryedgemelt_st (siz);
	    memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
	  }
	else
	  dst->entab = NULL;
	n = (melt_ptr_t) dst;
	break;
      }
      /*forwcopy gtyctype #4 CTYPE_GIMPLE */
    case MELTOBMAG_GIMPLE:
      {
	/* macro ggc_alloc_meltgimple_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltgimple_st
#define ggc_alloc_meltgimple_st() ((struct meltgimple_st*)(ggc_internal_alloc_stat (sizeof (struct meltgimple_st) MEM_STAT_INFO)))
#endif
	struct meltgimple_st *src = (struct meltgimple_st *) p;
	struct meltgimple_st *dst = ggc_alloc_meltgimple_st ();
	*dst = *src;
	n = (melt_ptr_t) dst;
	break;
      }
    case MELTOBMAG_MAPGIMPLES:
      {
/* ggc_alloc_meltmapgimples_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltmapgimples_st
#define ggc_alloc_meltmapgimples_st() ((struct meltmapgimples_st*) (ggc_internal_alloc_stat (sizeof (struct meltmapgimples_st) MEM_STAT_INFO)))
#endif
/* ggc_alloc_vec_entrygimplemelt_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_vec_entrygimplemelt_st
#define ggc_alloc_vec_entrygimplemelt_st(n) ((struct entrygimplemelt_st*) (ggc_internal_vec_alloc_stat (sizeof (struct entrygimplemelt_st), n MEM_STAT_INFO)))
#endif
	struct meltmapgimples_st *src = (struct meltmapgimples_st *) p;
	int siz = melt_primtab[src->lenix];
	struct meltmapgimples_st *dst = ggc_alloc_meltmapgimples_st ();
	dst->discr = src->discr;
	dst->count = src->count;
	dst->lenix = src->lenix;
	dst->meltmap_aux = src->meltmap_aux;
	if (siz > 0 && src->entab)
	  {
	    dst->entab = ggc_alloc_vec_entrygimplemelt_st (siz);
	    memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
	  }
	else
	  dst->entab = NULL;
	n = (melt_ptr_t) dst;
	break;
      }
      /*forwcopy gtyctype #5 CTYPE_GIMPLE_SEQ */
    case MELTOBMAG_GIMPLESEQ:
      {
	/* macro ggc_alloc_meltgimpleseq_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltgimpleseq_st
#define ggc_alloc_meltgimpleseq_st() ((struct meltgimpleseq_st*)(ggc_internal_alloc_stat (sizeof (struct meltgimpleseq_st) MEM_STAT_INFO)))
#endif
	struct meltgimpleseq_st *src = (struct meltgimpleseq_st *) p;
	struct meltgimpleseq_st *dst = ggc_alloc_meltgimpleseq_st ();
	*dst = *src;
	n = (melt_ptr_t) dst;
	break;
      }
    case MELTOBMAG_MAPGIMPLESEQS:
      {
/* ggc_alloc_meltmapgimpleseqs_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltmapgimpleseqs_st
#define ggc_alloc_meltmapgimpleseqs_st() ((struct meltmapgimpleseqs_st*) (ggc_internal_alloc_stat (sizeof (struct meltmapgimpleseqs_st) MEM_STAT_INFO)))
#endif
/* ggc_alloc_vec_entrygimpleseqmelt_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_vec_entrygimpleseqmelt_st
#define ggc_alloc_vec_entrygimpleseqmelt_st(n) ((struct entrygimpleseqmelt_st*) (ggc_internal_vec_alloc_stat (sizeof (struct entrygimpleseqmelt_st), n MEM_STAT_INFO)))
#endif
	struct meltmapgimpleseqs_st *src = (struct meltmapgimpleseqs_st *) p;
	int siz = melt_primtab[src->lenix];
	struct meltmapgimpleseqs_st *dst = ggc_alloc_meltmapgimpleseqs_st ();
	dst->discr = src->discr;
	dst->count = src->count;
	dst->lenix = src->lenix;
	dst->meltmap_aux = src->meltmap_aux;
	if (siz > 0 && src->entab)
	  {
	    dst->entab = ggc_alloc_vec_entrygimpleseqmelt_st (siz);
	    memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
	  }
	else
	  dst->entab = NULL;
	n = (melt_ptr_t) dst;
	break;
      }
      /*forwcopy gtyctype #6 CTYPE_LOOP */
    case MELTOBMAG_LOOP:
      {
	/* macro ggc_alloc_meltloop_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltloop_st
#define ggc_alloc_meltloop_st() ((struct meltloop_st*)(ggc_internal_alloc_stat (sizeof (struct meltloop_st) MEM_STAT_INFO)))
#endif
	struct meltloop_st *src = (struct meltloop_st *) p;
	struct meltloop_st *dst = ggc_alloc_meltloop_st ();
	*dst = *src;
	n = (melt_ptr_t) dst;
	break;
      }
    case MELTOBMAG_MAPLOOPS:
      {
/* ggc_alloc_meltmaploops_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltmaploops_st
#define ggc_alloc_meltmaploops_st() ((struct meltmaploops_st*) (ggc_internal_alloc_stat (sizeof (struct meltmaploops_st) MEM_STAT_INFO)))
#endif
/* ggc_alloc_vec_entryloopmelt_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_vec_entryloopmelt_st
#define ggc_alloc_vec_entryloopmelt_st(n) ((struct entryloopmelt_st*) (ggc_internal_vec_alloc_stat (sizeof (struct entryloopmelt_st), n MEM_STAT_INFO)))
#endif
	struct meltmaploops_st *src = (struct meltmaploops_st *) p;
	int siz = melt_primtab[src->lenix];
	struct meltmaploops_st *dst = ggc_alloc_meltmaploops_st ();
	dst->discr = src->discr;
	dst->count = src->count;
	dst->lenix = src->lenix;
	dst->meltmap_aux = src->meltmap_aux;
	if (siz > 0 && src->entab)
	  {
	    dst->entab = ggc_alloc_vec_entryloopmelt_st (siz);
	    memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
	  }
	else
	  dst->entab = NULL;
	n = (melt_ptr_t) dst;
	break;
      }
      /*forwcopy gtyctype #7 CTYPE_RTVEC */
    case MELTOBMAG_RTVEC:
      {
	/* macro ggc_alloc_meltrtvec_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltrtvec_st
#define ggc_alloc_meltrtvec_st() ((struct meltrtvec_st*)(ggc_internal_alloc_stat (sizeof (struct meltrtvec_st) MEM_STAT_INFO)))
#endif
	struct meltrtvec_st *src = (struct meltrtvec_st *) p;
	struct meltrtvec_st *dst = ggc_alloc_meltrtvec_st ();
	*dst = *src;
	n = (melt_ptr_t) dst;
	break;
      }
    case MELTOBMAG_MAPRTVECS:
      {
/* ggc_alloc_meltmaprtvecs_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltmaprtvecs_st
#define ggc_alloc_meltmaprtvecs_st() ((struct meltmaprtvecs_st*) (ggc_internal_alloc_stat (sizeof (struct meltmaprtvecs_st) MEM_STAT_INFO)))
#endif
/* ggc_alloc_vec_entryrtvecmelt_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_vec_entryrtvecmelt_st
#define ggc_alloc_vec_entryrtvecmelt_st(n) ((struct entryrtvecmelt_st*) (ggc_internal_vec_alloc_stat (sizeof (struct entryrtvecmelt_st), n MEM_STAT_INFO)))
#endif
	struct meltmaprtvecs_st *src = (struct meltmaprtvecs_st *) p;
	int siz = melt_primtab[src->lenix];
	struct meltmaprtvecs_st *dst = ggc_alloc_meltmaprtvecs_st ();
	dst->discr = src->discr;
	dst->count = src->count;
	dst->lenix = src->lenix;
	dst->meltmap_aux = src->meltmap_aux;
	if (siz > 0 && src->entab)
	  {
	    dst->entab = ggc_alloc_vec_entryrtvecmelt_st (siz);
	    memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
	  }
	else
	  dst->entab = NULL;
	n = (melt_ptr_t) dst;
	break;
      }
      /*forwcopy gtyctype #8 CTYPE_RTX */
    case MELTOBMAG_RTX:
      {
	/* macro ggc_alloc_meltrtx_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltrtx_st
#define ggc_alloc_meltrtx_st() ((struct meltrtx_st*)(ggc_internal_alloc_stat (sizeof (struct meltrtx_st) MEM_STAT_INFO)))
#endif
	struct meltrtx_st *src = (struct meltrtx_st *) p;
	struct meltrtx_st *dst = ggc_alloc_meltrtx_st ();
	*dst = *src;
	n = (melt_ptr_t) dst;
	break;
      }
    case MELTOBMAG_MAPRTXS:
      {
/* ggc_alloc_meltmaprtxs_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltmaprtxs_st
#define ggc_alloc_meltmaprtxs_st() ((struct meltmaprtxs_st*) (ggc_internal_alloc_stat (sizeof (struct meltmaprtxs_st) MEM_STAT_INFO)))
#endif
/* ggc_alloc_vec_entryrtxmelt_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_vec_entryrtxmelt_st
#define ggc_alloc_vec_entryrtxmelt_st(n) ((struct entryrtxmelt_st*) (ggc_internal_vec_alloc_stat (sizeof (struct entryrtxmelt_st), n MEM_STAT_INFO)))
#endif
	struct meltmaprtxs_st *src = (struct meltmaprtxs_st *) p;
	int siz = melt_primtab[src->lenix];
	struct meltmaprtxs_st *dst = ggc_alloc_meltmaprtxs_st ();
	dst->discr = src->discr;
	dst->count = src->count;
	dst->lenix = src->lenix;
	dst->meltmap_aux = src->meltmap_aux;
	if (siz > 0 && src->entab)
	  {
	    dst->entab = ggc_alloc_vec_entryrtxmelt_st (siz);
	    memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
	  }
	else
	  dst->entab = NULL;
	n = (melt_ptr_t) dst;
	break;
      }
      /*forwcopy gtyctype #9 CTYPE_TREE */
    case MELTOBMAG_TREE:
      {
	/* macro ggc_alloc_melttree_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_melttree_st
#define ggc_alloc_melttree_st() ((struct melttree_st*)(ggc_internal_alloc_stat (sizeof (struct melttree_st) MEM_STAT_INFO)))
#endif
	struct melttree_st *src = (struct melttree_st *) p;
	struct melttree_st *dst = ggc_alloc_melttree_st ();
	*dst = *src;
	n = (melt_ptr_t) dst;
	break;
      }
    case MELTOBMAG_MAPTREES:
      {
/* ggc_alloc_meltmaptrees_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltmaptrees_st
#define ggc_alloc_meltmaptrees_st() ((struct meltmaptrees_st*) (ggc_internal_alloc_stat (sizeof (struct meltmaptrees_st) MEM_STAT_INFO)))
#endif
/* ggc_alloc_vec_entrytreemelt_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_vec_entrytreemelt_st
#define ggc_alloc_vec_entrytreemelt_st(n) ((struct entrytreemelt_st*) (ggc_internal_vec_alloc_stat (sizeof (struct entrytreemelt_st), n MEM_STAT_INFO)))
#endif
	struct meltmaptrees_st *src = (struct meltmaptrees_st *) p;
	int siz = melt_primtab[src->lenix];
	struct meltmaptrees_st *dst = ggc_alloc_meltmaptrees_st ();
	dst->discr = src->discr;
	dst->count = src->count;
	dst->lenix = src->lenix;
	dst->meltmap_aux = src->meltmap_aux;
	if (siz > 0 && src->entab)
	  {
	    dst->entab = ggc_alloc_vec_entrytreemelt_st (siz);
	    memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
	  }
	else
	  dst->entab = NULL;
	n = (melt_ptr_t) dst;
	break;
      }
      /* trailer generated by generate_runtypesupport_forwcopy_fun  */
    default:
      fatal_error ("corruption: forward invalid p=%p discr=%p magic=%d",
		   (void *) p, (void *) p->u_discr, mag);
    }				/* end switch (mag) */

  melt_debuggc_eprintf ("melt_forwarded_copy#%ld/%04ld %p => %p %s",
			melt_nb_garbcoll, melt_forward_counter, (void *) p,
			(void *) n, melt_obmag_string (mag));
  if (n)
    {
#if ENABLE_CHECKING
      if (melt_alptr_1 && (void *) melt_alptr_1 == (void *) n)
	{
	  fprintf (stderr, "melt_forwarded_copy to alptr_1 %p mag %d\n",
		   melt_alptr_1, mag);
	  fflush (stderr);
	  melt_debuggc_eprintf ("melt_forwarded_copy #%ld alptr_1 %p mag %d",
				melt_nb_garbcoll, melt_alptr_1, mag);
	  melt_break_alptr_1 ("forwarded copy to alptr_1");
	}
      if (melt_alptr_2 && (void *) melt_alptr_2 == (void *) n)
	{
	  fprintf (stderr, "melt_forwarded_copy to alptr_2 %p mag %d\n",
		   melt_alptr_2, mag);
	  fflush (stderr);
	  melt_debuggc_eprintf ("melt_forwarded_copy #%ld alptr_2 %p",
				melt_nb_garbcoll, melt_alptr_2);
	  melt_break_alptr_2 ("forwarded copy to alptr_2");
	};
#endif /*ENABLE_CHECKING */

      p->u_forward.discr = MELT_FORWARDED_DISCR;
      p->u_forward.forward = n;

      gcc_assert (melt_scangcvect != NULL);
      {
	unsigned long ulen = melt_scangcvect->vv_ulen;
	if (MELT_UNLIKELY (ulen + 3 < melt_scangcvect->vv_size))
	  {
	    unsigned long newsiz = (ulen + ulen / 4 + 100);
	    melt_resize_scangcvect (newsiz);
	  }
	melt_scangcvect->vv_tab[ulen] = n;
	melt_scangcvect->vv_ulen = ulen + 1;
      }

    }
  return n;
}				/* end of melt_forwarded_copy generated by generate_runtypesupport_forwcopy_fun */

/** end of code generated by generate_runtypesupport_forwcopy_fun **/



/** start of code generated by generate_runtypesupport_scanning **/
 /* header from generate_runtypesupport_scanning */
/* The melt_scanning routine is mostly Chesney like ; however some types,
   including objects, strbuf, stringmaps, objectmaps, all the other
   *maps, contain a pointer to a non value ; this pointer should be
   carefully updated if it was young. */
static void
melt_scanning (melt_ptr_t p)
{
  unsigned omagic = 0;
  if (!p)
    return;
  gcc_assert (p != (void *) HTAB_DELETED_ENTRY);
  gcc_assert (p->u_discr && p->u_discr != (meltobject_ptr_t) 1);
  MELT_FORWARDED (p->u_discr);
  gcc_assert (!melt_is_young (p));
  omagic = p->u_discr->meltobj_magic;
  switch (omagic)
    {
/* end of header from generate_runtypesupport_scanning*/

      /*valdesc #1 VALDESC_BUCKETLONGS */
    case MELTOBMAG_BUCKETLONGS:
      {
	struct meltbucketlongs_st *src = (struct meltbucketlongs_st *) p;
	/* forwarding chunk from VALDESC_BUCKETLONGS in warmelt-base.melt */
	unsigned lnix = src->buckl_lenix;
	unsigned len = melt_primtab[lnix];
	unsigned ucnt = src->buckl_ucount;
	unsigned ix = 0;
	gcc_assert (lnix > 0);
	gcc_assert (len > 0);
	MELT_FORWARDED (src->buckl_aux);
	gcc_assert (ucnt <= len);
	for (ix = 0; ix < ucnt; ix++)
	  MELT_FORWARDED (src->buckl_entab[ix].ebl_va);
	/* end forwarding VALDESC_BUCKETLONGS */

	break;
      }

      /*valdesc #2 VALDESC_CLOSURE */
    case MELTOBMAG_CLOSURE:
      {
	struct meltclosure_st *src = (struct meltclosure_st *) p;
	/* forwarding from VALDESC_CLOSURE */
	int nbval = (int) src->nbval;
	int ix = 0;
	MELT_FORWARDED (src->rout);
	for (ix = 0; ix < nbval; ix++)
	  MELT_FORWARDED (src->tabval[ix]);

	break;
      }

      /*valdesc #3 VALDESC_DECAY */
    case MELTOBMAG_DECAY:
      {
	struct meltdecay_st *src = (struct meltdecay_st *) p;
	/* from VALDESC_DECAY */
	MELT_FORWARDED (src->val);

	break;
      }

      /*valdesc #4 VALDESC_HOOK */
    case MELTOBMAG_HOOK:
      {
	struct melthook_st *src = (struct melthook_st *) p;
	/* from VALDESC_HOOK in warmelt-base.melt */
	int nbval = (int) src->nbval;
	int ix = 0;
	for (ix = 0; ix < nbval; ix++)
	  MELT_FORWARDED (src->tabval[ix]);
	MELT_FORWARDED (src->hookdata);

	break;
      }

      /*valdesc #5 VALDESC_INT */
    case MELTOBMAG_INT:
      {
	break;
      }

      /*valdesc #6 VALDESC_LIST */
    case MELTOBMAG_LIST:
      {
	struct meltlist_st *src = (struct meltlist_st *) p;
	/* from VALDESC_LIST */
	MELT_FORWARDED (src->first);
	MELT_FORWARDED (src->last);

	break;
      }

      /*valdesc #7 VALDESC_MAPOBJECTS */
    case MELTOBMAG_MAPOBJECTS:
      {
	struct meltmapobjects_st *src = (struct meltmapobjects_st *) p;
	/* forwarding from VALDESC_MAPOBJECTS */
	int siz, ix;
	MELT_FORWARDED (src->meltmap_aux);
	if (!src->entab)
	  break;
	siz = melt_primtab[src->lenix];
	gcc_assert (siz > 0);
	if (melt_is_young (src->entab))
	  {
	    struct entryobjectsmelt_st *newtab =
	      /* Don't need a cleared allocation!  */
	      ggc_alloc_vec_entryobjectsmelt_st (siz);
	    memcpy (newtab, src->entab,
		    siz * sizeof (struct entryobjectsmelt_st));
	    src->entab = newtab;
	  }
	for (ix = 0; ix < siz; ix++)
	  {
	    meltobject_ptr_t at = src->entab[ix].e_at;
	    if (!at || at == (void *) HTAB_DELETED_ENTRY)
	      {
		src->entab[ix].e_va = NULL;
		continue;
	      }
	    MELT_FORWARDED (at);
	    src->entab[ix].e_at = at;
	    MELT_FORWARDED (src->entab[ix].e_va);
	  }
	/* end forwarding from VALDESC_MAPOBJECTS */

	break;
      }

      /*valdesc #8 VALDESC_MAPSTRINGS */
    case MELTOBMAG_MAPSTRINGS:
      {
	struct meltmapstrings_st *src = (struct meltmapstrings_st *) p;
	/* forwarding from VALDESC_MAPSTRINGS */
	int ix, siz;
	MELT_FORWARDED (src->meltmap_aux);
	if (!src->entab)
	  break;
	siz = melt_primtab[src->lenix];
	gcc_assert (siz > 0);
	if (melt_is_young (src->entab))
	  {
	    struct entrystringsmelt_st *newtab
	      /* Don't need a cleared allocation!  */
	      = ggc_alloc_vec_entrystringsmelt_st (siz);
	    memcpy (newtab, src->entab,
		    siz * sizeof (struct entrystringsmelt_st));
	    src->entab = newtab;
	  }
	for (ix = 0; ix < siz; ix++)
	  {
	    const char *at = src->entab[ix].e_at;
	    if (!at || at == (void *) HTAB_DELETED_ENTRY)
	      {
		src->entab[ix].e_va = NULL;
		continue;
	      }
	    if (melt_is_young ((const void *) at))
	      src->entab[ix].e_at = (const char *) ggc_strdup (at);
	    MELT_FORWARDED (src->entab[ix].e_va);
	  }
	/* end  forwarding from VALDESC_MAPSTRINGS */

	break;
      }

      /*valdesc #9 VALDESC_MIXBIGINT */
    case MELTOBMAG_MIXBIGINT:
      {
	struct meltmixbigint_st *src = (struct meltmixbigint_st *) p;
	/* from VALDESC_MIXBIGINT */
	MELT_FORWARDED (src->ptrval);

	break;
      }

      /*valdesc #10 VALDESC_MIXINT */
    case MELTOBMAG_MIXINT:
      {
	struct meltmixint_st *src = (struct meltmixint_st *) p;
	/* from VALDESC_MIXINT */
	MELT_FORWARDED (src->ptrval);

	break;
      }

      /*valdesc #11 VALDESC_MIXLOC */
    case MELTOBMAG_MIXLOC:
      {
	struct meltmixloc_st *src = (struct meltmixloc_st *) p;
	/* from VALDESC_MIXLOC */
	MELT_FORWARDED (src->ptrval);

	break;
      }

      /*valdesc #12 VALDESC_MULTIPLE */
    case MELTOBMAG_MULTIPLE:
      {
	struct meltmultiple_st *src = (struct meltmultiple_st *) p;
	/* forwarding chunk from VALDESC_MULTIPLE */
	int nbval = (int) src->nbval;
	int ix = 0;
	for (ix = 0; ix < nbval; ix++)
	  MELT_FORWARDED (src->tabval[ix]);
	/* end forwarding chunk from VALDESC_MULTIPLE */

	break;
      }

      /*valdesc #13 VALDESC_OBJECT */
    case MELTOBMAG_OBJECT:
      {
	struct meltobject_st *src = (struct meltobject_st *) p;
	/* from VALDESC_OBJECT */
	int ix = 0;
	int oblen = (int) (src->obj_len);
	for (ix = 0; ix < oblen; ix++)
	  MELT_FORWARDED (src->obj_vartab[ix]);
#if ENABLE_CHECKING
	/* for low level debugging with gdb, we may want to catch some forwarding operations */
	if (melt_alptr_1 && (void *) src == melt_alptr_1)
	  melt_break_alptr_1 ("forwardobj src=alptr1");
	if (melt_alptr_2 && (void *) src == melt_alptr_2)
	  melt_break_alptr_2 ("forwardobj src=alptr2");
	if (src->obj_hash == melt_objhash_1)
	  melt_break_objhash_1 ("forwardobj src with objhash1");
	if (src->obj_hash == melt_objhash_2)
	  melt_break_objhash_2 ("forwardobj src with objhash2");
#endif /* ENABLE_CHECKING */

	break;
      }

      /*valdesc #14 VALDESC_PAIR */
    case MELTOBMAG_PAIR:
      {
	struct meltpair_st *src = (struct meltpair_st *) p;
	/* forward VALDESC_PAIR in warmelt-base.melt */
	MELT_FORWARDED (src->hd);
	MELT_FORWARDED (src->tl);

	break;
      }

      /*valdesc #15 VALDESC_REAL */
    case MELTOBMAG_REAL:
      {
	break;
      }

      /*valdesc #16 VALDESC_ROUTINE */
    case MELTOBMAG_ROUTINE:
      {
	struct meltroutine_st *src = (struct meltroutine_st *) p;
	/* from VALDESC_ROUTINE */
	int nbval = (int) src->nbval;
	int ix = 0;
	for (ix = 0; ix < nbval; ix++)
	  MELT_FORWARDED (src->tabval[ix]);
	MELT_FORWARDED (src->routdata);

	break;
      }

      /*valdesc #17 VALDESC_SPECIAL_DATA */
    case MELTOBMAG_SPECIAL_DATA:
      {
	struct meltspecialdata_st *src = (struct meltspecialdata_st *) p;
	/* from VALDESC_SPECIAL_DATA */
	src->meltspec_mark = 1;
	MELT_FORWARDED (src->meltspec_value);

	break;
      }

      /*valdesc #18 VALDESC_STRBUF */
    case MELTOBMAG_STRBUF:
      {
	break;
      }

      /*valdesc #19 VALDESC_STRING */
    case MELTOBMAG_STRING:
      {
	break;
      }

/* GTY-ed ctypes scan forward for melt_scanning  */
/*gtyctype #1 CTYPE_BASIC_BLOCK*/
    case MELTOBMAG_BASICBLOCK:
      break;
    case MELTOBMAG_MAPBASICBLOCKS:
      {
	struct meltmapbasicblocks_st *src =
	  (struct meltmapbasicblocks_st *) p;
	int siz = 0, ix = 0;
	MELT_FORWARDED (src->meltmap_aux);
	if (!src->entab)
	  break;
	siz = melt_primtab[src->lenix];
	gcc_assert (siz > 0);
	if (melt_is_young (src->entab))
	  {
	    struct entrybasicblockmelt_st *newtab =
	      ggc_alloc_vec_entrybasicblockmelt_st (siz);
	    memcpy (newtab, src->entab,
		    siz * sizeof (struct entrybasicblockmelt_st));
	    src->entab = newtab;
	  }			/*end if young entab */
	for (ix = 0; ix < siz; ix++)
	  {
	    basic_block at = src->entab[ix].e_at;
	    if (!at || (void *) at == (void *) HTAB_DELETED_ENTRY)
	      {
		src->entab[ix].e_va = NULL;
		continue;
	      }			/*end if empty at */
	    MELT_FORWARDED (src->entab[ix].e_va);
	  }			/*end for ix */
      };			/* end case MELTOBMAG_MAPBASICBLOCKS */
      break;
      /*gtyctype #2 CTYPE_BITMAP */
    case MELTOBMAG_BITMAP:
      break;
    case MELTOBMAG_MAPBITMAPS:
      {
	struct meltmapbitmaps_st *src = (struct meltmapbitmaps_st *) p;
	int siz = 0, ix = 0;
	MELT_FORWARDED (src->meltmap_aux);
	if (!src->entab)
	  break;
	siz = melt_primtab[src->lenix];
	gcc_assert (siz > 0);
	if (melt_is_young (src->entab))
	  {
	    struct entrybitmapmelt_st *newtab =
	      ggc_alloc_vec_entrybitmapmelt_st (siz);
	    memcpy (newtab, src->entab,
		    siz * sizeof (struct entrybitmapmelt_st));
	    src->entab = newtab;
	  }			/*end if young entab */
	for (ix = 0; ix < siz; ix++)
	  {
	    bitmap at = src->entab[ix].e_at;
	    if (!at || (void *) at == (void *) HTAB_DELETED_ENTRY)
	      {
		src->entab[ix].e_va = NULL;
		continue;
	      }			/*end if empty at */
	    MELT_FORWARDED (src->entab[ix].e_va);
	  }			/*end for ix */
      };			/* end case MELTOBMAG_MAPBITMAPS */
      break;
      /*gtyctype #3 CTYPE_EDGE */
    case MELTOBMAG_EDGE:
      break;
    case MELTOBMAG_MAPEDGES:
      {
	struct meltmapedges_st *src = (struct meltmapedges_st *) p;
	int siz = 0, ix = 0;
	MELT_FORWARDED (src->meltmap_aux);
	if (!src->entab)
	  break;
	siz = melt_primtab[src->lenix];
	gcc_assert (siz > 0);
	if (melt_is_young (src->entab))
	  {
	    struct entryedgemelt_st *newtab =
	      ggc_alloc_vec_entryedgemelt_st (siz);
	    memcpy (newtab, src->entab,
		    siz * sizeof (struct entryedgemelt_st));
	    src->entab = newtab;
	  }			/*end if young entab */
	for (ix = 0; ix < siz; ix++)
	  {
	    edge at = src->entab[ix].e_at;
	    if (!at || (void *) at == (void *) HTAB_DELETED_ENTRY)
	      {
		src->entab[ix].e_va = NULL;
		continue;
	      }			/*end if empty at */
	    MELT_FORWARDED (src->entab[ix].e_va);
	  }			/*end for ix */
      };			/* end case MELTOBMAG_MAPEDGES */
      break;
      /*gtyctype #4 CTYPE_GIMPLE */
    case MELTOBMAG_GIMPLE:
      break;
    case MELTOBMAG_MAPGIMPLES:
      {
	struct meltmapgimples_st *src = (struct meltmapgimples_st *) p;
	int siz = 0, ix = 0;
	MELT_FORWARDED (src->meltmap_aux);
	if (!src->entab)
	  break;
	siz = melt_primtab[src->lenix];
	gcc_assert (siz > 0);
	if (melt_is_young (src->entab))
	  {
	    struct entrygimplemelt_st *newtab =
	      ggc_alloc_vec_entrygimplemelt_st (siz);
	    memcpy (newtab, src->entab,
		    siz * sizeof (struct entrygimplemelt_st));
	    src->entab = newtab;
	  }			/*end if young entab */
	for (ix = 0; ix < siz; ix++)
	  {
	    gimple at = src->entab[ix].e_at;
	    if (!at || (void *) at == (void *) HTAB_DELETED_ENTRY)
	      {
		src->entab[ix].e_va = NULL;
		continue;
	      }			/*end if empty at */
	    MELT_FORWARDED (src->entab[ix].e_va);
	  }			/*end for ix */
      };			/* end case MELTOBMAG_MAPGIMPLES */
      break;
      /*gtyctype #5 CTYPE_GIMPLE_SEQ */
    case MELTOBMAG_GIMPLESEQ:
      break;
    case MELTOBMAG_MAPGIMPLESEQS:
      {
	struct meltmapgimpleseqs_st *src = (struct meltmapgimpleseqs_st *) p;
	int siz = 0, ix = 0;
	MELT_FORWARDED (src->meltmap_aux);
	if (!src->entab)
	  break;
	siz = melt_primtab[src->lenix];
	gcc_assert (siz > 0);
	if (melt_is_young (src->entab))
	  {
	    struct entrygimpleseqmelt_st *newtab =
	      ggc_alloc_vec_entrygimpleseqmelt_st (siz);
	    memcpy (newtab, src->entab,
		    siz * sizeof (struct entrygimpleseqmelt_st));
	    src->entab = newtab;
	  }			/*end if young entab */
	for (ix = 0; ix < siz; ix++)
	  {
	    gimple_seq at = src->entab[ix].e_at;
	    if (!at || (void *) at == (void *) HTAB_DELETED_ENTRY)
	      {
		src->entab[ix].e_va = NULL;
		continue;
	      }			/*end if empty at */
	    MELT_FORWARDED (src->entab[ix].e_va);
	  }			/*end for ix */
      };			/* end case MELTOBMAG_MAPGIMPLESEQS */
      break;
      /*gtyctype #6 CTYPE_LOOP */
    case MELTOBMAG_LOOP:
      break;
    case MELTOBMAG_MAPLOOPS:
      {
	struct meltmaploops_st *src = (struct meltmaploops_st *) p;
	int siz = 0, ix = 0;
	MELT_FORWARDED (src->meltmap_aux);
	if (!src->entab)
	  break;
	siz = melt_primtab[src->lenix];
	gcc_assert (siz > 0);
	if (melt_is_young (src->entab))
	  {
	    struct entryloopmelt_st *newtab =
	      ggc_alloc_vec_entryloopmelt_st (siz);
	    memcpy (newtab, src->entab,
		    siz * sizeof (struct entryloopmelt_st));
	    src->entab = newtab;
	  }			/*end if young entab */
	for (ix = 0; ix < siz; ix++)
	  {
	    loop_p at = src->entab[ix].e_at;
	    if (!at || (void *) at == (void *) HTAB_DELETED_ENTRY)
	      {
		src->entab[ix].e_va = NULL;
		continue;
	      }			/*end if empty at */
	    MELT_FORWARDED (src->entab[ix].e_va);
	  }			/*end for ix */
      };			/* end case MELTOBMAG_MAPLOOPS */
      break;
      /*gtyctype #7 CTYPE_RTVEC */
    case MELTOBMAG_RTVEC:
      break;
    case MELTOBMAG_MAPRTVECS:
      {
	struct meltmaprtvecs_st *src = (struct meltmaprtvecs_st *) p;
	int siz = 0, ix = 0;
	MELT_FORWARDED (src->meltmap_aux);
	if (!src->entab)
	  break;
	siz = melt_primtab[src->lenix];
	gcc_assert (siz > 0);
	if (melt_is_young (src->entab))
	  {
	    struct entryrtvecmelt_st *newtab =
	      ggc_alloc_vec_entryrtvecmelt_st (siz);
	    memcpy (newtab, src->entab,
		    siz * sizeof (struct entryrtvecmelt_st));
	    src->entab = newtab;
	  }			/*end if young entab */
	for (ix = 0; ix < siz; ix++)
	  {
	    rtvec at = src->entab[ix].e_at;
	    if (!at || (void *) at == (void *) HTAB_DELETED_ENTRY)
	      {
		src->entab[ix].e_va = NULL;
		continue;
	      }			/*end if empty at */
	    MELT_FORWARDED (src->entab[ix].e_va);
	  }			/*end for ix */
      };			/* end case MELTOBMAG_MAPRTVECS */
      break;
      /*gtyctype #8 CTYPE_RTX */
    case MELTOBMAG_RTX:
      break;
    case MELTOBMAG_MAPRTXS:
      {
	struct meltmaprtxs_st *src = (struct meltmaprtxs_st *) p;
	int siz = 0, ix = 0;
	MELT_FORWARDED (src->meltmap_aux);
	if (!src->entab)
	  break;
	siz = melt_primtab[src->lenix];
	gcc_assert (siz > 0);
	if (melt_is_young (src->entab))
	  {
	    struct entryrtxmelt_st *newtab =
	      ggc_alloc_vec_entryrtxmelt_st (siz);
	    memcpy (newtab, src->entab,
		    siz * sizeof (struct entryrtxmelt_st));
	    src->entab = newtab;
	  }			/*end if young entab */
	for (ix = 0; ix < siz; ix++)
	  {
	    rtx at = src->entab[ix].e_at;
	    if (!at || (void *) at == (void *) HTAB_DELETED_ENTRY)
	      {
		src->entab[ix].e_va = NULL;
		continue;
	      }			/*end if empty at */
	    MELT_FORWARDED (src->entab[ix].e_va);
	  }			/*end for ix */
      };			/* end case MELTOBMAG_MAPRTXS */
      break;
      /*gtyctype #9 CTYPE_TREE */
    case MELTOBMAG_TREE:
      break;
    case MELTOBMAG_MAPTREES:
      {
	struct meltmaptrees_st *src = (struct meltmaptrees_st *) p;
	int siz = 0, ix = 0;
	MELT_FORWARDED (src->meltmap_aux);
	if (!src->entab)
	  break;
	siz = melt_primtab[src->lenix];
	gcc_assert (siz > 0);
	if (melt_is_young (src->entab))
	  {
	    struct entrytreemelt_st *newtab =
	      ggc_alloc_vec_entrytreemelt_st (siz);
	    memcpy (newtab, src->entab,
		    siz * sizeof (struct entrytreemelt_st));
	    src->entab = newtab;
	  }			/*end if young entab */
	for (ix = 0; ix < siz; ix++)
	  {
	    tree at = src->entab[ix].e_at;
	    if (!at || (void *) at == (void *) HTAB_DELETED_ENTRY)
	      {
		src->entab[ix].e_va = NULL;
		continue;
	      }			/*end if empty at */
	    MELT_FORWARDED (src->entab[ix].e_va);
	  }			/*end for ix */
      };			/* end case MELTOBMAG_MAPTREES */
      break;
      /* trailer generated by generate_runtypesupport_scanning */
    default:
      /* gcc_unreachable (); */
      fatal_error ("melt melt_scanning GC: corrupted heap, p=%p omagic=%d\n",
		   (void *) p, (int) omagic);
    }
}				/* end of melt_scanning generated by generate_runtypesupport_scanning */

/**end of code generated by generate_runtypesupport_scanning **/


/** start of code generated by generate_runtypesupport_boxingfun **/
/*gtyctype #1 CTYPE_BASIC_BLOCK*/

melt_ptr_t
meltgc_new_basicblock (meltobject_ptr_t discr_p, basic_block val)
{				/*generated boxingfun */
  MELT_ENTERFRAME (2, NULL);
#define resv meltfram__.mcfr_varptr[0]
#define discrv meltfram__.mcfr_varptr[1]
  discrv = discr_p;
  if (!discrv)
    discrv = MELT_PREDEF (DISCR_BASIC_BLOCK);
  if (melt_magic_discr ((melt_ptr_t) discrv) != MELTOBMAG_OBJECT)
    goto end;
  if (((meltobject_ptr_t) (discrv))->meltobj_magic != MELTOBMAG_BASICBLOCK)
    goto end;
  resv = meltgc_allocate (sizeof (struct meltbasicblock_st), 0);
  ((struct meltbasicblock_st *) (resv))->discr = (meltobject_ptr_t) discrv;
  ((struct meltbasicblock_st *) (resv))->val = val;
end:MELT_EXITFRAME ();
  return ((melt_ptr_t) (resv));
#undef resv
#undef discrv
}				/* end generated boxingfun meltgc_new_basicblock */

void
meltgc_basicblock_updatebox (melt_ptr_t box_p, basic_block val)
{				/*generated updateboxfun */
  MELT_ENTERFRAME (1, NULL);
#define boxv meltfram__.mcfr_varptr[0]
  boxv = box_p;
  if (melt_magic_discr ((melt_ptr_t) boxv) != MELTOBMAG_BASICBLOCK)
    goto end;
  if (((melt_ptr_t) boxv)->u_discr
      /* generated updatebox nonconst */
      == (meltobject_ptr_t) MELT_PREDEF (DISCR_CONSTANT_BASIC_BLOCK))
    goto end;
  ((struct meltbasicblock_st *) (boxv))->val = val;
  meltgc_touch ((melt_ptr_t) boxv);
end:MELT_EXITFRAME ();
#undef boxv
}				/* end generated updateboxfun meltgc_basicblock_updatebox */

/*gtyctype #2 CTYPE_BITMAP*/

melt_ptr_t
meltgc_new_bitmap (meltobject_ptr_t discr_p, bitmap val)
{				/*generated boxingfun */
  MELT_ENTERFRAME (2, NULL);
#define resv meltfram__.mcfr_varptr[0]
#define discrv meltfram__.mcfr_varptr[1]
  discrv = discr_p;
  if (!discrv)
    discrv = MELT_PREDEF (DISCR_BITMAP);
  if (melt_magic_discr ((melt_ptr_t) discrv) != MELTOBMAG_OBJECT)
    goto end;
  if (((meltobject_ptr_t) (discrv))->meltobj_magic != MELTOBMAG_BITMAP)
    goto end;
  resv = meltgc_allocate (sizeof (struct meltbitmap_st), 0);
  ((struct meltbitmap_st *) (resv))->discr = (meltobject_ptr_t) discrv;
  ((struct meltbitmap_st *) (resv))->val = val;
end:MELT_EXITFRAME ();
  return ((melt_ptr_t) (resv));
#undef resv
#undef discrv
}				/* end generated boxingfun meltgc_new_bitmap */

void
meltgc_bitmap_updatebox (melt_ptr_t box_p, bitmap val)
{				/*generated updateboxfun */
  MELT_ENTERFRAME (1, NULL);
#define boxv meltfram__.mcfr_varptr[0]
  boxv = box_p;
  if (melt_magic_discr ((melt_ptr_t) boxv) != MELTOBMAG_BITMAP)
    goto end;
  ((struct meltbitmap_st *) (boxv))->val = val;
  meltgc_touch ((melt_ptr_t) boxv);
end:MELT_EXITFRAME ();
#undef boxv
}				/* end generated updateboxfun meltgc_bitmap_updatebox */

/*gtyctype #3 CTYPE_EDGE*/

melt_ptr_t
meltgc_new_edge (meltobject_ptr_t discr_p, edge val)
{				/*generated boxingfun */
  MELT_ENTERFRAME (2, NULL);
#define resv meltfram__.mcfr_varptr[0]
#define discrv meltfram__.mcfr_varptr[1]
  discrv = discr_p;
  if (!discrv)
    discrv = MELT_PREDEF (DISCR_EDGE);
  if (melt_magic_discr ((melt_ptr_t) discrv) != MELTOBMAG_OBJECT)
    goto end;
  if (((meltobject_ptr_t) (discrv))->meltobj_magic != MELTOBMAG_EDGE)
    goto end;
  resv = meltgc_allocate (sizeof (struct meltedge_st), 0);
  ((struct meltedge_st *) (resv))->discr = (meltobject_ptr_t) discrv;
  ((struct meltedge_st *) (resv))->val = val;
end:MELT_EXITFRAME ();
  return ((melt_ptr_t) (resv));
#undef resv
#undef discrv
}				/* end generated boxingfun meltgc_new_edge */

void
meltgc_edge_updatebox (melt_ptr_t box_p, edge val)
{				/*generated updateboxfun */
  MELT_ENTERFRAME (1, NULL);
#define boxv meltfram__.mcfr_varptr[0]
  boxv = box_p;
  if (melt_magic_discr ((melt_ptr_t) boxv) != MELTOBMAG_EDGE)
    goto end;
  if (((melt_ptr_t) boxv)->u_discr
      /* generated updatebox nonconst */
      == (meltobject_ptr_t) MELT_PREDEF (DISCR_CONSTANT_EDGE))
    goto end;
  ((struct meltedge_st *) (boxv))->val = val;
  meltgc_touch ((melt_ptr_t) boxv);
end:MELT_EXITFRAME ();
#undef boxv
}				/* end generated updateboxfun meltgc_edge_updatebox */

/*gtyctype #4 CTYPE_GIMPLE*/

melt_ptr_t
meltgc_new_gimple (meltobject_ptr_t discr_p, gimple val)
{				/*generated boxingfun */
  MELT_ENTERFRAME (2, NULL);
#define resv meltfram__.mcfr_varptr[0]
#define discrv meltfram__.mcfr_varptr[1]
  discrv = discr_p;
  if (!discrv)
    discrv = MELT_PREDEF (DISCR_GIMPLE);
  if (melt_magic_discr ((melt_ptr_t) discrv) != MELTOBMAG_OBJECT)
    goto end;
  if (((meltobject_ptr_t) (discrv))->meltobj_magic != MELTOBMAG_GIMPLE)
    goto end;
  resv = meltgc_allocate (sizeof (struct meltgimple_st), 0);
  ((struct meltgimple_st *) (resv))->discr = (meltobject_ptr_t) discrv;
  ((struct meltgimple_st *) (resv))->val = val;
end:MELT_EXITFRAME ();
  return ((melt_ptr_t) (resv));
#undef resv
#undef discrv
}				/* end generated boxingfun meltgc_new_gimple */

void
meltgc_gimple_updatebox (melt_ptr_t box_p, gimple val)
{				/*generated updateboxfun */
  MELT_ENTERFRAME (1, NULL);
#define boxv meltfram__.mcfr_varptr[0]
  boxv = box_p;
  if (melt_magic_discr ((melt_ptr_t) boxv) != MELTOBMAG_GIMPLE)
    goto end;
  if (((melt_ptr_t) boxv)->u_discr
      /* generated updatebox nonconst */
      == (meltobject_ptr_t) MELT_PREDEF (DISCR_CONSTANT_GIMPLE))
    goto end;
  ((struct meltgimple_st *) (boxv))->val = val;
  meltgc_touch ((melt_ptr_t) boxv);
end:MELT_EXITFRAME ();
#undef boxv
}				/* end generated updateboxfun meltgc_gimple_updatebox */

/*gtyctype #5 CTYPE_GIMPLE_SEQ*/

melt_ptr_t
meltgc_new_gimpleseq (meltobject_ptr_t discr_p, gimple_seq val)
{				/*generated boxingfun */
  MELT_ENTERFRAME (2, NULL);
#define resv meltfram__.mcfr_varptr[0]
#define discrv meltfram__.mcfr_varptr[1]
  discrv = discr_p;
  if (!discrv)
    discrv = MELT_PREDEF (DISCR_GIMPLE_SEQ);
  if (melt_magic_discr ((melt_ptr_t) discrv) != MELTOBMAG_OBJECT)
    goto end;
  if (((meltobject_ptr_t) (discrv))->meltobj_magic != MELTOBMAG_GIMPLESEQ)
    goto end;
  resv = meltgc_allocate (sizeof (struct meltgimpleseq_st), 0);
  ((struct meltgimpleseq_st *) (resv))->discr = (meltobject_ptr_t) discrv;
  ((struct meltgimpleseq_st *) (resv))->val = val;
end:MELT_EXITFRAME ();
  return ((melt_ptr_t) (resv));
#undef resv
#undef discrv
}				/* end generated boxingfun meltgc_new_gimpleseq */

void
meltgc_gimpleseq_updatebox (melt_ptr_t box_p, gimple_seq val)
{				/*generated updateboxfun */
  MELT_ENTERFRAME (1, NULL);
#define boxv meltfram__.mcfr_varptr[0]
  boxv = box_p;
  if (melt_magic_discr ((melt_ptr_t) boxv) != MELTOBMAG_GIMPLESEQ)
    goto end;
  if (((melt_ptr_t) boxv)->u_discr
      /* generated updatebox nonconst */
      == (meltobject_ptr_t) MELT_PREDEF (DISCR_CONSTANT_GIMPLE_SEQ))
    goto end;
  ((struct meltgimpleseq_st *) (boxv))->val = val;
  meltgc_touch ((melt_ptr_t) boxv);
end:MELT_EXITFRAME ();
#undef boxv
}				/* end generated updateboxfun meltgc_gimpleseq_updatebox */

/*gtyctype #6 CTYPE_LOOP*/

melt_ptr_t
meltgc_new_loop (meltobject_ptr_t discr_p, loop_p val)
{				/*generated boxingfun */
  MELT_ENTERFRAME (2, NULL);
#define resv meltfram__.mcfr_varptr[0]
#define discrv meltfram__.mcfr_varptr[1]
  discrv = discr_p;
  if (!discrv)
    discrv = MELT_PREDEF (DISCR_LOOP);
  if (melt_magic_discr ((melt_ptr_t) discrv) != MELTOBMAG_OBJECT)
    goto end;
  if (((meltobject_ptr_t) (discrv))->meltobj_magic != MELTOBMAG_LOOP)
    goto end;
  resv = meltgc_allocate (sizeof (struct meltloop_st), 0);
  ((struct meltloop_st *) (resv))->discr = (meltobject_ptr_t) discrv;
  ((struct meltloop_st *) (resv))->val = val;
end:MELT_EXITFRAME ();
  return ((melt_ptr_t) (resv));
#undef resv
#undef discrv
}				/* end generated boxingfun meltgc_new_loop */

void
melt_loop_updatebox (melt_ptr_t box_p, loop_p val)
{				/*generated updateboxfun */
  MELT_ENTERFRAME (1, NULL);
#define boxv meltfram__.mcfr_varptr[0]
  boxv = box_p;
  if (melt_magic_discr ((melt_ptr_t) boxv) != MELTOBMAG_LOOP)
    goto end;
  if (((melt_ptr_t) boxv)->u_discr
      /* generated updatebox nonconst */
      == (meltobject_ptr_t) MELT_PREDEF (DISCR_CONSTANT_LOOP))
    goto end;
  ((struct meltloop_st *) (boxv))->val = val;
  meltgc_touch ((melt_ptr_t) boxv);
end:MELT_EXITFRAME ();
#undef boxv
}				/* end generated updateboxfun melt_loop_updatebox */

/*gtyctype #7 CTYPE_RTVEC*/

melt_ptr_t
meltgc_new_rtvec (meltobject_ptr_t discr_p, rtvec val)
{				/*generated boxingfun */
  MELT_ENTERFRAME (2, NULL);
#define resv meltfram__.mcfr_varptr[0]
#define discrv meltfram__.mcfr_varptr[1]
  discrv = discr_p;
  if (!discrv)
    discrv = MELT_PREDEF (DISCR_RTVEC);
  if (melt_magic_discr ((melt_ptr_t) discrv) != MELTOBMAG_OBJECT)
    goto end;
  if (((meltobject_ptr_t) (discrv))->meltobj_magic != MELTOBMAG_RTVEC)
    goto end;
  resv = meltgc_allocate (sizeof (struct meltrtvec_st), 0);
  ((struct meltrtvec_st *) (resv))->discr = (meltobject_ptr_t) discrv;
  ((struct meltrtvec_st *) (resv))->val = val;
end:MELT_EXITFRAME ();
  return ((melt_ptr_t) (resv));
#undef resv
#undef discrv
}				/* end generated boxingfun meltgc_new_rtvec */

void
meltgc_rtvec_updatebox (melt_ptr_t box_p, rtvec val)
{				/*generated updateboxfun */
  MELT_ENTERFRAME (1, NULL);
#define boxv meltfram__.mcfr_varptr[0]
  boxv = box_p;
  if (melt_magic_discr ((melt_ptr_t) boxv) != MELTOBMAG_RTVEC)
    goto end;
  ((struct meltrtvec_st *) (boxv))->val = val;
  meltgc_touch ((melt_ptr_t) boxv);
end:MELT_EXITFRAME ();
#undef boxv
}				/* end generated updateboxfun meltgc_rtvec_updatebox */

/*gtyctype #8 CTYPE_RTX*/

melt_ptr_t
meltgc_new_rtx (meltobject_ptr_t discr_p, rtx val)
{				/*generated boxingfun */
  MELT_ENTERFRAME (2, NULL);
#define resv meltfram__.mcfr_varptr[0]
#define discrv meltfram__.mcfr_varptr[1]
  discrv = discr_p;
  if (!discrv)
    discrv = MELT_PREDEF (DISCR_RTX);
  if (melt_magic_discr ((melt_ptr_t) discrv) != MELTOBMAG_OBJECT)
    goto end;
  if (((meltobject_ptr_t) (discrv))->meltobj_magic != MELTOBMAG_RTX)
    goto end;
  resv = meltgc_allocate (sizeof (struct meltrtx_st), 0);
  ((struct meltrtx_st *) (resv))->discr = (meltobject_ptr_t) discrv;
  ((struct meltrtx_st *) (resv))->val = val;
end:MELT_EXITFRAME ();
  return ((melt_ptr_t) (resv));
#undef resv
#undef discrv
}				/* end generated boxingfun meltgc_new_rtx */

void
meltgc_rtx_updatebox (melt_ptr_t box_p, rtx val)
{				/*generated updateboxfun */
  MELT_ENTERFRAME (1, NULL);
#define boxv meltfram__.mcfr_varptr[0]
  boxv = box_p;
  if (melt_magic_discr ((melt_ptr_t) boxv) != MELTOBMAG_RTX)
    goto end;
  ((struct meltrtx_st *) (boxv))->val = val;
  meltgc_touch ((melt_ptr_t) boxv);
end:MELT_EXITFRAME ();
#undef boxv
}				/* end generated updateboxfun meltgc_rtx_updatebox */

/*gtyctype #9 CTYPE_TREE*/

melt_ptr_t
meltgc_new_tree (meltobject_ptr_t discr_p, tree val)
{				/*generated boxingfun */
  MELT_ENTERFRAME (2, NULL);
#define resv meltfram__.mcfr_varptr[0]
#define discrv meltfram__.mcfr_varptr[1]
  discrv = discr_p;
  if (!discrv)
    discrv = MELT_PREDEF (DISCR_TREE);
  if (melt_magic_discr ((melt_ptr_t) discrv) != MELTOBMAG_OBJECT)
    goto end;
  if (((meltobject_ptr_t) (discrv))->meltobj_magic != MELTOBMAG_TREE)
    goto end;
  resv = meltgc_allocate (sizeof (struct melttree_st), 0);
  ((struct melttree_st *) (resv))->discr = (meltobject_ptr_t) discrv;
  ((struct melttree_st *) (resv))->val = val;
end:MELT_EXITFRAME ();
  return ((melt_ptr_t) (resv));
#undef resv
#undef discrv
}				/* end generated boxingfun meltgc_new_tree */

void
meltgc_tree_updatebox (melt_ptr_t box_p, tree val)
{				/*generated updateboxfun */
  MELT_ENTERFRAME (1, NULL);
#define boxv meltfram__.mcfr_varptr[0]
  boxv = box_p;
  if (melt_magic_discr ((melt_ptr_t) boxv) != MELTOBMAG_TREE)
    goto end;
  if (((melt_ptr_t) boxv)->u_discr
      /* generated updatebox nonconst */
      == (meltobject_ptr_t) MELT_PREDEF (DISCR_CONSTANT_TREE))
    goto end;
  ((struct melttree_st *) (boxv))->val = val;
  meltgc_touch ((melt_ptr_t) boxv);
end:MELT_EXITFRAME ();
#undef boxv
}				/* end generated updateboxfun meltgc_tree_updatebox */


/** end of code generated by generate_runtypesupport_boxingfun **/



/** generated by generate_runtypesupport_cloning_fun **/
 /* generated cloning routine head */
melt_ptr_t
meltgc_clone_with_discriminant (melt_ptr_t srcval_p, melt_ptr_t newdiscr_p)
{
  unsigned srcmagic = 0;
  unsigned newmagic = 0;
  MELT_ENTERFRAME (5, NULL);
#define resv       meltfram__.mcfr_varptr[0]
#define srcvalv    meltfram__.mcfr_varptr[1]
#define newdiscrv  meltfram__.mcfr_varptr[2]
#define srcdiscrv  meltfram__.mcfr_varptr[3]
#define compv      meltfram__.mcfr_varptr[4]
  srcvalv = srcval_p;
  newdiscrv = newdiscr_p;
  resv = srcvalv;
  if (!srcvalv)
    goto end;
  srcdiscrv = ((melt_ptr_t) srcvalv)->u_discr;
  if (!newdiscrv)
    newdiscrv = srcdiscrv;
  if (melt_magic_discr ((melt_ptr_t) newdiscrv) != MELTOBMAG_OBJECT
      || ((meltobject_ptr_t) newdiscrv)->obj_len <
      MELTLENGTH_CLASS_DISCRIMINANT)
    goto end;
  if (!melt_is_instance_of ((melt_ptr_t) newdiscrv,
			    MELT_PREDEF (CLASS_DISCRIMINANT)))
    goto end;
  srcmagic = melt_magic_discr ((melt_ptr_t) srcvalv);
  newmagic = ((meltobject_ptr_t) newdiscrv)->meltobj_magic;
  if (srcmagic != newmagic)
    goto end;
  switch (srcmagic)
    {				/* end cloning heeader */


/*** cloning 9 GTY-ed ctypes ***/

      /*cloning gtyctype #1 CTYPE_BASIC_BLOCK */
    case MELTOBMAG_BASICBLOCK:
      {				/* cloning boxed value CTYPE_BASIC_BLOCK */
	struct meltbasicblock_st *src = (struct meltbasicblock_st *) srcvalv;
	struct meltbasicblock_st *dst =
	  (struct meltbasicblock_st *)
	  meltgc_allocate (sizeof (struct meltbasicblock_st), 0);

	*dst = *src;
	dst->discr = (meltobject_ptr_t) newdiscrv;
	resv = (melt_ptr_t) dst;
      }
      break;
    case MELTOBMAG_MAPBASICBLOCKS:
      {				/* cloning map value CTYPE_BASIC_BLOCK */
	struct meltmapbasicblocks_st *src =
	  (struct meltmapbasicblocks_st *) srcvalv;
	unsigned oldlen = melt_primtab[src->lenix];
	unsigned newlen = 4 * src->count / 3 + 5;
	struct meltmapbasicblocks_st *dst =
	  (struct meltmapbasicblocks_st *)
	  meltgc_raw_new_mappointers ((meltobject_ptr_t) newdiscrv, newlen);
	unsigned ix = 0;
	dst->meltmap_aux = src->meltmap_aux;
	if (src->entab)
	  for (ix = 0; ix < oldlen; ix++)
	    {
	      melt_ptr_t curva = src->entab[ix].e_va;
	      basic_block curat = src->entab[ix].e_at;
	      if (curva != NULL && curat != (basic_block) HTAB_DELETED_ENTRY)
		meltgc_raw_put_mappointers ((void *) dst,
					    (const void *) curat, curva);
	    }
	resv = (melt_ptr_t) dst;
      };
      break;
      /*cloning gtyctype #2 CTYPE_BITMAP */
    case MELTOBMAG_BITMAP:
      {				/* cloning boxed value CTYPE_BITMAP */
	struct meltbitmap_st *src = (struct meltbitmap_st *) srcvalv;
	struct meltbitmap_st *dst =
	  (struct meltbitmap_st *)
	  meltgc_allocate (sizeof (struct meltbitmap_st), 0);

	*dst = *src;
	dst->discr = (meltobject_ptr_t) newdiscrv;
	resv = (melt_ptr_t) dst;
      }
      break;
    case MELTOBMAG_MAPBITMAPS:
      {				/* cloning map value CTYPE_BITMAP */
	struct meltmapbitmaps_st *src = (struct meltmapbitmaps_st *) srcvalv;
	unsigned oldlen = melt_primtab[src->lenix];
	unsigned newlen = 4 * src->count / 3 + 5;
	struct meltmapbitmaps_st *dst =
	  (struct meltmapbitmaps_st *)
	  meltgc_raw_new_mappointers ((meltobject_ptr_t) newdiscrv, newlen);
	unsigned ix = 0;
	dst->meltmap_aux = src->meltmap_aux;
	if (src->entab)
	  for (ix = 0; ix < oldlen; ix++)
	    {
	      melt_ptr_t curva = src->entab[ix].e_va;
	      bitmap curat = src->entab[ix].e_at;
	      if (curva != NULL && curat != (bitmap) HTAB_DELETED_ENTRY)
		meltgc_raw_put_mappointers ((void *) dst,
					    (const void *) curat, curva);
	    }
	resv = (melt_ptr_t) dst;
      };
      break;
      /*cloning gtyctype #3 CTYPE_EDGE */
    case MELTOBMAG_EDGE:
      {				/* cloning boxed value CTYPE_EDGE */
	struct meltedge_st *src = (struct meltedge_st *) srcvalv;
	struct meltedge_st *dst =
	  (struct meltedge_st *) meltgc_allocate (sizeof (struct meltedge_st),
						  0);

	*dst = *src;
	dst->discr = (meltobject_ptr_t) newdiscrv;
	resv = (melt_ptr_t) dst;
      }
      break;
    case MELTOBMAG_MAPEDGES:
      {				/* cloning map value CTYPE_EDGE */
	struct meltmapedges_st *src = (struct meltmapedges_st *) srcvalv;
	unsigned oldlen = melt_primtab[src->lenix];
	unsigned newlen = 4 * src->count / 3 + 5;
	struct meltmapedges_st *dst =
	  (struct meltmapedges_st *)
	  meltgc_raw_new_mappointers ((meltobject_ptr_t) newdiscrv, newlen);
	unsigned ix = 0;
	dst->meltmap_aux = src->meltmap_aux;
	if (src->entab)
	  for (ix = 0; ix < oldlen; ix++)
	    {
	      melt_ptr_t curva = src->entab[ix].e_va;
	      edge curat = src->entab[ix].e_at;
	      if (curva != NULL && curat != (edge) HTAB_DELETED_ENTRY)
		meltgc_raw_put_mappointers ((void *) dst,
					    (const void *) curat, curva);
	    }
	resv = (melt_ptr_t) dst;
      };
      break;
      /*cloning gtyctype #4 CTYPE_GIMPLE */
    case MELTOBMAG_GIMPLE:
      {				/* cloning boxed value CTYPE_GIMPLE */
	struct meltgimple_st *src = (struct meltgimple_st *) srcvalv;
	struct meltgimple_st *dst =
	  (struct meltgimple_st *)
	  meltgc_allocate (sizeof (struct meltgimple_st), 0);

	*dst = *src;
	dst->discr = (meltobject_ptr_t) newdiscrv;
	resv = (melt_ptr_t) dst;
      }
      break;
    case MELTOBMAG_MAPGIMPLES:
      {				/* cloning map value CTYPE_GIMPLE */
	struct meltmapgimples_st *src = (struct meltmapgimples_st *) srcvalv;
	unsigned oldlen = melt_primtab[src->lenix];
	unsigned newlen = 4 * src->count / 3 + 5;
	struct meltmapgimples_st *dst =
	  (struct meltmapgimples_st *)
	  meltgc_raw_new_mappointers ((meltobject_ptr_t) newdiscrv, newlen);
	unsigned ix = 0;
	dst->meltmap_aux = src->meltmap_aux;
	if (src->entab)
	  for (ix = 0; ix < oldlen; ix++)
	    {
	      melt_ptr_t curva = src->entab[ix].e_va;
	      gimple curat = src->entab[ix].e_at;
	      if (curva != NULL && curat != (gimple) HTAB_DELETED_ENTRY)
		meltgc_raw_put_mappointers ((void *) dst,
					    (const void *) curat, curva);
	    }
	resv = (melt_ptr_t) dst;
      };
      break;
      /*cloning gtyctype #5 CTYPE_GIMPLE_SEQ */
    case MELTOBMAG_GIMPLESEQ:
      {				/* cloning boxed value CTYPE_GIMPLE_SEQ */
	struct meltgimpleseq_st *src = (struct meltgimpleseq_st *) srcvalv;
	struct meltgimpleseq_st *dst =
	  (struct meltgimpleseq_st *)
	  meltgc_allocate (sizeof (struct meltgimpleseq_st), 0);

	*dst = *src;
	dst->discr = (meltobject_ptr_t) newdiscrv;
	resv = (melt_ptr_t) dst;
      }
      break;
    case MELTOBMAG_MAPGIMPLESEQS:
      {				/* cloning map value CTYPE_GIMPLE_SEQ */
	struct meltmapgimpleseqs_st *src =
	  (struct meltmapgimpleseqs_st *) srcvalv;
	unsigned oldlen = melt_primtab[src->lenix];
	unsigned newlen = 4 * src->count / 3 + 5;
	struct meltmapgimpleseqs_st *dst =
	  (struct meltmapgimpleseqs_st *)
	  meltgc_raw_new_mappointers ((meltobject_ptr_t) newdiscrv, newlen);
	unsigned ix = 0;
	dst->meltmap_aux = src->meltmap_aux;
	if (src->entab)
	  for (ix = 0; ix < oldlen; ix++)
	    {
	      melt_ptr_t curva = src->entab[ix].e_va;
	      gimple_seq curat = src->entab[ix].e_at;
	      if (curva != NULL && curat != (gimple_seq) HTAB_DELETED_ENTRY)
		meltgc_raw_put_mappointers ((void *) dst,
					    (const void *) curat, curva);
	    }
	resv = (melt_ptr_t) dst;
      };
      break;
      /*cloning gtyctype #6 CTYPE_LOOP */
    case MELTOBMAG_LOOP:
      {				/* cloning boxed value CTYPE_LOOP */
	struct meltloop_st *src = (struct meltloop_st *) srcvalv;
	struct meltloop_st *dst =
	  (struct meltloop_st *) meltgc_allocate (sizeof (struct meltloop_st),
						  0);

	*dst = *src;
	dst->discr = (meltobject_ptr_t) newdiscrv;
	resv = (melt_ptr_t) dst;
      }
      break;
    case MELTOBMAG_MAPLOOPS:
      {				/* cloning map value CTYPE_LOOP */
	struct meltmaploops_st *src = (struct meltmaploops_st *) srcvalv;
	unsigned oldlen = melt_primtab[src->lenix];
	unsigned newlen = 4 * src->count / 3 + 5;
	struct meltmaploops_st *dst =
	  (struct meltmaploops_st *)
	  meltgc_raw_new_mappointers ((meltobject_ptr_t) newdiscrv, newlen);
	unsigned ix = 0;
	dst->meltmap_aux = src->meltmap_aux;
	if (src->entab)
	  for (ix = 0; ix < oldlen; ix++)
	    {
	      melt_ptr_t curva = src->entab[ix].e_va;
	      loop_p curat = src->entab[ix].e_at;
	      if (curva != NULL && curat != (loop_p) HTAB_DELETED_ENTRY)
		meltgc_raw_put_mappointers ((void *) dst,
					    (const void *) curat, curva);
	    }
	resv = (melt_ptr_t) dst;
      };
      break;
      /*cloning gtyctype #7 CTYPE_RTVEC */
    case MELTOBMAG_RTVEC:
      {				/* cloning boxed value CTYPE_RTVEC */
	struct meltrtvec_st *src = (struct meltrtvec_st *) srcvalv;
	struct meltrtvec_st *dst =
	  (struct meltrtvec_st *)
	  meltgc_allocate (sizeof (struct meltrtvec_st), 0);

	*dst = *src;
	dst->discr = (meltobject_ptr_t) newdiscrv;
	resv = (melt_ptr_t) dst;
      }
      break;
    case MELTOBMAG_MAPRTVECS:
      {				/* cloning map value CTYPE_RTVEC */
	struct meltmaprtvecs_st *src = (struct meltmaprtvecs_st *) srcvalv;
	unsigned oldlen = melt_primtab[src->lenix];
	unsigned newlen = 4 * src->count / 3 + 5;
	struct meltmaprtvecs_st *dst =
	  (struct meltmaprtvecs_st *)
	  meltgc_raw_new_mappointers ((meltobject_ptr_t) newdiscrv, newlen);
	unsigned ix = 0;
	dst->meltmap_aux = src->meltmap_aux;
	if (src->entab)
	  for (ix = 0; ix < oldlen; ix++)
	    {
	      melt_ptr_t curva = src->entab[ix].e_va;
	      rtvec curat = src->entab[ix].e_at;
	      if (curva != NULL && curat != (rtvec) HTAB_DELETED_ENTRY)
		meltgc_raw_put_mappointers ((void *) dst,
					    (const void *) curat, curva);
	    }
	resv = (melt_ptr_t) dst;
      };
      break;
      /*cloning gtyctype #8 CTYPE_RTX */
    case MELTOBMAG_RTX:
      {				/* cloning boxed value CTYPE_RTX */
	struct meltrtx_st *src = (struct meltrtx_st *) srcvalv;
	struct meltrtx_st *dst =
	  (struct meltrtx_st *) meltgc_allocate (sizeof (struct meltrtx_st),
						 0);

	*dst = *src;
	dst->discr = (meltobject_ptr_t) newdiscrv;
	resv = (melt_ptr_t) dst;
      }
      break;
    case MELTOBMAG_MAPRTXS:
      {				/* cloning map value CTYPE_RTX */
	struct meltmaprtxs_st *src = (struct meltmaprtxs_st *) srcvalv;
	unsigned oldlen = melt_primtab[src->lenix];
	unsigned newlen = 4 * src->count / 3 + 5;
	struct meltmaprtxs_st *dst =
	  (struct meltmaprtxs_st *)
	  meltgc_raw_new_mappointers ((meltobject_ptr_t) newdiscrv, newlen);
	unsigned ix = 0;
	dst->meltmap_aux = src->meltmap_aux;
	if (src->entab)
	  for (ix = 0; ix < oldlen; ix++)
	    {
	      melt_ptr_t curva = src->entab[ix].e_va;
	      rtx curat = src->entab[ix].e_at;
	      if (curva != NULL && curat != (rtx) HTAB_DELETED_ENTRY)
		meltgc_raw_put_mappointers ((void *) dst,
					    (const void *) curat, curva);
	    }
	resv = (melt_ptr_t) dst;
      };
      break;
      /*cloning gtyctype #9 CTYPE_TREE */
    case MELTOBMAG_TREE:
      {				/* cloning boxed value CTYPE_TREE */
	struct melttree_st *src = (struct melttree_st *) srcvalv;
	struct melttree_st *dst =
	  (struct melttree_st *) meltgc_allocate (sizeof (struct melttree_st),
						  0);

	*dst = *src;
	dst->discr = (meltobject_ptr_t) newdiscrv;
	resv = (melt_ptr_t) dst;
      }
      break;
    case MELTOBMAG_MAPTREES:
      {				/* cloning map value CTYPE_TREE */
	struct meltmaptrees_st *src = (struct meltmaptrees_st *) srcvalv;
	unsigned oldlen = melt_primtab[src->lenix];
	unsigned newlen = 4 * src->count / 3 + 5;
	struct meltmaptrees_st *dst =
	  (struct meltmaptrees_st *)
	  meltgc_raw_new_mappointers ((meltobject_ptr_t) newdiscrv, newlen);
	unsigned ix = 0;
	dst->meltmap_aux = src->meltmap_aux;
	if (src->entab)
	  for (ix = 0; ix < oldlen; ix++)
	    {
	      melt_ptr_t curva = src->entab[ix].e_va;
	      tree curat = src->entab[ix].e_at;
	      if (curva != NULL && curat != (tree) HTAB_DELETED_ENTRY)
		meltgc_raw_put_mappointers ((void *) dst,
					    (const void *) curat, curva);
	    }
	resv = (melt_ptr_t) dst;
      };
      break;

/******* cloning the 19 value descriptors *******/
/** cloning value descriptor #1 VALDESC_BUCKETLONGS **/
      /*explicit cloning for VALDESC_BUCKETLONGS */
    case MELTOBMAG_BUCKETLONGS:
      {
	struct meltbucketlongs_st *src =
	  (struct meltbucketlongs_st *) srcvalv;
	struct meltbucketlongs_st *dst = NULL;
	/* clone chunk for VALDESC_BUCKETLONGS: */
	/* cloning chunk  from VALDESC_BUCKETLONGS in warmelt-base.melt */
	unsigned lnix = src->buckl_lenix;
	unsigned len = melt_primtab[lnix];
	unsigned cnt = src->buckl_ucount;
	unsigned dstlen = 0;
	unsigned ix = 0;
	gcc_assert (lnix > 0);
	gcc_assert (len > 0);
	gcc_assert (cnt <= len);
	dst = (struct meltbucketlongs_st *)
	  meltgc_new_longsbucket ((meltobject_ptr_t) newdiscrv,
				  cnt + cnt / 8 + 2);
	dstlen = melt_primtab[dst->buckl_lenix];
	dst->buckl_aux = src->buckl_aux;
	dst->buckl_xnum = src->buckl_xnum;
	dst->buckl_lenix = src->buckl_lenix;
	for (ix = 0; ix < cnt; ix++)
	  dst->buckl_entab[ix] = src->buckl_entab[ix];
	for (ix = cnt; ix < dstlen; ix++)
	  {
	    dst->buckl_entab[ix].ebl_at = 0L;
	    dst->buckl_entab[ix].ebl_va = NULL;
	  }
	/* end clone chunk VALDESC_BUCKETLONGS */
	;
	if (dst)
	  resv = (melt_ptr_t) dst;
      };
      break;
/** cloning value descriptor #2 VALDESC_CLOSURE **/
      /*explicit cloning for VALDESC_CLOSURE */
    case MELTOBMAG_CLOSURE:
      {
	struct meltclosure_st *src = (struct meltclosure_st *) srcvalv;
	struct meltclosure_st *dst = NULL;
	/* clone chunk for VALDESC_CLOSURE: */
	/* cloning from VALDESC_CLOSURE */
	unsigned nbval = (int) src->nbval;
	unsigned ix = 0;
	dst
	  =
	  (struct meltclosure_st *)
	  meltgc_allocate (sizeof (struct meltclosure_st),
			   nbval * sizeof (void *));
	src = (struct meltclosure_st *) srcvalv;
	dst->discr = (meltobject_ptr_t) newdiscrv;
	dst->rout = src->rout;
	for (ix = 0; ix < nbval; ix++)
	  dst->tabval[ix] = src->tabval[ix];
	/* end cloning from VALDESC_CLOSURE */
	;
	if (dst)
	  resv = (melt_ptr_t) dst;
      };
      break;
/** cloning value descriptor #3 VALDESC_DECAY **/
      /*default cloning for VALDESC_DECAY */
    case MELTOBMAG_DECAY:
      {
	struct meltdecay_st *src = (struct meltdecay_st *) srcvalv;
	struct meltdecay_st *dst =
	  (struct meltdecay_st *)
	  meltgc_allocate (sizeof (struct meltdecay_st), 0);
	*dst = *src;
	dst->discr = (meltobject_ptr_t) newdiscrv;
	resv = (melt_ptr_t) dst;
      }
      break;
/** cloning value descriptor #4 VALDESC_HOOK **/
      /*no cloning for VALDESC_HOOK */
    case MELTOBMAG_HOOK:
      break;
/** cloning value descriptor #5 VALDESC_INT **/
      /*default cloning for VALDESC_INT */
    case MELTOBMAG_INT:
      {
	struct meltint_st *src = (struct meltint_st *) srcvalv;
	struct meltint_st *dst =
	  (struct meltint_st *) meltgc_allocate (sizeof (struct meltint_st),
						 0);
	*dst = *src;
	dst->discr = (meltobject_ptr_t) newdiscrv;
	resv = (melt_ptr_t) dst;
      }
      break;
/** cloning value descriptor #6 VALDESC_LIST **/
      /*explicit cloning for VALDESC_LIST */
    case MELTOBMAG_LIST:
      {
	struct meltlist_st *src = (struct meltlist_st *) srcvalv;
	struct meltlist_st *dst = NULL;
	/* clone chunk for VALDESC_LIST: */
	/* cloning from VALDESC_LIST */
	struct meltpair_st *curpair = NULL;
	resv = dst =
	  (struct meltlist_st *) meltgc_new_list ((meltobject_ptr_t)
						  newdiscrv);
	src = (struct meltlist_st *) srcvalv;
	for (curpair = ((struct meltlist_st *) src)->first;
	     melt_magic_discr ((melt_ptr_t) curpair) == MELTOBMAG_PAIR;
	     curpair = (struct meltpair_st *) (curpair->tl))
	  {
	    src = (struct meltlist_st *) srcvalv;
	    dst = (struct meltlist_st *) resv;
	    compv = curpair;
	    meltgc_append_list ((melt_ptr_t) resv, curpair->hd);
	    /* copy, because GC might have moved values. */
	    curpair = (struct meltpair_st *) compv;
	    src = (struct meltlist_st *) srcvalv;
	    dst = (struct meltlist_st *) resv;
	  }
	/* end cloning from VALDESC_LIST */
	;
	if (dst)
	  resv = (melt_ptr_t) dst;
      };
      break;
/** cloning value descriptor #7 VALDESC_MAPOBJECTS **/
      /*explicit cloning for VALDESC_MAPOBJECTS */
    case MELTOBMAG_MAPOBJECTS:
      {
	struct meltmapobjects_st *src = (struct meltmapobjects_st *) srcvalv;
	struct meltmapobjects_st *dst = NULL;
	/* clone chunk for VALDESC_MAPOBJECTS: */
	/* cloning, from VALDESC_MAPOBJECTS */
	unsigned srccount = src->count;
	unsigned srclen = melt_primtab[src->lenix];
	unsigned newlen = 4 * srccount / 3 + 4;
	unsigned srcix = 0;
	dst = (struct meltmapobjects_st *)
	  meltgc_new_mapobjects ((meltobject_ptr_t) newdiscrv, newlen);
	resv = dst;
	dst->meltmap_aux = src->meltmap_aux;
	for (srcix = 0; srcix < srclen; srcix++)
	  {
	    meltobject_ptr_t curat = NULL;
	    melt_ptr_t curva = NULL;
	    src = (struct meltmapobjects_st *) srcvalv;
	    curat = src->entab[srcix].e_at;
	    curva = src->entab[srcix].e_va;
	    if (!curat || curat == (meltobject_ptr_t) HTAB_DELETED_ENTRY
		|| !curva)
	      continue;
	    meltgc_put_mapobjects ((meltmapobjects_ptr_t) resv, curat, curva);
	    /* update the dst, since it could have moved */
	    dst = (struct meltmapobjects_st *) resv;
	  }			/* end cloning, from VALDESC_MAPOBJECTS */
	;
	if (dst)
	  resv = (melt_ptr_t) dst;
      };
      break;
/** cloning value descriptor #8 VALDESC_MAPSTRINGS **/
      /*explicit cloning for VALDESC_MAPSTRINGS */
    case MELTOBMAG_MAPSTRINGS:
      {
	struct meltmapstrings_st *src = (struct meltmapstrings_st *) srcvalv;
	struct meltmapstrings_st *dst = NULL;
	/* clone chunk for VALDESC_MAPSTRINGS: */
	/* cloning from VALDESC_MAPSTRINGS */
	unsigned srccount = src->count;
	unsigned srclen = melt_primtab[src->lenix];
	unsigned newlen = 4 * srccount / 3 + 4;
	unsigned srcix = 0;
	dst =
	  (struct meltmapstrings_st *)
	  meltgc_new_mapstrings ((meltobject_ptr_t) newdiscrv, newlen);
	resv = dst;
	dst->meltmap_aux = src->meltmap_aux;
	for (srcix = 0; srcix < srclen; srcix++)
	  {
	    const char *curat = NULL;
	    melt_ptr_t curva = NULL;
	    src = (struct meltmapstrings_st *) srcvalv;
	    dst = (struct meltmapstrings_st *) resv;
	    curat = src->entab[srcix].e_at;
	    if (!curat || curat == (const char *) HTAB_DELETED_ENTRY
		|| !curat[0])
	      continue;
	    curva = src->entab[srcix].e_va;
	    if (!curva)
	      continue;
	    meltgc_put_mapstrings (dst, curat, curva);
	    dst = (struct meltmapstrings_st *) resv;
	  }
	/* end  cloning from VALDESC_MAPSTRINGS */
	;
	if (dst)
	  resv = (melt_ptr_t) dst;
      };
      break;
/** cloning value descriptor #9 VALDESC_MIXBIGINT **/
      /*no cloning for VALDESC_MIXBIGINT */
    case MELTOBMAG_MIXBIGINT:
      break;
/** cloning value descriptor #10 VALDESC_MIXINT **/
      /*default cloning for VALDESC_MIXINT */
    case MELTOBMAG_MIXINT:
      {
	struct meltmixint_st *src = (struct meltmixint_st *) srcvalv;
	struct meltmixint_st *dst =
	  (struct meltmixint_st *)
	  meltgc_allocate (sizeof (struct meltmixint_st), 0);
	*dst = *src;
	dst->discr = (meltobject_ptr_t) newdiscrv;
	resv = (melt_ptr_t) dst;
      }
      break;
/** cloning value descriptor #11 VALDESC_MIXLOC **/
      /*default cloning for VALDESC_MIXLOC */
    case MELTOBMAG_MIXLOC:
      {
	struct meltmixloc_st *src = (struct meltmixloc_st *) srcvalv;
	struct meltmixloc_st *dst =
	  (struct meltmixloc_st *)
	  meltgc_allocate (sizeof (struct meltmixloc_st), 0);
	*dst = *src;
	dst->discr = (meltobject_ptr_t) newdiscrv;
	resv = (melt_ptr_t) dst;
      }
      break;
/** cloning value descriptor #12 VALDESC_MULTIPLE **/
      /*explicit cloning for VALDESC_MULTIPLE */
    case MELTOBMAG_MULTIPLE:
      {
	struct meltmultiple_st *src = (struct meltmultiple_st *) srcvalv;
	struct meltmultiple_st *dst = NULL;
	/* clone chunk for VALDESC_MULTIPLE: */
	/* cloning from VALDESC_MULTIPLE */
	unsigned srclen = src->nbval;
	unsigned srcix = 0;
	resv = dst =
	  (struct meltmultiple_st *) meltgc_new_multiple ((meltobject_ptr_t)
							  newdiscrv, srclen);
	src = (struct meltmultiple_st *) srcvalv;	/* could have moved */
	for (srcix = 0; srcix < srclen; srcix++)
	  dst->tabval[srcix] = src->tabval[srcix];
	/* end cloning from VALDESC_MULTIPLE */
	;
	if (dst)
	  resv = (melt_ptr_t) dst;
      };
      break;
/** cloning value descriptor #13 VALDESC_OBJECT **/
      /*explicit cloning for VALDESC_OBJECT */
    case MELTOBMAG_OBJECT:
      {
	struct meltobject_st *src = (struct meltobject_st *) srcvalv;
	struct meltobject_st *dst = NULL;
	/* clone chunk for VALDESC_OBJECT: */
	/* cloning, from VALDESC_OBJECT */
	unsigned newlen = 0;
	unsigned srclen = src->obj_len;
	unsigned slotix = 0;
	if (melt_is_subclass_of ((meltobject_ptr_t) srcdiscrv,
				 (meltobject_ptr_t) newdiscrv))
	  {
	    newlen =
	      melt_multiple_length ((melt_ptr_t)
				    (((meltobject_ptr_t) newdiscrv)->
				     obj_vartab[MELTFIELD_CLASS_FIELDS]));
	    gcc_assert (newlen <= srclen);
	    dst =
	      meltgc_new_raw_object ((meltobject_ptr_t) newdiscrv, newlen);
	    for (slotix = 0; slotix < newlen; slotix++)
	      dst->obj_vartab[slotix] = src->obj_vartab[slotix];
	    dst->obj_num = src->obj_num;
	  }
	else if (melt_is_subclass_of ((meltobject_ptr_t) newdiscrv,
				      (meltobject_ptr_t) srcdiscrv))
	  {
	    newlen =
	      melt_multiple_length ((melt_ptr_t)
				    (((meltobject_ptr_t) newdiscrv)->
				     obj_vartab[MELTFIELD_CLASS_FIELDS]));
	    gcc_assert (newlen >= srclen);
	    dst =
	      meltgc_new_raw_object ((meltobject_ptr_t) newdiscrv, newlen);
	    for (slotix = 0; slotix < srclen; slotix++)
	      dst->obj_vartab[slotix] = src->obj_vartab[slotix];
	    dst->obj_num = src->obj_num;
	  }
#if ENABLE_CHECKING
	/* for low level debugging with gdb, we may want to catch some clone operations */
	if (melt_alptr_1 && (void *) src == melt_alptr_1)
	  melt_break_alptr_1 ("cloneobj src=alptr1");
	if (melt_alptr_2 && (void *) src == melt_alptr_2)
	  melt_break_alptr_2 ("cloneobj src=alptr2");
	if (src->obj_hash == melt_objhash_1)
	  melt_break_objhash_1 ("cloneobj src with objhash1");
	if (src->obj_hash == melt_objhash_2)
	  melt_break_objhash_2 ("cloneobj src with objhash2");
#endif /* ENABLE_CHECKING */
	;
	if (dst)
	  resv = (melt_ptr_t) dst;
      };
      break;
/** cloning value descriptor #14 VALDESC_PAIR **/
      /*default cloning for VALDESC_PAIR */
    case MELTOBMAG_PAIR:
      {
	struct meltpair_st *src = (struct meltpair_st *) srcvalv;
	struct meltpair_st *dst =
	  (struct meltpair_st *) meltgc_allocate (sizeof (struct meltpair_st),
						  0);
	*dst = *src;
	dst->discr = (meltobject_ptr_t) newdiscrv;
	resv = (melt_ptr_t) dst;
      }
      break;
/** cloning value descriptor #15 VALDESC_REAL **/
      /*default cloning for VALDESC_REAL */
    case MELTOBMAG_REAL:
      {
	struct meltreal_st *src = (struct meltreal_st *) srcvalv;
	struct meltreal_st *dst =
	  (struct meltreal_st *) meltgc_allocate (sizeof (struct meltreal_st),
						  0);
	*dst = *src;
	dst->discr = (meltobject_ptr_t) newdiscrv;
	resv = (melt_ptr_t) dst;
      }
      break;
/** cloning value descriptor #16 VALDESC_ROUTINE **/
      /*no cloning for VALDESC_ROUTINE */
    case MELTOBMAG_ROUTINE:
      break;
/** cloning value descriptor #17 VALDESC_SPECIAL_DATA **/
      /*no cloning for VALDESC_SPECIAL_DATA */
    case MELTOBMAG_SPECIAL_DATA:
      break;
/** cloning value descriptor #18 VALDESC_STRBUF **/
      /*explicit cloning for VALDESC_STRBUF */
    case MELTOBMAG_STRBUF:
      {
	struct meltstrbuf_st *src = (struct meltstrbuf_st *) srcvalv;
	struct meltstrbuf_st *dst = NULL;
	/* clone chunk for VALDESC_STRBUF: */
	/* clone chunk from VALDESC_STRBUF */
	resv = dst = (struct meltstrbuf_st *)
	  meltgc_new_strbuf ((meltobject_ptr_t) newdiscrv, NULL);
	src = (struct meltstrbuf_st *) srcvalv;
	meltgc_add_strbuf ((melt_ptr_t) dst,
			   melt_strbuf_str ((melt_ptr_t) src));
	/* end clone chunk from VALDESC_STRBUF */
	;
	if (dst)
	  resv = (melt_ptr_t) dst;
      };
      break;
/** cloning value descriptor #19 VALDESC_STRING **/
      /*explicit cloning for VALDESC_STRING */
    case MELTOBMAG_STRING:
      {
	struct meltstring_st *src = (struct meltstring_st *) srcvalv;
	struct meltstring_st *dst = NULL;
	/* clone chunk for VALDESC_STRING: */
	/* clone from VALDESC_STRING  */
	dst = (struct meltstring_st *)
	  meltgc_new_stringdup ((meltobject_ptr_t) newdiscrv, src->val);
	/* end clone from VALDESC_STRING  */
	;
	if (dst)
	  resv = (melt_ptr_t) dst;
      };
      break;

/* generated cloning routine trailer */
    default:;
    }				/*end switch srcmagic for cloning */
end:
  MELT_EXITFRAME ();
  return (melt_ptr_t) resv;
}				/* end of generated meltgc_clone_with_discriminant */

#undef resv
#undef srcvalv
#undef newdiscrv
#undef discrv
#undef compv


/*code generated by generate_runtypesupport_predefined_hooks for 112 predefined */









































































































/*predefined hook definition HOOK_OVERRIDE_GATE  #106*/
void
melthookproc_HOOK_OVERRIDE_GATE (long meltin_BEFOREGATE_p0,
				 long *meltout_AFTERGATE_o0)
{
#ifndef MELT_SKIP_HOOK_PREDEFINED_CODE
  typedef void melthooksig_HOOK_OVERRIDE_GATE_t (melt_ptr_t, long, long *);
  /*checkhook */ melt_assertmsg (" good hook HOOK_OVERRIDE_GATE",
				 melt_magic_discr ((melt_ptr_t)
						   MELT_PREDEF
						   (HOOK_OVERRIDE_GATE)) ==
				 MELTOBMAG_HOOK);

  melthooksig_HOOK_OVERRIDE_GATE_t *melthookptr_HOOK_OVERRIDE_GATE =
    (melthooksig_HOOK_OVERRIDE_GATE_t
     *) (((melthook_ptr_t) MELT_PREDEF (HOOK_OVERRIDE_GATE))->hookad);
  melt_assertmsg ("good hook routine HOOK_OVERRIDE_GATE",
		  melthookptr_HOOK_OVERRIDE_GATE);
  return (*melthookptr_HOOK_OVERRIDE_GATE) (MELT_PREDEF (HOOK_OVERRIDE_GATE),
					    meltin_BEFOREGATE_p0,
					    meltout_AFTERGATE_o0);
#endif /* MELT_SKIP_HOOK_PREDEFINED_CODE */
}				/* end  melthookproc_HOOK_OVERRIDE_GATE */








/* end of code generated by generate_runtypesupport_predefined_hooks for 112 predefined */

/*** End of code file meltbuild-sources/generated/meltrunsup-inc.c generated on 2013 May 14
 * by GCC MELT 4.8.0 20130314 (experimental) [melt-branch revision 198815] MELT_0.9.9-pre . ***/
