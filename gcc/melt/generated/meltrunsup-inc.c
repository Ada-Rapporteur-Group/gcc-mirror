/** Copyright (C) 2011 Free Software Foundation, Inc.
  This generated file meltrunsup-inc.c is part of GCC.

                  [DON'T EDIT THIS GENERATED FILE]

    GCC is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.

    GCC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.
**/




/* start of code generated by generate_runtypesupport_cod2ctype */
melt_ptr_t
melt_code_to_ctype (int code)
{
  switch (code)
    {

      /* #1: CTYPE_BASIC_BLOCK */
    case MELTBPAR_BB:
      return MELT_PREDEF (CTYPE_BASIC_BLOCK);
      /* #2: CTYPE_BITMAP */
    case MELTBPAR_BITMAP:
      return MELT_PREDEF (CTYPE_BITMAP);
      /* #3: CTYPE_CSTRING */
    case MELTBPAR_CSTRING:
      return MELT_PREDEF (CTYPE_CSTRING);
      /* #4: CTYPE_EDGE */
    case MELTBPAR_EDGE:
      return MELT_PREDEF (CTYPE_EDGE);
      /* #5: CTYPE_GIMPLE */
    case MELTBPAR_GIMPLE:
      return MELT_PREDEF (CTYPE_GIMPLE);
      /* #6: CTYPE_GIMPLE_SEQ */
    case MELTBPAR_GIMPLESEQ:
      return MELT_PREDEF (CTYPE_GIMPLE_SEQ);
      /* #7: CTYPE_LONG */
    case MELTBPAR_LONG:
      return MELT_PREDEF (CTYPE_LONG);
      /* #8: CTYPE_LOOP */
    case MELTBPAR_LOOP:
      return MELT_PREDEF (CTYPE_LOOP);
      /* #9: CTYPE_PPL_COEFFICIENT */
    case MELTBPAR_PPL_COEFFICIENT:
      return MELT_PREDEF (CTYPE_PPL_COEFFICIENT);
      /* #10: CTYPE_PPL_CONSTRAINT */
    case MELTBPAR_PPL_CONSTRAINT:
      return MELT_PREDEF (CTYPE_PPL_CONSTRAINT);
      /* #11: CTYPE_PPL_CONSTRAINT_SYSTEM */
    case MELTBPAR_PPL_CONSTRAINT_SYSTEM:
      return MELT_PREDEF (CTYPE_PPL_CONSTRAINT_SYSTEM);
      /* #12: CTYPE_PPL_LINEAR_EXPRESSION */
    case MELTBPAR_PPL_LINEAR_EXPRESSION:
      return MELT_PREDEF (CTYPE_PPL_LINEAR_EXPRESSION);
      /* #13: CTYPE_PPL_POLYHEDRON */
    case MELTBPAR_PPL_POLYHEDRON:
      return MELT_PREDEF (CTYPE_PPL_POLYHEDRON);
      /* #14: CTYPE_RTVEC */
    case MELTBPAR_RTVEC:
      return MELT_PREDEF (CTYPE_RTVEC);
      /* #15: CTYPE_RTX */
    case MELTBPAR_RTX:
      return MELT_PREDEF (CTYPE_RTX);
      /* #16: CTYPE_TREE */
    case MELTBPAR_TREE:
      return MELT_PREDEF (CTYPE_TREE);
      /* #17: CTYPE_VALUE */
    case MELTBPAR_PTR:
      return MELT_PREDEF (CTYPE_VALUE);
      /* #18: CTYPE_VOID */

    default:
      break;
    }				/*end switch code */
  return NULL;
}				/* end of generated melt_code_to_ctype */



/** start of code generated by generate_runtypesupport_mag2str **/
const char *
melt_obmag_string (int i)
{
#define MELT_MAG2STR_CACHEBUF 17
#define MELT_MAG2STR_MAGLEN   16
  static char melt_cacheobmagbuf[MELT_MAG2STR_CACHEBUF][MELT_MAG2STR_MAGLEN];
  switch (i)
    {
    case 0:
      return "MeltObMag!0";
      /*gtyctype #1 CTYPE_BASIC_BLOCK */
    case MELTOBMAG_BASICBLOCK:
      return "MELTOBMAG_BASICBLOCK";
    case MELTOBMAG_MAPBASICBLOCKS:
      return "MELTOBMAG_MAPBASICBLOCKS";

      /*gtyctype #2 CTYPE_BITMAP */
    case MELTOBMAG_BITMAP:
      return "MELTOBMAG_BITMAP";
    case MELTOBMAG_MAPBITMAPS:
      return "MELTOBMAG_MAPBITMAPS";

      /*gtyctype #3 CTYPE_CSTRING */
      /*runtypesupport_mag2str no boxed magic */
      /*runtypesupport_mag2str no map magic */

      /*gtyctype #4 CTYPE_EDGE */
    case MELTOBMAG_EDGE:
      return "MELTOBMAG_EDGE";
    case MELTOBMAG_MAPEDGES:
      return "MELTOBMAG_MAPEDGES";

      /*gtyctype #5 CTYPE_GIMPLE */
    case MELTOBMAG_GIMPLE:
      return "MELTOBMAG_GIMPLE";
    case MELTOBMAG_MAPGIMPLES:
      return "MELTOBMAG_MAPGIMPLES";

      /*gtyctype #6 CTYPE_GIMPLE_SEQ */
    case MELTOBMAG_GIMPLESEQ:
      return "MELTOBMAG_GIMPLESEQ";
    case MELTOBMAG_MAPGIMPLESEQS:
      return "MELTOBMAG_MAPGIMPLESEQS";

      /*gtyctype #7 CTYPE_LONG */
      /*runtypesupport_mag2str no boxed magic */
      /*runtypesupport_mag2str no map magic */

      /*gtyctype #8 CTYPE_LOOP */
    case MELTOBMAG_LOOP:
      return "MELTOBMAG_LOOP";
    case MELTOBMAG_MAPLOOPS:
      return "MELTOBMAG_MAPLOOPS";

      /*gtyctype #9 CTYPE_PPL_COEFFICIENT */
      /*runtypesupport_mag2str no boxed magic */
      /*runtypesupport_mag2str no map magic */

      /*gtyctype #10 CTYPE_PPL_CONSTRAINT */
      /*runtypesupport_mag2str no boxed magic */
      /*runtypesupport_mag2str no map magic */

      /*gtyctype #11 CTYPE_PPL_CONSTRAINT_SYSTEM */
      /*runtypesupport_mag2str no boxed magic */
      /*runtypesupport_mag2str no map magic */

      /*gtyctype #12 CTYPE_PPL_LINEAR_EXPRESSION */
      /*runtypesupport_mag2str no boxed magic */
      /*runtypesupport_mag2str no map magic */

      /*gtyctype #13 CTYPE_PPL_POLYHEDRON */
      /*runtypesupport_mag2str no boxed magic */
      /*runtypesupport_mag2str no map magic */

      /*gtyctype #14 CTYPE_RTVEC */
    case MELTOBMAG_RTVEC:
      return "MELTOBMAG_RTVEC";
    case MELTOBMAG_MAPRTVECS:
      return "MELTOBMAG_MAPRTVECS";

      /*gtyctype #15 CTYPE_RTX */
    case MELTOBMAG_RTX:
      return "MELTOBMAG_RTX";
    case MELTOBMAG_MAPRTXS:
      return "MELTOBMAG_MAPRTXS";

      /*gtyctype #16 CTYPE_TREE */
    case MELTOBMAG_TREE:
      return "MELTOBMAG_TREE";
    case MELTOBMAG_MAPTREES:
      return "MELTOBMAG_MAPTREES";

      /*gtyctype #17 CTYPE_VALUE */
      /*runtypesupport_mag2str no boxed magic */
      /*runtypesupport_mag2str no map magic */

      /*gtyctype #18 CTYPE_VOID */
      /*runtypesupport_mag2str no boxed magic */
      /*runtypesupport_mag2str no map magic */


      /*valdesc #1 VALDESC_CLOSURE */
    case MELTOBMAG_CLOSURE:
      return "MELTOBMAG_CLOSURE";

      /*valdesc #2 VALDESC_DECAY */
    case MELTOBMAG_DECAY:
      return "MELTOBMAG_DECAY";

      /*valdesc #3 VALDESC_INT */
    case MELTOBMAG_INT:
      return "MELTOBMAG_INT";

      /*valdesc #4 VALDESC_LIST */
    case MELTOBMAG_LIST:
      return "MELTOBMAG_LIST";

      /*valdesc #5 VALDESC_MAPOBJECTS */
    case MELTOBMAG_MAPOBJECTS:
      return "MELTOBMAG_MAPOBJECTS";

      /*valdesc #6 VALDESC_MAPSTRINGS */
    case MELTOBMAG_MAPSTRINGS:
      return "MELTOBMAG_MAPSTRINGS";

      /*valdesc #7 VALDESC_MIXBIGINT */
    case MELTOBMAG_MIXBIGINT:
      return "MELTOBMAG_MIXBIGINT";

      /*valdesc #8 VALDESC_MIXINT */
    case MELTOBMAG_MIXINT:
      return "MELTOBMAG_MIXINT";

      /*valdesc #9 VALDESC_MIXLOC */
    case MELTOBMAG_MIXLOC:
      return "MELTOBMAG_MIXLOC";

      /*valdesc #10 VALDESC_MULTIPLE */
    case MELTOBMAG_MULTIPLE:
      return "MELTOBMAG_MULTIPLE";

      /*valdesc #11 VALDESC_OBJECT */
    case MELTOBMAG_OBJECT:
      return "MELTOBMAG_OBJECT";

      /*valdesc #12 VALDESC_PAIR */
    case MELTOBMAG_PAIR:
      return "MELTOBMAG_PAIR";

      /*valdesc #13 VALDESC_REAL */
    case MELTOBMAG_REAL:
      return "MELTOBMAG_REAL";

      /*valdesc #14 VALDESC_ROUTINE */
    case MELTOBMAG_ROUTINE:
      return "MELTOBMAG_ROUTINE";

      /*valdesc #15 VALDESC_SPECIAL_FILE */
    case MELTOBMAG_SPEC_FILE:
      return "MELTOBMAG_SPEC_FILE";

      /*valdesc #16 VALDESC_SPECIAL_MPFR */
    case MELTOBMAG_SPEC_MPFR:
      return "MELTOBMAG_SPEC_MPFR";

      /*valdesc #17 VALDESC_SPECIAL_PPL_COEFFICIENT */
    case MELTOBMAG_SPECPPL_COEFFICIENT:
      return "MELTOBMAG_SPECPPL_COEFFICIENT";

      /*valdesc #18 VALDESC_SPECIAL_PPL_CONSTRAINT */
    case MELTOBMAG_SPECPPL_CONSTRAINT:
      return "MELTOBMAG_SPECPPL_CONSTRAINT";

      /*valdesc #19 VALDESC_SPECIAL_PPL_CONSTRAINT_SYSTEM */
    case MELTOBMAG_SPECPPL_CONSTRAINT_SYSTEM:
      return "MELTOBMAG_SPECPPL_CONSTRAINT_SYSTEM";

      /*valdesc #20 VALDESC_SPECIAL_PPL_GENERATOR */
    case MELTOBMAG_SPECPPL_GENERATOR:
      return "MELTOBMAG_SPECPPL_GENERATOR";

      /*valdesc #21 VALDESC_SPECIAL_PPL_GENERATOR_SYSTEM */
    case MELTOBMAG_SPECPPL_GENERATOR_SYSTEM:
      return "MELTOBMAG_SPECPPL_GENERATOR_SYSTEM";

      /*valdesc #22 VALDESC_SPECIAL_PPL_LINEAR_EXPRESSION */
    case MELTOBMAG_SPECPPL_LINEAR_EXPRESSION:
      return "MELTOBMAG_SPECPPL_LINEAR_EXPRESSION";

      /*valdesc #23 VALDESC_SPECIAL_PPL_POLYHEDRON */
    case MELTOBMAG_SPECPPL_POLYHEDRON:
      return "MELTOBMAG_SPECPPL_POLYHEDRON";

      /*valdesc #24 VALDESC_SPECIAL_RAW_FILE */
    case MELTOBMAG_SPEC_RAWFILE:
      return "MELTOBMAG_SPEC_RAWFILE";

      /*valdesc #25 VALDESC_STRBUF */
    case MELTOBMAG_STRBUF:
      return "MELTOBMAG_STRBUF";

      /*valdesc #26 VALDESC_STRING */
    case MELTOBMAG_STRING:
      return "MELTOBMAG_STRING";
    default:
      {
	int ix = (i & 0x3ffffff) % MELT_MAG2STR_CACHEBUF;
	snprintf (melt_cacheobmagbuf[ix], MELT_MAG2STR_MAGLEN - 1,
		  "?MeltObjMag?%d", i);
	return melt_cacheobmagbuf[ix];
      }
    }				/* end switch */
}				/* end generated melt_obmag_string */

/** end of code generated by generate_runtypesupport_mag2str **/


/** generated by generate_runtypesupport_forwcopy_fun **/

/* cheney like forwarding generated function */
melt_ptr_t
melt_forwarded_copy (melt_ptr_t p)
{				/* header generated by generate_runtypesupport_forwcopy_fun */
  melt_ptr_t n = 0;
  int mag = 0;
  gcc_assert (melt_is_young (p));
  gcc_assert (p->u_discr && p->u_discr != MELT_FORWARDED_DISCR);
  if (p->u_discr->meltobj_class == MELT_FORWARDED_DISCR)
    mag =
      ((meltobject_ptr_t)
       (((struct meltforward_st *) p->u_discr)->forward))->meltobj_magic;
  else
    mag = p->u_discr->meltobj_magic;
  melt_forward_counter++;
  switch (mag)
    {				/* end of generated header */

      /* value descriptor forward copy for melt_forwarded_copy  */

      /*valdesc #1 VALDESC_CLOSURE */
    case MELTOBMAG_CLOSURE:
      {
	struct meltclosure_st *src = (struct meltclosure_st *) p;
	struct meltclosure_st *dst = NULL;
	/* copy VALDESC_CLOSURE in warmelt-base.melt  */
/* ggc_alloc_meltclosure_st should be gengtype generated for VALDESC_CLOSURE */
#ifndef ggc_alloc_meltclosure_st
#define ggc_alloc_meltclosure_st(SIZE) ((struct meltclosure_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif
	int nbv = (int) src->nbval;
	int ix = 0;
	dst =
	  /* Don't need a cleared allocation!  */
	  ggc_alloc_meltclosure_st
	  (nbv * sizeof (void *) + offsetof (struct meltclosure_st, tabval));
	dst->discr = src->discr;
	dst->rout = src->rout;
	dst->nbval = (unsigned) nbv;
	for (ix = 0; ix < nbv; ix++)
	  dst->tabval[ix] = src->tabval[ix];

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #2 VALDESC_DECAY */
    case MELTOBMAG_DECAY:
      {
	struct meltdecay_st *src = (struct meltdecay_st *) p;
	struct meltdecay_st *dst = NULL;
	/* from VALDESC_DECAY */
/* ggc_alloc_meltdecay_st should be gengtype generated for VALDESC_DECAY */
#ifndef ggc_alloc_meltdecay_st
#define ggc_alloc_meltdecay_st() ((struct meltdecay_st *)(ggc_internal_alloc_stat (sizeof (struct meltdecay_st) MEM_STAT_INFO)))
#endif
	dst = ggc_alloc_meltdecay_st ();
	*dst = *src;

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #3 VALDESC_INT */
    case MELTOBMAG_INT:
      {
	struct meltint_st *src = (struct meltint_st *) p;
	struct meltint_st *dst = NULL;
	/* from VALDESC_INT */
/* ggc_alloc_meltint_st should be gengtype generated for VALDESC_INT */
#ifndef ggc_alloc_meltint_st
#define ggc_alloc_meltint_st() ((struct meltint_st *)(ggc_internal_alloc_stat (sizeof (struct meltint_st) MEM_STAT_INFO)))
#endif
	dst =
	  /* Don't need a cleared allocation.  */
	  ggc_alloc_meltint_st ();
	*dst = *src;

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #4 VALDESC_LIST */
    case MELTOBMAG_LIST:
      {
	struct meltlist_st *src = (struct meltlist_st *) p;
	struct meltlist_st *dst = NULL;
	/* from VALDESC_LIST */
/* ggc_alloc_meltlist_st should be gengtype gengtype for VALDESC_LIST */
#ifndef ggc_alloc_meltlist_st
#define ggc_alloc_meltlist_st() ((struct meltlist_st *)(ggc_internal_alloc_stat (sizeof (struct meltlist_st) MEM_STAT_INFO)))
#endif
	dst =
	  /* Don't need a cleared allocation!  */
	  ggc_alloc_meltlist_st ();
	*dst = *src;

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #5 VALDESC_MAPOBJECTS */
    case MELTOBMAG_MAPOBJECTS:
      {
	struct meltmapobjects_st *src = (struct meltmapobjects_st *) p;
	struct meltmapobjects_st *dst = NULL;
	/* copy VALDESC_MAPOBJECTS in warmelt-base.melt */
/* ggc_alloc_meltmapobjects_st should be gengtype generated for VALDESC_MAPOBJECTS */
#ifndef ggc_alloc_meltmapobjects_st
#define ggc_alloc_meltmapobjects_st() ((struct meltmapobjects_st *)(ggc_internal_alloc_stat (sizeof (struct meltmapobjects_st) MEM_STAT_INFO)))
#endif
#ifndef ggc_alloc_vec_entryobjectsmelt_st
#define ggc_alloc_vec_entryobjectsmelt_st(n) ((struct entryobjectsmelt_st *)(ggc_internal_vec_alloc_stat (sizeof (struct entryobjectsmelt_st), n MEM_STAT_INFO)))
#endif
#ifndef  ggc_alloc_cleared_vec_entryobjectsmelt_st
#define ggc_alloc_cleared_vec_entryobjectsmelt_st(n) ((struct entryobjectsmelt_st *)(ggc_internal_cleared_vec_alloc_stat (sizeof (struct entryobjectsmelt_st), n MEM_STAT_INFO)))
#endif
	int siz = melt_primtab[src->lenix];
	dst =
	  /* Don't need a cleared allocation.  */
	  ggc_alloc_meltmapobjects_st ();
	dst->discr = src->discr;
	dst->count = src->count;
	dst->lenix = src->lenix;
	if (siz > 0 && src->entab)
	  {
	    /* Don't need a cleared allocation.  */
	    dst->entab = ggc_alloc_vec_entryobjectsmelt_st (siz);
	    memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
	  }
	else
	  dst->entab = NULL;

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #6 VALDESC_MAPSTRINGS */
    case MELTOBMAG_MAPSTRINGS:
      {
	struct meltmapstrings_st *src = (struct meltmapstrings_st *) p;
	struct meltmapstrings_st *dst = NULL;
	/* copy VALDESC_MAPSTRINGS in warmelt-base.melt */
/* ggc_alloc_meltmapstrings_st should be gengtype generated for VALDESC_MAPSTRINGS */
#ifndef ggc_alloc_meltmapstrings_st
#define ggc_alloc_meltmapstrings_st() ((struct meltmapstrings_st *)(ggc_internal_alloc_stat (sizeof (struct meltmapstrings_st) MEM_STAT_INFO)))
#endif
#ifndef ggc_alloc_vec_entrystringsmelt_st
#define ggc_alloc_vec_entrystringsmelt_st(n) ((struct entrystringsmelt_st *)(ggc_internal_vec_alloc_stat (sizeof (struct entrystringsmelt_st), n MEM_STAT_INFO)))
#endif
#ifndef ggc_alloc_cleared_vec_entrystringsmelt_st
#define ggc_alloc_cleared_vec_entrystringsmelt_st(n) ((struct entrystringsmelt_st *)(ggc_internal_cleared_vec_alloc_stat (sizeof (struct entrystringsmelt_st), n MEM_STAT_INFO)))
#endif
	int siz = melt_primtab[src->lenix];
	dst =
	  /* Don't need a cleared allocation.  */
	  ggc_alloc_meltmapstrings_st ();
	dst->discr = src->discr;
	dst->count = src->count;
	dst->lenix = src->lenix;
	if (siz > 0 && src->entab)
	  {
	    /* Don't need a cleared allocation.  */
	    dst->entab = ggc_alloc_vec_entrystringsmelt_st (siz);
	    memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
	  }
	else
	  dst->entab = NULL;

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #7 VALDESC_MIXBIGINT */
    case MELTOBMAG_MIXBIGINT:
      {
	struct meltmixbigint_st *src = (struct meltmixbigint_st *) p;
	struct meltmixbigint_st *dst = NULL;
	/* from VALDESC_MIXBIGINT */
/* ggc_alloc_meltmixbigint_st should be gengtype generated for VALDESC_MIXBIGINT */
#ifndef ggc_alloc_meltmixbigint_st
#define ggc_alloc_meltmixbigint_st(SIZE) ((struct meltmixbigint_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif
	unsigned blen = src->biglen;
	dst =
	  /* Don't need a cleared allocation.  */
	  ggc_alloc_meltmixbigint_st
	  (blen * sizeof (long) + offsetof (struct meltmixbigint_st, tabig));
	dst->discr = src->discr;
	dst->ptrval = src->ptrval;
	dst->negative = src->negative;
	dst->biglen = blen;
	memcpy (dst->tabig, src->tabig, blen * sizeof (dst->tabig[0]));

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #8 VALDESC_MIXINT */
    case MELTOBMAG_MIXINT:
      {
	struct meltmixint_st *src = (struct meltmixint_st *) p;
	struct meltmixint_st *dst = NULL;
	/* from VALDESC_MIXINT */
/* ggc_alloc_meltmixint_st should be gengtype generated for VALDESC_MIXINT */
#ifndef ggc_alloc_meltmixint_st
#define ggc_alloc_meltmixint_st() ((struct meltmixint_st *)(ggc_internal_alloc_stat (sizeof (struct meltmixint_st) MEM_STAT_INFO)))
#endif
	dst =
	  /* Don't need a cleared allocation.  */
	  ggc_alloc_meltmixint_st ();
	*dst = *src;

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #9 VALDESC_MIXLOC */
    case MELTOBMAG_MIXLOC:
      {
	struct meltmixloc_st *src = (struct meltmixloc_st *) p;
	struct meltmixloc_st *dst = NULL;
	/* from VALDESC_MIXLOC */
/* ggc_alloc_meltmixloc_st should be gengtype generated for VALDESC_MIXLOC */
#ifndef ggc_alloc_meltmixloc_st
#define ggc_alloc_meltmixloc_st() ((struct meltmixloc_st *)(ggc_internal_alloc_stat (sizeof (struct meltmixloc_st) MEM_STAT_INFO)))
#endif
	dst =
	  /* Don't need a cleared allocation.  */
	  ggc_alloc_meltmixloc_st ();
	*dst = *src;

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #10 VALDESC_MULTIPLE */
    case MELTOBMAG_MULTIPLE:
      {
	struct meltmultiple_st *src = (struct meltmultiple_st *) p;
	struct meltmultiple_st *dst = NULL;
	/* from VALDESC_MULTIPLE */
	/* ggc_alloc_meltmultiple_st should be gengtype generated for VALDESC_MULTIPLE */
#ifndef ggc_alloc_meltmultiple_st
#define ggc_alloc_meltmultiple_st(SIZE) ((struct meltmultiple_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif
	int nbv = (int) src->nbval;
	int ix = 0;
	dst =
	  /* Don't need a cleared allocation!  */
	  ggc_alloc_meltmultiple_st
	  (nbv * sizeof (void *) + offsetof (struct meltmultiple_st, tabval));
	/* we cannot copy the whole src, because FLEXIBLE_DIM might be
	   1 and nbval could be 0 */
	dst->discr = src->discr;
	dst->nbval = src->nbval;
	for (ix = 0; ix < nbv; ix++)
	  dst->tabval[ix] = src->tabval[ix];

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #11 VALDESC_OBJECT */
    case MELTOBMAG_OBJECT:
      {
	struct meltobject_st *src = (struct meltobject_st *) p;
	struct meltobject_st *dst = NULL;
	/* from VALDESC_OBJECT */
	/* ggc_alloc_meltobject_st should be gengtype generated for VALDESC_OBJECT */
#ifndef ggc_alloc_meltobject_st
#define ggc_alloc_meltobject_st(SIZE) ((struct meltobject_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif
	int ix = 0;
	int oblen = (int) (src->obj_len);
	/* We don't need to clear at allocation, since the object is
	   explicitly filled here! */
	dst = ggc_alloc_meltobject_st
	  (oblen * sizeof (void *)
	   + offsetof (struct meltobject_st, obj_vartab));
	/* we cannot copy the whole src, because FLEXIBLE_DIM might be 1 */
	dst->meltobj_class = src->meltobj_class;
	dst->obj_hash = src->obj_hash;
	dst->obj_num = src->obj_num;
	dst->obj_len = oblen;
	for (ix = 0; ix < oblen; ix++)
	  dst->obj_vartab[ix] = src->obj_vartab[ix];

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #12 VALDESC_PAIR */
    case MELTOBMAG_PAIR:
      {
	struct meltpair_st *src = (struct meltpair_st *) p;
	struct meltpair_st *dst = NULL;
	/* copy VALDESC_PAIR in warmelt-base.melt */
	/* ggc_alloc_meltpair_st should be gengtype gengtype for VALDESC_PAIR */
#ifndef ggc_alloc_meltpair_st
#define ggc_alloc_meltpair_st() ((struct meltpair_st *)(ggc_internal_alloc_stat (sizeof (struct meltpair_st) MEM_STAT_INFO)))
#endif
	dst =			/* Don't need a cleared allocation.  */
	  ggc_alloc_meltpair_st ();
	*dst = *src;

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #13 VALDESC_REAL */
    case MELTOBMAG_REAL:
      {
	struct meltreal_st *src = (struct meltreal_st *) p;
	struct meltreal_st *dst = NULL;
	/* from VALDESC_REAL */
/* ggc_alloc_meltreal_st should be gengtype generated for VALDESC_REAL */
#ifndef ggc_alloc_meltreal_st
#define ggc_alloc_meltreal_st() ((struct meltreal_st *)(ggc_internal_alloc_stat (sizeof (struct meltreal_st) MEM_STAT_INFO)))
#endif
	dst =
	  /* Don't need a cleared allocation.  */
	  ggc_alloc_meltreal_st ();
	*dst = *src;

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #14 VALDESC_ROUTINE */
    case MELTOBMAG_ROUTINE:
      {
	struct meltroutine_st *src = (struct meltroutine_st *) p;
	struct meltroutine_st *dst = NULL;
	/* from VALDESC_ROUTINE */
	/* ggc_alloc_meltroutine_st should be gengtype generated for VALDESC_ROUTINE */
#ifndef ggc_alloc_meltroutine_st
#define ggc_alloc_meltroutine_st(SIZE) ((struct meltroutine_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif
	int nbv = (int) src->nbval;
	int ix = 0;
	dst =
	  /* Don't need a cleared allocation!  */
	  ggc_alloc_meltroutine_st
	  (nbv * sizeof (void *) + offsetof (struct meltroutine_st, tabval));
	dst->discr = src->discr;
	strncpy (dst->routdescr, src->routdescr, MELT_ROUTDESCR_LEN);
	dst->routdescr[MELT_ROUTDESCR_LEN - 1] = 0;
	dst->nbval = (unsigned) nbv;
	dst->routfunad = src->routfunad;
	for (ix = 0; ix < nbv; ix++)
	  dst->tabval[ix] = src->tabval[ix];
	dst->routdata = src->routdata;

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #15 VALDESC_SPECIAL_FILE */
    case MELTOBMAG_SPEC_FILE:
      {
	struct meltspecialfile_st *src = (struct meltspecialfile_st *) p;
	struct meltspecialfile_st *dst = NULL;
	/* from VALDESC_SPECIAL_FILE */
/* ggc_alloc_meltspecialfile_st should be gengtype generated for VALDESC_SPECIAL_FILE */
#ifndef ggc_alloc_meltspecialfile_st
#define ggc_alloc_meltspecialfile_st() ((struct meltspecialfile_st *)(ggc_internal_alloc_stat (sizeof (struct meltspecialfile_st) MEM_STAT_INFO)))
#endif
	dst = ggc_alloc_meltspecialfile_st ();
	*dst = *src;
	/* mark the new copy! */
	dst->mark = 1;
	/* add the new copy to the old (major) special list */
	dst->nextspec = melt_oldspeclist;
	melt_oldspeclist = (struct meltspecial_st *) dst;

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #16 VALDESC_SPECIAL_MPFR */
    case MELTOBMAG_SPEC_MPFR:
      {
	struct meltspecialmpfr_st *src = (struct meltspecialmpfr_st *) p;
	struct meltspecialmpfr_st *dst = NULL;
	/* from VALDESC_SPECIAL_MPFR */
/* ggc_alloc_meltspecialmpfr_st should be gengtype generated for VALDESC_SPECIAL_MPFR */
#ifndef ggc_alloc_meltspecialmpfr_st
#define ggc_alloc_meltspecialmpfr_st() ((struct meltspecialmpfr_st *)(ggc_internal_alloc_stat (sizeof (struct meltspecialmpfr_st) MEM_STAT_INFO)))
#endif
	dst = ggc_alloc_meltspecialmpfr_st ();
	*dst = *src;
	/* mark the new copy! */
	dst->mark = 1;
	/* add the new copy to the old (major) special list */
	dst->nextspec = melt_oldspeclist;
	melt_oldspeclist = (struct meltspecial_st *) dst;

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #17 VALDESC_SPECIAL_PPL_COEFFICIENT */
    case MELTOBMAG_SPECPPL_COEFFICIENT:
      {
	struct meltspecialpplcoefficient_st *src =
	  (struct meltspecialpplcoefficient_st *) p;
	struct meltspecialpplcoefficient_st *dst = NULL;
	/* from VALDESC_SPECIAL_PPL_COEFFICIENT */
/* ggc_alloc_meltspecialpplcoefficient_st should be gengtype generated for VALDESC_SPECIAL_PPL_COEFFICIENT */
#ifndef ggc_alloc_meltspecialpplcoefficient_st
#define ggc_alloc_meltspecialpplcoefficient_st() ((struct meltspecialpplcoefficient_st *)(ggc_internal_alloc_stat (sizeof (struct meltspecialpplcoefficient_st) MEM_STAT_INFO)))
#endif
	dst = ggc_alloc_meltspecialpplcoefficient_st ();
	*dst = *src;
	/* mark the new copy! */
	dst->mark = 1;
	/* add the new copy to the old (major) special list */
	dst->nextspec = melt_oldspeclist;
	melt_oldspeclist = (struct meltspecial_st *) dst;

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #18 VALDESC_SPECIAL_PPL_CONSTRAINT */
    case MELTOBMAG_SPECPPL_CONSTRAINT:
      {
	struct meltspecialpplconstraint_st *src =
	  (struct meltspecialpplconstraint_st *) p;
	struct meltspecialpplconstraint_st *dst = NULL;
	/* from VALDESC_SPECIAL_PPL_CONSTRAINT */
/* ggc_alloc_meltspecialpplconstraint_st should be gengtype gengtype for VALDESC_SPECIAL_PPL_CONSTRAINT */
#ifndef ggc_alloc_meltspecialpplconstraint_st
#define ggc_alloc_meltspecialpplconstraint_st() ((struct meltspecialpplconstraint_st *)(ggc_internal_alloc_stat (sizeof (struct meltspecialpplconstraint_st) MEM_STAT_INFO)))
#endif
	dst = ggc_alloc_meltspecialpplconstraint_st ();
	*dst = *src;
	/* mark the new copy! */
	dst->mark = 1;
	/* add the new copy to the old (major) special list */
	dst->nextspec = melt_oldspeclist;
	melt_oldspeclist = (struct meltspecial_st *) dst;

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #19 VALDESC_SPECIAL_PPL_CONSTRAINT_SYSTEM */
    case MELTOBMAG_SPECPPL_CONSTRAINT_SYSTEM:
      {
	struct meltspecialpplconstraintsystem_st *src =
	  (struct meltspecialpplconstraintsystem_st *) p;
	struct meltspecialpplconstraintsystem_st *dst = NULL;
	/* from VALDESC_SPECIAL_PPL_CONSTRAINT_SYSTEM */
	/* ggc_alloc_meltspecialpplconstraintsystem_st should be gengtype generated for VALDESC_SPECIAL_PPL_CONSTRAINT_SYSTEM */
#ifndef ggc_alloc_meltspecialpplconstraintsystem_st
#define ggc_alloc_meltspecialpplconstraintsystem_st() ((struct meltspecialpplconstraintsystem_st *)(ggc_internal_alloc_stat (sizeof (struct meltspecialpplconstraintsystem_st) MEM_STAT_INFO)))
#endif
	dst = ggc_alloc_meltspecialpplconstraintsystem_st ();
	*dst = *src;
	/* mark the new copy! */
	dst->mark = 1;
	/* add the new copy to the old (major) special list */
	dst->nextspec = melt_oldspeclist;
	melt_oldspeclist = (struct meltspecial_st *) dst;

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #20 VALDESC_SPECIAL_PPL_GENERATOR */
    case MELTOBMAG_SPECPPL_GENERATOR:
      {
	struct meltspecialpplgenerator_st *src =
	  (struct meltspecialpplgenerator_st *) p;
	struct meltspecialpplgenerator_st *dst = NULL;
	/* from VALDESC_SPECIAL_PPL_GENERATOR */
/* ggc_alloc_meltspecialpplgenerator_st should be gengtype generated for VALDESC_SPECIAL_PPL_GENERATOR */
#ifndef ggc_alloc_meltspecialpplgenerator_st
#define ggc_alloc_meltspecialpplgenerator_st() ((struct meltspecialpplgenerator_st *)(ggc_internal_alloc_stat (sizeof (struct meltspecialpplgenerator_st) MEM_STAT_INFO)))
#endif
	dst = ggc_alloc_meltspecialpplgenerator_st ();
	*dst = *src;
	/* mark the new copy! */
	dst->mark = 1;
	/* add the new copy to the old (major) special list */
	dst->nextspec = melt_oldspeclist;
	melt_oldspeclist = (struct meltspecial_st *) dst;

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #21 VALDESC_SPECIAL_PPL_GENERATOR_SYSTEM */
    case MELTOBMAG_SPECPPL_GENERATOR_SYSTEM:
      {
	struct meltspecialpplgeneratorsystem_st *src =
	  (struct meltspecialpplgeneratorsystem_st *) p;
	struct meltspecialpplgeneratorsystem_st *dst = NULL;
	/* from VALDESC_SPECIAL_PPL_GENERATOR_SYSTEM */
/*  ggc_alloc_meltspecialpplgeneratorsystem_st should be gengtype generated for VALDESC_SPECIAL_PPL_GENERATOR_SYSTEM */
#ifndef ggc_alloc_meltspecialpplgeneratorsystem_st
#define ggc_alloc_meltspecialpplgeneratorsystem_st() ((struct meltspecialpplgeneratorsystem_st *)(ggc_internal_alloc_stat (sizeof (struct meltspecialpplgeneratorsystem_st) MEM_STAT_INFO)))
#endif
	dst = ggc_alloc_meltspecialpplgeneratorsystem_st ();
	*dst = *src;
	/* mark the new copy! */
	dst->mark = 1;
	/* add the new copy to the old (major) special list */
	dst->nextspec = melt_oldspeclist;
	melt_oldspeclist = (struct meltspecial_st *) dst;

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #22 VALDESC_SPECIAL_PPL_LINEAR_EXPRESSION */
    case MELTOBMAG_SPECPPL_LINEAR_EXPRESSION:
      {
	struct meltspecialppllinearexpression_st *src =
	  (struct meltspecialppllinearexpression_st *) p;
	struct meltspecialppllinearexpression_st *dst = NULL;
	/* from VALDESC_SPECIAL_PPL_LINEAR_EXPRESSION */
/* ggc_alloc_meltspecialppllinearexpression_st should be gengtype generated for VALDESC_SPECIAL_PPL_LINEAR_EXPRESSION */
#ifndef ggc_alloc_meltspecialppllinearexpression_st
#define ggc_alloc_meltspecialppllinearexpression_st() ((struct meltspecialppllinearexpression_st *)(ggc_internal_alloc_stat (sizeof (struct meltspecialppllinearexpression_st) MEM_STAT_INFO)))
#endif
	dst = ggc_alloc_meltspecialppllinearexpression_st ();
	*dst = *src;
	/* mark the new copy! */
	dst->mark = 1;
	/* add the new copy to the old (major) special list */
	dst->nextspec = melt_oldspeclist;
	melt_oldspeclist = (struct meltspecial_st *) dst;

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #23 VALDESC_SPECIAL_PPL_POLYHEDRON */
    case MELTOBMAG_SPECPPL_POLYHEDRON:
      {
	struct meltspecialpplpolyhedron_st *src =
	  (struct meltspecialpplpolyhedron_st *) p;
	struct meltspecialpplpolyhedron_st *dst = NULL;
	/* from VALDESC_SPECIAL_PPL_POLYHEDRON */
/* ggc_alloc_meltspecialpplpolyhedron_st should be gengtype generated for VALDESC_SPECIAL_PPL_POLYHEDRON */
#ifndef ggc_alloc_meltspecialpplpolyhedron_st
#define ggc_alloc_meltspecialpplpolyhedron_st() ((struct meltspecialpplpolyhedron_st *)(ggc_internal_alloc_stat (sizeof (struct meltspecialpplpolyhedron_st) MEM_STAT_INFO)))
#endif
	dst = ggc_alloc_meltspecialpplpolyhedron_st ();
	*dst = *src;
	/* mark the new copy! */
	dst->mark = 1;
	/* add the new copy to the old (major) special list */
	dst->nextspec = melt_oldspeclist;
	melt_oldspeclist = (struct meltspecial_st *) dst;

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #24 VALDESC_SPECIAL_RAW_FILE */
    case MELTOBMAG_SPEC_RAWFILE:
      {
	struct meltspecialrawfile_st *src =
	  (struct meltspecialrawfile_st *) p;
	struct meltspecialrawfile_st *dst = NULL;
	/* from VALDESC_SPECIAL_RAW_FILE */
/* ggc_alloc_meltspecialrawfile_st should be gengtype generated for VALDESC_SPECIAL_RAW_FILE */
#ifndef ggc_alloc_meltspecialrawfile_st
#define ggc_alloc_meltspecialrawfile_st() ((struct meltspecialrawfile_st *)(ggc_internal_alloc_stat (sizeof (struct meltspecialrawfile_st) MEM_STAT_INFO)))
#endif
	dst = ggc_alloc_meltspecialrawfile_st ();
	*dst = *src;
	/* mark the new copy! */
	dst->mark = 1;
	/* add the new copy to the old (major) special list */
	dst->nextspec = melt_oldspeclist;
	melt_oldspeclist = (struct meltspecial_st *) dst;

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #25 VALDESC_STRBUF */
    case MELTOBMAG_STRBUF:
      {
	struct meltstrbuf_st *src = (struct meltstrbuf_st *) p;
	struct meltstrbuf_st *dst = NULL;
	/* from VALDESC_STRBUF */
/* ggc_alloc_meltstrbuf_st should be gengtype gengtype for VALDESC_STRBUF */
#ifndef ggc_alloc_meltstrbuf_st
#define ggc_alloc_meltstrbuf_st() ((struct meltstrbuf_st *)(ggc_internal_alloc_stat (sizeof (struct meltstrbuf_st) MEM_STAT_INFO)))
#endif
	unsigned blen = melt_primtab[src->buflenix];
	dst =
	  /* Don't need a cleared allocation.  */
	  ggc_alloc_meltstrbuf_st ();
	dst->discr = src->discr;
	dst->bufstart = src->bufstart;
	dst->bufend = src->bufend;
	dst->buflenix = src->buflenix;
	if (blen > 0)
	  {
#if BUILDING_GCC_VERSION > 4005
	    dst->bufzn =
	      CONST_CAST (char *, ggc_alloc_string (src->bufzn, blen + 1));
#else /*GCC 4.5 */
	    dst->bufzn = (char *) ggc_alloc_cleared (1 + blen);
	    memcpy (dst->bufzn, src->bufzn, blen);
#endif /*!GCC 4.5 */
	    dst->bufzn[blen] = (char) 0;
	  }
	else
	  dst->bufzn = NULL;

	n = (melt_ptr_t) dst;
	break;
      }

      /*valdesc #26 VALDESC_STRING */
    case MELTOBMAG_STRING:
      {
	struct meltstring_st *src = (struct meltstring_st *) p;
	struct meltstring_st *dst = NULL;
	/* from VALDESC_STRING file warmelt-base.melt */
/* ggc_alloc_meltstring_st should be gengtype generated for VALDESC_STRING */
#ifndef ggc_alloc_meltstring_st
#define ggc_alloc_meltstring_st(SIZE) ((struct meltstring_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif
	int srclen = (src->val) ? strlen (src->val) : 0;
	dst =
	  /* Don't need a cleared allocation.  */
	ggc_alloc_meltstring_st
	  (offsetof (struct meltstring_st, val) + (srclen + 1));
	dst->discr = src->discr;
	memcpy (dst->val, src->val, srclen);
	dst->val[srclen] = (char) 0;

	n = (melt_ptr_t) dst;
	break;
      }


/* gty ctype forward copy for melt_forwarded_copy */
/*forwcopy gtyctype #1 CTYPE_BASIC_BLOCK*/
    case MELTOBMAG_BASICBLOCK:
      {
	/* macro ggc_alloc_meltbasicblock_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltbasicblock_st
#define ggc_alloc_meltbasicblock_st() ((struct meltbasicblock_st*)(ggc_internal_alloc_stat (sizeof (struct meltbasicblock_st) MEM_STAT_INFO)))
#endif
	struct meltbasicblock_st *src = (struct meltbasicblock_st *) p;
	struct meltbasicblock_st *dst = ggc_alloc_meltbasicblock_st ();
	*dst = *src;
	n = (melt_ptr_t) dst;
	break;
      }
    case MELTOBMAG_MAPBASICBLOCKS:
      {
/* ggc_alloc_meltmapbasicblocks_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltmapbasicblocks_st
#define ggc_alloc_meltmapbasicblocks_st() ((struct meltmapbasicblocks_st*) (ggc_internal_alloc_stat (sizeof (struct meltmapbasicblocks_st) MEM_STAT_INFO)))
#endif
/* ggc_alloc_vec_entrybasicblockmelt_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_vec_entrybasicblockmelt_st
#define ggc_alloc_vec_entrybasicblockmelt_st(n) ((struct entrybasicblockmelt_st*) (ggc_internal_vec_alloc_stat (sizeof (struct entrybasicblockmelt_st), n MEM_STAT_INFO)))
#endif
	struct meltmapbasicblocks_st *src =
	  (struct meltmapbasicblocks_st *) p;
	int siz = melt_primtab[src->lenix];
	struct meltmapbasicblocks_st *dst =
	  ggc_alloc_meltmapbasicblocks_st ();
	dst->discr = src->discr;
	dst->count = src->count;
	dst->lenix = src->lenix;
	if (siz > 0 && src->entab)
	  {
	    dst->entab = ggc_alloc_vec_entrybasicblockmelt_st (siz);
	    memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
	  }
	else
	  dst->entab = NULL;
	n = (melt_ptr_t) dst;
	break;
      }
      /*forwcopy gtyctype #2 CTYPE_BITMAP */
    case MELTOBMAG_BITMAP:
      {
	/* macro ggc_alloc_meltbitmap_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltbitmap_st
#define ggc_alloc_meltbitmap_st() ((struct meltbitmap_st*)(ggc_internal_alloc_stat (sizeof (struct meltbitmap_st) MEM_STAT_INFO)))
#endif
	struct meltbitmap_st *src = (struct meltbitmap_st *) p;
	struct meltbitmap_st *dst = ggc_alloc_meltbitmap_st ();
	*dst = *src;
	n = (melt_ptr_t) dst;
	break;
      }
    case MELTOBMAG_MAPBITMAPS:
      {
/* ggc_alloc_meltmapbitmaps_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltmapbitmaps_st
#define ggc_alloc_meltmapbitmaps_st() ((struct meltmapbitmaps_st*) (ggc_internal_alloc_stat (sizeof (struct meltmapbitmaps_st) MEM_STAT_INFO)))
#endif
/* ggc_alloc_vec_entrybitmapmelt_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_vec_entrybitmapmelt_st
#define ggc_alloc_vec_entrybitmapmelt_st(n) ((struct entrybitmapmelt_st*) (ggc_internal_vec_alloc_stat (sizeof (struct entrybitmapmelt_st), n MEM_STAT_INFO)))
#endif
	struct meltmapbitmaps_st *src = (struct meltmapbitmaps_st *) p;
	int siz = melt_primtab[src->lenix];
	struct meltmapbitmaps_st *dst = ggc_alloc_meltmapbitmaps_st ();
	dst->discr = src->discr;
	dst->count = src->count;
	dst->lenix = src->lenix;
	if (siz > 0 && src->entab)
	  {
	    dst->entab = ggc_alloc_vec_entrybitmapmelt_st (siz);
	    memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
	  }
	else
	  dst->entab = NULL;
	n = (melt_ptr_t) dst;
	break;
      }
      /*forwcopy gtyctype #3 CTYPE_EDGE */
    case MELTOBMAG_EDGE:
      {
	/* macro ggc_alloc_meltedge_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltedge_st
#define ggc_alloc_meltedge_st() ((struct meltedge_st*)(ggc_internal_alloc_stat (sizeof (struct meltedge_st) MEM_STAT_INFO)))
#endif
	struct meltedge_st *src = (struct meltedge_st *) p;
	struct meltedge_st *dst = ggc_alloc_meltedge_st ();
	*dst = *src;
	n = (melt_ptr_t) dst;
	break;
      }
    case MELTOBMAG_MAPEDGES:
      {
/* ggc_alloc_meltmapedges_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltmapedges_st
#define ggc_alloc_meltmapedges_st() ((struct meltmapedges_st*) (ggc_internal_alloc_stat (sizeof (struct meltmapedges_st) MEM_STAT_INFO)))
#endif
/* ggc_alloc_vec_entryedgemelt_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_vec_entryedgemelt_st
#define ggc_alloc_vec_entryedgemelt_st(n) ((struct entryedgemelt_st*) (ggc_internal_vec_alloc_stat (sizeof (struct entryedgemelt_st), n MEM_STAT_INFO)))
#endif
	struct meltmapedges_st *src = (struct meltmapedges_st *) p;
	int siz = melt_primtab[src->lenix];
	struct meltmapedges_st *dst = ggc_alloc_meltmapedges_st ();
	dst->discr = src->discr;
	dst->count = src->count;
	dst->lenix = src->lenix;
	if (siz > 0 && src->entab)
	  {
	    dst->entab = ggc_alloc_vec_entryedgemelt_st (siz);
	    memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
	  }
	else
	  dst->entab = NULL;
	n = (melt_ptr_t) dst;
	break;
      }
      /*forwcopy gtyctype #4 CTYPE_GIMPLE */
    case MELTOBMAG_GIMPLE:
      {
	/* macro ggc_alloc_meltgimple_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltgimple_st
#define ggc_alloc_meltgimple_st() ((struct meltgimple_st*)(ggc_internal_alloc_stat (sizeof (struct meltgimple_st) MEM_STAT_INFO)))
#endif
	struct meltgimple_st *src = (struct meltgimple_st *) p;
	struct meltgimple_st *dst = ggc_alloc_meltgimple_st ();
	*dst = *src;
	n = (melt_ptr_t) dst;
	break;
      }
    case MELTOBMAG_MAPGIMPLES:
      {
/* ggc_alloc_meltmapgimples_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltmapgimples_st
#define ggc_alloc_meltmapgimples_st() ((struct meltmapgimples_st*) (ggc_internal_alloc_stat (sizeof (struct meltmapgimples_st) MEM_STAT_INFO)))
#endif
/* ggc_alloc_vec_entrygimplemelt_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_vec_entrygimplemelt_st
#define ggc_alloc_vec_entrygimplemelt_st(n) ((struct entrygimplemelt_st*) (ggc_internal_vec_alloc_stat (sizeof (struct entrygimplemelt_st), n MEM_STAT_INFO)))
#endif
	struct meltmapgimples_st *src = (struct meltmapgimples_st *) p;
	int siz = melt_primtab[src->lenix];
	struct meltmapgimples_st *dst = ggc_alloc_meltmapgimples_st ();
	dst->discr = src->discr;
	dst->count = src->count;
	dst->lenix = src->lenix;
	if (siz > 0 && src->entab)
	  {
	    dst->entab = ggc_alloc_vec_entrygimplemelt_st (siz);
	    memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
	  }
	else
	  dst->entab = NULL;
	n = (melt_ptr_t) dst;
	break;
      }
      /*forwcopy gtyctype #5 CTYPE_GIMPLE_SEQ */
    case MELTOBMAG_GIMPLESEQ:
      {
	/* macro ggc_alloc_meltgimpleseq_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltgimpleseq_st
#define ggc_alloc_meltgimpleseq_st() ((struct meltgimpleseq_st*)(ggc_internal_alloc_stat (sizeof (struct meltgimpleseq_st) MEM_STAT_INFO)))
#endif
	struct meltgimpleseq_st *src = (struct meltgimpleseq_st *) p;
	struct meltgimpleseq_st *dst = ggc_alloc_meltgimpleseq_st ();
	*dst = *src;
	n = (melt_ptr_t) dst;
	break;
      }
    case MELTOBMAG_MAPGIMPLESEQS:
      {
/* ggc_alloc_meltmapgimpleseqs_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltmapgimpleseqs_st
#define ggc_alloc_meltmapgimpleseqs_st() ((struct meltmapgimpleseqs_st*) (ggc_internal_alloc_stat (sizeof (struct meltmapgimpleseqs_st) MEM_STAT_INFO)))
#endif
/* ggc_alloc_vec_entrygimpleseqmelt_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_vec_entrygimpleseqmelt_st
#define ggc_alloc_vec_entrygimpleseqmelt_st(n) ((struct entrygimpleseqmelt_st*) (ggc_internal_vec_alloc_stat (sizeof (struct entrygimpleseqmelt_st), n MEM_STAT_INFO)))
#endif
	struct meltmapgimpleseqs_st *src = (struct meltmapgimpleseqs_st *) p;
	int siz = melt_primtab[src->lenix];
	struct meltmapgimpleseqs_st *dst = ggc_alloc_meltmapgimpleseqs_st ();
	dst->discr = src->discr;
	dst->count = src->count;
	dst->lenix = src->lenix;
	if (siz > 0 && src->entab)
	  {
	    dst->entab = ggc_alloc_vec_entrygimpleseqmelt_st (siz);
	    memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
	  }
	else
	  dst->entab = NULL;
	n = (melt_ptr_t) dst;
	break;
      }
      /*forwcopy gtyctype #6 CTYPE_LOOP */
    case MELTOBMAG_LOOP:
      {
	/* macro ggc_alloc_meltloop_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltloop_st
#define ggc_alloc_meltloop_st() ((struct meltloop_st*)(ggc_internal_alloc_stat (sizeof (struct meltloop_st) MEM_STAT_INFO)))
#endif
	struct meltloop_st *src = (struct meltloop_st *) p;
	struct meltloop_st *dst = ggc_alloc_meltloop_st ();
	*dst = *src;
	n = (melt_ptr_t) dst;
	break;
      }
    case MELTOBMAG_MAPLOOPS:
      {
/* ggc_alloc_meltmaploops_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltmaploops_st
#define ggc_alloc_meltmaploops_st() ((struct meltmaploops_st*) (ggc_internal_alloc_stat (sizeof (struct meltmaploops_st) MEM_STAT_INFO)))
#endif
/* ggc_alloc_vec_entryloopmelt_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_vec_entryloopmelt_st
#define ggc_alloc_vec_entryloopmelt_st(n) ((struct entryloopmelt_st*) (ggc_internal_vec_alloc_stat (sizeof (struct entryloopmelt_st), n MEM_STAT_INFO)))
#endif
	struct meltmaploops_st *src = (struct meltmaploops_st *) p;
	int siz = melt_primtab[src->lenix];
	struct meltmaploops_st *dst = ggc_alloc_meltmaploops_st ();
	dst->discr = src->discr;
	dst->count = src->count;
	dst->lenix = src->lenix;
	if (siz > 0 && src->entab)
	  {
	    dst->entab = ggc_alloc_vec_entryloopmelt_st (siz);
	    memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
	  }
	else
	  dst->entab = NULL;
	n = (melt_ptr_t) dst;
	break;
      }
      /*forwcopy gtyctype #7 CTYPE_RTVEC */
    case MELTOBMAG_RTVEC:
      {
	/* macro ggc_alloc_meltrtvec_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltrtvec_st
#define ggc_alloc_meltrtvec_st() ((struct meltrtvec_st*)(ggc_internal_alloc_stat (sizeof (struct meltrtvec_st) MEM_STAT_INFO)))
#endif
	struct meltrtvec_st *src = (struct meltrtvec_st *) p;
	struct meltrtvec_st *dst = ggc_alloc_meltrtvec_st ();
	*dst = *src;
	n = (melt_ptr_t) dst;
	break;
      }
    case MELTOBMAG_MAPRTVECS:
      {
/* ggc_alloc_meltmaprtvecs_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltmaprtvecs_st
#define ggc_alloc_meltmaprtvecs_st() ((struct meltmaprtvecs_st*) (ggc_internal_alloc_stat (sizeof (struct meltmaprtvecs_st) MEM_STAT_INFO)))
#endif
/* ggc_alloc_vec_entryrtvecmelt_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_vec_entryrtvecmelt_st
#define ggc_alloc_vec_entryrtvecmelt_st(n) ((struct entryrtvecmelt_st*) (ggc_internal_vec_alloc_stat (sizeof (struct entryrtvecmelt_st), n MEM_STAT_INFO)))
#endif
	struct meltmaprtvecs_st *src = (struct meltmaprtvecs_st *) p;
	int siz = melt_primtab[src->lenix];
	struct meltmaprtvecs_st *dst = ggc_alloc_meltmaprtvecs_st ();
	dst->discr = src->discr;
	dst->count = src->count;
	dst->lenix = src->lenix;
	if (siz > 0 && src->entab)
	  {
	    dst->entab = ggc_alloc_vec_entryrtvecmelt_st (siz);
	    memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
	  }
	else
	  dst->entab = NULL;
	n = (melt_ptr_t) dst;
	break;
      }
      /*forwcopy gtyctype #8 CTYPE_RTX */
    case MELTOBMAG_RTX:
      {
	/* macro ggc_alloc_meltrtx_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltrtx_st
#define ggc_alloc_meltrtx_st() ((struct meltrtx_st*)(ggc_internal_alloc_stat (sizeof (struct meltrtx_st) MEM_STAT_INFO)))
#endif
	struct meltrtx_st *src = (struct meltrtx_st *) p;
	struct meltrtx_st *dst = ggc_alloc_meltrtx_st ();
	*dst = *src;
	n = (melt_ptr_t) dst;
	break;
      }
    case MELTOBMAG_MAPRTXS:
      {
/* ggc_alloc_meltmaprtxs_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltmaprtxs_st
#define ggc_alloc_meltmaprtxs_st() ((struct meltmaprtxs_st*) (ggc_internal_alloc_stat (sizeof (struct meltmaprtxs_st) MEM_STAT_INFO)))
#endif
/* ggc_alloc_vec_entryrtxmelt_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_vec_entryrtxmelt_st
#define ggc_alloc_vec_entryrtxmelt_st(n) ((struct entryrtxmelt_st*) (ggc_internal_vec_alloc_stat (sizeof (struct entryrtxmelt_st), n MEM_STAT_INFO)))
#endif
	struct meltmaprtxs_st *src = (struct meltmaprtxs_st *) p;
	int siz = melt_primtab[src->lenix];
	struct meltmaprtxs_st *dst = ggc_alloc_meltmaprtxs_st ();
	dst->discr = src->discr;
	dst->count = src->count;
	dst->lenix = src->lenix;
	if (siz > 0 && src->entab)
	  {
	    dst->entab = ggc_alloc_vec_entryrtxmelt_st (siz);
	    memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
	  }
	else
	  dst->entab = NULL;
	n = (melt_ptr_t) dst;
	break;
      }
      /*forwcopy gtyctype #9 CTYPE_TREE */
    case MELTOBMAG_TREE:
      {
	/* macro ggc_alloc_melttree_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_melttree_st
#define ggc_alloc_melttree_st() ((struct melttree_st*)(ggc_internal_alloc_stat (sizeof (struct melttree_st) MEM_STAT_INFO)))
#endif
	struct melttree_st *src = (struct melttree_st *) p;
	struct melttree_st *dst = ggc_alloc_melttree_st ();
	*dst = *src;
	n = (melt_ptr_t) dst;
	break;
      }
    case MELTOBMAG_MAPTREES:
      {
/* ggc_alloc_meltmaptrees_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_meltmaptrees_st
#define ggc_alloc_meltmaptrees_st() ((struct meltmaptrees_st*) (ggc_internal_alloc_stat (sizeof (struct meltmaptrees_st) MEM_STAT_INFO)))
#endif
/* ggc_alloc_vec_entrytreemelt_st should be generated by gengtype not by runtypesupport_forwcopy */
#ifndef ggc_alloc_vec_entrytreemelt_st
#define ggc_alloc_vec_entrytreemelt_st(n) ((struct entrytreemelt_st*) (ggc_internal_vec_alloc_stat (sizeof (struct entrytreemelt_st), n MEM_STAT_INFO)))
#endif
	struct meltmaptrees_st *src = (struct meltmaptrees_st *) p;
	int siz = melt_primtab[src->lenix];
	struct meltmaptrees_st *dst = ggc_alloc_meltmaptrees_st ();
	dst->discr = src->discr;
	dst->count = src->count;
	dst->lenix = src->lenix;
	if (siz > 0 && src->entab)
	  {
	    dst->entab = ggc_alloc_vec_entrytreemelt_st (siz);
	    memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
	  }
	else
	  dst->entab = NULL;
	n = (melt_ptr_t) dst;
	break;
      }
      /* trailer generated by generate_runtypesupport_forwcopy_fun  */
    default:
      fatal_error ("corruption: forward invalid p=%p discr=%p magic=%d",
		   (void *) p, (void *) p->u_discr, mag);
    }				/* end switch (mag) */

  melt_debuggc_eprintf ("melt_forwarded_copy#%ld/%04ld %p => %p %s",
			melt_nb_garbcoll, melt_forward_counter, (void *) p,
			(void *) n, melt_obmag_string (mag));
  if (n)
    {
#if ENABLE_CHECKING
      if (melt_alptr_1 && (void *) melt_alptr_1 == (void *) n)
	{
	  fprintf (stderr, "melt_forwarded_copy to alptr_1 %p mag %d\n",
		   melt_alptr_1, mag);
	  fflush (stderr);
	  melt_debuggc_eprintf ("melt_forwarded_copy #%ld alptr_1 %p mag %d",
				melt_nb_garbcoll, melt_alptr_1, mag);
	  melt_break_alptr_1 ("forwarded copy to alptr_1");
	}
      if (melt_alptr_2 && (void *) melt_alptr_2 == (void *) n)
	{
	  fprintf (stderr, "melt_forwarded_copy to alptr_2 %p mag %d\n",
		   melt_alptr_2, mag);
	  fflush (stderr);
	  melt_debuggc_eprintf ("melt_forwarded_copy #%ld alptr_2 %p",
				melt_nb_garbcoll, melt_alptr_2);
	  melt_break_alptr_2 ("forwarded copy to alptr_2");
	};
#endif /*ENABLE_CHECKING */

      p->u_forward.discr = MELT_FORWARDED_DISCR;
      p->u_forward.forward = n;
      VEC_safe_push (melt_ptr_t, gc, melt_bscanvec, n);
    }
  return n;
}				/* end of melt_forwarded_copy generated by generate_runtypesupport_forwcopy_fun */

/** end of code generated by generate_runtypesupport_forwcopy_fun **/



/** start of code generated by generate_runtypesupport_scanning **/
 /* header from generate_runtypesupport_scanning */
/* The melt_scanning routine is mostly Chesney like ; however some types,
   including objects, strbuf, stringmaps, objectmaps, all the other
   *maps, contain a pointer to a non value ; this pointer should be
   carefully updated if it was young. */
static void
melt_scanning (melt_ptr_t p)
{
  unsigned omagic = 0;
  if (!p)
    return;
  gcc_assert (p != (void *) HTAB_DELETED_ENTRY);
  gcc_assert (p->u_discr && p->u_discr != (meltobject_ptr_t) 1);
  MELT_FORWARDED (p->u_discr);
  gcc_assert (!melt_is_young (p));
  omagic = p->u_discr->meltobj_magic;
  switch (omagic)
    {
/* end of header from generate_runtypesupport_scanning*/

      /*valdesc #1 VALDESC_CLOSURE */
    case MELTOBMAG_CLOSURE:
      {
	struct meltclosure_st *src = (struct meltclosure_st *) p;
	/* from VALDESC_CLOSURE */
	int nbval = (int) src->nbval;
	int ix = 0;
	MELT_FORWARDED (src->rout);
	for (ix = 0; ix < nbval; ix++)
	  MELT_FORWARDED (src->tabval[ix]);

	break;
      }

      /*valdesc #2 VALDESC_DECAY */
    case MELTOBMAG_DECAY:
      {
	struct meltdecay_st *src = (struct meltdecay_st *) p;
	/* from VALDESC_DECAY */
	MELT_FORWARDED (src->val);

	break;
      }

      /*valdesc #3 VALDESC_INT */
    case MELTOBMAG_INT:
      {
	break;
      }

      /*valdesc #4 VALDESC_LIST */
    case MELTOBMAG_LIST:
      {
	struct meltlist_st *src = (struct meltlist_st *) p;
	/* from VALDESC_LIST */
	MELT_FORWARDED (src->first);
	MELT_FORWARDED (src->last);

	break;
      }

      /*valdesc #5 VALDESC_MAPOBJECTS */
    case MELTOBMAG_MAPOBJECTS:
      {
	struct meltmapobjects_st *src = (struct meltmapobjects_st *) p;
	/* from VALDESC_MAPOBJECTS */
	int siz, ix;
	if (!src->entab)
	  break;
	siz = melt_primtab[src->lenix];
	gcc_assert (siz > 0);
	if (melt_is_young (src->entab))
	  {
	    struct entryobjectsmelt_st *newtab =
	      /* Don't need a cleared allocation!  */
	      ggc_alloc_vec_entryobjectsmelt_st (siz);
	    memcpy (newtab, src->entab,
		    siz * sizeof (struct entryobjectsmelt_st));
	    src->entab = newtab;
	  }
	for (ix = 0; ix < siz; ix++)
	  {
	    meltobject_ptr_t at = src->entab[ix].e_at;
	    if (!at || at == (void *) HTAB_DELETED_ENTRY)
	      {
		src->entab[ix].e_va = NULL;
		continue;
	      }
	    MELT_FORWARDED (at);
	    src->entab[ix].e_at = at;
	    MELT_FORWARDED (src->entab[ix].e_va);
	  }

	break;
      }

      /*valdesc #6 VALDESC_MAPSTRINGS */
    case MELTOBMAG_MAPSTRINGS:
      {
	struct meltmapstrings_st *src = (struct meltmapstrings_st *) p;
	/* from VALDESC_MAPSTRINGS */
	int ix, siz;
	if (!src->entab)
	  break;
	siz = melt_primtab[src->lenix];
	gcc_assert (siz > 0);
	if (melt_is_young (src->entab))
	  {
	    struct entrystringsmelt_st *newtab
	      /* Don't need a cleared allocation!  */
	      = ggc_alloc_vec_entrystringsmelt_st (siz);
	    memcpy (newtab, src->entab,
		    siz * sizeof (struct entrystringsmelt_st));
	    src->entab = newtab;
	  }
	for (ix = 0; ix < siz; ix++)
	  {
	    const char *at = src->entab[ix].e_at;
	    if (!at || at == (void *) HTAB_DELETED_ENTRY)
	      {
		src->entab[ix].e_va = NULL;
		continue;
	      }
	    if (melt_is_young ((const void *) at))
	      src->entab[ix].e_at = (const char *) ggc_strdup (at);
	    MELT_FORWARDED (src->entab[ix].e_va);
	  }

	break;
      }

      /*valdesc #7 VALDESC_MIXBIGINT */
    case MELTOBMAG_MIXBIGINT:
      {
	struct meltmixbigint_st *src = (struct meltmixbigint_st *) p;
	/* from VALDESC_MIXBIGINT */
	MELT_FORWARDED (src->ptrval);

	break;
      }

      /*valdesc #8 VALDESC_MIXINT */
    case MELTOBMAG_MIXINT:
      {
	struct meltmixint_st *src = (struct meltmixint_st *) p;
	/* from VALDESC_MIXINT */
	MELT_FORWARDED (src->ptrval);

	break;
      }

      /*valdesc #9 VALDESC_MIXLOC */
    case MELTOBMAG_MIXLOC:
      {
	struct meltmixloc_st *src = (struct meltmixloc_st *) p;
	/* from VALDESC_MIXLOC */
	MELT_FORWARDED (src->ptrval);

	break;
      }

      /*valdesc #10 VALDESC_MULTIPLE */
    case MELTOBMAG_MULTIPLE:
      {
	struct meltmultiple_st *src = (struct meltmultiple_st *) p;
	/* from VALDESC_MULTIPLE */
	int nbval = (int) src->nbval;
	int ix = 0;
	for (ix = 0; ix < nbval; ix++)
	  MELT_FORWARDED (src->tabval[ix]);

	break;
      }

      /*valdesc #11 VALDESC_OBJECT */
    case MELTOBMAG_OBJECT:
      {
	struct meltobject_st *src = (struct meltobject_st *) p;
	/* from VALDESC_OBJECT */
	int ix = 0;
	int oblen = (int) (src->obj_len);
	for (ix = 0; ix < oblen; ix++)
	  MELT_FORWARDED (src->obj_vartab[ix]);

	break;
      }

      /*valdesc #12 VALDESC_PAIR */
    case MELTOBMAG_PAIR:
      {
	struct meltpair_st *src = (struct meltpair_st *) p;
	/* forward VALDESC_PAIR in warmelt-base.melt */
	MELT_FORWARDED (src->hd);
	MELT_FORWARDED (src->tl);

	break;
      }

      /*valdesc #13 VALDESC_REAL */
    case MELTOBMAG_REAL:
      {
	break;
      }

      /*valdesc #14 VALDESC_ROUTINE */
    case MELTOBMAG_ROUTINE:
      {
	struct meltroutine_st *src = (struct meltroutine_st *) p;
	/* from VALDESC_ROUTINE */
	int nbval = (int) src->nbval;
	int ix = 0;
	for (ix = 0; ix < nbval; ix++)
	  MELT_FORWARDED (src->tabval[ix]);

	break;
      }

      /*valdesc #15 VALDESC_SPECIAL_FILE */
    case MELTOBMAG_SPEC_FILE:
      {
	struct meltspecialfile_st *src = (struct meltspecialfile_st *) p;
	/* from VALDESC_SPECIAL_FILE */
	src->mark = 1;

	break;
      }

      /*valdesc #16 VALDESC_SPECIAL_MPFR */
    case MELTOBMAG_SPEC_MPFR:
      {
	struct meltspecialmpfr_st *src = (struct meltspecialmpfr_st *) p;
	/* from VALDESC_SPECIAL_MPFR */
	src->mark = 1;

	break;
      }

      /*valdesc #17 VALDESC_SPECIAL_PPL_COEFFICIENT */
    case MELTOBMAG_SPECPPL_COEFFICIENT:
      {
	struct meltspecialpplcoefficient_st *src =
	  (struct meltspecialpplcoefficient_st *) p;
	/* from VALDESC_SPECIAL_PPL_COEFFICIENT */
	src->mark = 1;

	break;
      }

      /*valdesc #18 VALDESC_SPECIAL_PPL_CONSTRAINT */
    case MELTOBMAG_SPECPPL_CONSTRAINT:
      {
	struct meltspecialpplconstraint_st *src =
	  (struct meltspecialpplconstraint_st *) p;
	/* from VALDESC_SPECIAL_PPL_CONSTRAINT */
	src->mark = 1;

	break;
      }

      /*valdesc #19 VALDESC_SPECIAL_PPL_CONSTRAINT_SYSTEM */
    case MELTOBMAG_SPECPPL_CONSTRAINT_SYSTEM:
      {
	struct meltspecialpplconstraintsystem_st *src =
	  (struct meltspecialpplconstraintsystem_st *) p;
	/* from VALDESC_SPECIAL_PPL_CONSTRAINT_SYSTEM */
	src->mark = 1;

	break;
      }

      /*valdesc #20 VALDESC_SPECIAL_PPL_GENERATOR */
    case MELTOBMAG_SPECPPL_GENERATOR:
      {
	struct meltspecialpplgenerator_st *src =
	  (struct meltspecialpplgenerator_st *) p;
	/* from VALDESC_SPECIAL_PPL_GENERATOR */
	src->mark = 1;

	break;
      }

      /*valdesc #21 VALDESC_SPECIAL_PPL_GENERATOR_SYSTEM */
    case MELTOBMAG_SPECPPL_GENERATOR_SYSTEM:
      {
	struct meltspecialpplgeneratorsystem_st *src =
	  (struct meltspecialpplgeneratorsystem_st *) p;
	/* from VALDESC_SPECIAL_PPL_GENERATOR_SYSTEM */
	src->mark = 1;

	break;
      }

      /*valdesc #22 VALDESC_SPECIAL_PPL_LINEAR_EXPRESSION */
    case MELTOBMAG_SPECPPL_LINEAR_EXPRESSION:
      {
	struct meltspecialppllinearexpression_st *src =
	  (struct meltspecialppllinearexpression_st *) p;
	/* from VALDESC_SPECIAL_PPL_LINEAR_EXPRESSION */
	src->mark = 1;

	break;
      }

      /*valdesc #23 VALDESC_SPECIAL_PPL_POLYHEDRON */
    case MELTOBMAG_SPECPPL_POLYHEDRON:
      {
	struct meltspecialpplpolyhedron_st *src =
	  (struct meltspecialpplpolyhedron_st *) p;
	/* from VALDESC_SPECIAL_PPL_POLYHEDRON */
	src->mark = 1;

	break;
      }

      /*valdesc #24 VALDESC_SPECIAL_RAW_FILE */
    case MELTOBMAG_SPEC_RAWFILE:
      {
	struct meltspecialrawfile_st *src =
	  (struct meltspecialrawfile_st *) p;
	/* from VALDESC_SPECIAL_RAW_FILE */
	src->mark = 1;

	break;
      }

      /*valdesc #25 VALDESC_STRBUF */
    case MELTOBMAG_STRBUF:
      {
	break;
      }

      /*valdesc #26 VALDESC_STRING */
    case MELTOBMAG_STRING:
      {
	break;
      }

/* GTY-ed ctypes scan forward for melt_scanning  */
/*gtyctype #1 CTYPE_BASIC_BLOCK*/
    case MELTOBMAG_BASICBLOCK:
      break;
    case MELTOBMAG_MAPBASICBLOCKS:
      {
	struct meltmapbasicblocks_st *src =
	  (struct meltmapbasicblocks_st *) p;
	int siz = 0, ix = 0;
	if (!src->entab)
	  break;
	siz = melt_primtab[src->lenix];
	gcc_assert (siz > 0);
	if (melt_is_young (src->entab))
	  {
	    struct entrybasicblockmelt_st *newtab =
	      ggc_alloc_vec_entrybasicblockmelt_st (siz);
	    memcpy (newtab, src->entab,
		    siz * sizeof (struct entrybasicblockmelt_st));
	    src->entab = newtab;
	  }			/*end if young entab */
	for (ix = 0; ix < siz; ix++)
	  {
	    basic_block at = src->entab[ix].e_at;
	    if (!at || (void *) at == (void *) HTAB_DELETED_ENTRY)
	      {
		src->entab[ix].e_va = NULL;
		continue;
	      }			/*end if empty at */
	    MELT_FORWARDED (src->entab[ix].e_va);
	  }			/*end for ix */
      };			/* end case MELTOBMAG_MAPBASICBLOCKS */
      break;
      /*gtyctype #2 CTYPE_BITMAP */
    case MELTOBMAG_BITMAP:
      break;
    case MELTOBMAG_MAPBITMAPS:
      {
	struct meltmapbitmaps_st *src = (struct meltmapbitmaps_st *) p;
	int siz = 0, ix = 0;
	if (!src->entab)
	  break;
	siz = melt_primtab[src->lenix];
	gcc_assert (siz > 0);
	if (melt_is_young (src->entab))
	  {
	    struct entrybitmapmelt_st *newtab =
	      ggc_alloc_vec_entrybitmapmelt_st (siz);
	    memcpy (newtab, src->entab,
		    siz * sizeof (struct entrybitmapmelt_st));
	    src->entab = newtab;
	  }			/*end if young entab */
	for (ix = 0; ix < siz; ix++)
	  {
	    bitmap at = src->entab[ix].e_at;
	    if (!at || (void *) at == (void *) HTAB_DELETED_ENTRY)
	      {
		src->entab[ix].e_va = NULL;
		continue;
	      }			/*end if empty at */
	    MELT_FORWARDED (src->entab[ix].e_va);
	  }			/*end for ix */
      };			/* end case MELTOBMAG_MAPBITMAPS */
      break;
      /*gtyctype #3 CTYPE_EDGE */
    case MELTOBMAG_EDGE:
      break;
    case MELTOBMAG_MAPEDGES:
      {
	struct meltmapedges_st *src = (struct meltmapedges_st *) p;
	int siz = 0, ix = 0;
	if (!src->entab)
	  break;
	siz = melt_primtab[src->lenix];
	gcc_assert (siz > 0);
	if (melt_is_young (src->entab))
	  {
	    struct entryedgemelt_st *newtab =
	      ggc_alloc_vec_entryedgemelt_st (siz);
	    memcpy (newtab, src->entab,
		    siz * sizeof (struct entryedgemelt_st));
	    src->entab = newtab;
	  }			/*end if young entab */
	for (ix = 0; ix < siz; ix++)
	  {
	    edge at = src->entab[ix].e_at;
	    if (!at || (void *) at == (void *) HTAB_DELETED_ENTRY)
	      {
		src->entab[ix].e_va = NULL;
		continue;
	      }			/*end if empty at */
	    MELT_FORWARDED (src->entab[ix].e_va);
	  }			/*end for ix */
      };			/* end case MELTOBMAG_MAPEDGES */
      break;
      /*gtyctype #4 CTYPE_GIMPLE */
    case MELTOBMAG_GIMPLE:
      break;
    case MELTOBMAG_MAPGIMPLES:
      {
	struct meltmapgimples_st *src = (struct meltmapgimples_st *) p;
	int siz = 0, ix = 0;
	if (!src->entab)
	  break;
	siz = melt_primtab[src->lenix];
	gcc_assert (siz > 0);
	if (melt_is_young (src->entab))
	  {
	    struct entrygimplemelt_st *newtab =
	      ggc_alloc_vec_entrygimplemelt_st (siz);
	    memcpy (newtab, src->entab,
		    siz * sizeof (struct entrygimplemelt_st));
	    src->entab = newtab;
	  }			/*end if young entab */
	for (ix = 0; ix < siz; ix++)
	  {
	    gimple at = src->entab[ix].e_at;
	    if (!at || (void *) at == (void *) HTAB_DELETED_ENTRY)
	      {
		src->entab[ix].e_va = NULL;
		continue;
	      }			/*end if empty at */
	    MELT_FORWARDED (src->entab[ix].e_va);
	  }			/*end for ix */
      };			/* end case MELTOBMAG_MAPGIMPLES */
      break;
      /*gtyctype #5 CTYPE_GIMPLE_SEQ */
    case MELTOBMAG_GIMPLESEQ:
      break;
    case MELTOBMAG_MAPGIMPLESEQS:
      {
	struct meltmapgimpleseqs_st *src = (struct meltmapgimpleseqs_st *) p;
	int siz = 0, ix = 0;
	if (!src->entab)
	  break;
	siz = melt_primtab[src->lenix];
	gcc_assert (siz > 0);
	if (melt_is_young (src->entab))
	  {
	    struct entrygimpleseqmelt_st *newtab =
	      ggc_alloc_vec_entrygimpleseqmelt_st (siz);
	    memcpy (newtab, src->entab,
		    siz * sizeof (struct entrygimpleseqmelt_st));
	    src->entab = newtab;
	  }			/*end if young entab */
	for (ix = 0; ix < siz; ix++)
	  {
	    gimple_seq at = src->entab[ix].e_at;
	    if (!at || (void *) at == (void *) HTAB_DELETED_ENTRY)
	      {
		src->entab[ix].e_va = NULL;
		continue;
	      }			/*end if empty at */
	    MELT_FORWARDED (src->entab[ix].e_va);
	  }			/*end for ix */
      };			/* end case MELTOBMAG_MAPGIMPLESEQS */
      break;
      /*gtyctype #6 CTYPE_LOOP */
    case MELTOBMAG_LOOP:
      break;
    case MELTOBMAG_MAPLOOPS:
      {
	struct meltmaploops_st *src = (struct meltmaploops_st *) p;
	int siz = 0, ix = 0;
	if (!src->entab)
	  break;
	siz = melt_primtab[src->lenix];
	gcc_assert (siz > 0);
	if (melt_is_young (src->entab))
	  {
	    struct entryloopmelt_st *newtab =
	      ggc_alloc_vec_entryloopmelt_st (siz);
	    memcpy (newtab, src->entab,
		    siz * sizeof (struct entryloopmelt_st));
	    src->entab = newtab;
	  }			/*end if young entab */
	for (ix = 0; ix < siz; ix++)
	  {
	    loop_p at = src->entab[ix].e_at;
	    if (!at || (void *) at == (void *) HTAB_DELETED_ENTRY)
	      {
		src->entab[ix].e_va = NULL;
		continue;
	      }			/*end if empty at */
	    MELT_FORWARDED (src->entab[ix].e_va);
	  }			/*end for ix */
      };			/* end case MELTOBMAG_MAPLOOPS */
      break;
      /*gtyctype #7 CTYPE_RTVEC */
    case MELTOBMAG_RTVEC:
      break;
    case MELTOBMAG_MAPRTVECS:
      {
	struct meltmaprtvecs_st *src = (struct meltmaprtvecs_st *) p;
	int siz = 0, ix = 0;
	if (!src->entab)
	  break;
	siz = melt_primtab[src->lenix];
	gcc_assert (siz > 0);
	if (melt_is_young (src->entab))
	  {
	    struct entryrtvecmelt_st *newtab =
	      ggc_alloc_vec_entryrtvecmelt_st (siz);
	    memcpy (newtab, src->entab,
		    siz * sizeof (struct entryrtvecmelt_st));
	    src->entab = newtab;
	  }			/*end if young entab */
	for (ix = 0; ix < siz; ix++)
	  {
	    rtvec at = src->entab[ix].e_at;
	    if (!at || (void *) at == (void *) HTAB_DELETED_ENTRY)
	      {
		src->entab[ix].e_va = NULL;
		continue;
	      }			/*end if empty at */
	    MELT_FORWARDED (src->entab[ix].e_va);
	  }			/*end for ix */
      };			/* end case MELTOBMAG_MAPRTVECS */
      break;
      /*gtyctype #8 CTYPE_RTX */
    case MELTOBMAG_RTX:
      break;
    case MELTOBMAG_MAPRTXS:
      {
	struct meltmaprtxs_st *src = (struct meltmaprtxs_st *) p;
	int siz = 0, ix = 0;
	if (!src->entab)
	  break;
	siz = melt_primtab[src->lenix];
	gcc_assert (siz > 0);
	if (melt_is_young (src->entab))
	  {
	    struct entryrtxmelt_st *newtab =
	      ggc_alloc_vec_entryrtxmelt_st (siz);
	    memcpy (newtab, src->entab,
		    siz * sizeof (struct entryrtxmelt_st));
	    src->entab = newtab;
	  }			/*end if young entab */
	for (ix = 0; ix < siz; ix++)
	  {
	    rtx at = src->entab[ix].e_at;
	    if (!at || (void *) at == (void *) HTAB_DELETED_ENTRY)
	      {
		src->entab[ix].e_va = NULL;
		continue;
	      }			/*end if empty at */
	    MELT_FORWARDED (src->entab[ix].e_va);
	  }			/*end for ix */
      };			/* end case MELTOBMAG_MAPRTXS */
      break;
      /*gtyctype #9 CTYPE_TREE */
    case MELTOBMAG_TREE:
      break;
    case MELTOBMAG_MAPTREES:
      {
	struct meltmaptrees_st *src = (struct meltmaptrees_st *) p;
	int siz = 0, ix = 0;
	if (!src->entab)
	  break;
	siz = melt_primtab[src->lenix];
	gcc_assert (siz > 0);
	if (melt_is_young (src->entab))
	  {
	    struct entrytreemelt_st *newtab =
	      ggc_alloc_vec_entrytreemelt_st (siz);
	    memcpy (newtab, src->entab,
		    siz * sizeof (struct entrytreemelt_st));
	    src->entab = newtab;
	  }			/*end if young entab */
	for (ix = 0; ix < siz; ix++)
	  {
	    tree at = src->entab[ix].e_at;
	    if (!at || (void *) at == (void *) HTAB_DELETED_ENTRY)
	      {
		src->entab[ix].e_va = NULL;
		continue;
	      }			/*end if empty at */
	    MELT_FORWARDED (src->entab[ix].e_va);
	  }			/*end for ix */
      };			/* end case MELTOBMAG_MAPTREES */
      break;
      /* trailer generated by generate_runtypesupport_scanning */
    default:
      /* gcc_unreachable (); */
      fatal_error ("melt melt_scanning GC: corrupted heap, p=%p omagic=%d\n",
		   (void *) p, (int) omagic);
    }
}				/* end of melt_scanning generated by generate_runtypesupport_scanning */

/**end of code generated by generate_runtypesupport_scanning **/


/** start of code generated by generate_runtypesupport_boxingfun **/
/*gtyctype #1 CTYPE_BASIC_BLOCK*/

melt_ptr_t
meltgc_new_basicblock (meltobject_ptr_t discr_p, basic_block val)
{				/*generated boxingfun */
  MELT_ENTERFRAME (2, NULL);
#define resv meltfram__.mcfr_varptr[0]
#define discrv meltfram__.mcfr_varptr[1]
  discrv = discr_p;
  if (!discrv)
    discrv = MELT_PREDEF (DISCR_BASIC_BLOCK);
  if (melt_magic_discr ((melt_ptr_t) discrv) != MELTOBMAG_OBJECT)
    goto end;
  if (((meltobject_ptr_t) (discrv))->meltobj_magic != MELTOBMAG_BASICBLOCK)
    goto end;
  resv = meltgc_allocate (sizeof (struct meltbasicblock_st), 0);
  ((struct meltbasicblock_st *) (resv))->discr = (meltobject_ptr_t) discrv;
  ((struct meltbasicblock_st *) (resv))->val = val;
end:MELT_EXITFRAME ();
  return ((melt_ptr_t) (resv));
#undef resv
#undef discrv
}				/* end generated boxingfun meltgc_new_basicblock */

void
meltgc_basicblock_updatebox (melt_ptr_t box_p, basic_block val)
{				/*generated updateboxfun */
  MELT_ENTERFRAME (1, NULL);
#define boxv meltfram__.mcfr_varptr[0]
  boxv = box_p;
  if (melt_magic_discr ((melt_ptr_t) boxv) != MELTOBMAG_BASICBLOCK)
    goto end;
  ((struct meltbasicblock_st *) (boxv))->val = val;
  meltgc_touch ((melt_ptr_t) boxv);
end:MELT_EXITFRAME ();
#undef boxv
}				/* end generated updateboxfun meltgc_basicblock_updatebox */

/*gtyctype #2 CTYPE_BITMAP*/

melt_ptr_t
meltgc_new_bitmap (meltobject_ptr_t discr_p, bitmap val)
{				/*generated boxingfun */
  MELT_ENTERFRAME (2, NULL);
#define resv meltfram__.mcfr_varptr[0]
#define discrv meltfram__.mcfr_varptr[1]
  discrv = discr_p;
  if (!discrv)
    discrv = MELT_PREDEF (DISCR_BITMAP);
  if (melt_magic_discr ((melt_ptr_t) discrv) != MELTOBMAG_OBJECT)
    goto end;
  if (((meltobject_ptr_t) (discrv))->meltobj_magic != MELTOBMAG_BITMAP)
    goto end;
  resv = meltgc_allocate (sizeof (struct meltbitmap_st), 0);
  ((struct meltbitmap_st *) (resv))->discr = (meltobject_ptr_t) discrv;
  ((struct meltbitmap_st *) (resv))->val = val;
end:MELT_EXITFRAME ();
  return ((melt_ptr_t) (resv));
#undef resv
#undef discrv
}				/* end generated boxingfun meltgc_new_bitmap */

void
meltgc_bitmap_updatebox (melt_ptr_t box_p, bitmap val)
{				/*generated updateboxfun */
  MELT_ENTERFRAME (1, NULL);
#define boxv meltfram__.mcfr_varptr[0]
  boxv = box_p;
  if (melt_magic_discr ((melt_ptr_t) boxv) != MELTOBMAG_BITMAP)
    goto end;
  ((struct meltbitmap_st *) (boxv))->val = val;
  meltgc_touch ((melt_ptr_t) boxv);
end:MELT_EXITFRAME ();
#undef boxv
}				/* end generated updateboxfun meltgc_bitmap_updatebox */

/*gtyctype #3 CTYPE_EDGE*/

melt_ptr_t
meltgc_new_edge (meltobject_ptr_t discr_p, edge val)
{				/*generated boxingfun */
  MELT_ENTERFRAME (2, NULL);
#define resv meltfram__.mcfr_varptr[0]
#define discrv meltfram__.mcfr_varptr[1]
  discrv = discr_p;
  if (!discrv)
    discrv = MELT_PREDEF (DISCR_EDGE);
  if (melt_magic_discr ((melt_ptr_t) discrv) != MELTOBMAG_OBJECT)
    goto end;
  if (((meltobject_ptr_t) (discrv))->meltobj_magic != MELTOBMAG_EDGE)
    goto end;
  resv = meltgc_allocate (sizeof (struct meltedge_st), 0);
  ((struct meltedge_st *) (resv))->discr = (meltobject_ptr_t) discrv;
  ((struct meltedge_st *) (resv))->val = val;
end:MELT_EXITFRAME ();
  return ((melt_ptr_t) (resv));
#undef resv
#undef discrv
}				/* end generated boxingfun meltgc_new_edge */

void
meltgc_edge_updatebox (melt_ptr_t box_p, edge val)
{				/*generated updateboxfun */
  MELT_ENTERFRAME (1, NULL);
#define boxv meltfram__.mcfr_varptr[0]
  boxv = box_p;
  if (melt_magic_discr ((melt_ptr_t) boxv) != MELTOBMAG_EDGE)
    goto end;
  ((struct meltedge_st *) (boxv))->val = val;
  meltgc_touch ((melt_ptr_t) boxv);
end:MELT_EXITFRAME ();
#undef boxv
}				/* end generated updateboxfun meltgc_edge_updatebox */

/*gtyctype #4 CTYPE_GIMPLE*/

melt_ptr_t
meltgc_new_gimple (meltobject_ptr_t discr_p, gimple val)
{				/*generated boxingfun */
  MELT_ENTERFRAME (2, NULL);
#define resv meltfram__.mcfr_varptr[0]
#define discrv meltfram__.mcfr_varptr[1]
  discrv = discr_p;
  if (!discrv)
    discrv = MELT_PREDEF (DISCR_GIMPLE);
  if (melt_magic_discr ((melt_ptr_t) discrv) != MELTOBMAG_OBJECT)
    goto end;
  if (((meltobject_ptr_t) (discrv))->meltobj_magic != MELTOBMAG_GIMPLE)
    goto end;
  resv = meltgc_allocate (sizeof (struct meltgimple_st), 0);
  ((struct meltgimple_st *) (resv))->discr = (meltobject_ptr_t) discrv;
  ((struct meltgimple_st *) (resv))->val = val;
end:MELT_EXITFRAME ();
  return ((melt_ptr_t) (resv));
#undef resv
#undef discrv
}				/* end generated boxingfun meltgc_new_gimple */

void
meltgc_gimple_updatebox (melt_ptr_t box_p, gimple val)
{				/*generated updateboxfun */
  MELT_ENTERFRAME (1, NULL);
#define boxv meltfram__.mcfr_varptr[0]
  boxv = box_p;
  if (melt_magic_discr ((melt_ptr_t) boxv) != MELTOBMAG_GIMPLE)
    goto end;
  ((struct meltgimple_st *) (boxv))->val = val;
  meltgc_touch ((melt_ptr_t) boxv);
end:MELT_EXITFRAME ();
#undef boxv
}				/* end generated updateboxfun meltgc_gimple_updatebox */

/*gtyctype #5 CTYPE_GIMPLE_SEQ*/

melt_ptr_t
meltgc_new_gimpleseq (meltobject_ptr_t discr_p, gimple_seq val)
{				/*generated boxingfun */
  MELT_ENTERFRAME (2, NULL);
#define resv meltfram__.mcfr_varptr[0]
#define discrv meltfram__.mcfr_varptr[1]
  discrv = discr_p;
  if (!discrv)
    discrv = MELT_PREDEF (DISCR_GIMPLE_SEQ);
  if (melt_magic_discr ((melt_ptr_t) discrv) != MELTOBMAG_OBJECT)
    goto end;
  if (((meltobject_ptr_t) (discrv))->meltobj_magic != MELTOBMAG_GIMPLESEQ)
    goto end;
  resv = meltgc_allocate (sizeof (struct meltgimpleseq_st), 0);
  ((struct meltgimpleseq_st *) (resv))->discr = (meltobject_ptr_t) discrv;
  ((struct meltgimpleseq_st *) (resv))->val = val;
end:MELT_EXITFRAME ();
  return ((melt_ptr_t) (resv));
#undef resv
#undef discrv
}				/* end generated boxingfun meltgc_new_gimpleseq */

void
meltgc_gimpleseq_updatebox (melt_ptr_t box_p, gimple_seq val)
{				/*generated updateboxfun */
  MELT_ENTERFRAME (1, NULL);
#define boxv meltfram__.mcfr_varptr[0]
  boxv = box_p;
  if (melt_magic_discr ((melt_ptr_t) boxv) != MELTOBMAG_GIMPLESEQ)
    goto end;
  ((struct meltgimpleseq_st *) (boxv))->val = val;
  meltgc_touch ((melt_ptr_t) boxv);
end:MELT_EXITFRAME ();
#undef boxv
}				/* end generated updateboxfun meltgc_gimpleseq_updatebox */

/*gtyctype #6 CTYPE_LOOP*/

melt_ptr_t
meltgc_new_loop (meltobject_ptr_t discr_p, loop_p val)
{				/*generated boxingfun */
  MELT_ENTERFRAME (2, NULL);
#define resv meltfram__.mcfr_varptr[0]
#define discrv meltfram__.mcfr_varptr[1]
  discrv = discr_p;
  if (!discrv)
    discrv = MELT_PREDEF (DISCR_LOOP);
  if (melt_magic_discr ((melt_ptr_t) discrv) != MELTOBMAG_OBJECT)
    goto end;
  if (((meltobject_ptr_t) (discrv))->meltobj_magic != MELTOBMAG_LOOP)
    goto end;
  resv = meltgc_allocate (sizeof (struct meltloop_st), 0);
  ((struct meltloop_st *) (resv))->discr = (meltobject_ptr_t) discrv;
  ((struct meltloop_st *) (resv))->val = val;
end:MELT_EXITFRAME ();
  return ((melt_ptr_t) (resv));
#undef resv
#undef discrv
}				/* end generated boxingfun meltgc_new_loop */

void
melt_loop_updatebox (melt_ptr_t box_p, loop_p val)
{				/*generated updateboxfun */
  MELT_ENTERFRAME (1, NULL);
#define boxv meltfram__.mcfr_varptr[0]
  boxv = box_p;
  if (melt_magic_discr ((melt_ptr_t) boxv) != MELTOBMAG_LOOP)
    goto end;
  ((struct meltloop_st *) (boxv))->val = val;
  meltgc_touch ((melt_ptr_t) boxv);
end:MELT_EXITFRAME ();
#undef boxv
}				/* end generated updateboxfun melt_loop_updatebox */

/*gtyctype #7 CTYPE_RTVEC*/

melt_ptr_t
meltgc_new_rtvec (meltobject_ptr_t discr_p, rtvec val)
{				/*generated boxingfun */
  MELT_ENTERFRAME (2, NULL);
#define resv meltfram__.mcfr_varptr[0]
#define discrv meltfram__.mcfr_varptr[1]
  discrv = discr_p;
  if (!discrv)
    discrv = MELT_PREDEF (DISCR_RTVEC);
  if (melt_magic_discr ((melt_ptr_t) discrv) != MELTOBMAG_OBJECT)
    goto end;
  if (((meltobject_ptr_t) (discrv))->meltobj_magic != MELTOBMAG_RTVEC)
    goto end;
  resv = meltgc_allocate (sizeof (struct meltrtvec_st), 0);
  ((struct meltrtvec_st *) (resv))->discr = (meltobject_ptr_t) discrv;
  ((struct meltrtvec_st *) (resv))->val = val;
end:MELT_EXITFRAME ();
  return ((melt_ptr_t) (resv));
#undef resv
#undef discrv
}				/* end generated boxingfun meltgc_new_rtvec */

void
meltgc_rtvec_updatebox (melt_ptr_t box_p, rtvec val)
{				/*generated updateboxfun */
  MELT_ENTERFRAME (1, NULL);
#define boxv meltfram__.mcfr_varptr[0]
  boxv = box_p;
  if (melt_magic_discr ((melt_ptr_t) boxv) != MELTOBMAG_RTVEC)
    goto end;
  ((struct meltrtvec_st *) (boxv))->val = val;
  meltgc_touch ((melt_ptr_t) boxv);
end:MELT_EXITFRAME ();
#undef boxv
}				/* end generated updateboxfun meltgc_rtvec_updatebox */

/*gtyctype #8 CTYPE_RTX*/

melt_ptr_t
meltgc_new_rtx (meltobject_ptr_t discr_p, rtx val)
{				/*generated boxingfun */
  MELT_ENTERFRAME (2, NULL);
#define resv meltfram__.mcfr_varptr[0]
#define discrv meltfram__.mcfr_varptr[1]
  discrv = discr_p;
  if (!discrv)
    discrv = MELT_PREDEF (DISCR_RTX);
  if (melt_magic_discr ((melt_ptr_t) discrv) != MELTOBMAG_OBJECT)
    goto end;
  if (((meltobject_ptr_t) (discrv))->meltobj_magic != MELTOBMAG_RTX)
    goto end;
  resv = meltgc_allocate (sizeof (struct meltrtx_st), 0);
  ((struct meltrtx_st *) (resv))->discr = (meltobject_ptr_t) discrv;
  ((struct meltrtx_st *) (resv))->val = val;
end:MELT_EXITFRAME ();
  return ((melt_ptr_t) (resv));
#undef resv
#undef discrv
}				/* end generated boxingfun meltgc_new_rtx */

void
meltgc_rtx_updatebox (melt_ptr_t box_p, rtx val)
{				/*generated updateboxfun */
  MELT_ENTERFRAME (1, NULL);
#define boxv meltfram__.mcfr_varptr[0]
  boxv = box_p;
  if (melt_magic_discr ((melt_ptr_t) boxv) != MELTOBMAG_RTX)
    goto end;
  ((struct meltrtx_st *) (boxv))->val = val;
  meltgc_touch ((melt_ptr_t) boxv);
end:MELT_EXITFRAME ();
#undef boxv
}				/* end generated updateboxfun meltgc_rtx_updatebox */

/*gtyctype #9 CTYPE_TREE*/

melt_ptr_t
meltgc_new_tree (meltobject_ptr_t discr_p, tree val)
{				/*generated boxingfun */
  MELT_ENTERFRAME (2, NULL);
#define resv meltfram__.mcfr_varptr[0]
#define discrv meltfram__.mcfr_varptr[1]
  discrv = discr_p;
  if (!discrv)
    discrv = MELT_PREDEF (DISCR_TREE);
  if (melt_magic_discr ((melt_ptr_t) discrv) != MELTOBMAG_OBJECT)
    goto end;
  if (((meltobject_ptr_t) (discrv))->meltobj_magic != MELTOBMAG_TREE)
    goto end;
  resv = meltgc_allocate (sizeof (struct melttree_st), 0);
  ((struct melttree_st *) (resv))->discr = (meltobject_ptr_t) discrv;
  ((struct melttree_st *) (resv))->val = val;
end:MELT_EXITFRAME ();
  return ((melt_ptr_t) (resv));
#undef resv
#undef discrv
}				/* end generated boxingfun meltgc_new_tree */

void
meltgc_tree_updatebox (melt_ptr_t box_p, tree val)
{				/*generated updateboxfun */
  MELT_ENTERFRAME (1, NULL);
#define boxv meltfram__.mcfr_varptr[0]
  boxv = box_p;
  if (melt_magic_discr ((melt_ptr_t) boxv) != MELTOBMAG_TREE)
    goto end;
  ((struct melttree_st *) (boxv))->val = val;
  meltgc_touch ((melt_ptr_t) boxv);
end:MELT_EXITFRAME ();
#undef boxv
}				/* end generated updateboxfun meltgc_tree_updatebox */


/** end of code generated by generate_runtypesupport_boxingfun **/


/*** End of code file meltrunsup-inc.c generated on 2011 Oct 15
 * by GCC MELT 4.7.0 20111012 (experimental) [melt-branch revision 180041] MELT_0.9.1 . ***/
