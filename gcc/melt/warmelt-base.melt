;; -*- Lisp -*-
;; file warmelt-base.melt
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(comment "***
    Copyright 2008, 2009, 2010, 2011, 2012 Free Software Foundation, Inc.
    Contributed by Basile Starynkevitch <basile@starynkevitch.net>
               and Pierre Vittet  <piervit@pvittet.com>

    This file is part of GCC.

    GCC is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.

    GCC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.
***")

;; the copyright notice above apply both to warmelt-base.melt and 
;; to the generated file  warmelt-base*.c

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;    This file is part of a bootstrapping compiler for the MELT lisp
;;    dialect, compiler which should be able to compile itself (into
;;    generated C file[s])
;;    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; primitive to ignore a value
(defprimitive ignore (v) :void
  :doc #{Ignore the value passed as argument. Useful to avoid translation warnings, or to force the type of a conditional. See $CTYPE_VOID.}#
  #{/*ignore*/(void)($v)}#)  


;; primitive to return a void
(defprimitive void () :void 
  :doc #{Return a void value. See $IGNORE and $CTYPE_VOID.}#
#{/*void*/(void)0}#)

;; negation of is_object
(defprimitive is_not_object (obj) :long
  :doc #{Test if $OBJ is not an object. Negation of $IS_OBJECT.}#
  #{(melt_magic_discr((melt_ptr_t)($obj)) != MELTOBMAG_OBJECT)}#)


;; primitive to safely return a global predef by its index
(defprimitive get_globpredef (:long ix) :value
  :doc #{Safely gives the predefined of index $IX or null.}#
  #{/*get_globpredef*/ ((melt_ptr_t) melt_globpredef($ix))}#)

;; primitive to get the hashcode of an object (or 0)
(defprimitive obj_hash (v) :long
  :doc #{Safely gives the hashcode of object $V or else 0.}#
  #{(melt_obj_hash((melt_ptr_t)($v)))}#)

;; primitive to clone a value with another discriminant.
(defprimitive clone_with_discriminant (val discr) :value
  :doc #{Clone value $VAL with new discriminant $DISCR. Gives the
  original $VAL when cloning is not possible. For objects, make a new
  one copying the common fields. See the $VALDESC_CLONECHUNK field in
  $CLASS_VALUE_DESCRIPTOR. The primitive's code is generated.}#
  #{ meltgc_clone_with_discriminant((melt_ptr_t)($VAL), (melt_ptr_t)($DISCR)) }#)

;; primitive to get the length of an object (or 0)
(defprimitive obj_len (v) :long
  :doc #{Safely gives the length of object $V or else 0.}#
  #{(melt_obj_len((melt_ptr_t)($v)))}#)


;; primitive to get the number of an object (or 0)
(defprimitive obj_num (v) :long
  :doc #{Safely gives the number of object $V or else 0.}#
  #{(melt_obj_num((melt_ptr_t)($v)))}#)

;; primitive to compute a nonzero hash
(defprimitive nonzero_hash () :long
  :doc #{Gives a pseudo-random non-zero number suitable as an hash code.}# 
  "(melt_nonzerohash())")


;; primitives to force garbage collection
(defprimitive minor_garbcoll (:long siz) :void 
  :doc #{Force a minor MELT garbage collection. The $SIZ is the amount
  of memory to reserve.}#
  #{melt_garbcoll(($siz), MELT_MINOR_OR_FULL)}#)

(defprimitive full_garbcoll (:long siz) :void
  :doc #{Force a full MELT garbage collection. The $SIZ is the amount
  of memory to reserve.}#
  #{melt_garbcoll(($siz), MELT_NEED_FULL)}#)


;; check explicitly the call stack  
(defprimitive checkcallstack_msg (:cstring msg) :void
  :doc #{Low level costly primitive to check the entire call stack to
help hunt memory or GC bugs. Displays the given $MSG if the check went
wrong. Use it when desperate.}#
  #{melt_check_call_frames(MELT_ANYWHERE, $msg);}#)

;; internal primitive useful to increment the debug counter, used to
;; expand (DEBUG ...) macro
(defprimitive melt_increment_dbgcounter () :void
  #{/*melt_increment_dbgcounter*/ 
#if MELT_HAVE_DEBUG
melt_dbgcounter++;
#endif
}#)

;; for breakpoint
(defprimitive cbreak_msg (:cstring msg) :void
  :doc #{Low level primitive for GDB breakpoints. Use it temporarily,
given a string $MSG, with gdb when desperate.}#
  #{melt_cbreak($msg)}#)


(defprimitive c_time () :long
  :doc #{Get the current time(2) since Unix epoch in seconds.}#
  #{((long)time((time_t*)0))}#)

(defprimitive c_clock () :long
  :doc #{Get the current cpu clock(3) in microseconds.}#
  #{((long)clock())}#)

(defprimitive relative_time_millisec () :long
  :doc #{Get the real time, relative to MELT start, in milliseconds.}#
  #{melt_relative_time_millisec()}#)

(defprimitive set_real_timer_millisec (:long millisec) :void
  :doc #{Set the real time alarm in millisecond (or clear alarm if $MILLISEC is non-positive)}#
  #{melt_set_real_timer_millisec($MILLISEC)}#)

;; compare of longs [some primitives remain in warmelt-first.melt
;; because they are needed there]

(defprimitive <=i (:long a b) :long :doc #{Integer test that $A less or equal to $B.}#
  #{(($a) <= ($b))}#)

(defprimitive ==i (:long a b) :long  :doc #{Integer test that $A is equal to $B.}#
  #{(($a) == ($b))}#)


(defprimitive !=i (:long a b) :long  :doc #{Integer test that $A is unequal to $B.}#
  #{(($a) != ($b))}#)

;;; maximal & minimal of two longs
(defprimitive maxi (:long a b) :long 
  :doc #{$MAXI gives the maximum of two integers $A and $B}# 
#{MAX(($a),($b))}#)

(defprimitive mini (:long a b) :long 
  :doc #{$MINI gives the maximum of two integers $A and $B}# 
#{MIN(($a),($b))}#)


;;; long integer arithmetics; some primitives stay in warmelt-first.melt
(defprimitive -i (:long a b) :long  :doc #{Integer binary substraction of $a and $b.}#
  #{(($a) - ($b))}#)

(defprimitive *i (:long a b) :long  :doc #{Integer binary product of $a and $b.}#
  #{(($a) * ($b))}#)
(defprimitive andi (:long a b) :long   :doc #{Integer binary bitwise and of $a and $b.}#
  #{(($a) & ($b))}#)
(defprimitive ori (:long a b) :long  :doc #{Integer binary bitwise or of $a and $b.}#
  #{(($a) | ($b))}#)
(defprimitive xori (:long a b) :long :doc #{Integer binary bitwise exclusive-or of $a and $b.}#  
  #{(($a) ^ ($b))}#)

(defprimitive negi (:long i) :long  :doc #{Integer unary negation of $i.}#
  #{(-($i))}#)
(defprimitive noti (:long i) :long :doc #{Integer unary bitwise complement of $i.}# 
  #{(~($i))}#)


;;; functions for boxed arithmetic are costly, but you might find them useful.
(defun +iv (a b) 
  :doc #{Boxed integer addition of two boxed integers. 
  It is slow, since it is boxing.}#
  (if (is_integerbox a)
      (if (is_integerbox b)
	  (make_integerbox discr_constant_integer 
			   (+i (get_int a) (get_int b))))))

(defun -iv (a b) 
  :doc #{Boxed integer substraction of two boxed integers. 
  It is slow, since it is boxing.}#
  (if (is_integerbox a)
      (if (is_integerbox b)
	  (make_integerbox discr_constant_integer 
			   (-i (get_int a) (get_int b))))))


(defun *iv (a b) 
  :doc #{Boxed integer multiplication of two boxed integers. 
  It is slow, since it is boxing.}#
  (if (is_integerbox a)
      (if (is_integerbox b)
	  (make_integerbox discr_constant_integer 
			   (*i (get_int a) (get_int b))))))

(defun /iv (a b) 
  :doc #{Boxed integer division of two boxed integers. 
  It is slow, since it is boxing. Return null when undefined.}#
  (if (is_integerbox a)
      (if (is_integerbox b)
	  (if (get_int b)
	      (make_integerbox discr_constant_integer 
			       (/i (get_int a) (get_int b)))))))


(defun %iv (a b) 
  :doc #{Boxed integer remainder of two boxed integers. 
  It is slow, since it is boxing. Return null when undefined.}#
  (if (is_integerbox a)
      (if (is_integerbox b)
	  (let ( (:long ib (get_int b)) )
	    (if ib
		(make_integerbox discr_constant_integer 
				 (%i (get_int a) ib)))))))


(defprimitive +ivi (a :long lb) :value
  :doc #{Add boxed integer $A to constant raw long $LB. Return null if $A is not a boxed integer.}#
  #{/*+ivi*/ ((melt_magic_discr((melt_ptr_t) $A)==MELTOBMAG_INT)?
	 (meltgc_new_int
	   ((meltobject_ptr_t) MELT_PREDEF (DISCR_CONSTANT_INTEGER),
            (melt_unsafe_boxed_int_value((melt_ptr_t) $A) + ($LB))))
         :(melt_ptr_t)NULL)}#)



(defprimitive -ivi (a :long lb) :value
  :doc #{substract from boxed integer $A the constant raw long $LB. Return null if $A is not a boxed integer.}#
  #{/* -ivi*/ ((melt_magic_discr($A)==MELTOBMAG_INT)?
	 (meltgc_new_int
	   ((meltobject_ptr_t) MELT_PREDEF (DISCR_CONSTANT_INTEGER),
            (melt_unsafe_boxed_int_value($A) - ($LB))))
         :(melt_ptr_t)NULL)}#)


(defprimitive *ivi (a :long lb) :value
  :doc #{multiply boxed integer $A by constant raw long $LB. Return null if $A is not a boxed integer.}#
  #{/* *ivi*/ ((melt_magic_discr($A)==MELTOBMAG_INT)?
	 (meltgc_new_int
	   ((meltobject_ptr_t) MELT_PREDEF (DISCR_CONSTANT_INTEGER),
            (melt_unsafe_boxed_int_value($A) * ($LB))))
         :(melt_ptr_t)NULL)}#)


(defprimitive /ivi (a :long lb) :value
  :doc #{divide boxed integer $A by constant raw long $LB. Return null if $A is not a boxed integer or $LB is zero.}#
  #{/* /ivi*/ ((melt_magic_discr($A)==MELTOBMAG_INT && ($LB != 0L))?
	 (meltgc_new_int
	   ((meltobject_ptr_t) MELT_PREDEF (DISCR_CONSTANT_INTEGER),
            (melt_unsafe_boxed_int_value($A) / ($LB))))
         :(melt_ptr_t)NULL)}#)


(defprimitive %ivi (a :long lb) :value
  :doc #{modulus boxed integer $A by constant raw long $LB. Return null if $A is not a boxed integer or $LB is zero.}#
  #{/* %ivi*/ ((melt_magic_discr($A)==MELTOBMAG_INT && ($LB != 0L))?
	 (meltgc_new_int
	   ((meltobject_ptr_t) MELT_PREDEF (DISCR_CONSTANT_INTEGER),
            (melt_unsafe_boxed_int_value($A) % ($LB))))
         :(melt_ptr_t)NULL)}#)


(defprimitive <iv (a b) :long
  :doc #{Boxed integer compare of $A and $B for less than. 
Return 0 for non-boxed integer values.}#
  #{/* <iv */ ((melt_magic_discr((melt_ptr_t)($A)) == MELTOBMAG_INT)
           && (melt_magic_discr((melt_ptr_t)($B)) == MELTOBMAG_INT)
	   && (melt_unsafe_boxed_int_value($A)
               < (melt_unsafe_boxed_int_value($B))))}#)

(defprimitive <=iv (a b) :long
  :doc #{Boxed integer compare of $A and $B for less or equal. 
Return 0 for non-boxed integer values.}#
  #{/* <=iv */ ((melt_magic_discr((melt_ptr_t)($A)) == MELTOBMAG_INT)
           && (melt_magic_discr((melt_ptr_t)($B)) == MELTOBMAG_INT)
	   && (melt_unsafe_boxed_int_value($A)
               <= (melt_unsafe_boxed_int_value($B))))}#)

(defprimitive =iv (a b) :long
  :doc #{Boxed integer compare of $A and $B for numeric equality. 
Return 0 for non-boxed integer values.}#
  #{/* =iv */ ((melt_magic_discr((melt_ptr_t)($A)) == MELTOBMAG_INT)
           && (melt_magic_discr((melt_ptr_t)($B)) == MELTOBMAG_INT)
	   && (melt_unsafe_boxed_int_value($A)
               == (melt_unsafe_boxed_int_value($B))))}#)

(defprimitive !=iv (a b) :long
  :doc #{Boxed integer compare of $A and $B for numeric inequality. 
Return 0 for non-boxed integer values.}#
  #{/* !=iv */ ((melt_magic_discr((melt_ptr_t)($A)) == MELTOBMAG_INT)
           && (melt_magic_discr((melt_ptr_t)($B)) == MELTOBMAG_INT)
	   && (melt_unsafe_boxed_int_value($A)
               != (melt_unsafe_boxed_int_value($B))))}#)

(defprimitive >iv (a b) :long
  :doc #{Boxed integer compare of $A and $B for greater than. 
Return 0 for non-boxed integer values.}#
  #{/* >iv */ ((melt_magic_discr((melt_ptr_t)($A)) == MELTOBMAG_INT)
           && (melt_magic_discr((melt_ptr_t)($B)) == MELTOBMAG_INT)
	   && (melt_unsafe_boxed_int_value($A)
               > (melt_unsafe_boxed_int_value($B))))}#)

(defprimitive >=iv (a b) :long
  :doc #{Boxed integer compare of $A and $B for greater or equal. 
Return 0 for non-boxed integer values.}#
  #{/* >=iv */ ((melt_magic_discr((melt_ptr_t)($A)) == MELTOBMAG_INT)
           && (melt_magic_discr((melt_ptr_t)($B)) == MELTOBMAG_INT)
	   && (melt_unsafe_boxed_int_value($A)
               >= (melt_unsafe_boxed_int_value($B))))}#)

(defprimitive <ivi (a :long lb) :long
  :doc #{Compare boxed integer $A with constant raw long $LB for less than. Return 0 if $A is not a boxed integer.}#
  #{/* <ivi*/ ((melt_magic_discr($A)==MELTOBMAG_INT) && (melt_unsafe_boxed_int_value($A) < ($LB)))}#)

(defprimitive <=ivi (a :long lb) :long
  :doc #{Compare boxed integer $A with constant raw long $LB for less or equal. Return 0 if $A is not a boxed integer.}#
  #{/* <=ivi*/ ((melt_magic_discr($A)==MELTOBMAG_INT) && (melt_unsafe_boxed_int_value($A) <= ($LB)))}#)

(defprimitive >ivi (a :long lb) :long
  :doc #{Compare boxed integer $A with constant raw long $LB for greater than. Return 0 if $A is not a boxed integer.}#
  #{/* >ivi*/ ((melt_magic_discr($A)==MELTOBMAG_INT) && (melt_unsafe_boxed_int_value($A) > ($LB)))}#)

(defprimitive >=ivi (a :long lb) :long
  :doc #{Compare boxed integer $A with constant raw long $LB for greater or equal. Return 0 if $A is not a boxed integer.}#
  #{/* >=ivi*/ ((melt_magic_discr($A)==MELTOBMAG_INT) && (melt_unsafe_boxed_int_value($A) >= ($LB)))}#)

(defprimitive =ivi (a :long lb) :long
  :doc #{Compare boxed integer $A with constant raw long $LB for numeric equality. Return 0 if $A is not a boxed integer.}#
  #{/* >=ivi*/ ((melt_magic_discr($A)==MELTOBMAG_INT) && (melt_unsafe_boxed_int_value($A) == ($LB)))}#)

(defprimitive !=ivi (a :long lb) :long
  :doc #{Compare boxed integer $A with constant raw long $LB for numeric inequality. Return 0 if $A is not a boxed integer.}#
  #{/* >=ivi*/ ((melt_magic_discr($A)==MELTOBMAG_INT) && (melt_unsafe_boxed_int_value($A) != ($LB)))}#)

;;; various tests

(defprimitive notnull (v) :long :doc #{Test that $V is not the null value.}#
  #{(($v) != NULL)}#)

;;; zero test (for numbers)
(defprimitive zerop (:long i)  :long :doc #{Test that $I is zero.}# 
  #{/*zerop:*/ (($I) == 0L)}#)

;;; debug on dumpfile
(defprimitive outcstring_dbg (:cstring s) :void :doc #{output a debug string $S.}#
  #{melt_puts(dump_file,($s))}#)
(defprimitive outnum_dbg (:cstring pref :long l :cstring suf) :void
  :doc #{debug output an integer $L with prefix $PREF and suffix $SUF.}#
  #{melt_putnum(dump_file,($pref), ($l), ($suf))}#)
(defprimitive outstr_dbg (str) :void :doc #{output a debug string value $STR.}#
  #{melt_putstr(dump_file,(melt_ptr_t)($str))}#)

(defprimitive outstrbuf_dbg (sbuf) :void :doc #{output a debug stringbuffer value $SBUF.}#
  #{melt_putstrbuf(dump_file,(melt_ptr_t)($sbuf))}#)
(defprimitive outnewline_dbg () :void :doc #{output a debug newline.}#
  #{melt_newlineflush(dump_file)}#)
;;; output on stderr
(defprimitive outnum_err (:cstring pref :long l :cstring suf) :void
  :doc #{output on stderr the number $L with prefix $PREF and suffix $SUF.}#
  #{melt_putnum(stderr,($pref), ($l), ($suf))}#)
(defprimitive outcstring_err (:cstring s) :void
  :doc #{Output on stderr the string $s.}#
  #{melt_puts(stderr,($s))}#)
(defprimitive outstrbuf_err (sbuf) :void
  :doc #{Output on stderr the stringbuffer value $sbuf.}#
  #{melt_putstrbuf(stderr,(melt_ptr_t)($sbuf))}#)


;; various primitives

;; change the head of a pair
(defprimitive pair_set_head (pa hd) :void
  :doc #{Safely set in pair $PA its head to $HD. 
Please avoid using that to introduce circularities in lists.}#
 #{meltgc_pair_set_head((melt_ptr_t)($pa), ($hd))}#)
;; length of a pair list
(defprimitive pair_listlength (pa) :long
  :doc #{Compute the linked length of given pair value $PA or else 0.}#
  #{(melt_pair_listlength((melt_ptr_t)($pa)))}#)

;; make a pair
(defprimitive make_pair (discr hd tl) :value
  :doc #{Create a new pair of given discrimiant $DISCR head $HD and
tail $TL or else null.}#
  #{(meltgc_new_pair((meltobject_ptr_t)($discr), (melt_ptr_t)($hd), (melt_ptr_t)($tl)))}#)

;;;;;; MIXINT primitives (use get_int to get the integer)
(defprimitive is_mixint (mi) :long
  :doc #{Test if value $MI is a mixedint value.}#
  #{(melt_magic_discr((melt_ptr_t)($mi)) == MELTOBMAG_MIXINT)}#)
;; get the value
(defprimitive mixint_val (mi) :value
  :doc #{Get the value inside a mixedint value $MI. The integer can be retrieved using $GET_INT.}#
  #{(melt_val_mixint((melt_ptr_t)($mi)))}#)
;; make a mixint
(defprimitive make_mixint (dis val :long num) :value
  :doc #{Make a mixint value of given discriminant $DIS value $VAL and number $NUM or else null.}#
  #{(meltgc_new_mixint((meltobject_ptr_t)($dis), (melt_ptr_t)($val), ($num)))}#)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;; MIXLOC primitives (use get_int to get the integer)
;; test
(defprimitive is_mixloc (mi) :long
  :doc #{Test if value $MI is a mixed location value.}#
  #{(melt_magic_discr((melt_ptr_t)($mi)) == MELTOBMAG_MIXLOC)}#)
;; get the value
(defprimitive mixloc_val (mi) :value
  :doc #{Safely retrieve the value inside a mixed location value $MI.}#
  #{(melt_val_mixloc((melt_ptr_t)($mi)))}#)
(defprimitive mixloc_location (mi) :long
  :doc #{Safely retrieve as an opaque long the location of a mixed location value $MI.}#
  #{((long) melt_location_mixloc((melt_ptr_t)($mi)))}#)
(defprimitive mixloc_locline (mi) :long
  :doc #{Retrieve the line of the location of a mixed location value $MI.}#
  #{(LOCATION_LINE(melt_location_mixloc((melt_ptr_t)$mi)))}#)
(defprimitive mixloc_locfile (mi) :cstring
  :doc #{Retrieve the filename as a raw cstring of a mixed location value $MI.}#
  #{(LOCATION_FILE(melt_location_mixloc((melt_ptr_t)$mi)))}#)
(defprimitive mixloc_locbasefile (mi) :cstring
  :doc #{Retrieve the base filename as a raw cstring of a mixed location value $MI.}#
  #{(lbasename(LOCATION_FILE(melt_location_mixloc((melt_ptr_t)$mi))))}#)

(defprimitive make_string_mixloc_file (mi dis) :value
  :doc #{Retrieve the filename as a boxed string of a mixed location value $MI.}#
  #{(meltgc_new_stringdup((meltobject_ptr_t)($DIS), 
			  (LOCATION_FILE(melt_location_mixloc((melt_ptr_t)$MI)))))}#)

;; make a mixloc
(defprimitive make_mixloc (dis val :long num loc) :value
  :doc #{Make a mixed location value of given discriminant $DIS value $VAL
number $NUM opaque location number $LOC.}#
  #{(meltgc_new_mixloc((meltobject_ptr_t)($dis), (melt_ptr_t)($val), 
		       ($num), (location_t)($loc)))}#)



;; test for mixbigint
(defprimitive is_mixbigint (mb) :long
  :doc #{Test if value $MB is a mixed bigint.}#
  #{(melt_magic_discr((melt_ptr_t)($MB)) == MELTOBMAG_MIXBIGINT)}#)
(defprimitive mixbigint_val (mb) :value
  :doc #{Retrieve the value inside a mixed bigint $MB.}#
  #{melt_val_mixbigint((melt_ptr_t) $MB)}#)

(defprimitive ppstrbuf_mixbigint (:value sbuf :long indent :value mb) :void
 :doc #{Pretty prints into string buffer $SBUF at indentation $INDENT the mixed bigint $MB.}#
 #{meltgc_ppstrbuf_mixbigint((melt_ptr_t) $SBUF,$INDENT,(melt_ptr_t) $MB);}#
)


;;; READ FILE primitive
(defprimitive read_file (filnam) :value
  :doc #{Read from file named by the $FILNAM string balue a list of MELT s-expressions.}#
  #{(meltgc_read_file (melt_string_str((melt_ptr_t)($FILNAM)), (char*)0))}#)

(defprimitive read_strv (strv) :value
  :doc #{Return the list of s-exprs contained in in parsed string
  $STRV. $STRV can be a boxed string or a strbuf value.}#
  #{(meltgc_read_from_val ((melt_ptr_t) ($STRV), NULL))}# )

;; to signal an error in a  source with some additional string value
(defprimitive error_strv (loc :cstring cmsg :value strv) :void
  :doc #{Show an error at boxed location $LOC with raw message string $CMSG and string value $STRV.}#
  #{melt_error_str((melt_ptr_t)($loc), ($cmsg), (melt_ptr_t)($strv))}#)


;; signal a plain error in a  source
(defprimitive error_plain (loc :cstring cmsg) :void
  :doc #{Show a plain error at boxed location $LOC with raw message string $CMSG.}#
  #{/* error_plain */ melt_error_str((melt_ptr_t)($loc), ($cmsg), (melt_ptr_t)0)}#)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; to signal an warning in a  source with some additional string value
(defprimitive warning_strv (loc :cstring cmsg :value strv) :void
  :doc #{Show a warning at boxed location $LOC with raw message string $CMSG and string value $STRV.}#
  #{melt_warning_str(0, (melt_ptr_t)($loc), ($cmsg), (melt_ptr_t)($strv))}#)

;; signal a plain warning in a  source
(defprimitive warning_plain (loc :cstring cmsg) :void
  :doc #{Show a plain warning at boxed location $LOC with raw message string $CMSG.}#
  #{melt_warning_str(0, (melt_ptr_t)($loc), ($cmsg), (melt_ptr_t)0)}#)

;; signal a plain warning 
(defprimitive warningmsg_plain (:cstring cmsg) :void
  :doc #{Show a plain warning with raw message string $CMSG.}#
  #{warning(0, "MELT WARNING MSG [#%ld]::: %s", melt_dbgcounter, ($cmsg))}#  )

;; signal a plain error 
(defprimitive errormsg_plain (:cstring cmsg) :void
  :doc #{Show a plain error with raw message string $CMSG.}#
  #{error ("MELT ERROR MSG [#%ld]::: %s", melt_dbgcounter, ($cmsg))}#
  )




;; signal a plain warning with string
(defprimitive warningmsg_strv (:cstring cmsg :value strv) :void
  :doc #{Show a plain warning with raw message string $CMSG and string value $STRV.}#
  #{warning (0, "MELT WARNING MSG [#%ld]::: %s - %s", melt_dbgcounter, ($cmsg),
	  melt_string_str((melt_ptr_t)($STRV)))}#
  )

;; signal a plain error with string
(defprimitive errormsg_strv (:cstring cmsg :value strv) :void
  :doc #{Show a plain error with raw message string $CMSG and string value $STRV.}#
  #{error ("MELT ERROR MSG [#%ld]::: %s - %s", melt_dbgcounter, ($cmsg),
	  melt_string_str((melt_ptr_t)($STRV)))}#
  )

;; to signal an inform in a  source with some additional string value
(defprimitive inform_strv (loc :cstring cmsg :value strv) :void
  :doc #{Show a notice at boxed location $LOC with raw message string $CMSG and string value $STRV.}#
  #{melt_inform_str((melt_ptr_t)($loc), ($cmsg), (melt_ptr_t)($strv))}#)
;; signal a plain inform in a  source
(defprimitive inform_plain (loc :cstring cmsg) :void
  :doc #{Show a plain warning at boxed location $LOC with raw message string $CMSG.}#
  #{melt_inform_str((melt_ptr_t)($loc), ($cmsg), (melt_ptr_t)0)}#)


(defprimitive informsg_plain (:cstring cmsg) :void
  :doc #{Show a plain notice with raw message string $CMSG.}#
  #{inform(UNKNOWN_LOCATION, "MELT INFORM [#%ld]: %s",  melt_dbgcounter, ($cmsg))}#
  )

(defprimitive informsg_strv (:cstring cmsg :value strv) :void
  :doc #{Show a plain notice with raw message string $CMSG and string value $STRV.}#
  #{inform(UNKNOWN_LOCATION, "MELT INFORM [#%ld]: %s - %s",  
			     melt_dbgcounter, ($CMSG), 
			     melt_string_str ((melt_ptr_t) ($STRV)))}#
  )

;;; citerator on integers
(defciterator foreach_long_upto
  (:long imin imax)			;start formals
  eachlong				;state
  (:long ix)				;local formals
  :doc #{The $FOREACH_LONG_UPTO c-iterator provides the usual
ascending integer iterator. Start formals are $IMIN, the minimum start
integer, and $IMAX, le maximal ending integer. Local formal is $IX,
the current index. The body is executed for each integer value $IX
from $IMIN to $IMAX included.}#
  					;before expansion
#{/*start $eachlong */
    long $eachlong#_min =  $imin;
    long $eachlong#_max = $imax;
    long $eachlong#_cur = 0;
    for ($eachlong#_cur = $eachlong#_min;
         $eachlong#_cur <= $eachlong#_max;
	 $eachlong#_cur ++) {
	    $ix = $eachlong#_cur;	    
}#
 					;after expansion
   #{ } /*end eachlong */}#
)
   
;;; match an integer i mutiple of a given number n and submatch the quotient
(defcmatcher some_integer_multiple
  (:long i n)				;match & ins
  (:long q)					;outs
  intmult				;statesymb
  :doc #{The $SOME_INTEGER_MULTIPLE matcher with input number $N matches an
integer $I if $N is positive and $I is multiple of $N and the quotient
matches the subpattern $Q.}#
  ;; test expansion
  #{ /*$INTMULT ?*/ ($N>0 && (($I) % ($N))==0) }#
  ;; fill expansion
  #{ /*$INTMULT !*/ $Q = ($I) / ($N); }#
  )

;;; match an integer i different from a given number n
(defcmatcher some_integer_different_from
  (:long i n)
  ()
  intdiffrom
  :doc #{The $SOME_INTEGER_DIFFRERENT_FROM matcher with input number $N matches
an integer $I if $I is different from $N.}#
  ;; test expansion
  #{ /*$INTDIFFROM ?*/ ($I != $N) }#
  ;; no fill expansion
)

;;; match an integer i equal to a given number n
(defcmatcher some_integer_equal_to
  (:long i n)
  ()
  intequalto
  :doc #{The $SOME_INTEGER_EQUAL_TO matcher with input number $N matches
an integer $I if $I is or equal to $N.}#
  ;; test expansion
  #{ /*$INTEQUALTO ?*/ ($I == $N) }#
  ;; no fill expansion
)

;;; match an integer i greater or equal to a given number n
(defcmatcher some_integer_greater_or_equal_to
  (:long i n)
  ()
  intgreatorequal
  :doc #{The $SOME_INTEGER_GREATER_OR_EQUAL_TO matcher with input number $N matches
an integer $I if $I is greater or equal to $N.}#
  ;; test expansion
  #{ /*$INTGREATOREQUAL ?*/ ($I >= $N) }#
  ;; no fill expansion
)

;;; match an integer i greater than a given number n
(defcmatcher some_integer_greater_than
  (:long i n)
  ()
  intgreathan
  :doc #{The $SOME_INTEGER_GREATER_THAN matcher with input number $N matches
an integer $I if $I is greater than $N.}#
  ;; test expansion
  #{ /*$INTGREATHAN ?*/ ($I > $N) }#
  ;; no fill expansion
)

;;; match an integer i lower or equal to a given number n
(defcmatcher some_integer_lower_or_equal_to
  (:long i n)
  ()
  intloworequal
  :doc #{The $SOME_INTEGER_LOWER_OR_EQUAL_TO matcher with input number $N matches
an integer $I if $I is lower or equal to $N.}#
  ;; test expansion
  #{ /*$INTLOWOREQUAL ?*/ ($I <= $N) }#
  ;; no fill expansion
)

;;; match an integer i lower than a given number n
(defcmatcher some_integer_lower_than
  (:long i n)
  ()
  intlowthan
  :doc #{The $SOME_INTEGER_LOWER_THAN matcher with input number $N matches
an integer $I if $I is lower than $N.}#
  ;; test expansion
  #{ /*$INTLOWTHAN ?*/ ($I < $N) }#
  ;; no fill expansion
)

;;; match a boxed string, and set strval component
(defcmatcher some_string_value 
  (:value v)
  (:value sv)
  somestrval
  :doc #{The $SOME_STRING_VALUE matches a string value $V and passes it to the output $SV.}#
  ;; test
  #{ /*$SOMESTRVAL? */ (($V) && melt_magic_discr((melt_ptr_t)($V)) == MELTOBMAG_STRING) }#
  ;; fill
  #{ /*$SOMESTRVAL! */ $SV = $V; }#
)
;;;;;;;;;;;;;;;;

(defprimitive outnewline_err () :void
  :doc #{Output on stderr a newline and flush.}#
  "melt_newlineflush(stderr)")

(defprimitive outstr_err (str) :void
  :doc #{Output on stderr a MELT string.}#
  #{melt_putstr(stderr, (melt_ptr_t)($str))}#)


(defprimitive message_dbg (:cstring msg) :void :doc #{Debug message $msg}#
  #{debugeputs(($msg))}#)
(defprimitive messagenum_dbg (:cstring msg :long i) :void 
  :doc #{Debug output with message $msg number $i}#
  #{debugnum(($msg), ($i))}#)

(defprimitive messageval_dbg (:cstring msg :value val) :void
  :doc #{Debug output with message $msg value $val}#
  #{debugvalue(($msg), ((void*)($val)))}#)

(defprimitive longbacktrace_dbg (:cstring msg :long maxdepth) :void
  :doc #{Detailed debug backtrace with message $MSG up to $MAXDEPTH.}#
  #{debugbacktrace(($MSG), (int)($MAXDEPTH))}#)


(defprimitive checkval_dbg (val :cstring msg) :void
  :doc #{Low-level costly check of value $VAL with message $MSG. Mostly useful for gurus.}#
  #{/*checkval_dbg*/ {if ($VAL) 
       melt_checked_assignmsg ((melt_ptr_t) ($VAL), ($MSG));
     else (void)$MSG;}}#)

(defprimitive debugcstring (:cstring msg str) :void
  :doc #{Debug cstring $MSG $STR.}#
  #{debugeprintf("debugcstring %s '%s'", $msg, $str)}#)

(defprimitive debuglong (:cstring msg :long num) :void
  :doc #{Debug long stuff with $MSG and number $NUM.}#
  #{debugeprintf("debuglong %s %ld", $msg, $num)}#)

;;;;;; STRBUF primitives
;; primitive to make a strbuf
(defprimitive make_strbuf (discr) :value
  :doc #{Make a new stringbuffer value of given $DISCR - or null if bad $DISCR.}#
  #{(melt_ptr_t) meltgc_new_strbuf((meltobject_ptr_t)($DISCR), (const char*)0)}#)

;; reserve space for optimization purposes
(defprimitive strbuf_reserve (sbuf :long siz) :void
  :doc #{Reserve extra space in stringbuffer $SBUF for $SIZ bytes.}#
  #{ if ($SIZ > 0) meltgc_strbuf_reserve ((melt_ptr_t)$SBUF, (unsigned)$SIZ); }#
)

(defprimitive strbuf_usedlength (sbuf) :long
  :doc #{Give the used length of given $SBUF string buffer or else 0.}#
  #{melt_strbuf_usedlength((melt_ptr_t)($sbuf))}#)

(defprimitive output_length (out) :long
  :doc #{Return the length of a given output $OUT (i.e. the used length if it is a string buffer, the file position if it is a file) or else 0.}#
  #{melt_output_length ((melt_ptr_t)$OUT)}#)

(defprimitive is_strbuf (v) :long
  :doc #{Test if value $V is a stringbuffer.}# 
  #{(melt_magic_discr((melt_ptr_t)($v)) == MELTOBMAG_STRBUF)}#)

;;; make a string
(defprimitive make_string (dis str) :value
  :doc #{Make a new string of discriminant $DIS from string value $STR.}#
  #{(meltgc_new_stringdup((meltobject_ptr_t)($DIS), 
			  melt_string_str((melt_ptr_t)($STR))))}#)

(defprimitive is_stringconst (str :cstring cs) :long
  :doc #{Test that value string $STR is the raw string constant $CS.}#
  #{(melt_is_string_const((melt_ptr_t)($str), ($cs)))}#)

(defprimitive string_length (str) :long
  :doc #{Give the length of string value $STR.}#
  #{melt_string_length((melt_ptr_t)($str))}#)

(defprimitive string_suffixed (sv :cstring cs) :long
  :doc #{Test that the string value $SV ends with the suffix $CS.}#
  #{/*string_suffixed:*/(melt_string_is_ending ((melt_ptr_t)$SV, $CS))}#)

(defprimitive string_dynloaded_suffixed (sv) :long
  :doc #{Test that the string value $SV ends with the MELT_DYNLOADED_SUFFIX.}#
  #{/*string_dynloaded_suffixed:*/ (melt_string_is_ending ((melt_ptr_t)$SV, 
							   MELT_DYNLOADED_SUFFIX))}#)


(defprimitive string_prefixed (sv :cstring cs) :long
  :doc #{Test that the string value $SV starts with the suffix $CS.}#
  #{(melt_string_is_starting ((melt_ptr_t)$SV, $CS))}#)

(defprimitive string_starts (sv1 sv2) :long
  :doc #{Test that the string value $SV1 starts with the string value $SV2.}#
  #{(melt_string_is_starting ((melt_ptr_t)$SV1, melt_string_str ((melt_ptr_t)$SV2)))}#)

(defprimitive string_ends (sv1 sv2) :long
  :doc #{Test that the string value $SV1 ends with the string value $SV2.}#
  #{(melt_string_is_ending ((melt_ptr_t)$SV1, melt_string_str ((melt_ptr_t)$SV2)))}#)

(defprimitive string_hex_md5sum_constpath (:cstring path) :value
  :doc #{Return a boxed string contained the hexadecimal md5sum of raw $PATH, or null.}#
  #{(meltgc_string_hex_md5sum_file($PATH))}#)

(defprimitive string_hex_md5sum_pathstrv (pathv) :value
  :doc #{Return a boxed string contained the hexadecimal md5sum of the string value  $PATHV, or null.}#
  #{(meltgc_string_hex_md5sum_file (melt_string_str((melt_ptr_t)$PATHV)))}#)

(defprimitive string_hex_md5sum_path_sequence (pathseq) :value
  :doc #{Return a boxed string contained the cumulated hexadecimal
  md5sum on paths inside tuple $PATHSEQ, or null.}#
  #{(meltgc_string_hex_md5sum_file_sequence ((melt_ptr_t) $PATHSEQ))}#)


(defprimitive split_string_space (dis s) :value
  :doc #{Split a string value $S into a list of space separated strings of
discriminant $DIS.}#
#{meltgc_new_split_string (melt_string_str ((melt_ptr_t) $S), ' ', (melt_ptr_t) $DIS)}#)

(defprimitive split_string_comma (dis s) :value
  :doc #{Split a string value $S into a list of comma separated strings of
discriminant $DIS.}#
#{meltgc_new_split_string (melt_string_str ((melt_ptr_t) $S), ',', (melt_ptr_t) $DIS)}#)

(defprimitive split_string_colon (dis s) :value
  :doc #{Split a string value $S into a list of colon separated strings of
discriminant $DIS.}#
#{meltgc_new_split_string (melt_string_str ((melt_ptr_t) $S), ':', (melt_ptr_t) $DIS)}#)

(defprimitive split_string_equal (dis s) :value
  :doc #{Split a string value $S into a list of equal separated strings of
discriminant $DIS.}#
#{meltgc_new_split_string (melt_string_str ((melt_ptr_t) $S), '=', (melt_ptr_t) $DIS)}#)

;;; convert a strbuf into a string
(defprimitive strbuf2string (dis sbuf) :value
  :doc #{make a string value of discriminant $DIS from the stringbuffer $SBUF.}#
  #{(meltgc_new_stringdup((meltobject_ptr_t)($dis), melt_strbuf_str((melt_ptr_t)($sbuf))))}#)

;;; compute the naked basename
(defprimitive make_string_nakedbasename (dis str) :value
  :doc #{make a string value of discriminant $DIS from the naked basename from file path $STR.}#
  #{(meltgc_new_string_nakedbasename((meltobject_ptr_t)($DIS), 
				     melt_string_str((melt_ptr_t)($STR))))}#)

;;; compute the naked temporary path for a basename with a suffix
(defprimitive make_string_tempname_suffixed (dis str :cstring suff) :value
  :doc #{make a naked temporary path of discriminant $DIS for a
  basename $STR with suffix $SUFF.}#
  #{(meltgc_new_string_tempname_suffixed((meltobject_ptr_t)($DIS),
					 melt_string_str((melt_ptr_t)($STR)),
					 ($SUFF)))}#)


;; remove a suffix from a string or else copy it
(defprimitive make_string_without_suffix (dis str :cstring suffix) :value
  :doc #{Make a fresh copy with discriminant $DIS of string $STR 
removing the given $SUFFIX if it ends with it, or else a copy of $STR.}#
  #{/*make_string_without_suffix*/
  (meltgc_new_string_without_suffix ((meltobject_ptr_t)($DIS),
				     melt_string_str ((melt_ptr_t)($STR)),
				     ($SUFFIX))) }#
)

;; remove the MELT_DYNLOADED_SUFFIX from a string or else copy it
(defprimitive make_string_without_dynloaded_suffix (dis str) :value
  :doc #{Make a fresh copy with discriminant $DIS of string $STR 
removing the MELT_DYNLOADED_SUFFIX if it ends with it, or else a copy of $STR.}#
  #{/*make_string_without_dynloaded_suffix*/
  (meltgc_new_string_without_suffix ((meltobject_ptr_t)($DIS),
				     melt_string_str ((melt_ptr_t)($STR)),
				     MELT_DYNLOADED_SUFFIX))}#
)

;; compute a generated C source file
(defprimitive make_string_generated_c_filename (dis basestr dirstr) :value
  :doc #{make a generated C file path of discriminant $DIS with base $BASESTR and directory $DIRSTR adding a .c suffix.}#
  #{(meltgc_new_string_generated_c_filename((meltobject_ptr_t)($DIS),
					    melt_string_str ((melt_ptr_t)($BASESTR)),
					    melt_string_str ((melt_ptr_t)($DIRSTR)),
					    0))}#)


;; real path string, if accessible
(defprimitive make_string_real_access_path (dis :cstring filepath) :value
  :doc #{Make a string value of discriminant $DIS for the canonical real file
  path of $FILEPATH if it is accessible, or else NULL.}# 
 #{/*make_string_real_access_path*/ (meltgc_new_real_accessible_path_string 
				     ((meltobject_ptr_t) $DIS, 
				      $FILEPATH))}#)

;; likewise, for a string value filepathv
(defprimitive make_string_real_access_path_value (dis filev) :value
  :doc #{Make a string value of discriminant $DIS for the canonical real file
  path of string value $FILEV if it is accessible, or else NULL.}#
  #{/*make_string_real_access_path_value*/ (meltgc_new_real_accessible_path_string 
					    ((meltobject_ptr_t) $DIS,
					     melt_string_str ($FILEV)))}#)


;; generate a loadable module from a MELT generated C source file; the
;;  out is the dynloaded module without any MELT_DYNLOADED_SUFFIX. 
(defprimitive generate_flavored_melt_module (src outnam flavor) :void
  :doc #{Generate and load a module of given $FLAVOR whose source is named after $SRC 
and whose binary is named after $OUTNAM without any MELT_DYNLOADED_SUFFIX.}#
  #{ /*generate_flavored_melt_module*/ melt_compile_source (melt_string_str ((melt_ptr_t)$SRC),
			 melt_string_str ((melt_ptr_t)$OUTNAM),
			 NULL,
			 melt_string_str ((melt_ptr_t)$FLAVOR)); /*generate_flavored_melt_module*/
  }#)



;; primitive to load and initialize a module with a flavor in a given environement 
(defprimitive start_melt_module_of_flavor (env modname flavor) :value
  :doc #{start in environment $ENV  and load module of basename $MODNAME and $FLAVOR. Gives the new environment.}#
  #{meltgc_start_flavored_module ((melt_ptr_t)$ENV,
				  melt_string_str ((melt_ptr_t) $MODNAME),
				  melt_string_str ((melt_ptr_t) $FLAVOR));
  }#)


;;;;;;;;;;;;;;;; the melt version string
(defprimitive melt_version_str () :cstring
  :doc #{Gives the MELT version string.}#
  #{(melt_version_str())}#)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; OBJECT primitives
;; primitive to get an object length
(defprimitive object_length (ob) :long 
  :doc #{Gives the length of object $OB.}#
  #{((long)melt_object_length((melt_ptr_t)($ob)))}#)
;; primitive to get the nth field of an object
(defprimitive object_nth_field (ob :long n) :value
  :doc #{Safely retrieve from object $OB its $N-th field or else null.}#
  #{(melt_field_object((melt_ptr_t)($ob), ($n)))}#)

(defprimitive subclass_of (cl1 cl2) :long
  :doc #{Safely test if class $CL1 is a sub-class of class $CL2.}#
  #{melt_is_subclass_of((meltobject_ptr_t)($cl1), (meltobject_ptr_t)($cl2))}#)
(defprimitive subclass_or_eq (cl1 cl2) :long
  :doc #{Safely test if class $CL1 is the same or a sub-class of class $CL2.}#
  #{(($cl1 == $cl2) || melt_is_subclass_of((meltobject_ptr_t)($cl1), (meltobject_ptr_t)($cl2)))}#)

(defprimitive is_multiple_or_null (mul) :long
  :doc #{Safely test if $MUL is a tuple or null.}#
  #{(($mul) == NULL || (melt_unsafe_magic_discr((melt_ptr_t)($mul)) == MELTOBMAG_MULTIPLE))}#)
;; primitive to build the subsequence of a multiple
(defprimitive subseq_multiple (mul :long startix endix) :value
  :doc #{Make a tuple from as subsequence of $MUL from indexes $STARTIX to $ENDIX.}#
 #{ meltgc_new_subseq_multiple((melt_ptr_t)($mul),
				  (int)($startix), (int)($endix)) }#)

;; is_multiple, make_multiple, multiple_nth, multiple_put_nth are in
;; warmelt-first

;; cmatcher for the tuple nth argument
(defcmatcher tuple_nth 
  (matchedtup :long matchedrk)				;match & ins
  (outcomp)				;out
  tupnth				;statesymb
  :doc #{The $TUPLE_NTH matcher with input number $MATCHEDRK matches a
tuple of length greater than $MATCHEDRK and retrieve the component
of that index, and matches it against the sub-pattern.}#
  ;;test expansion
   #{/*$TUPNTH ?*/ (melt_is_multiple_at_least(((melt_ptr_t)$matchedtup), 1+ (int)($matchedrk)))}#
   ;;fill expansion
  #{/*$TUPNTH !*/ $outcomp = melt_multiple_nth((melt_ptr_t)($matchedtup),(int)($matchedrk));
   }#
  ;; no operator expansion 
)


;; cmatcher for a tuple of a given exact size
(defcmatcher tuple_sized
  (tup :long ln)			;match & ins
  () 					;outs
  tupsiz				;statesymb
  :doc #{Match a tuple of given exact size.}#
  ;;test expansion
   #{(melt_is_multiple_of_length((melt_ptr_t)($tup), (int) ($ln)))}#
  ;; no fill expansion
  ;; no operator expansion
)


;; public comparator for named instances
(defun compare_named_alpha (n1 n2)
  :doc #{Alphanumerical compare of named instances $N1 and $N2. 
Returns a boxed integer.}#
  (cond 
   ( (== n1 n2) 
     (return '0 ()))
   ( (is_not_a n1 class_named) 
     (return '1 ()))
   ( (is_not_a n2 class_named)
     (return '-1 ()))
   (:else
    (let ( (sn1 (unsafe_get_field :named_name n1))
	   (sn2 (unsafe_get_field :named_name n2)) )
      (cond
       ( (string< sn1 sn2) 
	 (return '-1 ()))
       ( (string> sn1 sn2)
	 (return '1 ()))
       (:else
	(return '0 ())))))))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; test if MELT is bootstrapping
(defprimitive melt_is_bootstrapping () :long
  :doc #{Test if MELT is bootstrapping. Only for MELT implementation gurus.}#
  #{(melt_flag_bootstrapping)}#
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; actually all the sbuf routines now take an outbuf argument, which can be either a string buffer of a file
(defprimitive is_out (v) :long
  :doc #{Test if value $V is a output value (a stringbuffer or a file).}# 
  #{ (melt_is_out ((melt_ptr_t) $v)) }#)

(defprimitive is_file (v) :long
  :doc #{Test if value $V is a file.}#
  #{ (melt_is_file ((melt_ptr_t) $V)) }#)

;; primitive to add a string const into a strbuf
(defprimitive add2sbuf_strconst (sbuf :cstring str) :void 
  :doc #{Add into stringbuffer $SBUF the constant string $STR.}#
  #{/*add2sbuf_strconst*/ meltgc_add_strbuf((melt_ptr_t)($SBUF), ($STR))}#)

;; primitive to add the MELT_DYNLOADED_SUFFIX into a strbuf
(defprimitive add2sbuf_dynloaded_suffix (sbuf) :void
  :doc #{Add into stringbuffer $SBUF the MELT_DYNLOADED_SUFFIX constant string.}#
  #{/*add2sbuf_dynloaded_suffix: */ meltgc_add_strbuf((melt_ptr_t)($SBUF), 
						      MELT_DYNLOADED_SUFFIX)}#)

;; primitive to add a string value into a strbuf
(defprimitive add2sbuf_string (sbuf str) :void 
  :doc #{Add into stringbuffer $SBUF the string value $STR.}#
  #{/*add2sbuf_string*/ meltgc_add_strbuf((melt_ptr_t)($SBUF), 
                      melt_string_str((melt_ptr_t)($STR)))}#)
;; primitive to add the location info of a mixedloc into a strbuf we
;; copy the location file name into a buffer, to avoid crashing if a
;; GC is called...
(defprimitive add2sbuf_mixloc (sbuf mixl) :void
  :doc #{Add into stringbuffer $SBUF the mixed loc $MIXL.}#
  #{/*add2sbufmixloc*/ if (melt_magic_discr((melt_ptr_t)($MIXL)) == MELTOBMAG_MIXLOC) {
    char smallcbuf[128];
    location_t loc = melt_location_mixloc ((melt_ptr_t)$MIXL);
    memset (smallcbuf, 0, sizeof(smallcbuf));
    snprintf (smallcbuf, sizeof (smallcbuf)-1, 
			"{%.120s:%d:%d}",
			LOCATION_FILE (loc), LOCATION_LINE (loc), LOCATION_COLUMN (loc));
    meltgc_add_strbuf_raw((melt_ptr_t)($SBUF), smallcbuf);
 } /*end add2sbufmixloc*/  }#)
;; primitive to add the short location info of a mixedloc into a strbuf
(defprimitive add2sbuf_short_mixloc (sbuf mixl) :void
  :doc #{Add into stringbuffer $SBUF the mixed loc $MIXL in short form.}#
  #{/*add2sbufshortmixloc*/  if (melt_magic_discr((melt_ptr_t)($mixl)) == MELTOBMAG_MIXLOC) {
  location_t loc = melt_location_mixloc((melt_ptr_t)$mixl);
  meltgc_strbuf_printf((melt_ptr_t)($sbuf), "{%s:%d:%d}", 
		       lbasename(LOCATION_FILE (loc)), 
		       LOCATION_LINE (loc), LOCATION_COLUMN (loc));
  } /*end add2sbufshortmixloc*/}#)
;; primitive to add the texi location info of a mixedloc into a strbuf
(defprimitive add2sbuf_texi_mixloc (sbuf mixl) :void
  :doc #{Add into stringbuffer $SBUF the mixed loc $MIXL in texinfo form.}#
  #{/*add2sbufteximixloc*/ if (melt_magic_discr((melt_ptr_t)($mixl)) == MELTOBMAG_MIXLOC) {
  location_t loc = melt_location_mixloc((melt_ptr_t)$mixl);
  meltgc_strbuf_printf((melt_ptr_t)($sbuf), "file @file{%s}, line %d", 
		       lbasename (LOCATION_FILE (loc)), 
		       LOCATION_LINE (loc)); 
  } /*end add2sbufteximixloc*/}#)

;; primitive to add an indentation or space into a strbuf
(defprimitive add2sbuf_indent (sbuf :long depth) :void
  :doc #{Add into stringbuffer $SBUF an indentation of given $DEPTH or a space.}#
  #{meltgc_strbuf_add_indent((melt_ptr_t)($sbuf), ($depth), 64)}#)


;; primitive to add an indented newline into a strbuf
(defprimitive add2sbuf_indentnl (sbuf :long depth) :void
  :doc #{Add into stringbuffer $SBUF an indented newline of given $DEPTH.}#
  #{meltgc_strbuf_add_indent((melt_ptr_t)($sbuf), ($depth), 0)}#)


;; primitive to add a strbuf into a strbuf
(defprimitive add2sbuf_sbuf (sbuf asbuf) :void 
  :doc #{Add into stringbuffer $SBUF the content of stringbuffer $ASBUF.}#
  #{/*add2sbuf_sbuf*/ meltgc_add_strbuf((melt_ptr_t)($SBUF), 
					melt_strbuf_str((melt_ptr_t)$ASBUF))}#)


;; primitive to add a string value, C encoded, into a strbuf
(defprimitive add2sbuf_cencstring (sbuf str) :void 
  :doc #{Add into stringbuffer $SBUF the content of string $STR with C encoding.}#
  #{meltgc_add_strbuf_cstr ((melt_ptr_t)($SBUF), 
                            melt_string_str ((melt_ptr_t)($STR)))}#)

;; primitive to add a strbuf, C encoded, into a strbuf
(defprimitive add2sbuf_cencstrbuf (sbuf asbuf) :void 
  :doc #{Add into stringbuffer $SBUF the content of stringbuffer $ASBUF with C encoding.}#
  #{meltgc_add_strbuf_cstr ((melt_ptr_t)($SBUF), melt_strbuf_str((melt_ptr_t)($ASBUF)))}#)


;; primitive to add a string value, Ccomment encoded, into a strbuf
(defprimitive add2sbuf_ccomstring (sbuf str) :void 
  :doc #{Add into stringbuffer $SBUF the content of string $STR with C-comment encoding, i.e. avoiding */.}#
  #{meltgc_add_strbuf_ccomment((melt_ptr_t)($SBUF), 
                               melt_string_str((melt_ptr_t)($STR)))}#)

;; primitive to add a strbuf, C encoded, into a strbuf
(defprimitive add2sbuf_ccomstrbuf (sbuf asbuf) :void 
  :doc #{Add into stringbuffer $SBUF the content of stringbuffer $ASBUF with C-comment encoding, i.e. avoiding */.}#
  #{meltgc_add_strbuf_ccomment((melt_ptr_t)($SBUF), 
			       melt_strbuf_str((melt_ptr_t)($ASBUF)))}#)

;; primitive to add a cstring const, Ccomment encoded, into a strbuf
(defprimitive add2sbuf_ccomconst (sbuf :cstring cstr) :void 
  :doc #{Add into stringbuffer $SBUF the constant string $CSTR with
 C-comment encoding so no */.}# 
 #{/*add2sbuf_ccomconst*/ meltgc_add_strbuf_ccomment((melt_ptr_t) ($SBUF), $CSTR)}#)

;; primitive to add into a strbuf a string as C ident (nonalphanum
;; replaced by _)
(defprimitive add2sbuf_cident (sbuf str) :void
  :doc #{Add into stringbuffer $SBUF the string $STR as a C identifier
  so nonalphanum replaced by _.}#
  #{meltgc_add_strbuf_cident((melt_ptr_t)($SBUF),
  melt_string_str((melt_ptr_t)($STR)))}#)

;; primitive to add into a strbuf the prefix of a string as C ident (nonalphanum
;; replaced by _) limited by a small length 
(defprimitive add2sbuf_cidentprefix  (sbuf str :long preflen) :void
  :doc #{Add into stringbuffer $SBUF the prefix string $STR as a C identifier
  so nonalphanum replaced by _ limited by $PREFLEN.}#
  #{meltgc_add_strbuf_cidentprefix((melt_ptr_t)($SBUF), 
                                   melt_string_str((melt_ptr_t)($STR)), ($PREFLEN))}#)

;; primitive to add a long in decimal into a strbuf
(defprimitive add2sbuf_longdec (sbuf :long num) :void
  :doc #{Add into stringbuffer $SBUF the number $NUM in decimal.}#
  #{meltgc_add_strbuf_dec((melt_ptr_t)($sbuf), ($num))}#)

;; primitive to add a long in hex into a strbuf
(defprimitive add2sbuf_longhex (sbuf :long num) :void
  :doc #{Add into stringbuffer $SBUF the number $NUM in hexa.}#
  #{meltgc_add_strbuf_hex((melt_ptr_t)($sbuf), ($num))}#)

;; primitive to add a routine descr into a strbuf
(defprimitive add2sbuf_routinedescr (sbuf rout) :void
  :doc #{Add into stringbuffer $SBUF the routine descriptor $ROUT.}#
  #{meltgc_add_strbuf((melt_ptr_t)($sbuf), melt_routine_descrstr((melt_ptr_t)($rout)))}#)

;;;;;;;;;;;;;;;;
;;; primitive to output a strbuf into a file named by a cstring
(defprimitive output_sbuf_strconst (sbuf :cstring nam) :void
  :doc #{Output into file named $NAM the content of strinbuffer $SBUF.}#
#{ /*output_sbuf_strconst*/ melt_output_strbuf_to_file((melt_ptr_t) ($SBUF), ($nam)) }#)
;;; primitive to output a strbuf into a file named by a stringval
(defprimitive output_sbuf_strval (sbuf vnam) :void
  :doc #{Output into file named by string value $VNAM the content of strinbuffer $SBUF.}#
#{ /*output_sbuf_strval*/ melt_output_strbuf_to_file((melt_ptr_t) ($SBUF), melt_string_str((melt_ptr_t) $VNAM)) }#)

;;; primitive to output a strbuf into a file named by a cstring
(defprimitive output_sbuf_no_overwrite_strconst (sbuf :cstring nam) :void
  :doc #{Output into file named $NAM the content of strinbuffer $SBUF, take care to not overwrite an file named $VNAM if it was the same.}#
#{ /*output_sbuf_no_overwrite_strconst*/ melt_output_strbuf_to_file_no_overwrite((melt_ptr_t)($SBUF), ($NAM)) }#)
;;; primitive to output a strbuf into a file named by a stringval
(defprimitive output_sbuf_no_overwrite_strval (sbuf vnam) :void
  :doc #{Output into file named by string value $VNAM the content of 
strinbuffer $SBUF, take care to not overwrite an old file named $VNAM if it was the same.}#
#{ /*output_sbuf_no_overwrite_strval*/ melt_output_strbuf_to_file_no_overwrite((melt_ptr_t)($SBUF), 
					   melt_string_str((melt_ptr_t) $VNAM)) }#)


;;;;;;;;;;;;;;;; variant for outbuf

;; primitive to add a string const into a outbuf
(defprimitive add2out_strconst (out :cstring str) :void 
  :doc #{Add to output $OUT the cstring $STR.}#
  #{meltgc_add_out((melt_ptr_t)($out), ($str))}#)
;; primitive to add a string value into a outbuf
(defprimitive add2out_string (out str) :void 
  :doc #{Add to output $OUT the string value $STR.}#
  #{meltgc_add_out((melt_ptr_t)($OUT), melt_string_str((melt_ptr_t)($STR)))}#)

;; primitive to add the location info of a mixedloc into a outbuf
(defprimitive add2out_mixloc (out mixl) :void
  :doc #{Add to output $OUT the mixed location $MIXL.}#
  #{/*add2outmixloc*/ if (melt_magic_discr((melt_ptr_t)($mixl)) == MELTOBMAG_MIXLOC) {
  char locbuf[256];
  location_t tloc = melt_location_mixloc((melt_ptr_t)$MIXL);
  memset (locbuf, 0, sizeof(locbuf));
  snprintf (locbuf, sizeof(locbuf)-1,
		    "{%.200s:%d}",
		    LOCATION_FILE (tloc),
		    LOCATION_LINE (tloc));
   meltgc_add_out_raw ((melt_ptr_t) $OUT, locbuf);
  } /*end add2outmixloc*/
}#)

;; primitive to add an indentation or space into a outbuf
(defprimitive add2out_indent (out :long depth) :void
  :doc #{Add to output $OUT the indentation $DEPTH or a space.}#
  #{meltgc_out_add_indent((melt_ptr_t)($OUT), ($depth), 64);}#
)


;; primitive to add an indented newline into a outbuf
(defprimitive add2out_indentnl (out :long depth) :void
  :doc #{Add to output $OUT the indented newline of given $DEPTH.}#
  #{meltgc_out_add_indent((melt_ptr_t)($OUT), ($depth), 0);}#
)


;; primitive to add a strbuf into a outbuf
(defprimitive add2out_sbuf (out asbuf) :void 
  :doc #{Add to output $OUT the stringbuffer $ASBUF.}#
  #{meltgc_add_out ((melt_ptr_t)($OUT), melt_strbuf_str ((melt_ptr_t) $ASBUF))}#)

;; primitive to add a string value, C encoded, into a outbuf
(defprimitive add2out_cencstring (out str) :void 
  :doc #{Add to output $OUT the C-encoded string value $STR.}#
  #{meltgc_add_out_cstr((melt_ptr_t)($OUT), 
			melt_string_str((melt_ptr_t)($STR)))}#)

;; primitive to add a substring value, C encoded, into a outbuf
(defprimitive add2out_cencsubstring (out str :long off slen) :void 
  :doc #{Add to output $OUT the C-encoded substring value $STR at offset $OFF of length $SLEN.}#
  #{meltgc_add_out_csubstr_len((melt_ptr_t)($OUT),
			       melt_string_str((melt_ptr_t)($STR)),
			       ($OFF), ($SLEN))}#)

;; primitive to add a C encoded constant string to a strbuf
(defprimitive add2out_cenconst (sbuf :cstring cstr) :void
  :doc #{Add into stringbuffer $SBUF the C-encoded constant string $CSTR}#
  #{meltgc_add_strbuf_cstr ((melt_ptr_t)($SBUF), $CSTR)}#)
;; primitive to add a strbuf, C encoded, into a outbuf
(defprimitive add2out_cencstrbuf (out asbuf) :void 
  :doc #{Add to output $OUT the C-encoded stringbuffer $ASBUF.}#
  #{meltgc_add_out_cstr((melt_ptr_t)($out), melt_strbuf_str((melt_ptr_t)($ASBUF)))}#)

;; primitive to add a string value, Ccomment encoded, into a outbuf
(defprimitive add2out_ccomstring (out str) :void 
  :doc #{Add to output $OUT the C-comment encoded string value $STR.}#
  #{meltgc_add_out_ccomment((melt_ptr_t)($OUT), 
                            melt_string_str((melt_ptr_t)($STR)))}#)

;; primitive to add a strbuf, C encoded, into a outbuf
(defprimitive add2out_ccomstrbuf (out asbuf) :void 
  :doc #{Add to $OUT the C-comment encoded stringbuffer $ASBUF.}#
  #{meltgc_add_out_ccomment((melt_ptr_t)($OUT), 
                            melt_strbuf_str((melt_ptr_t)($ASBUF)))}#)

;; primitive to add a cstring const, Ccomment encoded, into a outbuf
(defprimitive add2out_ccomconst (out :cstring cstr) :void 
  :doc #{Add to $OUT the constant C-comment encoded raw $CSTR.}#
  #{meltgc_add_out_ccomment(($out), $cstr)}#)

;; primitive to add into a outbuf a string as C ident (nonalphanum
;; replaced by _)
(defprimitive add2out_cident (out str) :void
  :doc #{Add to $OUT the MELT string $STR encocded as a C identifier, so
with every non-alnum character replaced with an underscore.}#
  #{meltgc_add_out_cident((melt_ptr_t)($OUT), 
			  melt_string_str((melt_ptr_t)($STR)))}#)

;; primitive to add into a outbuf the prefix of a string as C ident (nonalphanum
;; replaced by _) limited by a small length 
(defprimitive add2out_cidentprefix  (out str :long preflen) :void
  :doc #{Add to $OUT the prefix of a string encoded as a C identifier,
limited by a small length $PREFLEN.}#
  #{meltgc_add_out_cidentprefix((melt_ptr_t)($out), 
				melt_string_str((melt_ptr_t)($STR)), 
				($preflen))}#)

;; primitive to add a long in decimal into a outbuf
(defprimitive add2out_longdec (out :long num) :void
  :doc #{Add to $OUT the number $NUM in decimal.}#
  #{meltgc_add_out_dec((melt_ptr_t)($out), ($num))}#)

;; primitive to add a long in hex into a outbuf
(defprimitive add2out_longhex (out :long num) :void
  :doc #{Add to $OUT the number $NUM in hex.}#
  #{meltgc_add_out_hex((melt_ptr_t)($out), ($num))}#)

;; primitive to add a routine descr into a outbuf
(defprimitive add2out_routinedescr (out rout) :void
  :doc #{Add to $OUT the routine desscriptor $ROUT.}#
  #{meltgc_add_out((melt_ptr_t)($out), 
		   melt_routine_descrstr((melt_ptr_t)($rout)))}#)


(defselector add_to_out class_selector
  :doc #{The selector $ADD_TO_OUT add the reciever $RECV into the
output $OUT. It is called by the $ADD2OUT variadic function.}#
  :formals (recv out)
)

(defun add2out (out :rest)
  :doc #{Variadic function to add to an output $OUT (a file, a string buffer) 
  various things. Return the given $OUT. Use $ADD_TO_OUT selector for values. 
  Closure values are handled as manipulators for next thing.}#
  (if (not (is_out out))
      (return))
  (forever 
   argloop
   (variadic 
    ( ()
      (exit argloop))
    ( (:value v)
      (if (is_closure v)
	  (variadic
	   ((:value vv)
	    (v out vv))
	   ((:long ll)
	    (v out ll))
	   ((:cstring ss)
	    (v out ss))
	   ((:tree tt)
	    (v out tt))
	   ((:gimple gg)
	    (v out gg))
	   ((:gimple_seq gs)
	    (v out gs))
	   ((:edge ee)
	    (v out ee))
	   ((:loop lo)
	    (v out lo))
	   (:else
	    (let ( (vcty (variadic_ctype 0))
		   )
	      (errormsg_strv "ADD2OUT with manipulator for unsupported ctype"
			     (get_field :named_name vcty))
	      (assert_msg "invalid variadic argument after closure to ADD2OUT" ())
	      (return)
	      )))
	(add_to_out v out)))
    ( (:long n)
      (add2out_longdec out n))
    ( (:cstring s)
      (add2out_strconst out s))
    ( :else
      (let ( (vcty (variadic_ctype 0))
	     )
	(errormsg_strv "ADD2OUT for unsupported ctype; use a manipulator like OUTPUT_TREE "
		       (get_field :named_name vcty))
	)
      (assert_msg "invalid variadic argument to ADD2OUT" ())
      )))
  (return out)
  )

;;;;;;;;;;;;;;;;
(defun string4out (dis :rest)
  :doc #{Variadic function to make of string for output, 
  using $DIS as the string discriminant and the rest for filling it. See also $ADD2OUT.}#
  (unless dis (setq dis discr_string))
  (unless (is_a dis class_discriminant)
    (return))
  (let ( (:long goodmag 0)
	 )
    (code_chunk getmagidischk #{/* string4out $GETMAGIDISCHK */ $GOODMAG = 
		((meltobject_ptr_t)$DIS)->meltobj_magic == MELTOBMAG_STRING ;}#
		)
    (unless goodmag (return)))
  (let ( (out (make_strbuf discr_strbuf))
	 )
    (forever 
     argloop
     (variadic 
      ( ()
	(exit argloop))
      ( (:value v)
	(if (is_closure v)
	    (variadic
	     ((:value vv)
	      (v out vv))
	     ((:long ll)
	      (v out ll))
	     ((:cstring ss)
	      (v out ss))
	     ((:tree tt)
	      (v out tt))
	     ((:gimple gg)
	      (v out gg))
	     ((:gimple_seq gs)
	      (v out gs))
	     ((:edge ee)
	      (v out ee))
	     ((:loop lo)
	      (v out lo))
	     (:else
	      (let ( (vcty (variadic_ctype 0))
		     )
		(errormsg_strv "STRING4OUT with manipulator for unsupported ctype"
			       (get_field :named_name vcty))
		(assert_msg "invalid variadic argument after closure to STRING4OUT" ())
		(return)
		)))
	  (add_to_out v out)))
      ( (:long n)
	(add2out_longdec out n))
      ( (:cstring s)
	(add2out_strconst out s))
      ( :else
	(let ( (vcty (variadic_ctype 0))
	       )
	  (errormsg_strv "STRING4OUT for unsupported ctype; use a manipulator like OUTPUT_TREE "
			 (get_field :named_name vcty))
	  )
	(assert_msg "invalid variadic argument to STRING4OUT" ())
	)))
    (let ( (str (strbuf2string dis out))
	   )
      (return str)
      )))

;;;;;;;;;;;;;;;

;; read add2out4null as "add to out for null"
(defun add2out4null (v out)
  (assert_msg "check null v" (null v))
  (add2out_strconst out "*nil*"))
(install_method discr_null_receiver add_to_out add2out4null)

(defun add2out4integer (vn out)
  (assert_msg "check boxed number vn" (is_integerbox vn))
  (add2out_longdec out (get_int vn)))
(install_method discr_integer add_to_out add2out4integer)

(defun add2out4string (vs out)
  (assert_msg "check boxed string vs" (is_string vs))
  (add2out_string out vs))
(install_method discr_string add_to_out add2out4string)

(defun add2out4strbuf (vsbuf out)
  (assert_msg "check strbuf vsbuf" (is_strbuf vsbuf))
  (add2out_sbuf out vsbuf))
(install_method discr_strbuf add_to_out add2out4strbuf)

(defun add2out4clonedsymb (vc out)
  (match vc
	 (?(instance class_cloned_symbol
		     :named_name ?nvarnam
		     :csym_urank ?(integerbox_of ?nvarurank))
	   (assert_msg "check nvarnam" (is_string nvarnam))
	   (add2out_cident out nvarnam)
	   (add2out_strconst out "__")
	   (add2out_longdec out nvarurank))
	 (?_
	  (assert_msg "bad cloned symbol" ()))))
(install_method class_cloned_symbol add_to_out add2out4clonedsymb)

(defun add2out4named (vn out)
  (add2out_cident out (get_field :named_name vn)))
(install_method class_named add_to_out add2out4named)

(defun add2out4rootobject (vo out)
  (add2out_strconst out "*")
  (add2out_string out (get_field :named_name (discrim vo)))
  (add2out_strconst out "/")
  (add2out_longhex out (obj_hash vo))
  (add2out_strconst out "."))
(install_method class_root add_to_out add2out4rootobject)

(defun add2out4any (va out)
  (add2out_strconst out "*")
  (add2out_string out (get_field :named_name (discrim va))))
(install_method discr_any_receiver add_to_out add2out4any)



;;; cmatcher for a cstring of a given content
(defcmatcher cstring_same 
  (:cstring str cstr)
  ()
  strsam
  :doc #{The $CSTRING_SAME c-matcher matches a string $STR and test if
  it equals to the constant string $CSTR. The match fails if $STR is a
  null string or different from $CSTR.}# 

#{/*$strsam test*/ ($STR && $CSTR && !strcmp($STR, $CSTR)) }#
  ;; no fill or operator
)
;; cmatcher for a cstring starting with a given prefix
(defcmatcher cstring_prefixed 
  (:cstring str cstr)
  ()
  strprefixed
  :doc #{The $CSTRING_PREFIX c-matcher matches a string $STR and test if
  it starts with the constant string $CSTR. The match fails if $STR is a
  null string or not prefixed by $CSTR.}# 

#{/*$STRPREFIXED test*/ ($STR && $CSTR && !strncmp($STR, $CSTR, strlen ($CSTR))) }#
  ;; no fill or operator
)


;; primitive to compute the length of a cstring
(defprimitive cstring_length
  (:cstring cstr) :long
  :doc #{Compute safely the length a C-string $cstr. Gives 0 if null argument. }#
  #{(($cstr)?strlen($cstr):0)}#)

;;;;;;;;;;;;;;;;



;;; iterate fully in a map of strings
(defun mapstring_every (map f)
  :doc #{For a given hash-map of strings $MAP and a function $F,
apply $F to every attribute object and [perhaps allocated] string value. Returns
nil.}#
  (if (is_mapstring map)
      (if (is_closure f)
	  (foreach_in_mapstring
	   (map)
	   (curat curval)
	   (f curat curval)))))

;;; iterate & test over a map of strings - if the called f returns nil the
;;; iteration is stopped
(defun mapstring_iterate_test (map f)
  :doc #{For a given hash-map of strings $MAP and a function $F, apply
$F to every attribute object and string value. If it returns a null
value, with an other secundary value, gives the failing attribute, its
value, and the other.}#
  (if (is_mapstring map)
      (if (is_closure f)
	  (foreach_in_mapstring
	   (map)
	   (curat curval)
	   (multicall 
	    (test other)
	    (f curat curval)
	    (if (null test)
		(return curat curval other)
	   ))))))


;;;;;; MAPSTRINGs primitive

;; primitive to get the allocated size of a mapstring
(defprimitive mapstring_size (map) :long 
  :doc #{Safely return the current allocated size of a string-map $MAP or else 0.}#
  #{(melt_size_mapstrings((struct meltmapstrings_st*)($map)))}#)

;; primitive to get the attribute count of a mapstring
(defprimitive mapstring_count (map) :long
  :doc #{Safely return the current count of a string-map $MAP or else 0.}#
  #{(melt_count_mapstrings((struct meltmapstrings_st*)($map)))}#)


;; get an entry in a mapstring from a C string
(defprimitive mapstring_rawget (map :cstring cstr) :value
  :doc #{Safely get in a string-map $MAP the value associated with raw c-string $CSTR or else null.}#
  #{(melt_get_mapstrings((struct meltmapstrings_st*)($map), ($cstr)))}#)

;; primitive for putting into a map of strings
(defprimitive mapstring_rawput (map :cstring key :value val) :void
  :doc #{Safely put into a string-map $MAP the raw c-string $KEY associated to value $VAL.}#
  #{meltgc_put_mapstrings( (struct meltmapstrings_st *) ($map), ($key), (melt_ptr_t) ($val))}#)

;; primitives for removing from a map of strings
(defprimitive mapstring_rawremove (map :cstring key) :void
  :doc #{Safely remove from a string-map $MAP the value associated with raw c-string $KEY.}#
  #{meltgc_remove_mapstrings((struct meltmapstrings_st*) ($map), ($key))}#)


;;; full iterator on tuple - 
;;; the function is called with the component and its index
(defun multiple_every (tup f)
  :doc #{Apply to every component of tuple $TUP and its index the given
function $F. Return nil.}#
  (if (is_multiple tup)
      (if (is_closure f)
	  (foreach_in_multiple
	   (tup)
	   (comp :long ix)
	   (f comp ix)))))

;; full iterator backward
(defun multiple_backward_every (tup f)
  :doc #{Apply to every component (from last to first) of tuple $TUP
backwards, and its index the given function $F. Return nil.}#
  (if (is_multiple tup)
      (if (is_closure f)
	  (foreach_in_multiple_backward
	   (tup)
	   (comp :long ix)
	   (f comp ix)))))


;; iterator on two tuples
(defun multiple_every_both (tup1 tup2 f)
  :doc #{Given two tuples $TUP1 and $TUP2, apply function $F to every component of $TUP1 
with component of $TUP2 and index. Stop when either end is reached. Return nil.}#
  (if (is_multiple tup1)
      (if (is_multiple tup2)
	  (if (is_closure f)
	      (let ( (:long ln1 (multiple_length tup1))
		     (:long ln2 (multiple_length tup2))
		     (:long ix 0) )
		(forever tuploop
			 (if (>=i ix ln1) (exit tuploop))
			 (if (>=i ix ln2) (exit tuploop))
			 (f (multiple_nth tup1 ix) (multiple_nth tup2 ix) ix)
			 (setq ix (+i ix 1))))))))


;;;; MELT application depth & counter significant only when checking is enabled
(defprimitive melt_application_depth () :long 
  :doc #{Depth of MELT closures application - significant iff ENABLE_CHECKING.}#
  #{melt_application_depth()}#)

(defprimitive melt_application_shallower (:long maxdepth) :long
  :doc #{Test that the MELT application depth is less that $MAXDEPTH -
significant iff ENABLE_CHECKING.}# #{(melt_application_depth() <
  $MAXDEPTH)}#)

(defprimitive melt_application_count () :long
  :doc #{Count of MELT closures application - significant iff ENABLE_CHECKING.}#
  #{melt_application_count()}#)

(definstance melt_mode_reference class_reference
  :doc #{$MELT_MODE_REFERENCE is a reference dedicated to share data at the mode level.}#)


;;; a private reference for the list of closures for PLUGIN_PASS_EXECUTION
(definstance pass_execution_reference class_reference
  )

;;; private function to run all pass execution hooks
(defun run_all_pass_execution_hooks (hooklist passname :long passnum)
  ;; can't use debug_msg here!
  (foreach_in_list
   (hooklist)
   (curpair curhook)
   (curhook passname passnum)
   )
  (return)
)

;;; register a pass execution hook
(defun register_pass_execution_hook (fun)
  :doc #{Register closure $FUN as the hook for pass execution using
PLUGIN_PASS_EXECUTION. These hooks are called in order of
registration.  Their first argument is the boxed pass name string,
their second argument is the raw pass number stuff.  See also
$UNREGISTER_PASS_EXECUTION_HOOK.}#
  (if (is_closure fun)
      (let ( (hooklist (unsafe_get_field :referenced_value 
					 pass_execution_reference))
	     )
	(if (null hooklist)
	    (progn
	      (setq hooklist (list))
	      (put_fields pass_execution_reference :referenced_value hooklist)))
	(assert_msg "check hooklist" (is_list hooklist))
	;; check that the fun is not already registered
	(foreach_in_list
	 (hooklist)
	 (curpair curhook)
	 (if (== curhook fun)
	     (return))
	 )
	(list_append hooklist fun)
	(put_fields initial_system_data
		   :sysdata_passexec_hook 
		   (lambda (passname :long passnum)
		     (run_all_pass_execution_hooks hooklist passname passnum)))
	(return)
	)))

;;; unregister a pass execution hook 
(defun unregister_pass_execution_hook (fun)
  :doc #{Unregister a pass execution hook function $FUN previously
registered with $REGISTER_PASS_EXECUTION_HOOK.}#
  (if (is_closure fun)
      (let ( (oldhooklist (unsafe_get_field :referenced_value 
					    pass_execution_reference))
	     (newhooklist (list))
	     )
	(foreach_in_list
	 (oldhooklist)
	 (curpair curhook)
	 (if (!= curhook fun)
	     (list_append newhooklist curhook))
	 )
	(if (is_non_empty_list newhooklist)
	    (put_fields initial_system_data
		       :sysdata_passexec_hook ())
	  (put_fields initial_system_data
		     :sysdata_passexec_hook 
		     (lambda (passname :long passnum)
		       (run_all_pass_execution_hooks newhooklist passname passnum))))
)))

;;register a new pragma handler.
(defun register_pragma_handler (lsthandler)
  :doc #{register a list of new pragma handlers.  As :sysdata_meltpragmas must
  be a tuple (we use an index to recognize handlers), we have to recreate this
  tuple each time we call this function.  That why $LSTHANDLER is a list of
  handlers (class_gcc_pragma) and not a single object.  }#
  (assert_msg "register_pragma_handler takes a list as argument." 
    (is_list lsthandler))
  (let ((oldtuple (get_field :sysdata_meltpragmas initial_system_data))
        (:long oldsize 0))
    (if notnull oldtuple)
      (setq oldsize (multiple_length oldtuple))
    (let ((:long newsize (+i (multiple_length oldtuple)
                          (list_length lsthandler)))
          (newtuple (make_multiple discr_multiple newsize))
          (:long i 0))
    ;;copy in oldhandlers in the newtuple
    (foreach_in_multiple
    (oldtuple)
    (curhander :long iunused)
      (multiple_put_nth newtuple i curhander)
      (setq i (+i i 1))
    )
    ;;add new handler from lsthandler
    (foreach_in_list
    (lsthandler)
    (curpair curhandler)
      (assert_msg "register_pragma_handler must be a list of class_gcc_pragma."
        (is_a curhandler class_gcc_pragma))
      (multiple_put_nth newtuple i curhandler)
      (setq i (+i i 1))
    )
    (put_fields initial_system_data :sysdata_meltpragmas newtuple)
    ))
)

;; private pregenericize queue
(definstance pregenericize_delayed_queue class_delayed_queue
  :named_name '"pregenericize_delayed_queue"
  :delqu_first ()
  :delqu_last ()
  )

(defun register_pre_genericize_hook_first (fun)
  :doc #{Use $REGISTER_PRE_GENERICIZE_HOOK_FIRST to register a function $FUN to
  be run at PLUGIN_PRE_GENERICIZE hook, in first place.  $FUN must be a closure
  which take 1 argument (the boxed tree of function declaration being parsed).}#
  (let ( (firstlist (get_field :delqu_first pregenericize_delayed_queue))
	     )
    (if (null firstlist)
	    (progn
	      (setq firstlist (make_list discr_list))
	      (put_fields
	        pregenericize_delayed_queue
	        :delqu_first firstlist
	        :delqu_last (make_list discr_list))
	      (put_fields
	        initial_system_data
	        :sysdata_pre_genericize pre_genericize_hook_runner)))
    (if (is_closure fun)
      (list_append firstlist fun)
      (errormsg_plain
        "Bad hook passed to register_pre_genericize_hook")
    ))
)

(defun register_pre_genericize_hook_last (fun)
  :doc #{Use $REGISTER_PRE_GENERICIZE_HOOK_LAST to register a function $FUN to
  be run at PLUGIN_PRE_GENERICIZE hook, in last place.  $FUN must be a closure
  which take 1 argument (the boxed tree of function declaration being parsed).}#
  (let ( (lastlist (get_field :delqu_first pregenericize_delayed_queue))
	     )
    (if (null lastlist)
	    (progn
	      (setq lastlist (make_list discr_list))
	      (put_fields
	        pregenericize_delayed_queue
	        :delqu_first lastlist
	        :delqu_last (make_list discr_list))
	      (put_fields
	        initial_system_data
	        :sysdata_pre_genericize pre_genericize_hook_runner)))
    (if (is_closure fun)
      (list_append lastlist fun)
      (errormsg_plain
        "Bad hook passed to register_pre_genericize_hook")
    ))
)

;; internal function to for PLUGIN_PRE_GENERICIZE
(defun pre_genericize_hook_runner (fndeclv)
  :doc #{Function to be runned when PLUGIN_PRE_GENERICIZE hook is invoked.  
  For each closure registered in the list :sysdata_pre_genericize of
  initial_system_data, call them with $fndeclv, the tree declaration of the
  parsed function.   }#
  (let ( (firstlist (get_field :delqu_first pregenericize_delayed_queue))
	 (lastlist (get_field :delqu_last pregenericize_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (res ())
	 )
;;; call the first routines in natural order
    (foreach_in_list
     (firstlist)
     (firstpair firstproc)
     (setq res (firstproc fndeclv res))
     )
;;; reverse the last list
    (foreach_in_list
     (lastlist)
     (lastpair lastproc)
     (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
    (foreach_in_list
     (revlastlist)
     (revlastpair revlastproc)
     (setq res (revlastproc fndeclv res))
    )))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; private finishtype handling queue
(definstance finishtype_delayed_queue class_delayed_queue
  :named_name '"finishtype_delayed_queue"
  :delqu_first ()
  :delqu_last ()
  )

;; internal private primitive to notify the MELT runtime that
;; :sysdata_finishtype_hook has changed
(defprimitive melt_notify_finish_type () :void
  #{ /* melt_notify_finish_type */  meltgc_notify_finish_type_hook ();}#
)

;; internal private routine for PLUGIN_FINISH_TYPE 
(defun melt_finish_type_runner (boxtreev)
  (let ( (firstlist (get_field :delqu_first finishtype_delayed_queue))
	 (lastlist (get_field :delqu_last finishtype_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (res ())
	 )
;;; call the first routines in natural order
    (foreach_in_list
     (firstlist)
     (firstpair firstproc)
     (setq res (firstproc boxtreev res))
     )
;;; reverse the last list
    (foreach_in_list
     (lastlist)
     (lastpair lastproc)
     (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
    (foreach_in_list
     (revlastlist)
     (revlastpair revlastproc)
     (setq res (revlastproc boxtreev res))
    )))

(defun register_finish_type_hook_first (fun)
  :doc #{Use $REGISTER_FINISH_TYPE_HOOK_FIRST to register a function $FUN to
  be run at PLUGIN_FINISH_TYPE, in first place.  $FUN must be a closure
  which take 1 argument (the boxed tree of the parsed type).}#
  (if (is_closure fun)
      (let ( (firstlist (get_field :delqu_first finishtype_delayed_queue))
	    )
	(if (null firstlist)
	    (progn
	      (setq firstlist (make_list discr_list))
	      (put_fields
	        finishtype_delayed_queue
	        :delqu_first firstlist
	        :delqu_last (make_list discr_list))
	      (put_fields
	       initial_system_data
	       :sysdata_finishtype_hook melt_finish_type_runner)
	      (melt_notify_finish_type)
	      ))
	(list_append firstlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_finish_type_hook_first")
    ))

(defun register_finish_type_hook_last (fun)
  :doc #{Use $REGISTER_FINISH_TYPE_HOOK_LAST to register a function $FUN to
  be run at PLUGIN_FINISH_TYPE, in last place.  $FUN must be a closure
  which take 1 argument (the boxed tree of the parsed type).}#
  (if (is_closure fun)
      (let ( (lastlist (get_field :delqu_last finishtype_delayed_queue))
	    )
	(if (null lastlist)
	    (progn
	      (setq lastlist (make_list discr_list))
	      (put_fields
	        finishtype_delayed_queue
	        :delqu_first (make_list discr_list)
	        :delqu_last lastlist)
	      (put_fields
	       initial_system_data
	       :sysdata_finishtype_hook melt_finish_type_runner)
	      (melt_notify_finish_type)
	      ))
	(list_append lastlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_finish_type_hook_last")
))

;;;;;;;;;;;;;;;;
;; internal private primitive to notify the MELT runtime that
;; :sysdata_finishdecl_hook has changed
(defprimitive melt_notify_finish_decl () :void
  #{ /* melt_notify_finish_decl */  meltgc_notify_finish_decl_hook ();}#
)

;; private finishtype handling queue
(definstance finishdecl_delayed_queue class_delayed_queue
  :named_name '"finishdecl_delayed_queue"
  :delqu_first ()
  :delqu_last ()
  )

;; internal private routine for PLUGIN_FINISH_DECL 
(defun melt_finish_decl_runner (boxtreev)
  (let ( (firstlist (get_field :delqu_first finishdecl_delayed_queue))
	 (lastlist (get_field :delqu_last finishdecl_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (res ())
	 )
;;; call the first routines in natural order
    (foreach_in_list
     (firstlist)
     (firstpair firstproc)
     (setq res (firstproc boxtreev res))
     )
;;; reverse the last list
    (foreach_in_list
     (lastlist)
     (lastpair lastproc)
     (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
    (foreach_in_list
     (revlastlist)
     (revlastpair revlastproc)
     (setq res (revlastproc boxtreev res))
    )))

(defun register_finish_decl_hook_first (fun)
  :doc #{Use $REGISTER_FINISH_DECL_HOOK_FIRST to register a function
  $FUN to be run at PLUGIN_FINISH_DECL, in first place.  $FUN must be
  a closure which take 1 argument (the boxed tree of the parsed
  declaration). Only for GCC 4.7 or later.}#
  (if (is_closure fun)
      (let ( (firstlist (get_field :delqu_first finishdecl_delayed_queue))
	    )
	(if (null firstlist)
	    (progn
	      (setq firstlist (make_list discr_list))
	      (put_fields
	        finishdecl_delayed_queue
	        :delqu_first firstlist
	        :delqu_last (make_list discr_list))
	      (put_fields
	       initial_system_data
	       :sysdata_finishdecl_hook melt_finish_decl_runner)
	      (melt_notify_finish_decl)
	      ))
	(list_append firstlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_finish_decl_hook_first")
    ))

(defun register_finish_decl_hook_last (fun)
  :doc #{Use $REGISTER_FINISH_DECL_HOOK_LAST to register a function
  $FUN to be run at PLUGIN_FINISH_DECL, in last place.  $FUN must be a
  closure which take 1 argument (the boxed tree of the parsed
  declaration). Only for GCC 4.7 or later.}#
  (if (is_closure fun)
      (let ( (lastlist (get_field :delqu_last finishdecl_delayed_queue))
	    )
	(if (null lastlist)
	    (progn
	      (setq lastlist (make_list discr_list))
	      (put_fields
	        finishdecl_delayed_queue
	        :delqu_first (make_list discr_list)
	        :delqu_last lastlist)
	      (put_fields
	       initial_system_data
	       :sysdata_finishdecl_hook melt_finish_decl_runner)
	      (melt_notify_finish_decl)
	      ))
	(list_append lastlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_finish_decl_hook_last")
    ))





;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; handling PLUGIN_ALL_PASSES_START
;; private all_passes_start handling queue
(definstance all_passes_start_delayed_queue class_delayed_queue
  :named_name '"all_passes_start_delayed_queue"
  :delqu_first ()
  :delqu_last ()
  )

;; internal private routine for PLUGIN_ALL_PASSES_START 
(defun melt_all_passes_start_runner ()
  (let ( (firstlist (get_field :delqu_first finishdecl_delayed_queue))
	 (lastlist (get_field :delqu_last finishdecl_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (res ())
	 )
;;; call the first routines in natural order
    (foreach_in_list
     (firstlist)
     (firstpair firstproc)
     (setq res (firstproc res))
     )
;;; reverse the last list
    (foreach_in_list
     (lastlist)
     (lastpair lastproc)
     (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
    (foreach_in_list
     (revlastlist)
     (revlastpair revlastproc)
     (setq res (revlastproc res))
    )))

(defun register_all_passes_start_hook_first (fun)
  :doc #{Use $REGISTER_ALL_PASSES_START_HOOK_FIRST to register a function $FUN to
  be run at PLUGIN_ALL_PASSES_START, in first place.  $FUN must be a closure
  which take 1 argument (the boxed tree of the parsed declaration).}#
  (if (is_closure fun)
      (let ( (firstlist (get_field :delqu_first finishdecl_delayed_queue))
	    )
	(if (null firstlist)
	    (progn
	      (setq firstlist (make_list discr_list))
	      (put_fields
	        finishdecl_delayed_queue
	        :delqu_first firstlist
	        :delqu_last (make_list discr_list))
	      (put_fields
	       initial_system_data
	       :sysdata_all_passes_start_hook melt_all_passes_start_runner)
	      ))
	(list_append firstlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_all_passes_start_hook_first")
    ))

(defun register_all_passes_start_hook_last (fun)
  :doc #{Use $REGISTER_ALL_PASSES_START_HOOK_LAST to register a function $FUN to
  be run at PLUGIN_ALL_PASSES_START, in last place.  $FUN must be a closure
  which take 1 argument (the boxed tree of the parsed declaration).}#
  (if (is_closure fun)
      (let ( (lastlist (get_field :delqu_last finishdecl_delayed_queue))
	    )
	(if (null lastlist)
	    (progn
	      (setq lastlist (make_list discr_list))
	      (put_fields
	        finishdecl_delayed_queue
	        :delqu_first (make_list discr_list)
	        :delqu_last lastlist)
	      (put_fields
	       initial_system_data
	       :sysdata_all_passes_start_hook melt_all_passes_start_runner)
	      ))
	(list_append lastlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_all_passes_start_hook_last")
    ))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; handling PLUGIN_ALL_PASSES_END
;; private all_passes_end handling queue
(definstance all_passes_end_delayed_queue class_delayed_queue
  :named_name '"all_passes_end_delayed_queue"
  :delqu_first ()
  :delqu_last ()
  )

;; internal private routine for PLUGIN_ALL_PASSES_END 
(defun melt_all_passes_end_runner ()
  (let ( (firstlist (get_field :delqu_first finishdecl_delayed_queue))
	 (lastlist (get_field :delqu_last finishdecl_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (res ())
	 )
;;; call the first routines in natural order
    (foreach_in_list
     (firstlist)
     (firstpair firstproc)
     (setq res (firstproc res))
     )
;;; reverse the last list
    (foreach_in_list
     (lastlist)
     (lastpair lastproc)
     (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
    (foreach_in_list
     (revlastlist)
     (revlastpair revlastproc)
     (setq res (revlastproc res))
    )))

(defun register_all_passes_end_hook_first (fun)
  :doc #{Use $REGISTER_ALL_PASSES_END_HOOK_FIRST to register a function $FUN to
  be run at PLUGIN_ALL_PASSES_END, in first place.  $FUN must be a closure
  which take 1 argument (the boxed tree of the parsed declaration).}#
  (if (is_closure fun)
      (let ( (firstlist (get_field :delqu_first finishdecl_delayed_queue))
	    )
	(if (null firstlist)
	    (progn
	      (setq firstlist (make_list discr_list))
	      (put_fields
	        finishdecl_delayed_queue
	        :delqu_first firstlist
	        :delqu_last (make_list discr_list))
	      (put_fields
	       initial_system_data
	       :sysdata_all_passes_end_hook melt_all_passes_end_runner)
	      ))
	(list_append firstlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_all_passes_end_hook_first")
    ))

(defun register_all_passes_end_hook_last (fun)
  :doc #{Use $REGISTER_ALL_PASSES_END_HOOK_LAST to register a function $FUN to
  be run at PLUGIN_ALL_PASSES_END, in last place.  $FUN must be a closure
  which take 1 argument (the boxed tree of the parsed declaration).}#
  (if (is_closure fun)
      (let ( (lastlist (get_field :delqu_last finishdecl_delayed_queue))
	    )
	(if (null lastlist)
	    (progn
	      (setq lastlist (make_list discr_list))
	      (put_fields
	        finishdecl_delayed_queue
	        :delqu_first (make_list discr_list)
	        :delqu_last lastlist)
	      (put_fields
	       initial_system_data
	       :sysdata_all_passes_end_hook melt_all_passes_end_runner)
	      ))
	(list_append lastlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_all_passes_end_hook_last")
    ))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; handling PLUGIN_ALL_IPA_PASSES_START
;; private all_ipa_passes_start handling queue
(definstance all_ipa_passes_start_delayed_queue class_delayed_queue
  :named_name '"all_ipa_passes_start_delayed_queue"
  :delqu_first ()
  :delqu_last ()
  )

;; internal private routine for PLUGIN_ALL_IPA_PASSES_START 
(defun melt_all_ipa_passes_start_runner ()
  (let ( (firstlist (get_field :delqu_first finishdecl_delayed_queue))
	 (lastlist (get_field :delqu_last finishdecl_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (res ())
	 )
;;; call the first routines in natural order
    (foreach_in_list
     (firstlist)
     (firstpair firstproc)
     (setq res (firstproc res))
     )
;;; reverse the last list
    (foreach_in_list
     (lastlist)
     (lastpair lastproc)
     (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
    (foreach_in_list
     (revlastlist)
     (revlastpair revlastproc)
     (setq res (revlastproc res))
    )))

(defun register_all_ipa_passes_start_hook_first (fun)
  :doc #{Use $REGISTER_ALL_IPA_PASSES_START_HOOK_FIRST to register a function $FUN to
  be run at PLUGIN_ALL_IPA_PASSES_START, in first place.  $FUN must be a closure
  which take 1 argument (the boxed tree of the parsed declaration).}#
  (if (is_closure fun)
      (let ( (firstlist (get_field :delqu_first finishdecl_delayed_queue))
	    )
	(if (null firstlist)
	    (progn
	      (setq firstlist (make_list discr_list))
	      (put_fields
	        finishdecl_delayed_queue
	        :delqu_first firstlist
	        :delqu_last (make_list discr_list))
	      (put_fields
	       initial_system_data
	       :sysdata_all_ipa_passes_start_hook melt_all_ipa_passes_start_runner)
	      ))
	(list_append firstlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_all_ipa_passes_start_hook_first")
    ))

(defun register_all_ipa_passes_start_hook_last (fun)
  :doc #{Use $REGISTER_ALL_IPA_PASSES_START_HOOK_LAST to register a function $FUN to
  be run at PLUGIN_ALL_IPA_PASSES_START, in last place.  $FUN must be a closure
  which take 1 argument (the boxed tree of the parsed declaration).}#
  (if (is_closure fun)
      (let ( (lastlist (get_field :delqu_last finishdecl_delayed_queue))
	    )
	(if (null lastlist)
	    (progn
	      (setq lastlist (make_list discr_list))
	      (put_fields
	        finishdecl_delayed_queue
	        :delqu_first (make_list discr_list)
	        :delqu_last lastlist)
	      (put_fields
	       initial_system_data
	       :sysdata_all_ipa_passes_start_hook melt_all_ipa_passes_start_runner)
	      ))
	(list_append lastlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_all_ipa_passes_start_hook_last")
    ))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; handling PLUGIN_ALL_IPA_PASSES_END
;; private all_ipa_passes_end handling queue
(definstance all_ipa_passes_end_delayed_queue class_delayed_queue
  :named_name '"all_ipa_passes_end_delayed_queue"
  :delqu_first ()
  :delqu_last ()
  )

;; internal private routine for PLUGIN_ALL_IPA_PASSES_END 
(defun melt_all_ipa_passes_end_runner ()
  (let ( (firstlist (get_field :delqu_first finishdecl_delayed_queue))
	 (lastlist (get_field :delqu_last finishdecl_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (res ())
	 )
;;; call the first routines in natural order
    (foreach_in_list
     (firstlist)
     (firstpair firstproc)
     (setq res (firstproc res))
     )
;;; reverse the last list
    (foreach_in_list
     (lastlist)
     (lastpair lastproc)
     (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
    (foreach_in_list
     (revlastlist)
     (revlastpair revlastproc)
     (setq res (revlastproc res))
    )))

(defun register_all_ipa_passes_end_hook_first (fun)
  :doc #{Use $REGISTER_ALL_IPA_PASSES_END_HOOK_FIRST to register a function $FUN to
  be run at PLUGIN_ALL_IPA_PASSES_END, in first place.  $FUN must be a closure
  which take 1 argument (the boxed tree of the parsed declaration).}#
  (if (is_closure fun)
      (let ( (firstlist (get_field :delqu_first finishdecl_delayed_queue))
	    )
	(if (null firstlist)
	    (progn
	      (setq firstlist (make_list discr_list))
	      (put_fields
	        finishdecl_delayed_queue
	        :delqu_first firstlist
	        :delqu_last (make_list discr_list))
	      (put_fields
	       initial_system_data
	       :sysdata_all_ipa_passes_end_hook melt_all_ipa_passes_end_runner)
	      ))
	(list_append firstlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_all_ipa_passes_end_hook_first")
    ))

(defun register_all_ipa_passes_end_hook_last (fun)
  :doc #{Use $REGISTER_ALL_IPA_PASSES_END_HOOK_LAST to register a function $FUN to
  be run at PLUGIN_ALL_IPA_PASSES_END, in last place.  $FUN must be a closure
  which take 1 argument (the boxed tree of the parsed declaration).}#
  (if (is_closure fun)
      (let ( (lastlist (get_field :delqu_last finishdecl_delayed_queue))
	    )
	(if (null lastlist)
	    (progn
	      (setq lastlist (make_list discr_list))
	      (put_fields
	        finishdecl_delayed_queue
	        :delqu_first (make_list discr_list)
	        :delqu_last lastlist)
	      (put_fields
	       initial_system_data
	       :sysdata_all_ipa_passes_end_hook melt_all_ipa_passes_end_runner)
	      ))
	(list_append lastlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_all_ipa_passes_end_hook_last")
    ))






;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; handling PLUGIN_EARLY_GIMPLE_PASSES_START
;; private early_gimple_passes_start handling queue
(definstance early_gimple_passes_start_delayed_queue class_delayed_queue
  :named_name '"early_gimple_passes_start_delayed_queue"
  :delqu_first ()
  :delqu_last ()
  )

;; internal private routine for PLUGIN_EARLY_GIMPLE_PASSES_START 
(defun melt_early_gimple_passes_start_runner ()
  (let ( (firstlist (get_field :delqu_first finishdecl_delayed_queue))
	 (lastlist (get_field :delqu_last finishdecl_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (res ())
	 )
;;; call the first routines in natural order
    (foreach_in_list
     (firstlist)
     (firstpair firstproc)
     (setq res (firstproc res))
     )
;;; reverse the last list
    (foreach_in_list
     (lastlist)
     (lastpair lastproc)
     (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
    (foreach_in_list
     (revlastlist)
     (revlastpair revlastproc)
     (setq res (revlastproc res))
    )))

(defun register_early_gimple_passes_start_hook_first (fun)
  :doc #{Use $REGISTER_EARLY_GIMPLE_PASSES_START_HOOK_FIRST to register a function $FUN to
  be run at PLUGIN_EARLY_GIMPLE_PASSES_START, in first place.  $FUN must be a closure
  which take 1 argument (the boxed tree of the parsed declaration).}#
  (if (is_closure fun)
      (let ( (firstlist (get_field :delqu_first finishdecl_delayed_queue))
	    )
	(if (null firstlist)
	    (progn
	      (setq firstlist (make_list discr_list))
	      (put_fields
	        finishdecl_delayed_queue
	        :delqu_first firstlist
	        :delqu_last (make_list discr_list))
	      (put_fields
	       initial_system_data
	       :sysdata_early_gimple_passes_start_hook melt_early_gimple_passes_start_runner)
	      ))
	(list_append firstlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_early_gimple_passes_start_hook_first")
    ))

(defun register_early_gimple_passes_start_hook_last (fun)
  :doc #{Use $REGISTER_EARLY_GIMPLE_PASSES_START_HOOK_LAST to register a function $FUN to
  be run at PLUGIN_EARLY_GIMPLE_PASSES_START, in last place.  $FUN must be a closure
  which take 1 argument (the boxed tree of the parsed declaration).}#
  (if (is_closure fun)
      (let ( (lastlist (get_field :delqu_last finishdecl_delayed_queue))
	    )
	(if (null lastlist)
	    (progn
	      (setq lastlist (make_list discr_list))
	      (put_fields
	        finishdecl_delayed_queue
	        :delqu_first (make_list discr_list)
	        :delqu_last lastlist)
	      (put_fields
	       initial_system_data
	       :sysdata_early_gimple_passes_start_hook melt_early_gimple_passes_start_runner)
	      ))
	(list_append lastlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_early_gimple_passes_start_hook_last")
    ))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; handling PLUGIN_EARLY_GIMPLE_PASSES_END
;; private early_gimple_passes_end handling queue
(definstance early_gimple_passes_end_delayed_queue class_delayed_queue
  :named_name '"early_gimple_passes_end_delayed_queue"
  :delqu_first ()
  :delqu_last ()
  )

;; internal private routine for PLUGIN_EARLY_GIMPLE_PASSES_END 
(defun melt_early_gimple_passes_end_runner ()
  (let ( (firstlist (get_field :delqu_first finishdecl_delayed_queue))
	 (lastlist (get_field :delqu_last finishdecl_delayed_queue))
	 (revlastlist (make_list discr_list))
	 (res ())
	 )
;;; call the first routines in natural order
    (foreach_in_list
     (firstlist)
     (firstpair firstproc)
     (setq res (firstproc res))
     )
;;; reverse the last list
    (foreach_in_list
     (lastlist)
     (lastpair lastproc)
     (if (is_closure lastproc) (list_prepend revlastlist lastproc)))
;;; call the last routines in reverse order
    (foreach_in_list
     (revlastlist)
     (revlastpair revlastproc)
     (setq res (revlastproc res))
    )))

(defun register_early_gimple_passes_end_hook_first (fun)
  :doc #{Use $REGISTER_EARLY_GIMPLE_PASSES_END_HOOK_FIRST to register a function $FUN to
  be run at PLUGIN_EARLY_GIMPLE_PASSES_END, in first place.  $FUN must be a closure
  which take 1 argument (the boxed tree of the parsed declaration).}#
  (if (is_closure fun)
      (let ( (firstlist (get_field :delqu_first finishdecl_delayed_queue))
	    )
	(if (null firstlist)
	    (progn
	      (setq firstlist (make_list discr_list))
	      (put_fields
	        finishdecl_delayed_queue
	        :delqu_first firstlist
	        :delqu_last (make_list discr_list))
	      (put_fields
	       initial_system_data
	       :sysdata_early_gimple_passes_end_hook melt_early_gimple_passes_end_runner)
	      ))
	(list_append firstlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_early_gimple_passes_end_hook_first")
    ))

(defun register_early_gimple_passes_end_hook_last (fun)
  :doc #{Use $REGISTER_EARLY_GIMPLE_PASSES_END_HOOK_LAST to register a function $FUN to
  be run at PLUGIN_EARLY_GIMPLE_PASSES_END, in last place.  $FUN must be a closure
  which take 1 argument (the boxed tree of the parsed declaration).}#
  (if (is_closure fun)
      (let ( (lastlist (get_field :delqu_last finishdecl_delayed_queue))
	    )
	(if (null lastlist)
	    (progn
	      (setq lastlist (make_list discr_list))
	      (put_fields
	        finishdecl_delayed_queue
	        :delqu_first (make_list discr_list)
	        :delqu_last lastlist)
	      (put_fields
	       initial_system_data
	       :sysdata_early_gimple_passes_end_hook melt_early_gimple_passes_end_runner)
	      ))
	(list_append lastlist fun)
	)
    ;; fun not a closure
      (errormsg_plain
        "Bad function (non closure) passed to register_early_gimple_passes_end_hook_last")
    ))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; the descriptions of values which are not ctype related.
(defclass class_value_descriptor
  :doc #{The $CLASS_VALUE_DESCRIPTOR describes MELT values which are
  not ctype renated. $VALDESC_OBJMAGIC is the symbol MELTOBMAG_* of
  its magic number. $VALDESC_STRUCT is the GTY-ed struct
  name. $VALDESC_UNIONMEM is the union member name inside union
  melt_un. $VALDESC_MEMBCHUNK is the code chunk of the structure
  members after the discriminant. $VALDESC_DECLCHUNK is the code chunk
  for declarations, e.g. macros, outside of the GTY-ed
  structure. $VALDESC_GTY is the optional GTY
  argument. $VALDESC_COPYCHUNK is the code chunk copying src to an
  allocated dst. $VALDESC_FORWCHUNK is the code chunk formarding
  internal pointers. $VALDESC_CLONECHUNK is the code chunk to clone
  src, default to structure copy if :TRUE, used in the
  $CLONE_WITH_DISCRIMINANT primitive.}#
  :super class_named
  :fields (
	   valdesc_objmagic
	   valdesc_struct
	   valdesc_unionmem
	   valdesc_gty
	   valdesc_membchunk
	   valdesc_declchunk
	   valdesc_copychunk
	   valdesc_forwchunk
	   valdesc_clonechunk
	   )
)

(defclass class_varisized_value_descriptor
  :doc #{The $CLASS_VARISIZED_VALUE_DESCRIPTOR describes variable
  sized MELT values.}#
  :super class_value_descriptor
  :fields (
	   ))

(export_class
 class_value_descriptor 
 class_varisized_value_descriptor)


(defun set_reference (r v)
  :doc #{Safely put in a reference $R instance of $CLASS_REFERENCE 
the field :REFERENCED_VALUE to $V. Obsolete function, use $SET_REF macro.}#
  (put_fields r :referenced_value v))


;;;;;;;;;;;;;;;;
(definstance value_descriptor_list_reference
  class_reference
  :referenced_value (make_list discr_list)
)

(defun install_value_descriptor (vd)
  (assert_msg "check vd" (is_a vd class_value_descriptor))
  (list_append (get_field :referenced_value value_descriptor_list_reference) 
	       vd))

(defun retrieve_value_descriptor_list ()
  (get_field  :referenced_value value_descriptor_list_reference))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;; object value
(definstance valdesc_object class_varisized_value_descriptor
  :doc #{$VALDESC_OBJECT describes object values.}#
  :named_name '"VALDESC_OBJECT"
  :valdesc_objmagic '"MELTOBMAG_OBJECT"
  :valdesc_struct '"meltobject_st"
  :valdesc_unionmem '"u_object"
  :valdesc_membchunk #{$' /* from VALDESC_OBJECT in warmelt-base.melt */
  unsigned obj_hash;		/* hash code of the object */
  unsigned short obj_num;
  unsigned short obj_len;
  melt_ptr_t GTY ((length ("%h.obj_len"))) obj_vartab[MELT_FLEXIBLE_DIM];
  }#
  :valdesc_declchunk #{$' /* decl VALDESC_OBJECT */
#define meltobj_class discr
#define meltobj_magic obj_num
#define MELT_OBJECT_STRUCT(N) {			\
  meltobject_ptr_t meltobj_class;		\
  unsigned obj_hash;				\
  unsigned short obj_num;			\
  unsigned short obj_len;			\
  melt_ptr_t* obj_vartab[N];			\
  long _gap; }
  }#
  :valdesc_copychunk #{$' /* from VALDESC_OBJECT */
  /* ggc_alloc_meltobject_st should be gengtype generated for VALDESC_OBJECT */
#ifndef ggc_alloc_meltobject_st
#define ggc_alloc_meltobject_st(SIZE) ((struct meltobject_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif 
    int ix = 0;
    int oblen = (int) (src->obj_len);
    /* We don't need to clear at allocation, since the object is
       explicitly filled here! */
    dst = ggc_alloc_meltobject_st
      (oblen*sizeof(void*)
       + offsetof(struct meltobject_st, obj_vartab));
    /* we cannot copy the whole src, because MELT_FLEXIBLE_DIM might be 1 */
    dst->meltobj_class = src->meltobj_class;
    dst->obj_hash = src->obj_hash;
    dst->obj_num = src->obj_num;
    dst->obj_len = oblen;
    for (ix = 0; ix < oblen; ix++)
        dst->obj_vartab[ix] = src->obj_vartab[ix];
  }#
  :valdesc_clonechunk #{$' /* cloning, from VALDESC_OBJECT */
    unsigned newlen = 0;
    unsigned srclen = src->obj_len;
    unsigned slotix = 0;
    if (melt_is_subclass_of((meltobject_ptr_t)srcdiscrv, 
			    (meltobject_ptr_t)newdiscrv)) {
      newlen = 
        melt_multiple_length ((melt_ptr_t)
			      (((meltobject_ptr_t)newdiscrv)->obj_vartab[MELTFIELD_CLASS_FIELDS]));
      gcc_assert (newlen <= srclen);
      dst =  meltgc_new_raw_object ((meltobject_ptr_t)newdiscrv, newlen);
      for (slotix = 0; slotix < newlen; slotix++)
	dst->obj_vartab[slotix] = src->obj_vartab[slotix];
      dst->obj_num = src->obj_num;
    }
    else if (melt_is_subclass_of((meltobject_ptr_t)newdiscrv,
				 (meltobject_ptr_t)srcdiscrv)) {
      newlen = 
        melt_multiple_length ((melt_ptr_t)
			      (((meltobject_ptr_t)newdiscrv)->obj_vartab[MELTFIELD_CLASS_FIELDS]));      
      gcc_assert (newlen >= srclen);
      dst =  meltgc_new_raw_object ((meltobject_ptr_t)newdiscrv, newlen);
      for (slotix = 0; slotix < srclen; slotix++)
	dst->obj_vartab[slotix] = src->obj_vartab[slotix];
      dst->obj_num = src->obj_num;
    }
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_OBJECT */
    int ix = 0;
    int oblen = (int) (src->obj_len);
    for (ix = 0; ix < oblen; ix++)
      MELT_FORWARDED (src->obj_vartab[ix]);
  }#
)
(install_value_descriptor valdesc_object)

;;;;;;;;;;;;;;;; objects map values

(definstance valdesc_mapobjects class_value_descriptor
  :doc #{$VALDESC_MAPOBJECTS describes object-keyed map values.}#
  :named_name '"VALDESC_MAPOBJECTS"
  :valdesc_objmagic '"MELTOBMAG_MAPOBJECTS"
  :valdesc_struct '"meltmapobjects_st"
  :valdesc_unionmem '"u_mapobjects"
  :valdesc_membchunk #{$' /* from VALDESC_MAPOBJECTS in warmelt-base.melt */
  unsigned count;
  unsigned char lenix;
  melt_ptr_t meltmap_aux;
  struct entryobjectsmelt_st *GTY ((length ("melt_primtab[%h.lenix]")))
    entab;
  /* the following field is usually the value of entab (for
     objects in the young zone), to allocate the object and its fields
     at once; hence its GTY-ed length is zero */
  struct entryobjectsmelt_st GTY ((length ("0"))) map_space[MELT_FLEXIBLE_DIM];
  }#
  :valdesc_declchunk #{$' /* decl VALDESC_MAPOBJECTS in warmelt-base.melt */
    typedef struct meltmapobjects_st* meltmapobjects_ptr_t;
  }#
  :valdesc_copychunk #{$' /* copy VALDESC_MAPOBJECTS in warmelt-base.melt */
/* ggc_alloc_meltmapobjects_st should be gengtype generated for VALDESC_MAPOBJECTS */
#ifndef ggc_alloc_meltmapobjects_st
#define ggc_alloc_meltmapobjects_st() ((struct meltmapobjects_st *)(ggc_internal_alloc_stat (sizeof (struct meltmapobjects_st) MEM_STAT_INFO)))
#endif
#ifndef ggc_alloc_vec_entryobjectsmelt_st
#define ggc_alloc_vec_entryobjectsmelt_st(N) ((struct entryobjectsmelt_st *) (ggc_internal_vec_alloc_stat (sizeof (struct entryobjectsmelt_st), N MEM_STAT_INFO)))
#endif
#ifndef  ggc_alloc_cleared_vec_entryobjectsmelt_st
#define ggc_alloc_cleared_vec_entryobjectsmelt_st(n) ((struct entryobjectsmelt_st *)(ggc_internal_cleared_vec_alloc_stat (sizeof (struct entryobjectsmelt_st), n MEM_STAT_INFO)))
#endif
     int siz = melt_primtab[src->lenix];
     dst = 
	  /* Don't need a cleared allocation.  */
	  ggc_alloc_meltmapobjects_st ();
     dst->discr = src->discr;
     dst->count = src->count;
     dst->lenix = src->lenix;
     dst->meltmap_aux = src->meltmap_aux;
     if (siz > 0 && src->entab)
       {
       /* Don't need a cleared allocation.  */
         dst->entab = ggc_alloc_vec_entryobjectsmelt_st (siz);
         memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
       }
     else
       dst->entab = NULL;
  }#
  :valdesc_clonechunk #{$' /* cloning, from VALDESC_MAPOBJECTS */
     unsigned srccount = src->count;
     unsigned srclen = melt_primtab[src->lenix];
     unsigned newlen = 4*srccount/3+4;
     unsigned srcix = 0;
     dst = (struct meltmapobjects_st*) 
         meltgc_new_mapobjects ((meltobject_ptr_t)newdiscrv, newlen);
     resv = dst;
     dst->meltmap_aux = src->meltmap_aux;
     for (srcix = 0; srcix < srclen; srcix++) {
       meltobject_ptr_t curat = NULL;
       melt_ptr_t curva = NULL;
       src = (struct meltmapobjects_st*) srcvalv;
       curat = src->entab[srcix].e_at;
       curva = src->entab[srcix].e_va;
       if (!curat || curat == (meltobject_ptr_t) HTAB_DELETED_ENTRY
		  || !curva) 
         continue;
       meltgc_put_mapobjects((meltmapobjects_ptr_t)resv, curat, curva);
       /* update the dst, since it could have moved */
       dst =  (struct meltmapobjects_st*) resv;
     } /* end cloning, from VALDESC_MAPOBJECTS */
  }#
  :valdesc_forwchunk #{$' /* forwarding from VALDESC_MAPOBJECTS */
    int siz, ix;
    MELT_FORWARDED(src->meltmap_aux);
    if (!src->entab)
      break;
    siz = melt_primtab[src->lenix];
    gcc_assert (siz > 0);
    if (melt_is_young (src->entab))
      {
        struct entryobjectsmelt_st *newtab = 
          /* Don't need a cleared allocation!  */
          ggc_alloc_vec_entryobjectsmelt_st (siz);
        memcpy (newtab, src->entab,
                siz * sizeof (struct entryobjectsmelt_st));
        src->entab = newtab;
      }
    for (ix = 0; ix < siz; ix++)
      {
        meltobject_ptr_t at = src->entab[ix].e_at;
        if (!at || at == (void *) HTAB_DELETED_ENTRY)
          {
            src->entab[ix].e_va = NULL;
            continue;
          }
        MELT_FORWARDED (at);
        src->entab[ix].e_at = at;
        MELT_FORWARDED (src->entab[ix].e_va);
      }
    /* end forwarding from VALDESC_MAPOBJECTS */
  }#
)
(install_value_descriptor valdesc_mapobjects)

;;;;;;;;;;;;;;;; string map values
(definstance valdesc_mapstrings class_value_descriptor
  :doc #{$VALDESC_MAPSTRINGS describes string-keyed map values.}#
  :named_name '"VALDESC_MAPSTRINGS"
  :valdesc_objmagic '"MELTOBMAG_MAPSTRINGS"
  :valdesc_struct '"meltmapstrings_st"
  :valdesc_unionmem '"u_mapstrings"
  :valdesc_membchunk #{$' /* from VALDESC_MAPSTRINGS in warmelt-base.melt */
  unsigned count;
  unsigned char lenix;
  melt_ptr_t meltmap_aux;
  struct entrystringsmelt_st *GTY ((length ("melt_primtab[%h.lenix]")))
    entab;
  }#
  :valdesc_copychunk #{$' /* copy VALDESC_MAPSTRINGS in warmelt-base.melt */
/* ggc_alloc_meltmapstrings_st should be gengtype generated for VALDESC_MAPSTRINGS */
#ifndef ggc_alloc_meltmapstrings_st
#define ggc_alloc_meltmapstrings_st() ((struct meltmapstrings_st *)(ggc_internal_alloc_stat (sizeof (struct meltmapstrings_st) MEM_STAT_INFO)))
#endif
#ifndef ggc_alloc_vec_entrystringsmelt_st
#define ggc_alloc_vec_entrystringsmelt_st(n) ((struct entrystringsmelt_st *)(ggc_internal_vec_alloc_stat (sizeof (struct entrystringsmelt_st), n MEM_STAT_INFO)))
#endif
#ifndef ggc_alloc_cleared_vec_entrystringsmelt_st
#define ggc_alloc_cleared_vec_entrystringsmelt_st(n) ((struct entrystringsmelt_st *)(ggc_internal_cleared_vec_alloc_stat (sizeof (struct entrystringsmelt_st), n MEM_STAT_INFO)))
#endif
        int siz = melt_primtab[src->lenix];
	dst = 
	  /* Don't need a cleared allocation.  */
	  ggc_alloc_meltmapstrings_st ();
        dst->discr = src->discr;
        dst->count = src->count;
        dst->lenix = src->lenix;
        dst->meltmap_aux = src->meltmap_aux;
        if (siz > 0 && src->entab)
          {
          /* Don't need a cleared allocation.  */
            dst->entab = ggc_alloc_vec_entrystringsmelt_st (siz);
            memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
          }
        else
          dst->entab = NULL;
  }#
  :valdesc_clonechunk #{$' /* cloning from VALDESC_MAPSTRINGS */
     unsigned srccount = src->count;
     unsigned srclen = melt_primtab[src->lenix];
     unsigned newlen = 4*srccount/3+4;
     unsigned srcix = 0;
     dst = (struct meltmapstrings_st*) meltgc_new_mapstrings ((meltobject_ptr_t)newdiscrv, newlen);
     resv = dst;
     dst->meltmap_aux = src->meltmap_aux;
     for (srcix = 0; srcix < srclen; srcix++) {
       const char* curat = NULL;
       melt_ptr_t curva = NULL;
       src = (struct meltmapstrings_st*) srcvalv;
       dst = (struct meltmapstrings_st*) resv;
       curat = src->entab[srcix].e_at;
       if (!curat || curat == (const char*) HTAB_DELETED_ENTRY || !curat[0])
         continue;
       curva = src->entab[srcix].e_va;
       if (!curva) 
         continue;
       meltgc_put_mapstrings (dst, curat, curva);
       dst = (struct meltmapstrings_st*) resv;
     }
     /* end  cloning from VALDESC_MAPSTRINGS */
  }#
  :valdesc_forwchunk #{$' /* forwarding from VALDESC_MAPSTRINGS */
     int ix, siz;
     MELT_FORWARDED(src->meltmap_aux);
     if (!src->entab)
       break;
     siz = melt_primtab[src->lenix];
     gcc_assert (siz > 0);
     if (melt_is_young (src->entab))
       {
         struct entrystringsmelt_st *newtab
           /* Don't need a cleared allocation!  */
           = ggc_alloc_vec_entrystringsmelt_st (siz);
         memcpy (newtab, src->entab,
                 siz * sizeof (struct entrystringsmelt_st));
         src->entab = newtab;
       }
     for (ix = 0; ix < siz; ix++)
       {
         const char *at = src->entab[ix].e_at;
         if (!at || at == (void *) HTAB_DELETED_ENTRY)
           {
             src->entab[ix].e_va = NULL;
             continue;
           }
         if (melt_is_young ((const void *) at))
           src->entab[ix].e_at = (const char *) ggc_strdup (at);
         MELT_FORWARDED (src->entab[ix].e_va);
       }
    /* end  forwarding from VALDESC_MAPSTRINGS */
  }#
)
(install_value_descriptor valdesc_mapstrings)


;;;;;;;;;;;;;;;; decaying value
(definstance valdesc_decay class_value_descriptor
  :doc #{$VALDESC_DECAY describes decaying values.}#
  :named_name '"VALDESC_DECAY"
  :valdesc_objmagic '"MELTOBMAG_DECAY"
  :valdesc_struct '"meltdecay_st"
  :valdesc_unionmem '"u_decay"
  :valdesc_gty #{$' mark_hook ("melt_mark_decay")}#
  :valdesc_membchunk #{$' /* from VALDESC_DECAY in warmelt-base.melt */
  melt_ptr_t val;
  unsigned remain;		/* remaining number of marking */
  }#
  :valdesc_copychunk #{$' /* from VALDESC_DECAY */
/* ggc_alloc_meltdecay_st should be gengtype generated for VALDESC_DECAY */
#ifndef ggc_alloc_meltdecay_st
#define ggc_alloc_meltdecay_st() ((struct meltdecay_st *)(ggc_internal_alloc_stat (sizeof (struct meltdecay_st) MEM_STAT_INFO)))
#endif
     dst = ggc_alloc_meltdecay_st ();
     *dst = *src;
  }#
  :valdesc_clonechunk :true
  :valdesc_forwchunk #{$' /* from VALDESC_DECAY */
     MELT_FORWARDED (src->val);
  }#
)
(install_value_descriptor valdesc_decay)
  

;;;;;;;;;;;;;;;; multiple value
(definstance valdesc_multiple class_varisized_value_descriptor
  :doc #{$VALDESC_MULTIPLE describes multiple values, i.e. tuples.}#
  :named_name '"VALDESC_MULTIPLE"
  :valdesc_objmagic '"MELTOBMAG_MULTIPLE"
  :valdesc_struct '"meltmultiple_st"
  :valdesc_unionmem '"u_multiple"
  :valdesc_membchunk #{$' /* from VALDESC_MULTIPLE in warmelt-base.melt */
    unsigned nbval;
    melt_ptr_t GTY ((length ("%h.nbval"))) tabval[MELT_FLEXIBLE_DIM];
  }#
  :valdesc_declchunk #{$'  /* decl VALDESC_MULTIPLE in warmelt-base.melt */
#define MELT_MULTIPLE_STRUCT(N) {               \
    meltobject_ptr_t discr;                     \
    unsigned nbval;                             \
    melt_ptr_t tabval[N+1];  }
  typedef struct meltmultiple_st* meltmultiple_ptr_t;
  }#
  :valdesc_copychunk #{$'  /* copy chunk from VALDESC_MULTIPLE */
  /* ggc_alloc_meltmultiple_st should be gengtype generated for VALDESC_MULTIPLE */
#ifndef ggc_alloc_meltmultiple_st
#define ggc_alloc_meltmultiple_st(SIZE) ((struct meltmultiple_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif
    int nbv = (int) src->nbval;
    int ix = 0;
    dst = 
      /* Don't need a cleared allocation!  */
      ggc_alloc_meltmultiple_st 
      (nbv*sizeof(void*) + offsetof(struct meltmultiple_st, tabval));
    /* we cannot copy the whole src, because MELT_FLEXIBLE_DIM might be
       1 and nbval could be 0 */
    dst->discr = src->discr;
    dst->nbval = src->nbval;
    for (ix = 0; ix < nbv; ix++)
      dst->tabval[ix] = src->tabval[ix];
    /* end copy chunk from VALDESC_MULTIPLE */
  }#
  :valdesc_clonechunk #{$' /* cloning from VALDESC_MULTIPLE */
    unsigned srclen = src->nbval;
    unsigned srcix = 0;
    resv = dst = 
       (struct meltmultiple_st*) meltgc_new_multiple ((meltobject_ptr_t)newdiscrv, srclen);
    src = (struct meltmultiple_st*) srcvalv; /* could have moved */
    for (srcix = 0; srcix < srclen; srcix++) 
      dst->tabval[srcix] = src->tabval[srcix];
  /* end cloning from VALDESC_MULTIPLE */
  }#
  :valdesc_forwchunk #{$' /* forwarding chunk from VALDESC_MULTIPLE */
     int nbval = (int) src->nbval;
     int ix = 0;
     for (ix = 0; ix < nbval; ix++)
       MELT_FORWARDED (src->tabval[ix]);
     /* end forwarding chunk from VALDESC_MULTIPLE */
  }#
)
(install_value_descriptor valdesc_multiple)

;;;;;;;;;;;;;;;; closure value
(definstance valdesc_closure class_varisized_value_descriptor
  :doc #{$VALDESC_CLOSURE describes closure values, i.e. functions.}#
  :named_name '"VALDESC_CLOSURE"
  :valdesc_objmagic '"MELTOBMAG_CLOSURE"
  :valdesc_struct '"meltclosure_st"
  :valdesc_unionmem '"u_closure"
  :valdesc_membchunk #{$' /* from VALDESC_CLOSURE in warmelt-base.melt */
    meltroutine_ptr_t rout;
    unsigned nbval;
    melt_ptr_t GTY ((length ("%h.nbval"))) tabval[MELT_FLEXIBLE_DIM];
  }#
  :valdesc_declchunk #{$' /* decl VALDESC_CLOSURE  in warmelt-base.melt */
#define MELT_CLOSURE_STRUCT(N) {                \
    meltobject_ptr_t discr;                     \
    meltroutine_ptr_t rout;			\
    unsigned nbval;                             \
    melt_ptr_t tabval[N+1]; }
  }#
  :valdesc_copychunk #{$' /* copy VALDESC_CLOSURE in warmelt-base.melt  */
/* ggc_alloc_meltclosure_st should be gengtype generated for VALDESC_CLOSURE */
#ifndef ggc_alloc_meltclosure_st
#define ggc_alloc_meltclosure_st(SIZE) ((struct meltclosure_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif
     int nbv = (int) src->nbval;
     int ix = 0;
     dst = 
   /* Don't need a cleared allocation!  */
       ggc_alloc_meltclosure_st 
         (nbv*sizeof(void*) + offsetof(struct meltclosure_st, tabval));
     dst->discr = src->discr;
     dst->rout = src->rout;
     dst->nbval = (unsigned) nbv;
     for (ix = 0; ix < nbv; ix++)
       dst->tabval[ix] = src->tabval[ix];
  }#
  :valdesc_forwchunk #{$' /* forwarding from VALDESC_CLOSURE */
     int nbval = (int) src->nbval;
     int ix = 0;
     MELT_FORWARDED (src->rout);
     for (ix = 0; ix < nbval; ix++)
       MELT_FORWARDED (src->tabval[ix]);
  }#
  :valdesc_clonechunk  #{$' /* cloning from VALDESC_CLOSURE */
     unsigned nbval = (int) src->nbval;
     unsigned ix = 0;
     dst
        = (struct meltclosure_st*)meltgc_allocate (sizeof(struct meltclosure_st),
						   nbval*sizeof(void*));
     src = (struct meltclosure_st*)srcvalv;
     dst->discr = (meltobject_ptr_t)newdiscrv;
     dst->rout = src->rout;
     for (ix = 0; ix < nbval; ix++)
       dst->tabval[ix] = src->tabval[ix];
     /* end cloning from VALDESC_CLOSURE */
  }#
)
(install_value_descriptor valdesc_closure)

;;;;;;;;;;;;;;;; routine value
(definstance valdesc_routine class_varisized_value_descriptor
  :doc #{$VALDESC_ROUTINE describes routine values.}#
  :named_name '"VALDESC_ROUTINE"
  :valdesc_objmagic '"MELTOBMAG_ROUTINE"
  :valdesc_struct '"meltroutine_st"
  :valdesc_unionmem '"u_routine"
  :valdesc_membchunk #{$' /* from VALDESC_ROUTINE in warmelt-base.melt */
    char routdescr[MELT_ROUTDESCR_LEN];
    meltroutfun_t* GTY ((skip)) routfunad;
    melt_ptr_t routdata;
    unsigned nbval;
    melt_ptr_t GTY ((length ("%h.nbval"))) tabval[MELT_FLEXIBLE_DIM];
  }#
  :valdesc_declchunk #{$' /* decl VALDESC_ROUTINE */
#ifndef meltroutine_ptr_t_TYPEDEFINED
typedef struct meltroutine_st *meltroutine_ptr_t;
#define  meltroutine_ptr_t_TYPEDEFINED
#endif /*meltroutine_ptr_t_TYPEDEFINED from VALDESC_ROUTINE */

/* unsafely set inside the meltroutine_st pointed by Rptr the
   routine function pointer to Rout */
#define MELT_ROUTINE_SET_ROUTCODE(Rptr,Rout) do {	\
  ((struct meltroutine_st*)(Rptr))->routfunad		\
     = (Rout);						\
} while(0)

#define MELT_ROUTINE_STRUCT(N) {		\
  meltobject_ptr_t discr;			\
  char routdescr[MELT_ROUTDESCR_LEN];		\
  meltroutfun_t* routfunad;			\
  melt_ptr_t routdata;				\
  unsigned nbval;				\
  melt_ptr_t tabval[N+1]; }
  }#
  :valdesc_copychunk #{$' /* from VALDESC_ROUTINE */
  /* ggc_alloc_meltroutine_st should be gengtype generated for VALDESC_ROUTINE */
#ifndef ggc_alloc_meltroutine_st
#define ggc_alloc_meltroutine_st(SIZE) ((struct meltroutine_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif 
     int nbv = (int) src->nbval;
     int ix = 0;
     dst =
       /* Don't need a cleared allocation!  */
       ggc_alloc_meltroutine_st
       (nbv*sizeof(void*) + offsetof(struct meltroutine_st, tabval));
     dst->discr = src->discr;
     strncpy (dst->routdescr, src->routdescr, MELT_ROUTDESCR_LEN);
     dst->routdescr[MELT_ROUTDESCR_LEN - 1] = 0;
     dst->nbval = (unsigned) nbv;
     dst->routfunad = src->routfunad;
     for (ix = 0; ix < nbv; ix++)
       dst->tabval[ix] = src->tabval[ix];
     dst->routdata = src->routdata;
  }#
  ;; don't clone routines!
  :valdesc_forwchunk #{$' /* from VALDESC_ROUTINE */
     int nbval = (int) src->nbval;
     int ix = 0;
     for (ix = 0; ix < nbval; ix++)
       MELT_FORWARDED (src->tabval[ix]);
  }#
)
(install_value_descriptor valdesc_routine)



;;;;;;;;;;;;;;;; long bucket values
(definstance valdesc_bucketlongs class_varisized_value_descriptor
  :doc #{$VALDESC_BUCKETLONGS describe internal long-keyed buckets inside long bighashtables.}#
  :named_name '"VALDESC_BUCKETLONGS"
  :valdesc_objmagic '"MELTOBMAG_BUCKETLONGS"
  :valdesc_struct '"meltbucketlongs_st"
  :valdesc_unionmem '"u_bucketlongs"
  ;;;
  :valdesc_membchunk #{$' /* from VALDESC_BUCKETLONGS in warmelt-base.melt */ 
     melt_ptr_t buckl_aux; /* auxiliary data */
     unsigned char buckl_lenix; /* index in melt_primtab for allocated length */
     int buckl_xnum; /* extra number */
     unsigned buckl_ucount;     /* used count of bucket entries */
     struct melt_bucketlongentry_st GTY ((length("melt_primtab[%h.buckl_lenix]")))
        buckl_entab[MELT_FLEXIBLE_DIM]; /* sorted by increasing ebl_at */
  }#
  ;;;
  :valdesc_declchunk #{$' /* decl VALDESC_BUCKETLONGS  in warmelt-base.melt */ 
  typedef struct meltbucketlongs_st* meltbucketlongs_ptr_t;
#ifndef ggc_alloc_meltbucketlongs_st
#define ggc_alloc_meltbucketlongs_st(SIZE) ((struct meltbucketlongs_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif
  }#
  ;;;
  :valdesc_copychunk #{$' /* copy chunk from  VALDESC_BUCKETLONGS  in warmelt-base.melt */
  /* ggc_alloc_meltbucketlongs_st should be gengtype generated for VALDESC_BUCKETLONGS */
   unsigned lnix = src->buckl_lenix;
   unsigned len = melt_primtab[lnix];
   unsigned ucnt = 0;
   unsigned ix = 0;
   gcc_assert (lnix > 0);
   gcc_assert (len > 0);
   dst = /* Don't need a cleared allocation! */
     ggc_alloc_meltbucketlongs_st (len*sizeof (struct melt_bucketlongentry_st) 
				   + offsetof(struct meltbucketlongs_st, buckl_entab));
   dst->discr = src->discr;
   dst->buckl_lenix = src->buckl_lenix;
   dst->buckl_aux = src->buckl_aux;
   dst->buckl_xnum = src->buckl_xnum;
   ucnt = dst->buckl_ucount = src->buckl_ucount;
   for (ix = 0; ix < ucnt; ix++)
     dst->buckl_entab[ix] = src->buckl_entab[ix];
   for (ix = ucnt; ix < len; ix++) {
     dst->buckl_entab[ix].ebl_at = 0L;
     dst->buckl_entab[ix].ebl_va = NULL;
   }
   /* end copy chunk VALDESC_BUCKETLONGS */
  }#
  :valdesc_clonechunk #{$' /* cloning chunk  from VALDESC_BUCKETLONGS in warmelt-base.melt */
   unsigned lnix = src->buckl_lenix;
   unsigned len = melt_primtab[lnix];
   unsigned cnt = src->buckl_ucount;
   unsigned dstlen = 0;
   unsigned ix = 0;
   gcc_assert (lnix > 0);
   gcc_assert (len > 0);
   gcc_assert (cnt <= len);
   dst = (struct meltbucketlongs_st*)
      meltgc_new_longsbucket ((meltobject_ptr_t)newdiscrv, cnt + cnt/8 + 2);
   dstlen = melt_primtab[dst->buckl_lenix];
   dst->buckl_aux = src->buckl_aux;
   dst->buckl_xnum = src->buckl_xnum;
   dst->buckl_lenix = src->buckl_lenix;
   for (ix = 0; ix < cnt; ix++)
     dst->buckl_entab[ix] = src->buckl_entab[ix];
   for (ix = cnt; ix < dstlen; ix++) {
     dst->buckl_entab[ix].ebl_at = 0L;
     dst->buckl_entab[ix].ebl_va = NULL;
   }
   /* end clone chunk VALDESC_BUCKETLONGS */
  }#
  ;;
  :valdesc_forwchunk #{$' /* forwarding chunk from VALDESC_BUCKETLONGS in warmelt-base.melt */
   unsigned lnix = src->buckl_lenix;
   unsigned len = melt_primtab[lnix];
   unsigned ucnt = src->buckl_ucount;
   unsigned ix = 0;
   gcc_assert (lnix > 0);
   gcc_assert (len > 0);
   MELT_FORWARDED (src->buckl_aux);
   gcc_assert (ucnt <= len);
   for (ix = 0; ix < ucnt; ix++)
      MELT_FORWARDED (src->buckl_entab[ix].ebl_va);
  /* end forwarding VALDESC_BUCKETLONGS */
  }#
  )
(install_value_descriptor valdesc_bucketlongs)


;;;;;;;;;;;;;;;; string value
(definstance valdesc_string class_varisized_value_descriptor
  :doc #{$VALDESC_STRING describes string values.}#
  :named_name '"VALDESC_STRING"
  :valdesc_objmagic '"MELTOBMAG_STRING"
  :valdesc_struct '"meltstring_st"
  :valdesc_unionmem '"u_string"
  :valdesc_membchunk #{$' /* from VALDESC_STRING in warmelt-base.melt */  
    char val[MELT_FLEXIBLE_DIM];	/* null terminated */
  }#
  :valdesc_declchunk #{$' /* decl VALDESC_STRING from warmelt-base.melt */
#define MELT_STRING_STRUCT(N) {			\
  meltobject_ptr_t discr;			\
  char val[(N)+1];	/* null terminated */	\
  long _gap; }
  }#
  :valdesc_copychunk #{$' /* copy from VALDESC_STRING file warmelt-base.melt*/  
/* ggc_alloc_meltstring_st should be gengtype generated for VALDESC_STRING */
#ifndef ggc_alloc_meltstring_st
#define ggc_alloc_meltstring_st(SIZE) ((struct meltstring_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif
     int srclen = (src->val)?strlen (src->val):0;
     dst = 
       /* Don't need a cleared allocation.  */
       ggc_alloc_meltstring_st 
         (offsetof(struct meltstring_st, val) + (srclen+1));
     dst->discr = src->discr;
     memcpy (dst->val, src->val, srclen);
     dst->val[srclen] = (char)0;
      /* end copy from VALDESC_STRING */
  }#
  :valdesc_clonechunk #{$' /* clone from VALDESC_STRING  */
     dst = (struct meltstring_st*)
          meltgc_new_stringdup ((meltobject_ptr_t)newdiscrv, 
				src->val);
     /* end clone from VALDESC_STRING  */
  }#
)
(install_value_descriptor valdesc_string)

;;;;;;;;;;;;;;;; string buffer value
(definstance valdesc_strbuf class_value_descriptor
  :doc #{$VALDESC_STRBUF describes string buffers values}#
  :named_name '"VALDESC_STRBUF"
  :valdesc_objmagic '"MELTOBMAG_STRBUF"
  :valdesc_struct '"meltstrbuf_st"
  :valdesc_unionmem '"u_strbuf"
  :valdesc_membchunk #{$' /* from VALDESC_STRBUF in warmelt-base.melt */
  /* no GTY on bufzn, it a scalar data */  
  char * bufzn;
  unsigned char buflenix;	/* allocated length index of
				   buffer */
  unsigned bufstart;
  unsigned bufend;		/* start & end useful positions */
  /* the following field is usually the value of buf (for
     objects in the young zone), to allocate the object and its fields
     at once; no GTY length on buf_space, since it is a non pointer data. */
  char  buf_space[MELT_FLEXIBLE_DIM];
  }#
  :valdesc_copychunk #{$' /* copy chunk from VALDESC_STRBUF */
/* ggc_alloc_meltstrbuf_st should be gengtype gengtype for VALDESC_STRBUF */
#ifndef ggc_alloc_meltstrbuf_st
#define ggc_alloc_meltstrbuf_st() ((struct meltstrbuf_st *)(ggc_internal_alloc_stat (sizeof (struct meltstrbuf_st) MEM_STAT_INFO)))
#endif
     unsigned blen = melt_primtab[src->buflenix];
     dst = 
       /* Don't need a cleared allocation.  */
       ggc_alloc_meltstrbuf_st ();
     dst->discr = src->discr;
     dst->bufstart = src->bufstart;
     dst->bufend = src->bufend;
     dst->buflenix = src->buflenix;
     if (blen > 0)
        {
#if BUILDING_GCC_VERSION > 4005 || GCCPLUGIN_VERSION > 4005 || MELT_GCC_VERSION > 4005
          dst->bufzn = CONST_CAST (char *, ggc_alloc_string (src->bufzn, blen+1));
#else /*GCC 4.5*/ 
          dst->bufzn = (char *) ggc_alloc_cleared (1 + blen);
          memcpy (dst->bufzn, src->bufzn, blen);
#endif  /*!GCC 4.5*/
          dst->bufzn[blen] = (char)0;
        }
      else
        dst->bufzn = NULL;
    /* end copy chunk from VALDESC_STRBUF */
  }#
  :valdesc_clonechunk #{$' /* clone chunk from VALDESC_STRBUF */
    resv = dst = (struct meltstrbuf_st*) 
       meltgc_new_strbuf ((meltobject_ptr_t)newdiscrv, NULL);
    src = (struct meltstrbuf_st*)srcvalv;
    meltgc_add_strbuf ((melt_ptr_t) dst, melt_strbuf_str ((melt_ptr_t)src));
    /* end clone chunk from VALDESC_STRBUF */
  }#
)
(install_value_descriptor valdesc_strbuf)


;;;;;;;;;;;;;;;; pair value
(definstance valdesc_pair class_value_descriptor
  :doc #{$VALDESC_PAIR describes pair values inside lists.}#
  :named_name '"VALDESC_PAIR"
  :valdesc_objmagic '"MELTOBMAG_PAIR"
  :valdesc_struct '"meltpair_st"
  :valdesc_unionmem '"u_pair"
  :valdesc_gty #{$' chain_next ("%h.tl")}#
  :valdesc_declchunk #{$' /* decl VALDESC_PAIR in warmelt-base.melt */
  typedef struct meltpair_st *meltpair_ptr_t;
  }#
  :valdesc_membchunk #{$' /* from VALDESC_PAIR in warmelt-base.melt */
    melt_ptr_t hd;
    struct meltpair_st *tl;
  }#
  :valdesc_copychunk #{$' /* copy VALDESC_PAIR in warmelt-base.melt */
  /* ggc_alloc_meltpair_st should be gengtype gengtype for VALDESC_PAIR */
#ifndef ggc_alloc_meltpair_st
#define ggc_alloc_meltpair_st() ((struct meltpair_st *)(ggc_internal_alloc_stat (sizeof (struct meltpair_st) MEM_STAT_INFO)))
#endif
    dst = /* Don't need a cleared allocation.  */
	  ggc_alloc_meltpair_st ();
    *dst = *src;
  }#
  :valdesc_clonechunk :true
  :valdesc_forwchunk #{$' /* forward VALDESC_PAIR in warmelt-base.melt */
     MELT_FORWARDED (src->hd);
     MELT_FORWARDED (src->tl);
  }#
)
(install_value_descriptor valdesc_pair)
  

;;;;;;;;;;;;;;;; list value
(definstance valdesc_list class_value_descriptor
  :doc #{$VALDESC_LIST describes list values containing pairs.}#
  :named_name '"VALDESC_LIST"
  :valdesc_objmagic '"MELTOBMAG_LIST"
  :valdesc_struct '"meltlist_st"
  :valdesc_unionmem '"u_list"
  :valdesc_membchunk #{$' /* from VALDESC_LIST in warmelt-base.melt */
    struct meltpair_st *first;
    struct meltpair_st *last;
  }#
  :valdesc_declchunk #{$' /* decl VALDESC_LIST in warmelt-base.melt */
  typedef struct meltlist_st *meltlist_ptr_t;
  }#
  :valdesc_copychunk #{$' /* copy chunk from VALDESC_LIST */
/* ggc_alloc_meltlist_st should be gengtype gengtype for VALDESC_LIST */
#ifndef ggc_alloc_meltlist_st
#define ggc_alloc_meltlist_st() ((struct meltlist_st *)(ggc_internal_alloc_stat (sizeof (struct meltlist_st) MEM_STAT_INFO)))
#endif
     dst = 
	  /* Don't need a cleared allocation!  */
	 ggc_alloc_meltlist_st ();
     *dst = *src;
     /* end chunk from VALDESC_LIST */
  }#
  :valdesc_clonechunk #{$' /* cloning from VALDESC_LIST */
     struct meltpair_st* curpair = NULL;
     resv = dst = (struct meltlist_st*) meltgc_new_list ((meltobject_ptr_t)newdiscrv);
     src = (struct meltlist_st*) srcvalv;
     for (curpair = ((struct meltlist_st *) src)->first;
          melt_magic_discr ((melt_ptr_t) curpair) == MELTOBMAG_PAIR; 
          curpair = (struct meltpair_st *) (curpair->tl)) {
     src = (struct meltlist_st*) srcvalv; 
     dst = (struct meltlist_st*) resv;
     compv = curpair;
     meltgc_append_list ((melt_ptr_t) resv, curpair->hd);
     /* copy, because GC might have moved values. */
     curpair = (struct meltpair_st*) compv;
     src = (struct meltlist_st*) srcvalv; 
     dst = (struct meltlist_st*) resv;
    }
     /* end cloning from VALDESC_LIST */
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_LIST */
     MELT_FORWARDED (src->first);
     MELT_FORWARDED (src->last);
  }#

)
(install_value_descriptor valdesc_list)

;;;;;;;;;;;;;;;; int value
(definstance valdesc_int class_value_descriptor
  :doc #{$VALDESC_INT describes int values boxing long integers.}#
  :named_name '"VALDESC_INT"
  :valdesc_objmagic '"MELTOBMAG_INT"
  :valdesc_struct '"meltint_st"
  :valdesc_unionmem '"u_int"
  :valdesc_membchunk #{$' /* from VALDESC_INT in warmelt-base.melt */
    long val;
  }#
  :valdesc_declchunk #{$' /* decl VALDESC_INT in warmelt-base.melt */
  typedef struct meltint_st *meltint_ptr_t;
  #define melt_unsafe_boxed_int_value(V) (((meltint_ptr_t)(V))->val)
  static inline long melt_boxed_int_value(melt_ptr_t v)
  { return (melt_magic_discr(v)==MELTOBMAG_INT)? melt_unsafe_boxed_int_value(v) : 0L; }
  }#
  :valdesc_copychunk #{$' /* from VALDESC_INT */
/* ggc_alloc_meltint_st should be gengtype generated for VALDESC_INT */
#ifndef ggc_alloc_meltint_st
#define ggc_alloc_meltint_st() ((struct meltint_st *)(ggc_internal_alloc_stat (sizeof (struct meltint_st) MEM_STAT_INFO)))
#endif
     dst = 
        /* Don't need a cleared allocation.  */
	  ggc_alloc_meltint_st ();
     *dst = *src;
  }#
  :valdesc_clonechunk :true
)
(install_value_descriptor valdesc_int)

;;;;;;;;;;;;;;;; mixint value
(definstance valdesc_mixint class_value_descriptor
  :doc #{$VALDESC_MIXINT describes mixint values mixing integers with a value.}#
  :named_name '"VALDESC_MIXINT"
  :valdesc_objmagic '"MELTOBMAG_MIXINT"
  :valdesc_struct '"meltmixint_st"
  :valdesc_unionmem '"u_mixint"
  :valdesc_membchunk #{$' /* from VALDESC_MIXINT in warmelt-base.melt */
    melt_ptr_t ptrval;
    long intval;
  }#
  :valdesc_copychunk #{$' /* from VALDESC_MIXINT */
/* ggc_alloc_meltmixint_st should be gengtype generated for VALDESC_MIXINT */
#ifndef ggc_alloc_meltmixint_st
#define ggc_alloc_meltmixint_st() ((struct meltmixint_st *)(ggc_internal_alloc_stat (sizeof (struct meltmixint_st) MEM_STAT_INFO)))
#endif
    dst = 
      /* Don't need a cleared allocation.  */
        ggc_alloc_meltmixint_st ();
    *dst = *src;
  }#
  :valdesc_clonechunk :true
  :valdesc_forwchunk #{$' /* from VALDESC_MIXINT */
    MELT_FORWARDED (src->ptrval);
  }#
)
(install_value_descriptor valdesc_mixint)

;;;;;;;;;;;;;;;; mixloc value
(definstance valdesc_mixloc class_value_descriptor
  :doc #{$VALDESC_MIXLOC describes mixloc values mixing locations with a value.}#
  :named_name '"VALDESC_MIXLOC"
  :valdesc_objmagic '"MELTOBMAG_MIXLOC"
  :valdesc_struct '"meltmixloc_st"
  :valdesc_unionmem '"u_mixloc"
  :valdesc_membchunk #{$' /* from VALDESC_MIXLOC in warmelt-base.melt.melt */
    melt_ptr_t ptrval;
    long intval;
    location_t locval;
  }#
  :valdesc_copychunk #{$' /* from VALDESC_MIXLOC */
/* ggc_alloc_meltmixloc_st should be gengtype generated for VALDESC_MIXLOC */
#ifndef ggc_alloc_meltmixloc_st
#define ggc_alloc_meltmixloc_st() ((struct meltmixloc_st *)(ggc_internal_alloc_stat (sizeof (struct meltmixloc_st) MEM_STAT_INFO)))
#endif
    dst = 
       /* Don't need a cleared allocation.  */
       ggc_alloc_meltmixloc_st ();
    *dst = *src;
  }#
  :valdesc_clonechunk :true
  :valdesc_forwchunk #{$' /* from VALDESC_MIXLOC */
    MELT_FORWARDED (src->ptrval);
  }#
)
(install_value_descriptor valdesc_mixloc)

;;;;;;;;;;;;;;;; mixbigint value
(definstance valdesc_mixbigint class_varisized_value_descriptor
  :doc #{$VALDESC_MIXBIGINT describes mixbigint values.}#
  :named_name '"VALDESC_MIXBIGINT"
  :valdesc_objmagic '"MELTOBMAG_MIXBIGINT"
  :valdesc_struct '"meltmixbigint_st"
  :valdesc_unionmem '"u_mixbigint"
  :valdesc_membchunk #{$' /* from VALDESC_MIXBIGINT in warmelt-base.melt */
/* an exported array mpz compatible; since we use an exported mpz format, 
   the value can be copied and trashed by MELT garbage collector without 
   harm. */
    melt_ptr_t ptrval;
    bool negative;
    unsigned biglen;
    /* no GTY on tabig, it is a array of non-pointer data */
    long tabig[MELT_FLEXIBLE_DIM];
  }#
  :valdesc_copychunk #{$' /* from VALDESC_MIXBIGINT */
/* ggc_alloc_meltmixbigint_st should be gengtype generated for VALDESC_MIXBIGINT */
#ifndef ggc_alloc_meltmixbigint_st
#define ggc_alloc_meltmixbigint_st(SIZE) ((struct meltmixbigint_st *)(ggc_internal_alloc_stat (SIZE MEM_STAT_INFO)))
#endif
     unsigned blen = src->biglen;
     dst = 
       /* Don't need a cleared allocation.  */
       ggc_alloc_meltmixbigint_st 
       (blen*sizeof(long) + offsetof(struct meltmixbigint_st, tabig));
     dst->discr = src->discr;
     dst->ptrval = src->ptrval;
     dst->negative = src->negative;
     dst->biglen = blen;
     memcpy (dst->tabig, src->tabig, blen*sizeof(dst->tabig[0]));
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_MIXBIGINT */
    MELT_FORWARDED (src->ptrval);
  }#
)
(install_value_descriptor valdesc_mixbigint)

;;;;;;;;;;;;;;;; real value
(definstance valdesc_real class_value_descriptor
  :doc #{$VALDESC_REAL describes real values.}#
  :named_name '"VALDESC_REAL"
  :valdesc_objmagic '"MELTOBMAG_REAL"
  :valdesc_struct '"meltreal_st"
  :valdesc_unionmem '"u_real"
  :valdesc_membchunk #{$' /* from VALDESC_REAL in warmelt-base.melt */
    REAL_VALUE_TYPE val;
  }#
  :valdesc_clonechunk :true
  :valdesc_copychunk #{$' /* from VALDESC_REAL */
/* ggc_alloc_meltreal_st should be gengtype generated for VALDESC_REAL */
#ifndef ggc_alloc_meltreal_st
#define ggc_alloc_meltreal_st() ((struct meltreal_st *)(ggc_internal_alloc_stat (sizeof (struct meltreal_st) MEM_STAT_INFO)))
#endif
    dst =
        /* Don't need a cleared allocation.  */
	ggc_alloc_meltreal_st ();
    *dst = *src;
  }#
)
(install_value_descriptor valdesc_real)

;;;;;;;;;;;;;;;; ****************** SPECIAL VALUES
;;;;;;;;;;;;;;;; special file value
(definstance valdesc_special_file class_value_descriptor
  :doc #{$VALDESC_SPECIAL_FILE describes special file values.}#
  :named_name '"VALDESC_SPECIAL_FILE"
  :valdesc_objmagic '"MELTOBMAG_SPEC_FILE"
  :valdesc_struct '"meltspecialfile_st"
  :valdesc_unionmem '"u_special_file"
  :valdesc_gty #{$' mark_hook ("melt_mark_special")}#
  :valdesc_membchunk #{$' /* from VALDESC_SPECIAL_FILE in warmelt-base.melt */
    int mark;
    struct meltspecial_st *GTY ((skip)) nextspec;
    union melt_special_un GTY ((skip)) val;
  }#
  :valdesc_copychunk #{$' /* from VALDESC_SPECIAL_FILE */
/* ggc_alloc_meltspecialfile_st should be gengtype generated for VALDESC_SPECIAL_FILE */
#ifndef ggc_alloc_meltspecialfile_st
#define ggc_alloc_meltspecialfile_st() ((struct meltspecialfile_st *)(ggc_internal_alloc_stat (sizeof (struct meltspecialfile_st) MEM_STAT_INFO)))
#endif
    dst = ggc_alloc_meltspecialfile_st ();
    *dst = *src;
    /* mark the new copy! */
    dst->mark = 1;
    /* add the new copy to the old (major) special list */
    dst->nextspec = melt_oldspeclist;
    melt_oldspeclist = (struct meltspecial_st*)dst;
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_SPECIAL_FILE */
    src->mark = 1;
  }#

)
(install_value_descriptor valdesc_special_file)

;;;;;;;;;;;;;;;; special raw file value
(definstance valdesc_special_raw_file class_value_descriptor
  :doc #{$VALDESC_SPECIAL_RAW_FILE describes special raw file values.}#
  :named_name '"VALDESC_SPECIAL_RAW_FILE"
  :valdesc_objmagic '"MELTOBMAG_SPEC_RAWFILE"
  :valdesc_struct '"meltspecialrawfile_st"
  :valdesc_unionmem '"u_special_rawfile"
  :valdesc_gty #{$' mark_hook ("melt_mark_special")}#
  :valdesc_membchunk #{$' /* from VALDESC_SPECIAL_RAW_FILE in warmelt-base.melt */
    int mark;
    struct meltspecial_st *GTY ((skip)) nextspec;
    union melt_special_un GTY ((skip)) val;
  }#
  :valdesc_copychunk #{$' /* from VALDESC_SPECIAL_RAW_FILE */
/* ggc_alloc_meltspecialrawfile_st should be gengtype generated for VALDESC_SPECIAL_RAW_FILE */
#ifndef ggc_alloc_meltspecialrawfile_st
#define ggc_alloc_meltspecialrawfile_st() ((struct meltspecialrawfile_st *)(ggc_internal_alloc_stat (sizeof (struct meltspecialrawfile_st) MEM_STAT_INFO)))
#endif
    dst = ggc_alloc_meltspecialrawfile_st ();
    *dst = *src;
    /* mark the new copy! */
    dst->mark = 1;
    /* add the new copy to the old (major) special list */
    dst->nextspec = melt_oldspeclist;
    melt_oldspeclist = (struct meltspecial_st*)dst;
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_SPECIAL_RAW_FILE */
    src->mark = 1;
  }#
)
(install_value_descriptor valdesc_special_raw_file)

;;;;;;;;;;;;;;;; special mpfr value
(definstance valdesc_special_mpfr class_value_descriptor
  :doc #{$VALDESC_SPECIAL_MPFR describes special MPFR values.}#
  :named_name '"VALDESC_SPECIAL_MPFR"
  :valdesc_objmagic '"MELTOBMAG_SPEC_MPFR"
  :valdesc_struct '"meltspecialmpfr_st"
  :valdesc_unionmem '"u_special_mpfr"
  :valdesc_gty #{$' mark_hook ("melt_mark_special")}#
  :valdesc_membchunk #{$' /* from VALDESC_SPECIAL_MPFR in warmelt-base.melt */
    int mark;
    struct meltspecial_st *GTY ((skip)) nextspec;
    union melt_special_un GTY ((skip)) val;
  }#
  :valdesc_copychunk #{$' /* from VALDESC_SPECIAL_MPFR */
/* ggc_alloc_meltspecialmpfr_st should be gengtype generated for VALDESC_SPECIAL_MPFR */
#ifndef ggc_alloc_meltspecialmpfr_st
#define ggc_alloc_meltspecialmpfr_st() ((struct meltspecialmpfr_st *)(ggc_internal_alloc_stat (sizeof (struct meltspecialmpfr_st) MEM_STAT_INFO)))
#endif
    dst = ggc_alloc_meltspecialmpfr_st ();
    *dst = *src;
    /* mark the new copy! */
    dst->mark = 1;
    /* add the new copy to the old (major) special list */
    dst->nextspec = melt_oldspeclist;
    melt_oldspeclist = (struct meltspecial_st*)dst;
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_SPECIAL_MPFR */
    src->mark = 1;
  }#
)
(install_value_descriptor valdesc_special_mpfr)

;;;;;;;;;;;;;;;; special PPL coefficient value
(definstance valdesc_special_ppl_coefficient class_value_descriptor
  :doc #{$VALDESC_SPECIAL_PPL_COEFFICIENT describes special PPL coefficient values.}#
  :named_name '"VALDESC_SPECIAL_PPL_COEFFICIENT"
  :valdesc_objmagic '"MELTOBMAG_SPECPPL_COEFFICIENT"
  :valdesc_struct '"meltspecialpplcoefficient_st"
  :valdesc_unionmem '"u_special_ppl_coefficient"
  :valdesc_gty #{$' mark_hook ("melt_mark_special")}#
  :valdesc_membchunk #{$' /* from VALDESC_SPECIAL_PPL_COEFFICIENT in warmelt-base.melt */
    int mark;
    struct meltspecial_st *GTY ((skip)) nextspec;
    union melt_special_un GTY ((skip)) val;
  }#
  :valdesc_copychunk #{$' /* from VALDESC_SPECIAL_PPL_COEFFICIENT */
/* ggc_alloc_meltspecialpplcoefficient_st should be gengtype generated for VALDESC_SPECIAL_PPL_COEFFICIENT */
#ifndef ggc_alloc_meltspecialpplcoefficient_st
#define ggc_alloc_meltspecialpplcoefficient_st() ((struct meltspecialpplcoefficient_st *)(ggc_internal_alloc_stat (sizeof (struct meltspecialpplcoefficient_st) MEM_STAT_INFO)))
#endif
    dst = ggc_alloc_meltspecialpplcoefficient_st ();
    *dst = *src;
    /* mark the new copy! */
    dst->mark = 1;
    /* add the new copy to the old (major) special list */
    dst->nextspec = melt_oldspeclist;
    melt_oldspeclist = (struct meltspecial_st*)dst;
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_SPECIAL_PPL_COEFFICIENT */
    src->mark = 1;
  }#
)
(install_value_descriptor valdesc_special_ppl_coefficient)

;;;;;;;;;;;;;;;; special PPL linear expression value
(definstance valdesc_special_ppl_linear_expression class_value_descriptor
  :doc #{$VALDESC_SPECIAL_PPL_LINEAR_EXPRESSION describes special PPL 
linear expression values.}#
  :named_name '"VALDESC_SPECIAL_PPL_LINEAR_EXPRESSION"
  :valdesc_objmagic '"MELTOBMAG_SPECPPL_LINEAR_EXPRESSION"
  :valdesc_struct '"meltspecialppllinearexpression_st"
  :valdesc_unionmem '"u_special_ppl_linear_expression"
  :valdesc_gty #{$' mark_hook ("melt_mark_special")}#
  :valdesc_membchunk #{$' /* from VALDESC_SPECIAL_PPL_LINEAR_EXPRESSION in warmelt-base.melt*/
    int mark;
    struct meltspecial_st *GTY ((skip)) nextspec;
    union melt_special_un GTY ((skip)) val;
  }#
  :valdesc_copychunk #{$' /* from VALDESC_SPECIAL_PPL_LINEAR_EXPRESSION */
/* ggc_alloc_meltspecialppllinearexpression_st should be gengtype generated for VALDESC_SPECIAL_PPL_LINEAR_EXPRESSION */
#ifndef ggc_alloc_meltspecialppllinearexpression_st
#define ggc_alloc_meltspecialppllinearexpression_st() ((struct meltspecialppllinearexpression_st *)(ggc_internal_alloc_stat (sizeof (struct meltspecialppllinearexpression_st) MEM_STAT_INFO)))
#endif
    dst = ggc_alloc_meltspecialppllinearexpression_st ();
    *dst = *src;
    /* mark the new copy! */
    dst->mark = 1;
    /* add the new copy to the old (major) special list */
    dst->nextspec = melt_oldspeclist;
    melt_oldspeclist = (struct meltspecial_st*)dst;
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_SPECIAL_PPL_LINEAR_EXPRESSION */
    src->mark = 1;
  }#
)
(install_value_descriptor valdesc_special_ppl_linear_expression)

;;;;;;;;;;;;;;;; special PPL constraint value
(definstance valdesc_special_ppl_constraint class_value_descriptor
  :doc #{$VALDESC_SPECIAL_PPL_CONSTRAINT describes special PPL 
constraints values.}#
  :named_name '"VALDESC_SPECIAL_PPL_CONSTRAINT"
  :valdesc_objmagic '"MELTOBMAG_SPECPPL_CONSTRAINT"
  :valdesc_struct '"meltspecialpplconstraint_st"
  :valdesc_unionmem '"u_special_ppl_constraint"
  :valdesc_gty #{$' mark_hook ("melt_mark_special")}#
  :valdesc_membchunk #{$' /* from VALDESC_SPECIAL_PPL_CONSTRAINT in warmelt-base.melt*/
    int mark;
    struct meltspecial_st *GTY ((skip)) nextspec;
    union melt_special_un GTY ((skip)) val;
  }#
  :valdesc_copychunk #{$' /* from VALDESC_SPECIAL_PPL_CONSTRAINT */
/* ggc_alloc_meltspecialpplconstraint_st should be gengtype gengtype for VALDESC_SPECIAL_PPL_CONSTRAINT */
#ifndef ggc_alloc_meltspecialpplconstraint_st
#define ggc_alloc_meltspecialpplconstraint_st() ((struct meltspecialpplconstraint_st *)(ggc_internal_alloc_stat (sizeof (struct meltspecialpplconstraint_st) MEM_STAT_INFO)))
#endif
    dst = ggc_alloc_meltspecialpplconstraint_st ();
    *dst = *src;
    /* mark the new copy! */
    dst->mark = 1;
    /* add the new copy to the old (major) special list */
    dst->nextspec = melt_oldspeclist;
    melt_oldspeclist = (struct meltspecial_st*)dst;
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_SPECIAL_PPL_CONSTRAINT */
    src->mark = 1;
  }#
)
(install_value_descriptor valdesc_special_ppl_constraint)

;;;;;;;;;;;;;;;; special PPL constraint system value
(definstance valdesc_special_ppl_constraint_system class_value_descriptor
  :doc #{$VALDESC_SPECIAL_PPL_CONSTRAINT_SYSTEM describes special PPL 
constraint systems values.}#
  :named_name '"VALDESC_SPECIAL_PPL_CONSTRAINT_SYSTEM"
  :valdesc_objmagic '"MELTOBMAG_SPECPPL_CONSTRAINT_SYSTEM"
  :valdesc_struct '"meltspecialpplconstraintsystem_st"
  :valdesc_unionmem '"u_special_ppl_constraint_system"
  :valdesc_gty #{$' mark_hook ("melt_mark_special")}#
  :valdesc_membchunk #{$' /* from VALDESC_SPECIAL_PPL_CONSTRAINT_SYSTEM in warmelt-base.melt */
    int mark;
    struct meltspecial_st *GTY ((skip)) nextspec;
    union melt_special_un GTY ((skip)) val;
  }#
  :valdesc_copychunk #{$' /* from VALDESC_SPECIAL_PPL_CONSTRAINT_SYSTEM */
  /* ggc_alloc_meltspecialpplconstraintsystem_st should be gengtype generated for VALDESC_SPECIAL_PPL_CONSTRAINT_SYSTEM */
#ifndef ggc_alloc_meltspecialpplconstraintsystem_st
#define ggc_alloc_meltspecialpplconstraintsystem_st() ((struct meltspecialpplconstraintsystem_st *)(ggc_internal_alloc_stat (sizeof (struct meltspecialpplconstraintsystem_st) MEM_STAT_INFO)))
#endif
    dst = ggc_alloc_meltspecialpplconstraintsystem_st ();
    *dst = *src;
    /* mark the new copy! */
    dst->mark = 1;
    /* add the new copy to the old (major) special list */
    dst->nextspec = melt_oldspeclist;
    melt_oldspeclist = (struct meltspecial_st*)dst;
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_SPECIAL_PPL_CONSTRAINT_SYSTEM */
    src->mark = 1;
  }#
)
(install_value_descriptor valdesc_special_ppl_constraint_system)

;;;;;;;;;;;;;;;; special PPL generator value
(definstance valdesc_special_ppl_generator class_value_descriptor
  :doc #{$VALDESC_SPECIAL_PPL_GENERATOR describes special PPL 
generators values.}#
  :named_name '"VALDESC_SPECIAL_PPL_GENERATOR"
  :valdesc_objmagic '"MELTOBMAG_SPECPPL_GENERATOR"
  :valdesc_struct '"meltspecialpplgenerator_st"
  :valdesc_unionmem '"u_special_ppl_generator"
  :valdesc_gty #{$' mark_hook ("melt_mark_special")}#
  :valdesc_membchunk #{$' /* from VALDESC_SPECIAL_PPL_GENERATOR in warmelt-base.melt */
    int mark;
    struct meltspecial_st *GTY ((skip)) nextspec;
    union melt_special_un GTY ((skip)) val;
  }#
  :valdesc_copychunk #{$' /* from VALDESC_SPECIAL_PPL_GENERATOR */
/* ggc_alloc_meltspecialpplgenerator_st should be gengtype generated for VALDESC_SPECIAL_PPL_GENERATOR */
#ifndef ggc_alloc_meltspecialpplgenerator_st
#define ggc_alloc_meltspecialpplgenerator_st() ((struct meltspecialpplgenerator_st *)(ggc_internal_alloc_stat (sizeof (struct meltspecialpplgenerator_st) MEM_STAT_INFO)))
#endif
    dst = ggc_alloc_meltspecialpplgenerator_st ();
    *dst = *src;
    /* mark the new copy! */
    dst->mark = 1;
    /* add the new copy to the old (major) special list */
    dst->nextspec = melt_oldspeclist;
    melt_oldspeclist = (struct meltspecial_st*)dst;
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_SPECIAL_PPL_GENERATOR */
    src->mark = 1;
  }#
)
(install_value_descriptor valdesc_special_ppl_generator)

;;;;;;;;;;;;;;;; special PPL generator system value
(definstance valdesc_special_ppl_generator_system class_value_descriptor
  :doc #{$VALDESC_SPECIAL_PPL_GENERATOR_SYSTEM describes special PPL 
generator systems values.}#
  :named_name '"VALDESC_SPECIAL_PPL_GENERATOR_SYSTEM"
  :valdesc_objmagic '"MELTOBMAG_SPECPPL_GENERATOR_SYSTEM"
  :valdesc_struct '"meltspecialpplgeneratorsystem_st"
  :valdesc_unionmem '"u_special_ppl_generator_system"
  :valdesc_gty #{$'mark_hook ("melt_mark_special")}#
  :valdesc_membchunk #{$' /* from VALDESC_SPECIAL_PPL_GENERATOR_SYSTEM in warmelt-base.melt */
    int mark;
    struct meltspecial_st *GTY ((skip)) nextspec;
    union melt_special_un GTY ((skip)) val;
  }#
  :valdesc_copychunk #{$' /* from VALDESC_SPECIAL_PPL_GENERATOR_SYSTEM */
/*  ggc_alloc_meltspecialpplgeneratorsystem_st should be gengtype generated for VALDESC_SPECIAL_PPL_GENERATOR_SYSTEM */
#ifndef ggc_alloc_meltspecialpplgeneratorsystem_st
#define ggc_alloc_meltspecialpplgeneratorsystem_st() ((struct meltspecialpplgeneratorsystem_st *)(ggc_internal_alloc_stat (sizeof (struct meltspecialpplgeneratorsystem_st) MEM_STAT_INFO)))
#endif
    dst = ggc_alloc_meltspecialpplgeneratorsystem_st ();
    *dst = *src;
    /* mark the new copy! */
    dst->mark = 1;
    /* add the new copy to the old (major) special list */
    dst->nextspec = melt_oldspeclist;
    melt_oldspeclist = (struct meltspecial_st*)dst;
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_SPECIAL_PPL_GENERATOR_SYSTEM */
    src->mark = 1;
  }#
)
(install_value_descriptor valdesc_special_ppl_generator_system)

;;;;;;;;;;;;;;;; special PPL polyhedron value
(definstance valdesc_special_ppl_polyhedron class_value_descriptor
  :doc #{$VALDESC_SPECIAL_PPL_POLYHEDRON describes special PPL 
polyhedron values.}#
  :named_name '"VALDESC_SPECIAL_PPL_POLYHEDRON"
  :valdesc_objmagic '"MELTOBMAG_SPECPPL_POLYHEDRON"
  :valdesc_struct '"meltspecialpplpolyhedron_st"
  :valdesc_unionmem '"u_special_ppl_polyhedron"
  :valdesc_gty #{$'mark_hook ("melt_mark_special")}#
  :valdesc_membchunk #{$' /* from VALDESC_SPECIAL_PPL_POLYHEDRON in warmelt-base.melt */
    int mark;
    struct meltspecial_st *GTY ((skip)) nextspec;
    union melt_special_un GTY ((skip)) val;
  }#
  :valdesc_copychunk #{$' /* from VALDESC_SPECIAL_PPL_POLYHEDRON */
/* ggc_alloc_meltspecialpplpolyhedron_st should be gengtype generated for VALDESC_SPECIAL_PPL_POLYHEDRON */
#ifndef ggc_alloc_meltspecialpplpolyhedron_st
#define ggc_alloc_meltspecialpplpolyhedron_st() ((struct meltspecialpplpolyhedron_st *)(ggc_internal_alloc_stat (sizeof (struct meltspecialpplpolyhedron_st) MEM_STAT_INFO)))
#endif
    dst = ggc_alloc_meltspecialpplpolyhedron_st ();
    *dst = *src;
    /* mark the new copy! */
    dst->mark = 1;
    /* add the new copy to the old (major) special list */
    dst->nextspec = melt_oldspeclist;
    melt_oldspeclist = (struct meltspecial_st*)dst;
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_SPECIAL_PPL_POLYHEDRON */
    src->mark = 1;
  }#
)
(install_value_descriptor valdesc_special_ppl_polyhedron)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; variadic related utilities

;; the index of variadic argument
(defprimitive variadic_index () :long
  :doc #{Returns the current index of variadic argument, or -1 outside
  of variadic functions.}#
;; the melt_variadic_index macro is defined by code emitted in function
;; outpucod_procroutine of file warmelt-outobj.melt
  #{ /*variadic_index*/
#ifdef melt_variadic_index
  (melt_variadic_index)
#else
  -1
#endif /*melt_variadic_index*/
}#)

;; the length or count of variadic arguments
(defprimitive variadic_length () :long
  :doc #{Returns the length of variadic arguments, or -1 outside
  of variadic functions.}#
;; the melt_variadic_length macro is defined by code emitted in function
;; outpucod_procroutine of file warmelt-outobj.melt
  #{ /*variadic_length*/
#ifdef melt_variadic_length
  (melt_variadic_length)
#else
  -1
#endif /*melt_variadic_length*/
}#)


;; skip some variadic arguments
(defprimitive variadic_skip (:long delta) :void
  :doc #{Skip some variadic arguments, by incrementing appropriately the variadic index.}#
;; the melt_variadic_index & melt_variadic_length macros are defined
;; by code emitted in function outpucod_procroutine of file
;; warmelt-outobj.melt
  #{ /*variadic_skip*/
#ifdef melt_variadic_index
  melt_variadic_index += (int) ($DELTA);
  if (melt_variadic_index < 0) 
     melt_variadic_index = 0;
  else if (melt_variadic_index > melt_variadic_length) 
     melt_variadic_index = melt_variadic_length;
#else
  /* no variadic_skip outside of variadic functions */
  (void) ($DELTA);
#endif /*melt_variadic_index*/
}#)



(defprimitive variadic_type_code (:long delta) :long
  :doc #{Return the type code, i.e. an integer from the MELTBPAR_*
  enumeration, of the variadic argument at offset $DELTA, or else
  [outside of variadic functions, or index out of bounds] 0, that is
  MELTBPAR__NONE. See also $VARIADIC_CTYPE.}#
#{ /*variadic_type_code*/
#ifdef melt_variadic_index
  (((melt_variadic_index + $DELTA) >= 0
    && (melt_variadic_index + $DELTA) < melt_variadic_length) 
  ? (long) (meltxargdescr_[melt_variadic_index + $DELTA] & MELT_ARGDESCR_MAX)
  : 0)
#else
  (0 && $DELTA /* no variadic_type_code outside of variadic functions */)
#endif /*melt_variadic_index*/
}#)

(defprimitive variadic_ctype  (:long delta) :value
  :doc #{Return the ctype of the variadic argument at offset $DELTA,
  or else Nil. See also $VARIADIC_TYPE_CODE.}#
#{ /*variadic_type_code*/
#ifdef melt_variadic_index
  (((melt_variadic_index + $DELTA) >= 0
    && (melt_variadic_index + $DELTA) < melt_variadic_length) 
  ?  melt_code_to_ctype (meltxargdescr_[melt_variadic_index + $DELTA] 
			 & MELT_ARGDESCR_MAX)
  : NULL)
#else
  NULL /* no variadic_ctype outside of variadic functions */
#endif /*melt_variadic_index*/
}#)


(defprimitive poll_all_inputs (:long delayms) :long
  :doc #{Poll all inputs and run appropriate handlers with a delay of $DELAYMS milliseconds}#
  #{ /*poll_all_inputs*/ meltgc_poll_inputs (melt_get_inisysdata (MELTFIELD_SYSDATA_INCHANNEL_DATA), 
                                             (int) $DELAYMS) }#)

(defprimitive increment (:long left incr) :void
  :doc #{Increment $LEFT (when variable) with $INCR.}#
  #{ /*increment*/ $LEFT += $INCR; 
  }#)



;;;;
(defciterator block_signals
  ()
  blksignal
  ()
  :doc #{The $BLOCK_SIGNALS C-iterator provides a sequence inside
which signals are not handled. It could be dynamically nested.}# 
  #{ /* block_signals $BLKSIGNAL start */
     long $BLKSIGNAL#_lev = melt_blocklevel_signals;
     melt_blocklevel_signals = $BLKSIGNAL#_lev + 1;
  }#
  #{ /* block_signals $BLKSIGNAL end */
     melt_blocklevel_signals = $BLKSIGNAL#_lev;
     MELT_CHECK_SIGNAL();
  }#
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(export_values
 ;; keep the alphanumerical order
		
 !=i
 *i
 -i
 <=i
 ==i

 +iv
 -iv
 *iv
 /iv
 %iv

 <iv
 <=iv
 =iv
 !=iv
 >iv 
 >=iv

 <ivi
 <=ivi
 =ivi
 !=ivi
 >ivi
 >=ivi

 +ivi
 -ivi
 *ivi
 /ivi
 %ivi

 add2out
 add2out_ccomconst
 add2out_ccomstrbuf
 add2out_ccomstring 
 add2out_cencstrbuf
 add2out_cencstring
 add2out_cenconst 
 add2out_cencsubstring
 add2out_cident
 add2out_cidentprefix
 add2out_indent
 add2out_indentnl
 add2out_longdec
 add2out_longhex
 add2out_mixloc
 add2out_routinedescr
 add2out_sbuf
 add2out_strconst
 add2out_string
 add2sbuf_ccomconst
 add2sbuf_ccomstrbuf
 add2sbuf_ccomstring 
 add2sbuf_cencstrbuf
 add2sbuf_cencstring
 add2sbuf_cident
 add2sbuf_cidentprefix
 add2sbuf_dynloaded_suffix
 add2sbuf_indent
 add2sbuf_indentnl
 add2sbuf_longdec
 add2sbuf_longhex
 add2sbuf_mixloc
 add2sbuf_routinedescr
 add2sbuf_sbuf
 add2sbuf_short_mixloc
 add2sbuf_strconst
 add2sbuf_string
 add2sbuf_texi_mixloc
 add_to_out
 andi
 block_signals
 c_clock
 c_time
 cbreak_msg
 checkcallstack_msg
 checkval_dbg
 clone_with_discriminant
 compare_named_alpha
 cstring_length
 cstring_prefixed
 cstring_same
 debugcstring
 debuglong
 error_plain
 error_strv
 errormsg_plain
 errormsg_strv
 foreach_long_upto
 full_garbcoll
 generate_flavored_melt_module
 get_globpredef
 ignore
 increment
 inform_plain
 inform_strv
 informsg_plain
 informsg_strv
 is_file
 is_mixbigint
 is_mixint
 is_mixloc
 is_multiple_or_null
 is_not_object
 is_out
 is_strbuf
 is_stringconst
 longbacktrace_dbg
 make_mixint
 make_mixloc
 make_pair
 make_strbuf
 make_string
 make_string_generated_c_filename
 make_string_mixloc_file
 make_string_nakedbasename
 make_string_real_access_path
 make_string_real_access_path_value 
 make_string_tempname_suffixed
 make_string_without_dynloaded_suffix
 make_string_without_suffix
 mapstring_count
 mapstring_every
 mapstring_iterate_test	
 mapstring_rawget
 mapstring_rawput
 mapstring_rawremove
 mapstring_size
 maxi
 melt_application_count
 melt_application_depth
 melt_application_shallower
 melt_increment_dbgcounter
 melt_is_bootstrapping
 melt_mode_reference
 melt_version_str
 message_dbg
 messagenum_dbg 
 messageval_dbg
 mini
 minor_garbcoll
 mixbigint_val
 mixint_val
 mixloc_location
 mixloc_locbasefile 
 mixloc_locfile
 mixloc_locline
 mixloc_val
 multiple_backward_every
 multiple_every
 multiple_every_both
 negi
 nonzero_hash
 noti
 notnull
 obj_hash
 obj_len
 obj_num
 object_length
 object_nth_field
 ori
 outcstring_dbg
 outcstring_err	
 outnewline_dbg
 outnewline_err
 outnum_dbg
 outnum_err
 output_length
 output_sbuf_no_overwrite_strconst
 output_sbuf_no_overwrite_strval
 output_sbuf_strconst
 output_sbuf_strval
 outstr_dbg
 outstr_err
 outstrbuf_dbg
 outstrbuf_err
 poll_all_inputs
 pair_listlength
 pair_set_head 
 ppstrbuf_mixbigint
 read_file
 read_strv
 relative_time_millisec
 register_all_ipa_passes_end_hook_first
 register_all_ipa_passes_end_hook_last
 register_all_ipa_passes_start_hook_first
 register_all_ipa_passes_start_hook_last
 register_all_passes_end_hook_first
 register_all_passes_end_hook_last
 register_all_passes_start_hook_first
 register_all_passes_start_hook_last
 register_early_gimple_passes_end_hook_first
 register_early_gimple_passes_end_hook_last
 register_early_gimple_passes_start_hook_first
 register_early_gimple_passes_start_hook_last
 register_finish_decl_hook_first
 register_finish_decl_hook_last
 register_finish_type_hook_first
 register_finish_type_hook_last
 register_pass_execution_hook
 register_pragma_handler
 register_pre_genericize_hook_first
 register_pre_genericize_hook_last
 retrieve_value_descriptor_list
 set_reference
 set_real_timer_millisec
 some_integer_different_from
 some_integer_equal_to
 some_integer_greater_or_equal_to
 some_integer_greater_than
 some_integer_lower_or_equal_to
 some_integer_lower_than
 some_integer_multiple
 some_string_value
 split_string_colon
 split_string_comma
 split_string_equal
 split_string_space 
 start_melt_module_of_flavor 
 strbuf2string
 strbuf_reserve
 strbuf_usedlength
 string4out
 string_dynloaded_suffixed
 string_ends
 string_hex_md5sum_constpath 
 string_hex_md5sum_path_sequence
 string_hex_md5sum_pathstrv
 string_length
 string_prefixed
 string_starts
 string_suffixed
 subclass_of
 subclass_or_eq
 subseq_multiple
 tuple_nth
 tuple_sized
 unregister_pass_execution_hook
 valdesc_bucketlongs
 valdesc_closure
 valdesc_decay
 valdesc_int
 valdesc_list
 valdesc_mapobjects
 valdesc_mapstrings
 valdesc_mixbigint
 valdesc_mixint
 valdesc_mixloc
 valdesc_multiple
 valdesc_object
 valdesc_pair
 valdesc_real
 valdesc_routine
 valdesc_special_file
 valdesc_special_file
 valdesc_special_mpfr
 valdesc_special_ppl_coefficient
 valdesc_special_ppl_constraint
 valdesc_special_ppl_constraint_system
 valdesc_special_ppl_generator
 valdesc_special_ppl_generator_system
 valdesc_special_ppl_linear_expression
 valdesc_special_ppl_polyhedron
 valdesc_special_raw_file
 valdesc_strbuf
 valdesc_string
 variadic_ctype
 variadic_index
 variadic_length
 variadic_skip
 variadic_type_code
 void
 warning_plain
 warning_strv
 warningmsg_plain
 warningmsg_strv
 xori
 zerop
 )


(export_synonym melt_mode_container melt_mode_reference)

(export_synonym set_content set_reference)

;;;; eof warmelt-base.melt
