;; -*- Lisp -*-
;; file warmelt-base.melt
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(comment "***
    Copyright 2008, 2009, 2010 Free Software Foundation, Inc.
    Contributed by Basile Starynkevitch <basile@starynkevitch.net>

    This file is part of GCC.

    GCC is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3, or (at your option)
    any later version.

    GCC is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.
***")

;; the copyright notice above apply both to warmelt-base.melt and 
;; to the generated file  warmelt-base*.c

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;    This file is part of a bootstrapping compiler for the MELT lisp
;;    dialect, compiler which should be able to compile itself (into
;;    generated C file[s])
;;    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; primitive to ignore a value
(defprimitive ignore (v) :void
  :doc #{Ignore the value passed as argument. Useful to avoid translation warnings, or to force the type of a conditional. See $CTYPE_VOID.}#
  #{/*ignore*/(void)($v)}#)  


;; primitive to return a void
(defprimitive void () :void 
  :doc #{Return a void value. See $IGNORE and $CTYPE_VOID.}#
#{/*void*/0}#)

;; negation of is_object
(defprimitive is_not_object (obj) :long
  :doc #{Test if $OBJ is not an object. Negation of $IS_OBJECT.}#
  #{(melt_magic_discr((melt_ptr_t)($obj)) != MELTOBMAG_OBJECT)}#)


;; primitive to safely return a global predef by its index
(defprimitive get_globpredef (:long ix) :value
  :doc #{Safely gives the predefined of index $IX or null.}#
  #{(melt_globpredef($ix))}#)

;; primitive to get the hashcode of an object (or 0)
(defprimitive obj_hash (v) :long
  :doc #{Safely gives the hashcode of object $V or else 0.}#
  #{(melt_obj_hash((melt_ptr_t)($v)))}#)


;; primitive to get the length of an object (or 0)
(defprimitive obj_len (v) :long
  :doc #{Safely gives the length of object $V or else 0.}#
  #{(melt_obj_len((melt_ptr_t)($v)))}#)


;; primitive to get the number of an object (or 0)
(defprimitive obj_num (v) :long
  :doc #{Safely gives the number of object $V or else 0.}#
  #{(melt_obj_num((melt_ptr_t)($v)))}#)

;; primitive to compute a nonzero hash
(defprimitive nonzero_hash () :long
  :doc #{Gives a pseudo-random non-zero number suitable as an hash code.}# 
  "(melt_nonzerohash())")


;; primitives to force garbage collection
(defprimitive minor_garbcoll (:long siz) :void 
  :doc #{Force a minor MELT garbage collection. The $SIZ is the amount
  of memory to reserve.}#
  #{melt_garbcoll(($siz), MELT_MINOR_OR_FULL)}#)

(defprimitive full_garbcoll (:long siz) :void
  :doc #{Force a full MELT garbage collection. The $SIZ is the amount
  of memory to reserve.}#
  #{melt_garbcoll(($siz), MELT_NEED_FULL)}#)


;; check explicitly the call stack  
(defprimitive checkcallstack_msg (:cstring msg) :void
  :doc #{Low level costly primitive to check the entire call stack to
help hunt memory or GC bugs. Displays the given $MSG if the check went
wrong. Use it when desperate.}#
  #{melt_check_call_frames(MELT_ANYWHERE, $msg);}#)


;; for breakpoint
(defprimitive cbreak_msg (:cstring msg) :void
  :doc #{Low level primitive for GDB breakpoints. Use it temporarily,
given a string $MSG, with gdb when desperate.}#
  #{melt_cbreak($msg)}#)


;; compare of longs [some primitives remain in warmelt-first.melt
;; because they are needed there]

(defprimitive <=i (:long a b) :long :doc #{Integer test that $A less or equal to $B.}#
  #{(($a) <= ($b))}#)

(defprimitive ==i (:long a b) :long  :doc #{Integer test that $A is equal to $B.}#
  #{(($a) == ($b))}#)


(defprimitive !=i (:long a b) :long  :doc #{Integer test that $A is unequal to $B.}#
  #{(($a) != ($b))}#)

;;; maximal & minimal of two longs
(defprimitive maxi (:long a b) :long 
  :doc #{$MAXI gives the maximum of two integers $A and $B}# 
#{MAX(($a),($b))}#)

(defprimitive mini (:long a b) :long 
  :doc #{$MINI gives the maximum of two integers $A and $B}# 
#{MIN(($a),($b))}#)


;;; long integer arithmetics; some primitives stay in warmelt-first.melt
(defprimitive -i (:long a b) :long  :doc #{Integer binary substraction of $a and $b.}#
  #{(($a) - ($b))}#)

(defprimitive *i (:long a b) :long  :doc #{Integer binary product of $a and $b.}#
  #{(($a) * ($b))}#)
(defprimitive andi (:long a b) :long   :doc #{Integer binary bitwise and of $a and $b.}#
  #{(($a) & ($b))}#)
(defprimitive ori (:long a b) :long  :doc #{Integer binary bitwise or of $a and $b.}#
  #{(($a) | ($b))}#)
(defprimitive xori (:long a b) :long :doc #{Integer binary bitwise exclusive-or of $a and $b.}#  
  #{(($a) ^ ($b))}#)

(defprimitive negi (:long i) :long  :doc #{Integer unary negation of $i.}#
  #{(-($i))}#)
(defprimitive noti (:long i) :long :doc #{Integer unary bitwise complement of $i.}# 
  #{(~($i))}#)

;;; various tests

(defprimitive notnull (v) :long :doc #{Test that $V is not the null value.}#
  #{(($v) != NULL)}#)

;;; zero test (for numbers)
(defprimitive zerop (:long i)  :long :doc #{Test that $I is zero.}# #{(($i) == OL)}#)

;;; debug on dumpfile
(defprimitive outcstring_dbg (:cstring s) :void :doc #{output a debug string $S.}#
  #{melt_puts(dump_file,($s))}#)
(defprimitive outnum_dbg (:cstring pref :long l :cstring suf) :void
  :doc #{debug output an integer $L with prefix $PREF and suffix $SUF.}#
  #{melt_putnum(dump_file,($pref), ($l), ($suf))}#)
(defprimitive outstr_dbg (str) :void :doc #{output a debug string value $STR.}#
  #{melt_putstr(dump_file,(melt_ptr_t)($str))}#)

(defprimitive outstrbuf_dbg (sbuf) :void :doc #{output a debug stringbuffer value $SBUF.}#
  #{melt_putstrbuf(dump_file,(melt_ptr_t)($sbuf))}#)
(defprimitive outnewline_dbg () :void :doc #{output a debug newline.}#
  #{melt_newlineflush(dump_file)}#)
;;; output on stderr
(defprimitive outnum_err (:cstring pref :long l :cstring suf) :void
  :doc #{output on stderr the number $L with prefix $PREF and suffix $SUF.}#
  #{melt_putnum(stderr,($pref), ($l), ($suf))}#)
(defprimitive outcstring_err (:cstring s) :void
  :doc #{Output on stderr the string $s.}#
  #{melt_puts(stderr,($s))}#)
(defprimitive outstrbuf_err (sbuf) :void
  :doc #{Output on stderr the stringbuffer value $sbuf.}#
  #{melt_putstrbuf(stderr,(melt_ptr_t)($sbuf))}#)


;; various primitives

;; change the head of a pair
(defprimitive pair_set_head (pa hd) :void
  :doc #{Safely set in pair $PA its head to $HD. 
Please avoid using that to introduce circularities in lists.}#
 #{meltgc_pair_set_head((melt_ptr_t)($pa), ($hd))}#)
;; length of a pair list
(defprimitive pair_listlength (pa) :long
  :doc #{Compute the linked length of given pair value $PA or else 0.}#
  #{(melt_pair_listlength((melt_ptr_t)($pa)))}#)

;; make a pair
(defprimitive make_pair (discr hd tl) :value
  :doc #{Create a new pair of given discrimiant $DISCR head $HD and
tail $TL or else null.}#
  #{(meltgc_new_pair((meltobject_ptr_t)($discr), (melt_ptr_t)($hd), (melt_ptr_t)($tl)))}#)

;;;;;; MIXINT primitives (use get_int to get the integer)
(defprimitive is_mixint (mi) :long
  :doc #{Test if value $MI is a mixedint value.}#
  #{(melt_magic_discr((melt_ptr_t)($mi)) == MELTOBMAG_MIXINT)}#)
;; get the value
(defprimitive mixint_val (mi) :value
  :doc #{Get the value inside a mixedint value $MI. The integer can be retrieved using $GET_INT.}#
  #{(melt_val_mixint((melt_ptr_t)($mi)))}#)
;; make a mixint
(defprimitive make_mixint (dis val :long num) :value
  :doc #{Make a mixint value of given discriminant $DIS value $VAL and number $NUM or else null.}#
  #{(meltgc_new_mixint((meltobject_ptr_t)($dis), (melt_ptr_t)($val), ($num)))}#)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;; MIXLOC primitives (use get_int to get the integer)
;; test
(defprimitive is_mixloc (mi) :long
  :doc #{Test if value $MI is a mixed location value.}#
  #{(melt_magic_discr((melt_ptr_t)($mi)) == MELTOBMAG_MIXLOC)}#)
;; get the value
(defprimitive mixloc_val (mi) :value
  :doc #{Safely retrieve the value inside a mixed location value $MI.}#
  #{(melt_val_mixloc((melt_ptr_t)($mi)))}#)
(defprimitive mixloc_location (mi) :long
  :doc #{Safely retrieve as an opaque long the location of a mixed location value $MI.}#
  #{((long) melt_location_mixloc((melt_ptr_t)($mi)))}#)
(defprimitive mixloc_locline (mi) :long
  :doc #{Retrieve the line of the location of a mixed location value $MI.}#
  #{(LOCATION_LINE(melt_location_mixloc((melt_ptr_t)$mi)))}#)
(defprimitive mixloc_locfile (mi) :cstring
  :doc #{Retrieve the filename as a raw cstring of a mixed location value $MI.}#
  #{(LOCATION_FILE(melt_location_mixloc((melt_ptr_t)$mi)))}#)

(defprimitive make_string_mixloc_file (mi dis) :value
  :doc #{Retrieve the filename as a boxed string of a mixed location value $MI.}#
  #{(meltgc_new_stringdup((meltobject_ptr_t)($DIS), 
			  (LOCATION_FILE(melt_location_mixloc((melt_ptr_t)$MI)))))}#)

;; make a mixloc
(defprimitive make_mixloc (dis val :long num loc) :value
  :doc #{Make a mixed location value of given discriminant $DIS value $VAL
number $NUM opaque location number $LOC.}#
  #{(meltgc_new_mixloc((meltobject_ptr_t)($dis), (melt_ptr_t)($val), 
		       ($num), (location_t)($loc)))}#)



;; test for mixbigint
(defprimitive is_mixbigint (mb) :long
  :doc #{Test if value $MB is a mixed bigint.}#
  "(melt_magic_discr((melt_ptr_t)(" mb ")) == MELTOBMAG_MIXBIGINT)")
(defprimitive mixbigint_val (mb) :value
  :doc #{Retrieve the value inside a mixed bigint $MB.}#
  #{melt_val_mixbigint($mb)}#)

(defprimitive ppstrbuf_mixbigint (:value sbuf :long indent :value mb) :void
 :doc #{Pretty prints into string buffer $SBUF at indentation $INDENT the mixed bigint $MB.}#
 #{meltgc_ppstrbuf_mixbigint($sbuf,$indent,$mb);}#
)


;;; READ FILE primitive
(defprimitive read_file (filnam) :value
  :doc #{Read from file named by the $FILNAM string balue a list of MELT s-expressions.}#
  #{(meltgc_read_file (melt_string_str((melt_ptr_t)($filnam)), (char*)0))}#)


;; to signal an error in a  source with some additional string value
(defprimitive error_strv (loc :cstring cmsg :value strv) :void
  :doc #{Show an error at boxed location $LOC with raw message string $CMSG and string value $STRV.}#
  #{melt_error_str((melt_ptr_t)($loc), ($cmsg), (melt_ptr_t)($strv))}#)


;; signal a plain error in a  source
(defprimitive error_plain (loc :cstring cmsg) :void
  :doc #{Show a plain error at boxed location $LOC with raw message string $CMSG.}#
  #{melt_error_str((melt_ptr_t)($loc), ($cmsg), (melt_ptr_t)0)}#)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; to signal an warning in a  source with some additional string value
(defprimitive warning_strv (loc :cstring cmsg :value strv) :void
  :doc #{Show a warning at boxed location $LOC with raw message string $CMSG and string value $STRV.}#
  #{melt_warning_str(0, (melt_ptr_t)($loc), ($cmsg), (melt_ptr_t)($strv))}#)

;; signal a plain warning in a  source
(defprimitive warning_plain (loc :cstring cmsg) :void
  :doc #{Show a plain warning at boxed location $LOC with raw message string $CMSG.}#
  #{melt_warning_str(0, (melt_ptr_t)($loc), ($cmsg), (melt_ptr_t)0)}#)

;; signal a plain warning 
(defprimitive warningmsg_plain (:cstring cmsg) :void
  :doc #{Show a plain warning with raw message string $CMSG.}#
  #{warning(0, "MELT WARNING MSG [#%ld]::: %s", melt_dbgcounter, ($cmsg))}#  )

;; signal a plain error 
(defprimitive errormsg_plain (:cstring cmsg) :void
  :doc #{Show a plain error with raw message string $CMSG.}#
  #{error ("MELT ERROR MSG [#%ld]::: %s", melt_dbgcounter, ($cmsg))}#
  )




;; signal a plain warning with string
(defprimitive warningmsg_strv (:cstring cmsg :value strv) :void
  :doc #{Show a plain warning with raw message string $CMSG and string value $STRV.}#
  #{warning (0, "MELT WARNING MSG [#%ld]::: %s - %s", melt_dbgcounter, ($cmsg),
	  melt_string_str((melt_ptr_t)($strv)))}#
  )

;; signal a plain error with string
(defprimitive errormsg_strv (:cstring cmsg :value strv) :void
  :doc #{Show a plain error with raw message string $CMSG and string value $STRV.}#
  #{error ("MELT ERROR MSG [#%ld]::: %s - %s", melt_dbgcounter, ($cmsg),
	  melt_string_str((melt_ptr_t)($strv)))}#
  )

;; to signal an inform in a  source with some additional string value
(defprimitive inform_strv (loc :cstring cmsg :value strv) :void
  :doc #{Show a notice at boxed location $LOC with raw message string $CMSG and string value $STRV.}#
  #{melt_inform_str((melt_ptr_t)($loc), ($cmsg), (melt_ptr_t)($strv))}#)
;; signal a plain inform in a  source
(defprimitive inform_plain (loc :cstring cmsg) :void
  :doc #{Show a plain warning at boxed location $LOC with raw message string $CMSG.}#
  #{melt_inform_str((melt_ptr_t)($loc), ($cmsg), (melt_ptr_t)0)}#)


(defprimitive informsg_plain (:cstring cmsg) :void
  :doc #{Show a plain notice with raw message string $CMSG.}#
  #{inform(UNKNOWN_LOCATION, "MELT INFORM [#%ld]: %s",  melt_dbgcounter, ($cmsg))}#
  )

(defprimitive informsg_strv (:cstring cmsg :value strv) :void
  :doc #{Show a plain notice with raw message string $CMSG and string value $STRV.}#
  #{inform(UNKNOWN_LOCATION, "MELT INFORM [#%ld]: %s - %s",  
			     melt_dbgcounter, ($cmsg), 
			     melt_string_str ($STRV))}#
  )

;;; citerator on integers
(defciterator foreach_long_upto
  (:long imin imax)			;start formals
  eachlong				;state
  (:long ix)				;local formals
  :doc #{The $FOREACH_LONG_UPTO c-iterator provides the usual
ascending integer iterator. Start formals are $IMIN, the minimum start
integer, and $IMAX, le maximal ending integer. Local formal is $IX,
the current index. The body is executed for each integer value $IX
from $IMIN to $IMAX included.}#
  					;before expansion
#{/*start $eachlong */
    long $eachlong#_min =  $imin;
    long $eachlong#_max = $imax;
    long $eachlong#_cur = 0;
    for ($eachlong#_cur = $eachlong#_min;
         $eachlong#_cur <= $eachlong#_max;
	 $eachlong#_cur ++) {
	    $ix = $eachlong#_cur;	    
}#
 					;after expansion
   #{ } /*end eachlong */}#
)
   
;;; match an integer i mutiple of a given number n and submatch the quotient
(defcmatcher some_integer_multiple
  (:long i n)				;match & ins
  (:long q)					;outs
  intmult				;statesymb
  :doc #{The $SOME_INTEGER_MULTIPLE matcher with input number $N matches an
integer $I if $N is positive and $I is multiple of $N and the quotient
matches the subpattern $Q.}#
  ;; test expansion
  #{ /*$INTMULT ?*/ ($N>0 && (($I) % ($N))==0) }#
  ;; fill expansion
  #{ /*$INTMULT !*/ $Q = ($I) / ($N); }#
  )

;;; match an integer i greater than a given number n
(defcmatcher some_integer_greater_than
  (:long i n)
  ()
  intgreathan
  :doc #{The $SOME_INTEGER_GREATER_THAN matcher with input number $N matches
an integer $I if $I is greater than $N.}#
  ;; test expansion
  #{ /*$INTGREATHAN ?*/ ($I > $N) }#
  ;; no fill expansion
)

;;;;;;;;;;;;;;;;

(defprimitive outnewline_err () :void
  :doc #{Output on stderr a newline and flush.}#
  "melt_newlineflush(stderr)")

(defprimitive outstr_err (str) :void
  :doc #{Output on stderr a MELT string.}#
  #{melt_putstr(stderr, (melt_ptr_t)($str))}#)


(defprimitive message_dbg (:cstring msg) :void :doc #{Debug message $msg}#
  #{debugeputs(($msg))}#)
(defprimitive messagenum_dbg (:cstring msg :long i) :void 
  :doc #{Debug output with message $msg number $i}#
  #{debugnum(($msg), ($i))}#)

(defprimitive messageval_dbg (:cstring msg :value val) :void
  :doc #{Debug output with message $msg value $val}#
  #{debugvalue(($msg), ((void*)($val)))}#)

(defprimitive longbacktrace_dbg (:cstring msg :long maxdepth) :void
  :doc #{Detailed debug backtrace with message $MSG up to $MAXDEPTH.}#
  #{debugbacktrace(($msg), (int)(maxdepth))}#)


(defprimitive checkval_dbg (val :cstring msg) :value
  :doc #{Low-level costly check of value $VAL with message $MSG. Mostly useful for gurus.}#
  #{melt_checked_assignmsg (($val),($msg))}#)

(defprimitive debugcstring (:cstring msg str) :void
  :doc #{Debug cstring $MSG $STR.}#
  #{debugeprintf("debugcstring %s '%s'", $msg, $str)}#)

(defprimitive debuglong (:cstring msg :long num) :void
  :doc #{Debug long stuff with $MSG and number $NUM.}#
  #{debugeprintf("debuglong %s %ld", $msg, $num)}#)

;;;;;; STRBUF primitives
;; primitive to make a strbuf
(defprimitive make_strbuf (discr) :value
  :doc #{Make a new stringbuffer value of given $DISCR - or null if bad $DISCR.}#
  #{meltgc_new_strbuf((meltobject_ptr_t)($discr), (char*)0)}#)

(defprimitive strbuf_usedlength (sbuf) :long
  :doc #{Give the used length of given $SBUF string buffer or else 0.}#
  #{melt_strbuf_usedlength((melt_ptr_t)($sbuf))}#)

(defprimitive output_length (out) :long
  :doc #{Return the length of a given output $OUT (i.e. the used length if it is a string buffer, the file position if it is a file) or else 0.}#
  #{melt_output_length ((melt_ptr_t)$OUT)}#)

(defprimitive is_strbuf (v) :long
  :doc #{Test if value $V is a stringbuffer.}# 
  #{(melt_magic_discr((melt_ptr_t)($v)) == MELTOBMAG_STRBUF)}#)

;;; make a string
(defprimitive make_string (dis str) :value
  :doc #{Make a new string of discriminant $DIS from string value $STR.}#
  #{(meltgc_new_stringdup((meltobject_ptr_t)($dis), 
			  melt_string_str((melt_ptr_t)($str))))}#)

(defprimitive is_stringconst (str :cstring cs) :long
  :doc #{Test that value string $STR is the raw string constant $CS.}#
  #{(melt_is_string_const((melt_ptr_t)($str), ($cs)))}#)

(defprimitive string_length (str) :long
  :doc #{Give the length of string value $STR.}#
  #{melt_string_length((melt_ptr_t)($str))}#)

(defprimitive string= (s1 s2) :long 
  :doc #{Test that value strings $S1 and $S2 are equal as strings.}#
  #{melt_string_same(($s1), ($s2))}#)


(defprimitive string!= (s1 s2) :long 
  :doc #{Test that value strings $S1 and $S2 are not equal as strings.}#
  #{!melt_string_same(($s1), ($s2))}#)


(defprimitive split_string_space (dis :cstring cs) :value
  :doc #{Split a cstring $CS into a list of space separated strings of
discriminant $DIS.}#
#{meltgc_new_split_string($cs, ' ', (melt_ptr_t) $dis)}#)

(defprimitive split_string_comma (dis :cstring cs) :value
  :doc #{Split a cstring $CS into a list of comma separated strings of
discriminant $DIS.}#
#{meltgc_new_split_string($cs, ',', (melt_ptr_t) $dis)}#)

(defprimitive split_string_colon (dis :cstring cs) :value
  :doc #{Split a cstring $CS into a list of colon separated strings of
discriminant $DIS.}#
#{meltgc_new_split_string($cs, ':', (melt_ptr_t)$dis)}#)

;;; convert a strbuf into a string
(defprimitive strbuf2string (dis sbuf) :value
  :doc #{make a string value of discriminant $DIS from the stringbuffer $SBUF.}#
  #{(meltgc_new_stringdup((meltobject_ptr_t)($dis), melt_strbuf_str((melt_ptr_t)($sbuf))))}#)

;;; compute the naked basename
(defprimitive make_string_nakedbasename (dis str) :value
  :doc #{make a string value of discriminant $DIS from the naked basename from file path $STR.}#
  #{(meltgc_new_string_nakedbasename((meltobject_ptr_t)($dis), melt_string_str((melt_ptr_t)($str))))}#)

;;; compute the naked temporary path for a basename with a suffix
(defprimitive make_string_tempname_suffixed (dis str :cstring suff) :value
  :doc #{make a naked temporary path of discriminant $DIS for a
  basename $STR with suffix $SUFF.}#
  #{(meltgc_new_string_tempname_suffixed((meltobject_ptr_t)($dis),
					 melt_string_str((melt_ptr_t)($str)),
					 ($suff)))}#)

;; compute a generated C source file
(defprimitive make_string_generated_c_filename (dis basestr dirstr) :value
  :doc #{make a generated C file path of discriminant $DIS with base $BASESTR and directory $DIRSTR adding a .c suffix.}#
  #{(meltgc_new_string_generated_c_filename((meltobject_ptr_t)($DIS),
					    melt_string_str ((melt_ptr_t)($BASESTR)),
					    melt_string_str ((melt_ptr_t)($DIRSTR)),
					    0))}#)

;;;; compile a C code file as module and load it. First argument is an
;;;; environment, second argument is the string containing the C file
;;;; path. Return value is the new environment provided by the loaded
;;;; module.
(defprimitive load_melt_module (env str) :value
  :doc #{load a MELT module by C compilation of file $STR with
  environment $ENV. Gives the new environment after loading the module.}#
  #{(meltgc_make_load_melt_module ((melt_ptr_t)($env),
				   melt_string_str((melt_ptr_t)($str)),
				   /*load_melt_module*/
				   "melt_module"))}#)

;; likewise, but for debug
(defprimitive load_debug_melt_module (env str) :value
  :doc #{load a MELT module by C compilation of file $STR with
  environment $ENV. Gives the new environment after loading the module.}#
  #{(meltgc_make_load_melt_module ((melt_ptr_t)($env),
				   melt_string_str((melt_ptr_t)($str)),
				   /*load_debug_melt_module*/
				   "melt_module_withoutline"))}#)

;; generate a loadable module from a MELT generated C source file; the
;;  out is the dynloaded module without any *.so suffix 
(defprimitive generate_melt_module (src outnam) :void
  :doc #{Generate and load a module whose source is named after $SRC 
and whose binary is named after $OUTNAM without any '.so' suffix.}#
  #{meltgc_make_melt_module($src,$outnam,"melt_module");}#)

;; generate a debug loadable module from a MELT generated C source file; the
;;  out is the dynloaded module without any *.so suffix 
(defprimitive generate_debug_melt_module (src outnam) :void
  :doc #{Generate and load a module whose source is named after $SRC 
and whose binary is named after $OUTNAM without any '.so' suffix.}#
  #{meltgc_make_melt_module($src,$outnam,"melt_module_withoutline");}#)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;; OBJECT primitives
;; primitive to get an object length
(defprimitive object_length (ob) :long 
  :doc #{Gives the length of object $OB.}#
  #{((long)melt_object_length((melt_ptr_t)($ob)))}#)
;; primitive to get the nth field of an object
(defprimitive object_nth_field (ob :long n) :value
  :doc #{Safely retrieve from object $OB its $N-th field or else null.}#
  #{(melt_field_object((melt_ptr_t)($ob), ($n)))}#)

(defprimitive subclass_of (cl1 cl2) :long
  :doc #{Safely test if class $CL1 is a sub-class of class $CL2.}#
  #{melt_is_subclass_of((meltobject_ptr_t)($cl1), (meltobject_ptr_t)($cl2))}#)
(defprimitive subclass_or_eq (cl1 cl2) :long
  :doc #{Safely test if class $CL1 is the same or a sub-class of class $CL2.}#
  #{(($cl1 == $cl2) || melt_is_subclass_of((meltobject_ptr_t)($cl1), (meltobject_ptr_t)($cl2)))}#)

(defprimitive is_multiple_or_null (mul) :long
  :doc #{Safely test if $MUL is a tuple or null.}#
  #{(($mul) == NULL || (melt_unsafe_magic_discr((melt_ptr_t)($mul)) == MELTOBMAG_MULTIPLE))}#)
;; primitive to build the subsequence of a multiple
(defprimitive subseq_multiple (mul :long startix endix) :value
  :doc #{Make a tuple from as subsequence of $MUL from indexes $STARTIX to $ENDIX.}#
 #{ meltgc_new_subseq_multiple((melt_ptr_t)($mul),
				  (int)($startix), (int)($endix)) }#)

;; is_multiple, make_multiple, multiple_nth, multiple_put_nth are in
;; warmelt-first

;; cmatcher for the tuple nth argument
(defcmatcher tuple_nth 
  (matchedtup :long matchedrk)				;match & ins
  (outcomp)				;out
  tupnth				;statesymb
  :doc #{The $TUPLE_NTH matcher with input number $MATCHEDRK matches a
tuple of length greater than $MATCHEDRK and retrieve the component
of that index, and matches it against the sub-pattern.}#
  ;;test expansion
   #{/*$TUPNTH ?*/ (melt_is_multiple_at_least(((melt_ptr_t)$matchedtup), 1+ (int)($matchedrk)))}#
   ;;fill expansion
  #{/*$TUPNTH !*/ $outcomp = melt_multiple_nth((melt_ptr_t)($matchedtup),(int)($matchedrk));
   }#
  ;; no operator expansion 
)


;; cmatcher for a tuple of a given exact size
(defcmatcher tuple_sized
  (tup :long ln)			;match & ins
  () 					;outs
  tupsiz				;statesymb
  :doc #{Match a tuple of given exact size.}#
  ;;test expansion
   #{(melt_is_multiple_of_length((melt_ptr_t)($tup), (int) ($ln)))}#
  ;; no fill expansion
  ;; no operator expansion
)


;; public comparator for named instances
(defun compare_named_alpha (n1 n2)
  :doc #{Alphanumerical compare of named instances $N1 and $N2. 
Returns a boxed integer.}#
  (cond 
   ( (== n1 n2) '0)
   ( (is_not_a n1 class_named) 
     '1)
   ( (is_not_a n2 class_named)
     '-1)
   (:else
    (let ( (sn1 (unsafe_get_field :named_name n1))
	   (sn2 (unsafe_get_field :named_name n2)) )
      (cond
       ( (string< sn1 sn2) 
	 '-1)
       ( (string> sn1 sn2)
	 '1)
       (:else
	'0))))))


;; actually all the sbuf routines now take an outbuf argument, which can be either a string buffer of a file
(defprimitive is_out (v) :long
  :doc #{Test if value $V is a output value (a stringbuffer or a file).}# 
  #{ (melt_is_out ((melt_ptr_t) $v)) }#)
;; primitive to add a string const into a strbuf
(defprimitive add2sbuf_strconst (sbuf :cstring str) :void 
  :doc #{Add into stringbuffer $SBUF the constant string $STR.}#
  #{meltgc_add_strbuf((melt_ptr_t)($sbuf), ($str))}#)

;; primitive to add a string value into a strbuf
(defprimitive add2sbuf_string (sbuf str) :void 
  :doc #{Add into stringbuffer $SBUF the string value $STR.}#
  #{meltgc_add_strbuf((melt_ptr_t)($sbuf), melt_string_str((melt_ptr_t)($str)))}#)
;; primitive to add the location info of a mixedloc into a strbuf we
;; copy the location file name into a buffer, to avoid crashing if a
;; GC is called...
(defprimitive add2sbuf_mixloc (sbuf mixl) :void
  :doc #{Add into stringbuffer $SBUF the mixed loc $MIXL.}#
  #{/*add2sbufmixloc*/ if (melt_magic_discr((melt_ptr_t)($mixl)) == MELTOBMAG_MIXLOC) {
    char smallbuf[128];
    location_t loc = melt_location_mixloc ((melt_ptr_t)$mixl);
    memset (smallbuf, 0, sizeof(smallbuf));
    snprintf (smallbuf, sizeof (smallbuf)-1, 
			"{%.120s:%d:%d}",
			LOCATION_FILE (loc), LOCATION_LINE (loc), LOCATION_COLUMN (loc));
    meltgc_add_strbuf_raw((melt_ptr_t)($sbuf), smallbuf);
 } /*end add2sbufmixloc*/  }#)
;; primitive to add the short location info of a mixedloc into a strbuf
(defprimitive add2sbuf_short_mixloc (sbuf mixl) :void
  :doc #{Add into stringbuffer $SBUF the mixed loc $MIXL in short form.}#
  #{/*add2sbufshortmixloc*/  if (melt_magic_discr((melt_ptr_t)($mixl)) == MELTOBMAG_MIXLOC) {
  location_t loc = melt_location_mixloc((melt_ptr_t)$mixl);
  meltgc_strbuf_printf((melt_ptr_t)($sbuf), "{%s:%d:%d}", 
		       lbasename(LOCATION_FILE (loc)), 
		       LOCATION_LINE (loc), LOCATION_COLUMN (loc));
  } /*end add2sbufshortmixloc*/}#)
;; primitive to add the texi location info of a mixedloc into a strbuf
(defprimitive add2sbuf_texi_mixloc (sbuf mixl) :void
  :doc #{Add into stringbuffer $SBUF the mixed loc $MIXL in texinfo form.}#
  #{/*add2sbufteximixloc*/ if (melt_magic_discr((melt_ptr_t)($mixl)) == MELTOBMAG_MIXLOC) {
  location_t loc = melt_location_mixloc((melt_ptr_t)$mixl);
  meltgc_strbuf_printf((melt_ptr_t)($sbuf), "file @file{%s}, line %d", 
		       lbasename (LOCATION_FILE (loc)), 
		       LOCATION_LINE (loc)); 
  } /*end add2sbufteximixloc*/}#)

;; primitive to add an indentation or space into a strbuf
(defprimitive add2sbuf_indent (sbuf :long depth) :void
  :doc #{Add into stringbuffer $SBUF an indentation of given $DEPTH or a space.}#
  #{meltgc_strbuf_add_indent((melt_ptr_t)($sbuf), ($depth), 64)}#)


;; primitive to add an indented newline into a strbuf
(defprimitive add2sbuf_indentnl (sbuf :long depth) :void
  :doc #{Add into stringbuffer $SBUF an indented newline of given $DEPTH.}#
  #{meltgc_strbuf_add_indent((melt_ptr_t)($sbuf), ($depth), 0)}#)


;; primitive to add a strbuf into a strbuf
(defprimitive add2sbuf_sbuf (sbuf asbuf) :void 
  :doc #{Add into stringbuffer $SBUF the content of stringbuffer $ASBUF.}#
  #{meltgc_add_strbuf((melt_ptr_t)($sbuf), melt_strbuf_str($asbuf))}#)

;; primitive to add a string value, C encoded, into a strbuf
(defprimitive add2sbuf_cencstring (sbuf str) :void 
  :doc #{Add into stringbuffer $SBUF the content of string $STR with C encoding.}#
  #{meltgc_add_strbuf_cstr((melt_ptr_t)($sbuf), melt_string_str((melt_ptr_t)($str)))}#)

;; primitive to add a strbuf, C encoded, into a strbuf
(defprimitive add2sbuf_cencstrbuf (sbuf asbuf) :void 
  :doc #{Add into stringbuffer $SBUF the content of stringbuffer $ASBUF with C encoding.}#
  #{meltgc_add_strbuf_cstr((melt_ptr_t)($sbuf), melt_strbuf_str((melt_ptr_t)($asbuf)))}#)

;; primitive to add a string value, Ccomment encoded, into a strbuf
(defprimitive add2sbuf_ccomstring (sbuf str) :void 
  :doc #{Add into stringbuffer $SBUF the content of string $STR with C-comment encoding, i.e. avoiding */.}#
  #{meltgc_add_strbuf_ccomment((melt_ptr_t)($sbuf), melt_string_str((melt_ptr_t)($str)))}#)

;; primitive to add a strbuf, C encoded, into a strbuf
(defprimitive add2sbuf_ccomstrbuf (sbuf asbuf) :void 
  :doc #{Add into stringbuffer $SBUF the content of stringbuffer $ASBUF with C-comment encoding, i.e. avoiding */.}#
  #{meltgc_add_strbuf_ccomment((melt_ptr_t)($sbuf), 
			       melt_strbuf_str((melt_ptr_t)($asbuf)))}#)

;; primitive to add a cstring const, Ccomment encoded, into a strbuf
(defprimitive add2sbuf_ccomconst (sbuf :cstring cstr) :void 
  :doc #{Add into stringbuffer $SBUF the constant string $CSTR with
 C-comment encoding so no */.}# 
 #{meltgc_add_strbuf_ccomment(($sbuf), $cstr)}#)

;; primitive to add into a strbuf a string as C ident (nonalphanum
;; replaced by _)
(defprimitive add2sbuf_cident (sbuf str) :void
  :doc #{Add into stringbuffer $SBUF the string $STR as a C identifier
  so nonalphanum replaced by _.}#
  #{meltgc_add_strbuf_cident((melt_ptr_t)($sbuf),
  melt_string_str((melt_ptr_t)($str)))}#)

;; primitive to add into a strbuf the prefix of a string as C ident (nonalphanum
;; replaced by _) limited by a small length 
(defprimitive add2sbuf_cidentprefix  (sbuf str :long preflen) :void
  :doc #{Add into stringbuffer $SBUF the prefix string $STR as a C identifier
  so nonalphanum replaced by _ limited by $PREFLEN.}#
  #{meltgc_add_strbuf_cidentprefix((melt_ptr_t)($sbuf), melt_string_str((melt_ptr_t)($str)), ($preflen))}#)

;; primitive to add a long in decimal into a strbuf
(defprimitive add2sbuf_longdec (sbuf :long num) :void
  :doc #{Add into stringbuffer $SBUF the number $NUM in decimal.}#
  #{meltgc_add_strbuf_dec((melt_ptr_t)($sbuf), ($num))}#)

;; primitive to add a long in hex into a strbuf
(defprimitive add2sbuf_longhex (sbuf :long num) :void
  :doc #{Add into stringbuffer $SBUF the number $NUM in hexa.}#
  #{meltgc_add_strbuf_hex((melt_ptr_t)($sbuf), ($num))}#)

;; primitive to add a routine descr into a strbuf
(defprimitive add2sbuf_routinedescr (sbuf rout) :void
  :doc #{Add into stringbuffer $SBUF the routine descriptor $ROUT.}#
  #{meltgc_add_strbuf((melt_ptr_t)($sbuf), melt_routine_descrstr((melt_ptr_t)($rout)))}#)

;;;;;;;;;;;;;;;;
;;; primitive to output a strbuf into a file named by a cstring
(defprimitive output_sbuf_strconst (sbuf :cstring nam) :void
  :doc #{Output into file named $NAM the content of strinbuffer $SBUF.}#
#{ melt_output_strbuf_to_file(($sbuf), ($nam)) }#)
;;; primitive to output a strbuf into a file named by a stringval
(defprimitive output_sbuf_strval (sbuf vnam) :void
  :doc #{Output into file named by string value $VNAM the content of strinbuffer $SBUF.}#
#{ melt_output_strbuf_to_file(($sbuf), melt_string_str($vnam)) }#)


;;;;;;;;;;;;;;;; variant for outbuf

;; primitive to add a string const into a outbuf
(defprimitive add2out_strconst (out :cstring str) :void 
  :doc #{Add to output $OUT the cstring $STR.}#
  #{meltgc_add_out((melt_ptr_t)($out), ($str))}#)
;; primitive to add a string value into a outbuf
(defprimitive add2out_string (out str) :void 
  :doc #{Add to output $OUT the string value $STR.}#
  #{meltgc_add_out((melt_ptr_t)($out), melt_string_str((melt_ptr_t)($str)))}#)

;; primitive to add the location info of a mixedloc into a outbuf
(defprimitive add2out_mixloc (out mixl) :void
  :doc #{Add to output $OUT the mixed location $MIXL.}#
  #{/*add2outmixloc*/ if (melt_magic_discr((melt_ptr_t)($mixl)) == MELTOBMAG_MIXLOC) {
  char locbuf[128];
  location_t tloc = melt_location_mixloc((melt_ptr_t)$MIXL);
  memset (locbuf, 0, sizeof(locbuf));
  snprintf (locbuf, sizeof(locbuf)-1,
		    "{%.110s:%d}",
		    LOCATION_FILE (tloc),
		    LOCATION_LINE (tloc));
   meltgc_add_out_raw ((melt_ptr_t) $OUT, locbuf);
  } /*end add2outmixloc*/
}#)

;; primitive to add an indentation or space into a outbuf
(defprimitive add2out_indent (out :long depth) :void
  :doc #{Add to output $OUT the indentation $DEPTH or a space.}#
  #{meltgc_out_add_indent((melt_ptr_t)($out), ($depth), 64);}#)


;; primitive to add an indented newline into a outbuf
(defprimitive add2out_indentnl (out :long depth) :void
  :doc #{Add to output $OUT the indented newline of given $DEPTH.}#
  #{meltgc_out_add_indent((melt_ptr_t)($out), ($depth), 0);}#)


;; primitive to add a strbuf into a outbuf
(defprimitive add2out_sbuf (out asbuf) :void 
  :doc #{Add to output $OUT the stringbuffer $ASBUF.}#
  #{meltgc_add_out((melt_ptr_t)($out), melt_out_str($asbuf))}#)

;; primitive to add a string value, C encoded, into a outbuf
(defprimitive add2out_cencstring (out str) :void 
  :doc #{Add to output $OUT the C-encoded string value $STR.}#
  #{meltgc_add_out_cstr((melt_ptr_t)($out), melt_string_str((melt_ptr_t)($str)))}#)

;; primitive to add a substring value, C encoded, into a outbuf
(defprimitive add2out_cencsubstring (out str :long off slen) :void 
  :doc #{Add to output $OUT the C-encoded substring value $STR at offset $OFF of length $SLEN.}#
  #{meltgc_add_out_csubstr_len((melt_ptr_t)($OUT),
			       melt_string_str((melt_ptr_t)($STR)),
			       ($OFF), ($SLEN))}#)

;; primitive to add a strbuf, C encoded, into a outbuf
(defprimitive add2out_cencstrbuf (out asbuf) :void 
  :doc #{Add to output $OUT the C-encoded stringbuffer $ASBUF.}#
  #{meltgc_add_out_cstr((melt_ptr_t)($out), melt_out_str((melt_ptr_t)($asbuf)))}#)

;; primitive to add a string value, Ccomment encoded, into a outbuf
(defprimitive add2out_ccomstring (out str) :void 
  :doc #{Add to output $OUT the C-comment encoded string value $STR.}#
  #{meltgc_add_out_ccomment((melt_ptr_t)($out), melt_string_str((melt_ptr_t)($str)))}#)

;; primitive to add a strbuf, C encoded, into a outbuf
(defprimitive add2out_ccomstrbuf (out asbuf) :void 
  :doc #{Add to $OUT the C-comment encoded stringbuffer $ASBUF.}#
  #{meltgc_add_out_ccomment((melt_ptr_t)($out), melt_out_str((melt_ptr_t)($asbuf)))}#)

;; primitive to add a cstring const, Ccomment encoded, into a outbuf
(defprimitive add2out_ccomconst (out :cstring cstr) :void 
  :doc #{Add to $OUT the constant C-comment encoded raw $CSTR.}#
  #{meltgc_add_out_ccomment(($out), $cstr)}#)

;; primitive to add into a outbuf a string as C ident (nonalphanum
;; replaced by _)
(defprimitive add2out_cident (out str) :void
  :doc #{Add to $OUT the MELT string $STR encocded as a C identifier, so
with every non-alnum character replaced with an underscore.}#
  #{meltgc_add_out_cident((melt_ptr_t)($out), 
			  melt_string_str((melt_ptr_t)($str)))}#)

;; primitive to add into a outbuf the prefix of a string as C ident (nonalphanum
;; replaced by _) limited by a small length 
(defprimitive add2out_cidentprefix  (out str :long preflen) :void
  :doc #{Add to $OUT the prefix of a string encoded as a C identifier,
limited by a small length $PREFLEN.}#
  #{meltgc_add_out_cidentprefix((melt_ptr_t)($out), 
				melt_string_str((melt_ptr_t)($str)), 
				($preflen))}#)

;; primitive to add a long in decimal into a outbuf
(defprimitive add2out_longdec (out :long num) :void
  :doc #{Add to $OUT the number $NUM in decimal.}#
  #{meltgc_add_out_dec((melt_ptr_t)($out), ($num))}#)

;; primitive to add a long in hex into a outbuf
(defprimitive add2out_longhex (out :long num) :void
  :doc #{Add to $OUT the number $NUM in hex.}#
  #{meltgc_add_out_hex((melt_ptr_t)($out), ($num))}#)

;; primitive to add a routine descr into a outbuf
(defprimitive add2out_routinedescr (out rout) :void
  :doc #{Add to $OUT the routine desscriptor $ROUT.}#
  #{meltgc_add_out((melt_ptr_t)($out), 
		   melt_routine_descrstr((melt_ptr_t)($rout)))}#)


;;; cmatcher for a cstring of a given content
(defcmatcher cstring_same 
  (:cstring str cstr)
  ()
  strsam
  :doc #{The $CSTRING_SAME c-matcher match a string $STR and test if
  it equals to the constant string $CSTR. The match fails if $STR is a
  null string or different from $CSTR.}# 

#{/*$strsam test*/ ($str && $cstr && !strcmp($str, $cstr)) }#
  ;; no fill or operator
)

;; primitive to compute the length of a cstring
(defprimitive cstring_length
  (:cstring cstr) :long
  :doc #{Compute safely the length a C-string $cstr. Gives 0 if null argument. }#
  #{(($cstr)?strlen($cstr):0)}#)

;;;;;;;;;;;;;;;;



;;; iterate fully in a map of strings
(defun mapstring_every (map f)
  :doc #{For a given hash-map of strings $MAP and a function $F,
apply $F to every attribute object and [perhaps allocated] string value. Returns
nil.}#
  (if (is_mapstring map)
      (if (is_closure f)
	  (foreach_in_mapstring
	   (map)
	   (curat curval)
	   (f curat curval)))))

;;; iterate & test over a map of strings - if the called f returns nil the
;;; iteration is stopped
(defun mapstring_iterate_test (map f)
  :doc #{For a given hash-map of strings $MAP and a function $F, apply
$F to every attribute object and string value. If it returns a null
value, with an other secundary value, gives the failing attribute, its
value, and the other.}#
  (if (is_mapstring map)
      (if (is_closure f)
	  (foreach_in_mapstring
	   (map)
	   (curat curval)
	   (multicall 
	    (test other)
	    (f curat curval)
	    (if (null test)
		(return curat curval other)
	   ))))))


;;;;;; MAPSTRINGs primitive

;; primitive to get the allocated size of a mapstring
(defprimitive mapstring_size (map) :long 
  :doc #{Safely return the current allocated size of a string-map $MAP or else 0.}#
  #{(melt_size_mapstrings((struct meltmapstrings_st*)($map)))}#)

;; primitive to get the attribute count of a mapstring
(defprimitive mapstring_count (map) :long
  :doc #{Safely return the current count of a string-map $MAP or else 0.}#
  #{(melt_count_mapstrings((struct meltmapstrings_st*)($map)))}#)


;; get an entry in a mapstring from a C string
(defprimitive mapstring_rawget (map :cstring cstr) :value
  :doc #{Safely get in a string-map $MAP the value associated with raw c-string $CSTR or else null.}#
  #{(melt_get_mapstrings((struct meltmapstrings_st*)($map), ($cstr)))}#)

;; primitive for putting into a map of strings
(defprimitive mapstring_rawput (map :cstring key :value val) :void
  :doc #{Safely put into a string-map $MAP the raw c-string $KEY associated to value $VAL.}#
  #{meltgc_put_mapstrings( (struct meltmapstrings_st *) ($map), ($key), (melt_ptr_t) ($val))}#)

;; primitives for removing from a map of strings
(defprimitive mapstring_rawremove (map :cstring key) :void
  :doc #{Safely remove from a string-map $MAP the value associated with raw c-string $KEY.}#
  #{meltgc_remove_mapstrings((struct meltmapstrings_st*) ($map), ($key))}#)


;;; full iterator on tuple - 
;;; the function is called with the component and its index
(defun multiple_every (tup f)
  :doc #{Apply to every component of tuple $TUP and its index the given
function $F. Return nil.}#
  (if (is_multiple tup)
      (if (is_closure f)
	  (foreach_in_multiple
	   (tup)
	   (comp :long ix)
	   (f comp ix)))))

;; full iterator backward
(defun multiple_backward_every (tup f)
  :doc #{Apply to every component (from last to first) of tuple $TUP
backwards, and its index the given function $F. Return nil.}#
  (if (is_multiple tup)
      (if (is_closure f)
	  (foreach_in_multiple_backward
	   (tup)
	   (comp :long ix)
	   (f comp ix)))))


;; iterator on two tuples
(defun multiple_every_both (tup1 tup2 f)
  :doc #{Given two tuples $TUP1 and $TUP2, apply function $F to every component of $TUP1 
with component of $TUP2 and index. Stop when either end is reached. Return nil.}#
  (if (is_multiple tup1)
      (if (is_multiple tup2)
	  (if (is_closure f)
	      (let ( (:long ln1 (multiple_length tup1))
		     (:long ln2 (multiple_length tup2))
		     (:long ix 0) )
		(forever tuploop
			 (if (>=i ix ln1) (exit tuploop))
			 (if (>=i ix ln2) (exit tuploop))
			 (f (multiple_nth tup1 ix) (multiple_nth tup2 ix) ix)
			 (setq ix (+i ix 1))))))))


;;;; MELT application depth & counter significant only when checking is enabled
(defprimitive melt_application_depth () :long 
  :doc #{Depth of MELT closures application - significant iff ENABLE_CHECKING.}#
  #{melt_application_depth()}#)

(defprimitive melt_application_shallower (:long maxdepth) :long
  :doc #{Test that the MELT application depth is less that $MAXDEPTH -
significant iff ENABLE_CHECKING.}# #{(melt_application_depth() <
  $MAXDEPTH)}#)

(defprimitive melt_application_count () :long
  :doc #{Count of MELT closures application - significant iff ENABLE_CHECKING.}#
  #{melt_application_count()}#)

(definstance melt_mode_container class_container
  :doc #{$MELT_MODE_CONTAINER is a container dedicated to share data at the mode level.}#)


;;; a private container for the list of closures for PLUGIN_PASS_EXECUTION
(definstance pass_execution_container class_container
  :container_value ()
  )

;;; private function to run all pass execution hooks
(defun run_all_pass_execution_hooks (hooklist passname :long passnum)
  ;; can't use debug_msg here!
  (foreach_in_list
   (hooklist)
   (curpair curhook)
   (curhook passname passnum)
   )
  (return)
)

;;; register a pass execution hook
(defun register_pass_execution_hook (fun)
  :doc #{Register closure $FUN as the hook for pass execution using
PLUGIN_PASS_EXECUTION. These hooks are called in order of
registrration.  Their first argument is the boxed pass name string,
their second argument is the raw pass number stuff.  See also
$UNREGISTER_PASS_EXECUTION_HOOK.}#
  (if (is_closure fun)
      (let ( (hooklist (unsafe_get_field :container_value 
					 pass_execution_container))
	     )
	(if (null hooklist)
	    (progn
	      (setq hooklist (list))
	      (put_fields pass_execution_container :container_value hooklist)))
	(assert_msg "check hooklist" (is_list hooklist))
	;; check that the fun is not already registered
	(foreach_in_list
	 (hooklist)
	 (curpair curhook)
	 (if (== curhook fun)
	     (return))
	 )
	(list_append hooklist fun)
	(put_fields initial_system_data
		   :sysdata_passexec_hook 
		   (lambda (passname :long passnum)
		     (run_all_pass_execution_hooks hooklist passname passnum)))
	(code_chunk regpassxechook 
		    #{ /*$REGPASSXECHOOK*/
		       meltgc_notify_sysdata_passexec_hook (); 
		       }#)
	(return)
	)))

;;; unregister a pass execution hook 
(defun unregister_pass_execution_hook (fun)
  :doc #{Unregister a pass execution hook function $FUN previously
registered with $REGISTER_PASS_EXECUTION_HOOK.}#
  (if (is_closure fun)
      (let ( (oldhooklist (unsafe_get_field :container_value 
					    pass_execution_container))
	     (newhooklist (list))
	     )
	(foreach_in_list
	 (oldhooklist)
	 (curpair curhook)
	 (if (!= curhook fun)
	     (list_append newhooklist curhook))
	 )
	(if (is_non_empty_list newhooklist)
	    (put_fields initial_system_data
		       :sysdata_passexec_hook ())
	  (put_fields initial_system_data
		     :sysdata_passexec_hook 
		     (lambda (passname :long passnum)
		       (run_all_pass_execution_hooks newhooklist passname passnum))))
	(code_chunk unregpassxechook 
		    #{ /*$UNREGPASSXECHOOK*/
		       meltgc_notify_sysdata_passexec_hook (); 
		       }#)
)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; the descriptions of values which are not ctype related.
(defclass class_value_descriptor
  :doc #{The $CLASS_VALUE_DESCRIPTOR describes MELT values which are
  not ctype renated. $VALDESC_OBJMAGIC is the symbol MELTOBMAG_* of
  its magic number. $VALDESC_STRUCT is the GTY-ed struct
  name. $VALDESC_UNIONMEM is the union member name inside union
  melt_un. $VALDESC_MEMBCHUNK is the code chunk of the structure
  members after the discriminant. $VALDESC_DECLCHUNK is the code chunk
  for declarations, e.g. macros, outside of the GTY-ed
  structure. $VALDESC_GTY is the optional GTY
  argument. $VALDESC_COPYCHUNK is the code chunk copying src to an
  allocated dst. $VALDESC_FORWCHUNK is the code chunk formarding
  internal pointers.}#
  :super class_named
  :fields (
	   valdesc_objmagic
	   valdesc_struct
	   valdesc_unionmem
	   valdesc_gty
	   valdesc_membchunk
	   valdesc_declchunk
	   valdesc_copychunk
	   valdesc_forwchunk
	   )
)

(defclass class_varisized_value_descriptor
  :doc #{The $CLASS_VARISIZED_VALUE_DESCRIPTOR describes variable
  sized MELT values.}#
  :super class_value_descriptor
  :fields (
	   ))

(export_class 
 class_value_descriptor 
 class_varisized_value_descriptor)

;;;;;;;;;;;;;;;;
(definstance value_descriptor_list_container
  class_container
  :container_value (make_list discr_list)
)

(defun install_value_descriptor (vd)
  (assert_msg "check vd" (is_a vd class_value_descriptor))
  (list_append (get_field :container_value value_descriptor_list_container) 
	       vd))

(defun retrieve_value_descriptor_list ()
  (get_field  :container_value value_descriptor_list_container))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;; object value
(definstance valdesc_object class_varisized_value_descriptor
  :doc #{$VALDESC_OBJECT describes object values.}#
  :named_name '"VALDESC_OBJECT"
  :valdesc_objmagic '"MELTOBMAG_OBJECT"
  :valdesc_struct '"meltobject_st"
  :valdesc_unionmem '"u_object"
  :valdesc_membchunk #{$' /* from VALDESC_OBJECT in warmelt-base.melt */
  unsigned obj_hash;		/* hash code of the object */
  unsigned short obj_num;
  unsigned short obj_len;
  melt_ptr_t GTY ((length ("%h.obj_len"))) obj_vartab[FLEXIBLE_DIM];
  }#
  :valdesc_declchunk #{$' /* decl VALDESC_OBJECT */
#define meltobj_class discr
#define meltobj_magic obj_num
#define MELT_OBJECT_STRUCT(N) {			\
  meltobject_ptr_t meltobj_class;		\
  unsigned obj_hash;				\
  unsigned short obj_num;			\
  unsigned short obj_len;			\
  melt_ptr_t* obj_vartab[N];			\
  long _gap; }
  }#
  :valdesc_copychunk #{$' /* from VALDESC_OBJECT */
    int ix = 0;
    int oblen = (int) (src->obj_len);
    /* We don't need to clear at allocation, since the object is
       explicitly filled here! */
    dst = ggc_alloc_meltobject_st
      (oblen*sizeof(void*)
       + offsetof(struct meltobject_st, obj_vartab));
    /* we cannot copy the whole src, because FLEXIBLE_DIM might be 1 */
    dst->meltobj_class = src->meltobj_class;
    dst->obj_hash = src->obj_hash;
    dst->obj_num = src->obj_num;
    dst->obj_len = oblen;
    for (ix = 0; ix < oblen; ix++)
        dst->obj_vartab[ix] = src->obj_vartab[ix];
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_OBJECT */
    int ix = 0;
    int oblen = (int) (src->obj_len);
    for (ix = 0; ix < oblen; ix++)
      MELT_FORWARDED (src->obj_vartab[ix]);
  }#
)
(install_value_descriptor valdesc_object)

;;;;;;;;;;;;;;;; objects map values

(definstance valdesc_mapobjects class_value_descriptor
  :doc #{$VALDESC_MAPOBJECTS describes object-keyed map values.}#
  :named_name '"VALDESC_MAPOBJECTS"
  :valdesc_objmagic '"MELTOBMAG_MAPOBJECTS"
  :valdesc_struct '"meltmapobjects_st"
  :valdesc_unionmem '"u_mapobjects"
  :valdesc_membchunk #{$' /* from VALDESC_MAPOBJECTS in warmelt-base.melt */
  unsigned count;
  unsigned char lenix;
  struct entryobjectsmelt_st *GTY ((length ("melt_primtab[%h.lenix]")))
    entab;
  /* the following field is usually the value of entab (for
     objects in the young zone), to allocate the object and its fields
     at once; hence its GTY-ed length is zero */
  struct entryobjectsmelt_st GTY ((length ("0"))) map_space[FLEXIBLE_DIM];
  }#
  :valdesc_declchunk #{$' /* decl VALDESC_MAPOBJECTS in warmelt-base.melt */
    typedef struct meltmapobjects_st* meltmapobjects_ptr_t;
  }#
  :valdesc_copychunk #{$' /* from VALDESC_MAPOBJECTS */
     int siz = melt_primtab[src->lenix];
     dst->discr = src->discr;
     dst->count = src->count;
     dst->lenix = src->lenix;
     if (siz > 0 && src->entab)
       {
       /* Don't need a cleared allocation.  */
         dst->entab = ggc_alloc_vec_entryobjectsmelt_st (siz);
         memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
       }
     else
       dst->entab = NULL;
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_MAPOBJECTS */
    int siz, ix;
    if (!src->entab)
      break;
    siz = melt_primtab[src->lenix];
    gcc_assert (siz > 0);
    if (melt_is_young (src->entab))
      {
        struct entryobjectsmelt_st *newtab = 
          /* Don't need a cleared allocation!  */
          ggc_alloc_vec_entryobjectsmelt_st (siz);
        memcpy (newtab, src->entab,
                siz * sizeof (struct entryobjectsmelt_st));
        src->entab = newtab;
      }
    for (ix = 0; ix < siz; ix++)
      {
        meltobject_ptr_t at = src->entab[ix].e_at;
        if (!at || at == (void *) HTAB_DELETED_ENTRY)
          {
            src->entab[ix].e_va = NULL;
            continue;
          }
        MELT_FORWARDED (at);
        src->entab[ix].e_at = at;
        MELT_FORWARDED (src->entab[ix].e_va);
      }
  }#
)
(install_value_descriptor valdesc_mapobjects)

;;;;;;;;;;;;;;;; string map values
(definstance valdesc_mapstrings class_value_descriptor
  :doc #{$VALDESC_MAPSTRINGS describes string-keyed map values.}#
  :named_name '"VALDESC_MAPSTRINGS"
  :valdesc_objmagic '"MELTOBMAG_MAPSTRINGS"
  :valdesc_struct '"meltmapstrings_st"
  :valdesc_unionmem '"u_mapstrings"
  :valdesc_membchunk #{$' /* from VALDESC_MAPSTRINGS in warmelt-base.melt */
  unsigned count;
  unsigned char lenix;
  struct entrystringsmelt_st *GTY ((length ("melt_primtab[%h.lenix]")))
    entab;
  }#
  :valdesc_copychunk #{$' /* from VALDESC_MAPSTRINGS */
        int siz = melt_primtab[src->lenix];
        dst->discr = src->discr;
        dst->count = src->count;
        dst->lenix = src->lenix;
        if (siz > 0 && src->entab)
          {
          /* Don't need a cleared allocation.  */
            dst->entab = ggc_alloc_vec_entrystringsmelt_st (siz);
            memcpy (dst->entab, src->entab, siz * sizeof (dst->entab[0]));
          }
        else
          dst->entab = NULL;
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_MAPSTRINGS */
     int ix, siz;
     if (!src->entab)
       break;
     siz = melt_primtab[src->lenix];
     gcc_assert (siz > 0);
     if (melt_is_young (src->entab))
       {
         struct entrystringsmelt_st *newtab
           /* Don't need a cleared allocation!  */
           = ggc_alloc_vec_entrystringsmelt_st (siz);
         memcpy (newtab, src->entab,
                 siz * sizeof (struct entrystringsmelt_st));
         src->entab = newtab;
       }
     for (ix = 0; ix < siz; ix++)
       {
         const char *at = src->entab[ix].e_at;
         if (!at || at == (void *) HTAB_DELETED_ENTRY)
           {
             src->entab[ix].e_va = NULL;
             continue;
           }
         if (melt_is_young ((const void *) at))
           src->entab[ix].e_at = (const char *) ggc_strdup (at);
         MELT_FORWARDED (src->entab[ix].e_va);
       }
  }#
)
(install_value_descriptor valdesc_mapstrings)


;;;;;;;;;;;;;;;; decaying value
(definstance valdesc_decay class_value_descriptor
  :doc #{$VALDESC_DECAY describes decaying values.}#
  :named_name '"VALDESC_DECAY"
  :valdesc_objmagic '"MELTOBMAG_DECAY"
  :valdesc_struct '"meltdecay_st"
  :valdesc_unionmem '"u_decay"
  :valdesc_gty #{$' mark_hook ("melt_mark_decay")}#
  :valdesc_membchunk #{$' /* from VALDESC_DECAY in warmelt-base.melt */
  melt_ptr_t val;
  unsigned remain;		/* remaining number of marking */
  }#
  :valdesc_copychunk #{$' /* from VALDESC_DECAY */
     dst = ggc_alloc_meltdecay_st ();
     *dst = *src;
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_DECAY */
     MELT_FORWARDED (src->val);
  }#
)
(install_value_descriptor valdesc_decay)
  
;;;;;;;;;;;;;;;; boxed value (boxing another value)
(definstance valdesc_box class_value_descriptor
  :doc #{$VALDESC_BOX describes boxing values.}#
  :named_name '"VALDESC_BOX"
  :valdesc_objmagic '"MELTOBMAG_BOX"
  :valdesc_struct '"meltbox_st"
  :valdesc_unionmem '"u_box"
  :valdesc_membchunk #{$' /* from VALDESC_BOX in warmelt-base.melt */
  melt_ptr_t val;
  }#
  :valdesc_declchunk #{$' /* decl VALDESC_BOX in warmelt-base.melt */
  typedef struct meltbox_st* meltbox_ptr_t;
  }#
  :valdesc_copychunk #{$' /* from VALDESC_BOX */
     dst = ggc_alloc_meltbox_st ();
     *dst = *src;
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_BOX */
     MELT_FORWARDED (src->val);
  }#
)
(install_value_descriptor valdesc_box)

;;;;;;;;;;;;;;;; multiple value
(definstance valdesc_multiple class_varisized_value_descriptor
  :doc #{$VALDESC_MULTIPLE describes multiple values, i.e. tuples.}#
  :named_name '"VALDESC_MULTIPLE"
  :valdesc_objmagic '"MELTOBMAG_MULTIPLE"
  :valdesc_struct '"meltmultiple_st"
  :valdesc_unionmem '"u_multiple"
  :valdesc_membchunk #{$' /* from VALDESC_MULTIPLE in warmelt-base.melt */
    unsigned nbval;
    melt_ptr_t GTY ((length ("%h.nbval"))) tabval[FLEXIBLE_DIM];
  }#
  :valdesc_declchunk #{$'  /* decl VALDESC_MULTIPLE in warmelt-base.melt */
#define MELT_MULTIPLE_STRUCT(N) {               \
    meltobject_ptr_t discr;                     \
    unsigned nbval;                             \
    melt_ptr_t tabval[N];                       \
    long _gap; }
  typedef struct meltmultiple_st* meltmultiple_ptr_t;
  }#
  :valdesc_copychunk #{$'  /* from VALDESC_MULTIPLE */
    int nbv = (int) src->nbval;
    int ix = 0;
    dst = 
      /* Don't need a cleared allocation!  */
      ggc_alloc_meltmultiple_st 
      (nbv*sizeof(void*) + offsetof(struct meltmultiple_st, tabval));
    /* we cannot copy the whole src, because FLEXIBLE_DIM might be
       1 and nbval could be 0 */
    dst->discr = src->discr;
    dst->nbval = src->nbval;
    for (ix = 0; ix < nbv; ix++)
      dst->tabval[ix] = src->tabval[ix];
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_MULTIPLE */
     int nbval = (int) src->nbval;
     int ix = 0;
     for (ix = 0; ix < nbval; ix++)
       MELT_FORWARDED (src->tabval[ix]);
  }#
)
(install_value_descriptor valdesc_multiple)

;;;;;;;;;;;;;;;; closure value
(definstance valdesc_closure class_varisized_value_descriptor
  :doc #{$VALDESC_CLOSURE describes closure values, i.e. functions.}#
  :named_name '"VALDESC_CLOSURE"
  :valdesc_objmagic '"MELTOBMAG_CLOSURE"
  :valdesc_struct '"meltclosure_st"
  :valdesc_unionmem '"u_closure"
  :valdesc_membchunk #{$' /* from VALDESC_CLOSURE in warmelt-base.melt */
    meltroutine_ptr_t rout;
    unsigned nbval;
    melt_ptr_t GTY ((length ("%h.nbval"))) tabval[FLEXIBLE_DIM];
  }#
  :valdesc_declchunk #{$' /* decl VALDESC_CLOSURE */
#define MELT_CLOSURE_STRUCT(N) {                \
    meltobject_ptr_t discr;                     \
    unsigned nbval;                             \
    melt_ptr_t tabval[N];                       \
    long _gap; }
  }#
  :valdesc_copychunk #{$' /* from VALDESC_CLOSURE */
     int nbv = (int) src->nbval;
     int ix = 0;
     dst = 
   /* Don't need a cleared allocation!  */
       ggc_alloc_meltclosure_st 
         (nbv*sizeof(void*) + offsetof(struct meltclosure_st, tabval));
     dst->discr = src->discr;
     dst->rout = src->rout;
     dst->nbval = (unsigned) nbv;
     for (ix = 0; ix < nbv; ix++)
       dst->tabval[ix] = src->tabval[ix];
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_CLOSURE */
     int nbval = (int) src->nbval;
     int ix = 0;
     MELT_FORWARDED (src->rout);
     for (ix = 0; ix < nbval; ix++)
       MELT_FORWARDED (src->tabval[ix]);
  }#
)
(install_value_descriptor valdesc_closure)

;;;;;;;;;;;;;;;; routine value
(definstance valdesc_routine class_varisized_value_descriptor
  :doc #{$VALDESC_ROUTINE describes routine values.}#
  :named_name '"VALDESC_ROUTINE"
  :valdesc_objmagic '"MELTOBMAG_ROUTINE"
  :valdesc_struct '"meltroutine_st"
  :valdesc_unionmem '"u_routine"
  :valdesc_membchunk #{$' /* from VALDESC_ROUTINE in warmelt-base.melt */
    char routdescr[MELT_ROUTDESCR_LEN];
    meltroutfun_t* GTY ((skip)) routfunad;
    melt_ptr_t routdata;
    unsigned nbval;
    melt_ptr_t GTY ((length ("%h.nbval"))) tabval[FLEXIBLE_DIM];
  }#
  :valdesc_declchunk #{$' /* decl VALDESC_ROUTINE */
#ifndef meltroutine_ptr_t_TYPEDEFINED
typedef struct meltroutine_st *meltroutine_ptr_t;
#define  meltroutine_ptr_t_TYPEDEFINED
#endif /*meltroutine_ptr_t_TYPEDEFINED from VALDESC_ROUTINE */

/* unsafely set inside the meltroutine_st pointed by Rptr the
   routine function pointer to Rout */
#define MELT_ROUTINE_SET_ROUTCODE(Rptr,Rout) do {	\
  ((struct meltroutine_st*)(Rptr))->routfunad		\
     = (Rout);						\
} while(0)

#define MELT_ROUTINE_STRUCT(N) {		\
  meltobject_ptr_t discr;			\
  char routdescr[MELT_ROUTDESCR_LEN];		\
  meltroutfun_t* routfunad;			\
  melt_ptr_t routdata;				\
  unsigned nbval;				\
  melt_ptr_t tabval[N];				\
  long _gap; }
  }#
  :valdesc_copychunk #{$' /* from VALDESC_ROUTINE */
     int nbv = (int) src->nbval;
     int ix = 0;
     dst =
       /* Don't need a cleared allocation!  */
       ggc_alloc_meltroutine_st
       (nbv*sizeof(void*) + offsetof(struct meltroutine_st, tabval));
     dst->discr = src->discr;
     strncpy (dst->routdescr, src->routdescr, MELT_ROUTDESCR_LEN);
     dst->routdescr[MELT_ROUTDESCR_LEN - 1] = 0;
     dst->nbval = (unsigned) nbv;
     dst->routfunad = src->routfunad;
     for (ix = 0; ix < nbv; ix++)
       dst->tabval[ix] = src->tabval[ix];
     dst->routdata = src->routdata;
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_ROUTINE */
     int nbval = (int) src->nbval;
     int ix = 0;
     for (ix = 0; ix < nbval; ix++)
       MELT_FORWARDED (src->tabval[ix]);
  }#
)
(install_value_descriptor valdesc_routine)

;;;;;;;;;;;;;;;; string value
(definstance valdesc_string class_varisized_value_descriptor
  :doc #{$VALDESC_STRING describes string values.}#
  :named_name '"VALDESC_STRING"
  :valdesc_objmagic '"MELTOBMAG_STRING"
  :valdesc_struct '"meltstring_st"
  :valdesc_unionmem '"u_string"
  :valdesc_membchunk #{$' /* from VALDESC_STRING in warmelt-base.melt */  
    char val[FLEXIBLE_DIM];	/* null terminated */
  }#
  :valdesc_declchunk #{$' /* decl VALDESC_STRING from warmelt-base.melt */
#define MELT_STRING_STRUCT(N) {			\
  meltobject_ptr_t discr;			\
  char val[(N)+1];	/* null terminated */	\
  long _gap; }
  }#
  :valdesc_copychunk #{$' /* from VALDESC_STRING file warmelt-base.melt*/  
     int srclen = (src->val)?strlen (src->val):0;
     dst = 
       /* Don't need a cleared allocation.  */
       ggc_alloc_meltstring_st 
         (offsetof(struct meltstring_st, val) + (srclen+1));
     dst->discr = src->discr;
     memcpy (dst->val, src->val, srclen);
     dst->val[srclen] = (char)0;
  }#
)
(install_value_descriptor valdesc_string)

;;;;;;;;;;;;;;;; string buffer value
(definstance valdesc_strbuf class_value_descriptor
  :doc #{$VALDESC_STRBUF describes string buffers values}#
  :named_name '"VALDESC_STRBUF"
  :valdesc_objmagic '"MELTOBMAG_STRBUF"
  :valdesc_struct '"meltstrbuf_st"
  :valdesc_unionmem '"u_strbuf"
  :valdesc_membchunk #{$' /* from VALDESC_STRBUF in warmelt-base.melt */  
  char *GTY ((length ("1+melt_primtab[%h.buflenix]"))) bufzn;
  unsigned char buflenix;	/* allocated length index of
				   buffer */
  unsigned bufstart;
  unsigned bufend;		/* start & end useful positions */
  /* the following field is usually the value of buf (for
     objects in the young zone), to allocate the object and its fields
     at once; hence its GTY-ed length is zero */
  char GTY ((length ("0"))) buf_space[FLEXIBLE_DIM];
  }#
  :valdesc_copychunk #{$' /* from VALDESC_STRBUF */
     unsigned blen = melt_primtab[src->buflenix];
     dst = 
       /* Don't need a cleared allocation.  */
       ggc_alloc_meltstrbuf_st ();
     dst->discr = src->discr;
     dst->bufstart = src->bufstart;
     dst->bufend = src->bufend;
     dst->buflenix = src->buflenix;
     if (blen > 0)
        {
#if BUILDING_GCC_VERSION > 4005
          dst->bufzn = CONST_CAST (char *, ggc_alloc_string (src->bufzn, blen+1));
#else /*GCC 4.5*/ 
          dst->bufzn = (char *) ggc_alloc_cleared (1 + blen);
          memcpy (dst->bufzn, src->bufzn, blen);
#endif  /*!GCC 4.5*/
          dst->bufzn[blen] = (char)0;
        }
      else
        dst->bufzn = NULL;
  }#
)
(install_value_descriptor valdesc_strbuf)


;;;;;;;;;;;;;;;; pair value
(definstance valdesc_pair class_value_descriptor
  :doc #{$VALDESC_PAIR describes pair values inside lists.}#
  :named_name '"VALDESC_PAIR"
  :valdesc_objmagic '"MELTOBMAG_PAIR"
  :valdesc_struct '"meltpair_st"
  :valdesc_unionmem '"u_pair"
  :valdesc_gty #{$' chain_next ("%h.tl")}#
  :valdesc_declchunk #{$' /* decl VALDESC_PAIR in warmelt-base.melt */
  typedef struct meltpair_st *meltpair_ptr_t;
  }#
  :valdesc_membchunk #{$' /* from VALDESC_PAIR in warmelt-base.melt */
    melt_ptr_t hd;
    struct meltpair_st *tl;
  }#
  :valdesc_copychunk #{$' /* copy VALDESC_PAIR in warmelt-base.melt */
    dst = /* Don't need a cleared allocation.  */
	  ggc_alloc_meltpair_st ();
    *dst = *src;
  }#
  :valdesc_forwchunk #{$' /* forward VALDESC_PAIR in warmelt-base.melt */
     MELT_FORWARDED (src->hd);
     MELT_FORWARDED (src->tl);
  }#
)
(install_value_descriptor valdesc_pair)
  

;;;;;;;;;;;;;;;; list value
(definstance valdesc_list class_value_descriptor
  :doc #{$VALDESC_LIST describes list values containing pairs.}#
  :named_name '"VALDESC_LIST"
  :valdesc_objmagic '"MELTOBMAG_LIST"
  :valdesc_struct '"meltlist_st"
  :valdesc_unionmem '"u_list"
  :valdesc_membchunk #{$' /* from VALDESC_LIST in warmelt-base.melt */
    struct meltpair_st *first;
    struct meltpair_st *last;
  }#
  :valdesc_declchunk #{$' /* decl VALDESC_LIST in warmelt-base.melt */
  typedef struct meltlist_st *meltlist_ptr_t;
  }#
  :valdesc_copychunk #{$' /* from VALDESC_LIST */
     dst = 
	  /* Don't need a cleared allocation!  */
	 ggc_alloc_meltlist_st ();
     *dst = *src;
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_LIST */
     MELT_FORWARDED (src->first);
     MELT_FORWARDED (src->last);
  }#

)
(install_value_descriptor valdesc_list)

;;;;;;;;;;;;;;;; int value
(definstance valdesc_int class_value_descriptor
  :doc #{$VALDESC_INT describes int values boxing long integers.}#
  :named_name '"VALDESC_INT"
  :valdesc_objmagic '"MELTOBMAG_INT"
  :valdesc_struct '"meltint_st"
  :valdesc_unionmem '"u_int"
  :valdesc_membchunk #{$' /* from VALDESC_INT in warmelt-base.melt */
    long val;
  }#
  :valdesc_copychunk #{$' /* from VALDESC_INT */
     dst = 
        /* Don't need a cleared allocation.  */
	  ggc_alloc_meltint_st ();
     *dst = *src;
  }#
)
(install_value_descriptor valdesc_int)

;;;;;;;;;;;;;;;; mixint value
(definstance valdesc_mixint class_value_descriptor
  :doc #{$VALDESC_MIXINT describes mixint values mixing integers with a value.}#
  :named_name '"VALDESC_MIXINT"
  :valdesc_objmagic '"MELTOBMAG_MIXINT"
  :valdesc_struct '"meltmixint_st"
  :valdesc_unionmem '"u_mixint"
  :valdesc_membchunk #{$' /* from VALDESC_MIXINT in warmelt-base.melt */
    melt_ptr_t ptrval;
    long intval;
  }#
  :valdesc_copychunk #{$' /* from VALDESC_MIXINT */
    dst = 
      /* Don't need a cleared allocation.  */
        ggc_alloc_meltmixint_st ();
    *dst = *src;
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_MIXINT */
    MELT_FORWARDED (src->ptrval);
  }#
)
(install_value_descriptor valdesc_mixint)

;;;;;;;;;;;;;;;; mixloc value
(definstance valdesc_mixloc class_value_descriptor
  :doc #{$VALDESC_MIXLOC describes mixloc values mixing locations with a value.}#
  :named_name '"VALDESC_MIXLOC"
  :valdesc_objmagic '"MELTOBMAG_MIXLOC"
  :valdesc_struct '"meltmixloc_st"
  :valdesc_unionmem '"u_mixloc"
  :valdesc_membchunk #{$' /* from VALDESC_MIXLOC in warmelt-base.melt.melt */
    melt_ptr_t ptrval;
    long intval;
    location_t locval;
  }#
  :valdesc_copychunk #{$' /* from VALDESC_MIXLOC */
    dst = 
       /* Don't need a cleared allocation.  */
       ggc_alloc_meltmixloc_st ();
    *dst = *src;
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_MIXLOC */
    MELT_FORWARDED (src->ptrval);
  }#
)
(install_value_descriptor valdesc_mixloc)

;;;;;;;;;;;;;;;; mixbigint value
(definstance valdesc_mixbigint class_varisized_value_descriptor
  :doc #{$VALDESC_MIXBIGINT describes mixbigint values.}#
  :named_name '"VALDESC_MIXBIGINT"
  :valdesc_objmagic '"MELTOBMAG_MIXBIGINT"
  :valdesc_struct '"meltmixbigint_st"
  :valdesc_unionmem '"u_mixbigint"
  :valdesc_membchunk #{$' /* from VALDESC_MIXBIGINT in warmelt-base.melt */
/* an exported array mpz compatible; since we use an exported mpz format, 
   the value can be copied and trashed by MELT garbage collector without 
   harm. */
    melt_ptr_t ptrval;
    bool negative;
    unsigned biglen;
    long GTY ((length ("%h.biglen"))) tabig[FLEXIBLE_DIM];
  }#
  :valdesc_copychunk #{$' /* from VALDESC_MIXBIGINT */
     unsigned blen = src->biglen;
     dst = 
       /* Don't need a cleared allocation.  */
       ggc_alloc_meltmixbigint_st 
       (blen*sizeof(long) + offsetof(struct meltmixbigint_st, tabig));
     dst->discr = src->discr;
     dst->ptrval = src->ptrval;
     dst->negative = src->negative;
     dst->biglen = blen;
     memcpy (dst->tabig, src->tabig, blen*sizeof(dst->tabig[0]));
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_MIXBIGINT */
    MELT_FORWARDED (src->ptrval);
  }#
)
(install_value_descriptor valdesc_mixbigint)

;;;;;;;;;;;;;;;; real value
(definstance valdesc_real class_value_descriptor
  :doc #{$VALDESC_REAL describes real values.}#
  :named_name '"VALDESC_REAL"
  :valdesc_objmagic '"MELTOBMAG_REAL"
  :valdesc_struct '"meltreal_st"
  :valdesc_unionmem '"u_real"
  :valdesc_membchunk #{$' /* from VALDESC_REAL in warmelt-base.melt */
    REAL_VALUE_TYPE val;
  }#
  :valdesc_copychunk #{$' /* from VALDESC_REAL */
    dst =
        /* Don't need a cleared allocation.  */
	ggc_alloc_meltreal_st ();
    *dst = *src;
  }#
)
(install_value_descriptor valdesc_real)

;;;;;;;;;;;;;;;; ****************** SPECIAL VALUES
;;;;;;;;;;;;;;;; special file value
(definstance valdesc_special_file class_value_descriptor
  :doc #{$VALDESC_SPECIAL_FILE describes special file values.}#
  :named_name '"VALDESC_SPECIAL_FILE"
  :valdesc_objmagic '"MELTOBMAG_SPEC_FILE"
  :valdesc_struct '"meltspecialfile_st"
  :valdesc_unionmem '"u_special_file"
  :valdesc_gty #{$' mark_hook ("melt_mark_special")}#
  :valdesc_membchunk #{$' /* from VALDESC_SPECIAL_FILE in warmelt-base.melt */
    int mark;
    struct meltspecial_st *GTY ((skip)) nextspec;
    union melt_special_un GTY ((skip)) val;
  }#
  :valdesc_copychunk #{$' /* from VALDESC_SPECIAL_FILE */
    dst = ggc_alloc_meltspecialfile_st ();
    *dst = *src;
    /* mark the new copy! */
    dst->mark = 1;
    /* add the new copy to the old (major) special list */
    dst->nextspec = melt_oldspeclist;
    melt_oldspeclist = (struct meltspecial_st*)dst;
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_SPECIAL_FILE */
    src->mark = 1;
  }#

)
(install_value_descriptor valdesc_special_file)

;;;;;;;;;;;;;;;; special raw file value
(definstance valdesc_special_raw_file class_value_descriptor
  :doc #{$VALDESC_SPECIAL_RAW_FILE describes special raw file values.}#
  :named_name '"VALDESC_SPECIAL_RAW_FILE"
  :valdesc_objmagic '"MELTOBMAG_SPEC_RAWFILE"
  :valdesc_struct '"meltspecialrawfile_st"
  :valdesc_unionmem '"u_special_rawfile"
  :valdesc_gty #{$' mark_hook ("melt_mark_special")}#
  :valdesc_membchunk #{$' /* from VALDESC_SPECIAL_RAW_FILE in warmelt-base.melt */
    int mark;
    struct meltspecial_st *GTY ((skip)) nextspec;
    union melt_special_un GTY ((skip)) val;
  }#
  :valdesc_copychunk #{$' /* from VALDESC_SPECIAL_RAW_FILE */
    dst = ggc_alloc_meltspecialrawfile_st ();
    *dst = *src;
    /* mark the new copy! */
    dst->mark = 1;
    /* add the new copy to the old (major) special list */
    dst->nextspec = melt_oldspeclist;
    melt_oldspeclist = (struct meltspecial_st*)dst;
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_SPECIAL_RAW_FILE */
    src->mark = 1;
  }#
)
(install_value_descriptor valdesc_special_raw_file)

;;;;;;;;;;;;;;;; special mpfr value
(definstance valdesc_special_mpfr class_value_descriptor
  :doc #{$VALDESC_SPECIAL_MPFR describes special MPFR values.}#
  :named_name '"VALDESC_SPECIAL_MPFR"
  :valdesc_objmagic '"MELTOBMAG_SPEC_MPFR"
  :valdesc_struct '"meltspecialmpfr_st"
  :valdesc_unionmem '"u_special_mpfr"
  :valdesc_gty #{$' mark_hook ("melt_mark_special")}#
  :valdesc_membchunk #{$' /* from VALDESC_SPECIAL_MPFR in warmelt-base.melt */
    int mark;
    struct meltspecial_st *GTY ((skip)) nextspec;
    union melt_special_un GTY ((skip)) val;
  }#
  :valdesc_copychunk #{$' /* from VALDESC_SPECIAL_MPFR */
    dst = ggc_alloc_meltspecialmpfr_st ();
    *dst = *src;
    /* mark the new copy! */
    dst->mark = 1;
    /* add the new copy to the old (major) special list */
    dst->nextspec = melt_oldspeclist;
    melt_oldspeclist = (struct meltspecial_st*)dst;
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_SPECIAL_MPFR */
    src->mark = 1;
  }#
)
(install_value_descriptor valdesc_special_mpfr)

;;;;;;;;;;;;;;;; special PPL coefficient value
(definstance valdesc_special_ppl_coefficient class_value_descriptor
  :doc #{$VALDESC_SPECIAL_PPL_COEFFICIENT describes special PPL coefficient values.}#
  :named_name '"VALDESC_SPECIAL_PPL_COEFFICIENT"
  :valdesc_objmagic '"MELTOBMAG_SPECPPL_COEFFICIENT"
  :valdesc_struct '"meltspecialpplcoefficient_st"
  :valdesc_unionmem '"u_special_ppl_coefficient"
  :valdesc_gty #{$' mark_hook ("melt_mark_special")}#
  :valdesc_membchunk #{$' /* from VALDESC_SPECIAL_PPL_COEFFICIENT in warmelt-base.melt */
    int mark;
    struct meltspecial_st *GTY ((skip)) nextspec;
    union melt_special_un GTY ((skip)) val;
  }#
  :valdesc_copychunk #{$' /* from VALDESC_SPECIAL_PPL_COEFFICIENT */
    dst = ggc_alloc_meltspecialpplcoefficient_st ();
    *dst = *src;
    /* mark the new copy! */
    dst->mark = 1;
    /* add the new copy to the old (major) special list */
    dst->nextspec = melt_oldspeclist;
    melt_oldspeclist = (struct meltspecial_st*)dst;
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_SPECIAL_PPL_COEFFICIENT */
    src->mark = 1;
  }#
)
(install_value_descriptor valdesc_special_ppl_coefficient)

;;;;;;;;;;;;;;;; special PPL linear expression value
(definstance valdesc_special_ppl_linear_expression class_value_descriptor
  :doc #{$VALDESC_SPECIAL_PPL_LINEAR_EXPRESSION describes special PPL 
linear expression values.}#
  :named_name '"VALDESC_SPECIAL_PPL_LINEAR_EXPRESSION"
  :valdesc_objmagic '"MELTOBMAG_SPECPPL_LINEAR_EXPRESSION"
  :valdesc_struct '"meltspecialppllinearexpression_st"
  :valdesc_unionmem '"u_special_ppl_linear_expression"
  :valdesc_gty #{$' mark_hook ("melt_mark_special")}#
  :valdesc_membchunk #{$' /* from VALDESC_SPECIAL_PPL_LINEAR_EXPRESSION in warmelt-base.melt*/
    int mark;
    struct meltspecial_st *GTY ((skip)) nextspec;
    union melt_special_un GTY ((skip)) val;
  }#
  :valdesc_copychunk #{$' /* from VALDESC_SPECIAL_PPL_LINEAR_EXPRESSION */
    dst = ggc_alloc_meltspecialppllinearexpression_st ();
    *dst = *src;
    /* mark the new copy! */
    dst->mark = 1;
    /* add the new copy to the old (major) special list */
    dst->nextspec = melt_oldspeclist;
    melt_oldspeclist = (struct meltspecial_st*)dst;
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_SPECIAL_PPL_LINEAR_EXPRESSION */
    src->mark = 1;
  }#
)
(install_value_descriptor valdesc_special_ppl_linear_expression)

;;;;;;;;;;;;;;;; special PPL constraint value
(definstance valdesc_special_ppl_constraint class_value_descriptor
  :doc #{$VALDESC_SPECIAL_PPL_CONSTRAINT describes special PPL 
constraints values.}#
  :named_name '"VALDESC_SPECIAL_PPL_CONSTRAINT"
  :valdesc_objmagic '"MELTOBMAG_SPECPPL_CONSTRAINT"
  :valdesc_struct '"meltspecialpplconstraint_st"
  :valdesc_unionmem '"u_special_ppl_constraint"
  :valdesc_gty #{$' mark_hook ("melt_mark_special")}#
  :valdesc_membchunk #{$' /* from VALDESC_SPECIAL_PPL_CONSTRAINT in warmelt-base.melt*/
    int mark;
    struct meltspecial_st *GTY ((skip)) nextspec;
    union melt_special_un GTY ((skip)) val;
  }#
  :valdesc_copychunk #{$' /* from VALDESC_SPECIAL_PPL_CONSTRAINT */
    dst = ggc_alloc_meltspecialpplconstraint_st ();
    *dst = *src;
    /* mark the new copy! */
    dst->mark = 1;
    /* add the new copy to the old (major) special list */
    dst->nextspec = melt_oldspeclist;
    melt_oldspeclist = (struct meltspecial_st*)dst;
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_SPECIAL_PPL_CONSTRAINT */
    src->mark = 1;
  }#
)
(install_value_descriptor valdesc_special_ppl_constraint)

;;;;;;;;;;;;;;;; special PPL constraint system value
(definstance valdesc_special_ppl_constraint_system class_value_descriptor
  :doc #{$VALDESC_SPECIAL_PPL_CONSTRAINT_SYSTEM describes special PPL 
constraint systems values.}#
  :named_name '"VALDESC_SPECIAL_PPL_CONSTRAINT_SYSTEM"
  :valdesc_objmagic '"MELTOBMAG_SPECPPL_CONSTRAINT_SYSTEM"
  :valdesc_struct '"meltspecialpplconstraintsystem_st"
  :valdesc_unionmem '"u_special_ppl_constraint_system"
  :valdesc_gty #{$' mark_hook ("melt_mark_special")}#
  :valdesc_membchunk #{$' /* from VALDESC_SPECIAL_PPL_CONSTRAINT_SYSTEM in warmelt-base.melt */
    int mark;
    struct meltspecial_st *GTY ((skip)) nextspec;
    union melt_special_un GTY ((skip)) val;
  }#
  :valdesc_copychunk #{$' /* from VALDESC_SPECIAL_PPL_CONSTRAINT_SYSTEM */
    dst = ggc_alloc_meltspecialpplconstraintsystem_st ();
    *dst = *src;
    /* mark the new copy! */
    dst->mark = 1;
    /* add the new copy to the old (major) special list */
    dst->nextspec = melt_oldspeclist;
    melt_oldspeclist = (struct meltspecial_st*)dst;
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_SPECIAL_PPL_CONSTRAINT_SYSTEM */
    src->mark = 1;
  }#
)
(install_value_descriptor valdesc_special_ppl_constraint_system)

;;;;;;;;;;;;;;;; special PPL generator value
(definstance valdesc_special_ppl_generator class_value_descriptor
  :doc #{$VALDESC_SPECIAL_PPL_GENERATOR describes special PPL 
generators values.}#
  :named_name '"VALDESC_SPECIAL_PPL_GENERATOR"
  :valdesc_objmagic '"MELTOBMAG_SPECPPL_GENERATOR"
  :valdesc_struct '"meltspecialpplgenerator_st"
  :valdesc_unionmem '"u_special_ppl_generator"
  :valdesc_gty #{$' mark_hook ("melt_mark_special")}#
  :valdesc_membchunk #{$' /* from VALDESC_SPECIAL_PPL_GENERATOR in warmelt-base.melt */
    int mark;
    struct meltspecial_st *GTY ((skip)) nextspec;
    union melt_special_un GTY ((skip)) val;
  }#
  :valdesc_copychunk #{$' /* from VALDESC_SPECIAL_PPL_GENERATOR */
    dst = ggc_alloc_meltspecialpplgenerator_st ();
    *dst = *src;
    /* mark the new copy! */
    dst->mark = 1;
    /* add the new copy to the old (major) special list */
    dst->nextspec = melt_oldspeclist;
    melt_oldspeclist = (struct meltspecial_st*)dst;
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_SPECIAL_PPL_GENERATOR */
    src->mark = 1;
  }#
)
(install_value_descriptor valdesc_special_ppl_generator)

;;;;;;;;;;;;;;;; special PPL generator system value
(definstance valdesc_special_ppl_generator_system class_value_descriptor
  :doc #{$VALDESC_SPECIAL_PPL_GENERATOR_SYSTEM describes special PPL 
generator systems values.}#
  :named_name '"VALDESC_SPECIAL_PPL_GENERATOR_SYSTEM"
  :valdesc_objmagic '"MELTOBMAG_SPECPPL_GENERATOR_SYSTEM"
  :valdesc_struct '"meltspecialpplgeneratorsystem_st"
  :valdesc_unionmem '"u_special_ppl_generator_system"
  :valdesc_gty #{$'mark_hook ("melt_mark_special")}#
  :valdesc_membchunk #{$' /* from VALDESC_SPECIAL_PPL_GENERATOR_SYSTEM in warmelt-base.melt */
    int mark;
    struct meltspecial_st *GTY ((skip)) nextspec;
    union melt_special_un GTY ((skip)) val;
  }#
  :valdesc_copychunk #{$' /* from VALDESC_SPECIAL_PPL_GENERATOR_SYSTEM */
    dst = ggc_alloc_meltspecialpplgeneratorsystem_st ();
    *dst = *src;
    /* mark the new copy! */
    dst->mark = 1;
    /* add the new copy to the old (major) special list */
    dst->nextspec = melt_oldspeclist;
    melt_oldspeclist = (struct meltspecial_st*)dst;
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_SPECIAL_PPL_GENERATOR_SYSTEM */
    src->mark = 1;
  }#
)
(install_value_descriptor valdesc_special_ppl_generator_system)

;;;;;;;;;;;;;;;; special PPL polyhedron value
(definstance valdesc_special_ppl_polyhedron class_value_descriptor
  :doc #{$VALDESC_SPECIAL_PPL_POLYHEDRON describes special PPL 
polyhedron values.}#
  :named_name '"VALDESC_SPECIAL_PPL_POLYHEDRON"
  :valdesc_objmagic '"MELTOBMAG_SPECPPL_POLYHEDRON"
  :valdesc_struct '"meltspecialpplpolyhedron_st"
  :valdesc_unionmem '"u_special_ppl_polyhedron"
  :valdesc_gty #{$'mark_hook ("melt_mark_special")}#
  :valdesc_membchunk #{$' /* from VALDESC_SPECIAL_PPL_POLYHEDRON in warmelt-base.melt */
    int mark;
    struct meltspecial_st *GTY ((skip)) nextspec;
    union melt_special_un GTY ((skip)) val;
  }#
  :valdesc_copychunk #{$' /* from VALDESC_SPECIAL_PPL_POLYHEDRON */
    dst = ggc_alloc_meltspecialpplpolyhedron_st ();
    *dst = *src;
    /* mark the new copy! */
    dst->mark = 1;
    /* add the new copy to the old (major) special list */
    dst->nextspec = melt_oldspeclist;
    melt_oldspeclist = (struct meltspecial_st*)dst;
  }#
  :valdesc_forwchunk #{$' /* from VALDESC_SPECIAL_PPL_POLYHEDRON */
    src->mark = 1;
  }#
)
(install_value_descriptor valdesc_special_ppl_polyhedron)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(export_values
 ignore
 void
 is_not_object
 get_globpredef
 obj_hash
 obj_len
 obj_num
 nonzero_hash
 minor_garbcoll
 full_garbcoll
 checkcallstack_msg
 cbreak_msg
 <=i
 ==i
 !=i
 -i
 *i
 maxi
 mini
 andi
 ori
 xori
 negi
 noti
 notnull
 zerop
 outcstring_dbg
 outnum_dbg
 outstr_dbg
 outstrbuf_dbg
 outnewline_dbg
 outnum_err
 outcstring_err	
 outstrbuf_err
 pair_set_head 
 pair_listlength
 make_pair
 is_mixint
 mixint_val
 make_mixint
 is_mixloc
 mixloc_val
 mixloc_location
 mixloc_locline
 mixloc_locfile
 make_mixloc
 is_mixbigint
 mixbigint_val
 ppstrbuf_mixbigint
 read_file
 error_strv
 error_plain
 warning_strv
 warning_plain
 warningmsg_plain
 warningmsg_strv
 errormsg_plain
 errormsg_strv
 inform_strv
 inform_plain
 informsg_plain
 informsg_strv


 foreach_long_upto
 some_integer_multiple
 some_integer_greater_than
 outnewline_err
 outstr_err
 message_dbg
 messagenum_dbg 
 messageval_dbg
 longbacktrace_dbg
 checkval_dbg
 debugcstring
 debuglong
 make_strbuf
 strbuf_usedlength
 is_strbuf

 make_string
 is_stringconst
 string_length
 string=
 string!=
 split_string_space
 split_string_comma
 split_string_colon
 strbuf2string
 make_string_generated_c_filename
 make_string_nakedbasename
 make_string_tempname_suffixed
 make_string_mixloc_file
 load_debug_melt_module
 load_melt_module
 generate_debug_melt_module
 generate_melt_module
 object_length
 object_nth_field
 subclass_of
 subclass_or_eq
 is_multiple_or_null
 subseq_multiple
 compare_named_alpha

 is_out
 add2sbuf_ccomconst
 add2sbuf_ccomstrbuf
 add2sbuf_ccomstring 
 add2sbuf_cencstrbuf
 add2sbuf_cencstring
 add2sbuf_cident
 add2sbuf_cidentprefix
 add2sbuf_indent
 add2sbuf_indentnl
 add2sbuf_longdec
 add2sbuf_longhex
 add2sbuf_mixloc
 add2sbuf_routinedescr
 add2sbuf_sbuf
 add2sbuf_short_mixloc
 add2sbuf_strconst
 add2sbuf_string
 add2sbuf_texi_mixloc
 output_sbuf_strconst
 output_sbuf_strval
 output_length

 add2out_ccomconst
 add2out_ccomstrbuf
 add2out_ccomstring 
 add2out_cencstrbuf
 add2out_cencstring
 add2out_cencsubstring
 add2out_cident
 add2out_cidentprefix
 add2out_indent
 add2out_indentnl
 add2out_longdec
 add2out_longhex
 add2out_mixloc
 add2out_routinedescr
 add2out_sbuf
 add2out_strconst
 add2out_string

 tuple_nth
 tuple_sized

 cstring_same
 cstring_length

 mapstring_every
 mapstring_iterate_test	
 mapstring_count
 mapstring_size
 mapstring_rawget
 mapstring_rawput
 mapstring_rawremove
		
 multiple_every_both
 multiple_every
 multiple_backward_every

 melt_application_count
 melt_application_depth
 melt_application_shallower

 melt_mode_container

 register_pass_execution_hook
 unregister_pass_execution_hook

 retrieve_value_descriptor_list
 valdesc_object
 valdesc_decay
 valdesc_box
 valdesc_multiple
 valdesc_closure
 valdesc_routine
 valdesc_string
 valdesc_strbuf
 valdesc_pair
 valdesc_list
 valdesc_int
 valdesc_mapobjects
 valdesc_mapstrings
 valdesc_mixint
 valdesc_mixloc
 valdesc_mixbigint
 valdesc_real
 valdesc_special_file
 valdesc_special_file
 valdesc_special_raw_file
 valdesc_special_mpfr
 valdesc_special_ppl_coefficient
 valdesc_special_ppl_linear_expression
 valdesc_special_ppl_constraint
 valdesc_special_ppl_constraint_system
 valdesc_special_ppl_generator
 valdesc_special_ppl_generator_system
 valdesc_special_ppl_polyhedron

 )


;;;; eof warmelt-base.melt
