#!/usr/bin/perl
# Generate fusion.md
#
# Copyright (C) 2020-2023 Free Software Foundation, Inc.
#
# This file is part of GCC.
#
# GCC is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3, or (at your option)
# any later version.
#
# GCC is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GCC; see the file COPYING3.  If not see
# <http://www.gnu.org/licenses/>.

use warnings;
use strict;

print <<'EOF';
;; Generated automatically by genfusion.pl

;; Copyright (C) 2020-2023 Free Software Foundation, Inc.
;;
;; This file is part of GCC.
;;
;; GCC is free software; you can redistribute it and/or modify it under
;; the terms of the GNU General Public License as published by the Free
;; Software Foundation; either version 3, or (at your option) any later
;; version.
;;
;; GCC is distributed in the hope that it will be useful, but WITHOUT ANY
;; WARRANTY; without even the implied warranty of MERCHANTABILITY or
;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
;; for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with GCC; see the file COPYING3.  If not see
;; <http://www.gnu.org/licenses/>.

EOF

# Print the insns for load and compare with -1/0/1.
# Arguments:
# lmode      -- Integer mode ("DI", "SI", "HI", or "QI").
# result     -- "clobber", "GPR", or $lmode
# ccmode     -- Sign vs. unsigned ("CC" or "CCUNS").
# mem_format -- Memory format ("d" or "ds").
# cmpl       -- Suffix for compare ("l" or "")
# const_pred -- Predicate for constant (i.e. -1/0/1 or 0/1).
# extend     -- "sign", "zero", or "none".
# echr       -- Suffix for load ("a", "z", or "").
# load       -- Load instruction (i.e. "ld", "lwa", "lwz", etc.)
# np         -- enum non_prefixed_form for memory type
# constraint -- constraint to use
# mem_pred   -- predicate for the memory operation

sub print_ld_cmpi_p10
{
  my ($lmode, $result, $ccmode, $cmpl, $const_pred,
      $extend, $load, $np, $constraint, $mem_pred) = @_;

  # For clobber, we need a SI/DI reg in case we split because we have to
  # sign/zero extend.
  my $clobbermode = ($lmode =~ m/^[HQ]I$/) ? "GPR" : $lmode;

  # Break long print statements into smaller lines.
  my $info = join (" ",
		   "load mode is ${lmode} result mode is ${result}",
		   "compare mode is ${ccmode} extend is ${extend}");

  my $name = join ("",
		   "${load}_cmp${cmpl}di_cr0_${lmode}",
		   "_${result}_${ccmode}_${extend}");

  my $cmp_op1 = "(match_operand:${lmode} 1 \"${mem_pred}\" \"${constraint}\")";

  my $spaces = " " x (length ($ccmode) + 18);

  print ";; load-cmpi fusion pattern generated by gen_ld_cmpi_p10\n";
  print ";; ${info}\n";
  print "(define_insn_and_split \"*${name}\"\n";
  print "  [(set (match_operand:${ccmode} 2 \"cc_reg_operand\" \"=x\")\n";
  print "        (compare:${ccmode} ${cmp_op1}\n";
  print "${spaces}(match_operand:${lmode} 3 \"${const_pred}\" \"n\")))\n";

  if ($result eq "clobber")
    {
      print "   (clobber (match_scratch:${clobbermode} 0 \"=r\"))]\n";
    }

  else
    {
      my $load_op0 = "(match_operand:${result} 0 \"gpc_reg_operand\" \"=r\")";
      my $load_op1 = (($result eq $lmode)
		      ? "(match_dup 1)"
		      : "(${extend}_extend:${result} (match_dup 1))");
      print "   (set ${load_op0} ${load_op1})]\n";
    }

  # Do not match prefixed loads.  The machine only fuses non-prefixed loads
  # with compare immediate.  Take into account whether the load is a ds-form
  # or a d-form instruction.
  print "  \"(TARGET_P10_FUSION)\"\n";
  print "  \"${load}%X1 %0,%1\\;cmp${cmpl}di %2,%0,%3\"\n";
  print "  \"&& reload_completed\n";
  print "   && (cc_reg_not_cr0_operand (operands[2], CCmode)\n";
  print "       || !address_is_non_pfx_d_or_x (XEXP (operands[1], 0),\n";
  print "                                      ${lmode}mode, ${np}))\"\n";

  if ($extend eq "none")
    {
      print "  [(set (match_dup 0) (match_dup 1))\n";
    }

  else
    {
      my $resultmode = ($result eq "clobber") ? $clobbermode : $result;
      print "  [(set (match_dup 0) (${extend}_extend:${resultmode} (match_dup 1)))\n";
    }

  print "   (set (match_dup 2)\n";
  print "        (compare:${ccmode} (match_dup 0) (match_dup 3)))]\n";
  print "  \"\"\n";
  print "  [(set_attr \"type\" \"fused_load_cmpi\")\n";
  print "   (set_attr \"cost\" \"8\")\n";
  print "   (set_attr \"length\" \"8\")])\n";
  print "\n";
}

sub gen_ld_cmpi_p10
{
  my ($lmode, $result, $mem_format, $extend);

  # Map mode to load instruction
  my %signed_load = ("DI" => "ld",
		     "SI" => "lwa",
		     "HI" => "lha");

  my %unsigned_load = ("DI" => "ld",
		       "SI" => "lwz",
		       "HI" => "lhz",
		       "QI" => "lbz");

  # Memory predicate to use.
  my %signed_memory_predicate = ("DI" => "ds_form_mem_operand",
				 "SI" => "ds_form_mem_operand",
				 "HI" => "non_update_memory_operand");

  my %unsigned_memory_predicate = ("DI" => "ds_form_mem_operand",
				   "SI" => "non_update_memory_operand",
				   "HI" => "non_update_memory_operand",
				   "QI" => "non_update_memory_operand");

  # Internal format of the memory instruction (enum non_prefixed_form) to use.
  my %np = ("ds" => "NON_PREFIXED_DS",
	    "d"  => "NON_PREFIXED_D");

  # Result modes to use. Clobber is used when you are comparing the load to
  # -1/0/1, but you are not using it otherwise.  EXTDI does not exist. We
  # cannot directly use HI/QI results because we only have word and double word
  # compared.  For promotion, don't allow EXTQI because that would allow HI
  # results which we can't do (use GPR instead).
  my %result_modes = ("DI" => ["clobber", "DI"],
		      "SI" => ["clobber", "SI", "EXTSI" ],
		      "HI" => ["clobber", "EXTHI" ],
		      "QI" => ["clobber", "GPR" ]);

  foreach $lmode ("DI", "SI", "HI", "QI")
    {
      foreach $result (@{ $result_modes{$lmode} })
	{
	  # Handle CCmode (sign extended compares to -1, 0, or 1).  We don't
	  # have  a LBA instruction, so skip QImode.  Both LD and LWA are
	  # DS-form instructions for signed loads.
	  if ($lmode ne "QI")
	    {
	      $mem_format = ($lmode =~ m/^[DS]I$/) ? "ds" : "d";
	      $extend = (($lmode eq "DI"
			  || $lmode eq $result
			  || ($lmode eq "SI" && $result eq "clobber"))
			 ? "none"
			 : "sign");

	      print_ld_cmpi_p10 ($lmode, $result, "CC", "",
				 "const_m1_to_1_operand", $extend,
				 $signed_load{$lmode}, $np{$mem_format}, "m",
				 $signed_memory_predicate{$lmode});
	    }

	  # Handle CCUNS mode (zero extended compares to 0 or 1.
	  # LD is DS-form, but LWZ is not for unsigned loads.
	  $mem_format = ($lmode eq "DI") ? "ds" : "d";
	  $extend = (($lmode eq "DI"
		      || $lmode eq $result
		      || ($lmode eq "SI" && $result eq "clobber"))
		     ? "none"
		     : "zero");

	  print_ld_cmpi_p10 ($lmode, $result, "CCUNS", "l",
			     "const_0_to_1_operand", $extend,
			     $unsigned_load{$lmode}, $np{$mem_format}, "m",
			     $unsigned_memory_predicate{$lmode});
	}
    }
}

sub gen_logical_addsubf
{
    my @logicals = ( "and", "andc", "eqv", "nand", "nor", "or", "orc", "xor" );
    my %logicals_addsub = ( "and"=>1, "nand"=>1, "nor"=>1, "or"=>1 );
    my @addsub = ( "add", "subf" );
    my %isaddsub = ( "add"=>1, "subf"=>1 );
    my %complement = ( "and"=> 0, "andc"=> 1, "eqv"=> 0, "nand"=> 3,
		       "nor"=> 3, "or"=> 0, "orc"=> 1, "xor"=> 0,
		       "add"=> 0, "subf"=> 0 );
    my %invert = ( "and"=> 0, "andc"=> 0, "eqv"=> 1, "nand"=> 0,
		   "nor"=> 0, "or"=> 0, "orc"=> 0, "xor"=> 0,
		   "add"=> 0, "subf"=> 0 );
    my %commute2 = ( "and"=> 1, "andc"=> 0, "eqv"=> 1, "nand"=> 0,
		     "nor"=> 0, "or"=> 1, "orc"=> 0, "xor"=> 1 );
    my %rtlop = ( "and"=>"and", "andc"=>"and", "eqv"=>"xor", "nand"=>"ior",
		  "nor"=>"and", "or"=>"ior", "orc"=>"ior", "xor"=>"xor",
		  "add"=>"plus", "subf"=>"minus" );

    my ($kind, $vchr, $mode, $pred, $constraint, $cr, $outer, @outer_ops,
	$outer_op, $outer_comp, $outer_inv, $outer_rtl, $inner, @inner_ops,
	$inner_comp, $inner_inv, $inner_rtl, $inner_op, $both_commute, $c4,
	$bc, $inner_arg0, $inner_arg1, $inner_exp, $outer_arg2, $outer_exp,
	$ftype, $insn, $is_subf, $is_rsubf, $outer_32, $outer_42,$outer_name,
	$fuse_type);
  KIND: foreach $kind ('scalar','vector') {
      @outer_ops = @logicals;
      if ( $kind eq 'vector' ) {
	  $vchr = "v";
	  $mode = "VM";
	  $pred = "altivec_register_operand";
	  $constraint = "v";
	  $fuse_type = "fused_vector";
      } else {
	  $vchr = "";
	  $mode = "GPR";
	  $pred = "gpc_reg_operand";
	  $constraint = "r";
	  $fuse_type = "fused_arith_logical";
	  push (@outer_ops, @addsub);
	  push (@outer_ops, ( "rsubf" ));
      }
      $c4 = "${constraint},${constraint},${constraint},${constraint}";
    OUTER: foreach $outer ( @outer_ops ) {
	$outer_name = "${vchr}${outer}";
	$is_subf = ( $outer eq "subf" );
	$is_rsubf = ( $outer eq "rsubf" );
	if ( $is_rsubf ) {
	    $outer = "subf";
	}
	$outer_op = "${vchr}${outer}";
	$outer_comp = $complement{$outer};
	$outer_inv = $invert{$outer};
	$outer_rtl = $rtlop{$outer};
	@inner_ops = @logicals;
	$ftype = "logical-logical";
	if ( exists $isaddsub{$outer} ) {
	    @inner_ops = sort keys %logicals_addsub;
	    $ftype = "logical-add";
	} elsif ( $kind ne 'vector' && exists $logicals_addsub{$outer} ) {
	    push (@inner_ops, @addsub);
	}
      INNER: foreach $inner ( @inner_ops ) {
	  if ( exists $isaddsub{$inner} ) {
	      $ftype = "add-logical";
	  }
	  $inner_comp = $complement{$inner};
	  $inner_inv = $invert{$inner};
	  $inner_rtl = $rtlop{$inner};
	  $inner_op = "${vchr}${inner}";
	  # If both ops commute then we can specify % on operand 1
	  # so the pattern will let operands 1 and 2 interchange.
	  $both_commute = ($inner eq $outer) && ($commute2{$inner} == 1);
	  $bc = ""; if ( $both_commute ) { $bc = "%"; }
	  $inner_arg0 = "(match_operand:${mode} 0 \"${pred}\" \"${c4}\")";
	  $inner_arg1 = "(match_operand:${mode} 1 \"${pred}\" \"${bc}${c4}\")";
	  if ( ($inner_comp & 1) == 1 ) {
	      $inner_arg0 = "(not:${mode} $inner_arg0)";
	  }
	  if ( ($inner_comp & 2) == 2 ) {
	      $inner_arg1 = "(not:${mode} $inner_arg1)";
	  }
	  $inner_exp = "(${inner_rtl}:${mode} ${inner_arg0}
                          ${inner_arg1})";
	  if ( $inner_inv == 1 ) {
	      $inner_exp = "(not:${mode} $inner_exp)";
	  }
	  $outer_arg2 = "(match_operand:${mode} 2 \"${pred}\" \"${c4}\")";
	  if ( ($outer_comp & 1) == 1 ) {
	      $outer_arg2 = "(not:${mode} $outer_arg2)";
	  }
	  if ( ($outer_comp & 2) == 2 ) {
	      $inner_exp = "(not:${mode} $inner_exp)";
	  }
	  if ( $is_subf ) {
	      $outer_32 = "%2,%3";
	      $outer_42 = "%2,%4";
	  } else {
	      $outer_32 = "%3,%2";
	      $outer_42 = "%4,%2";
	  }
	  if ( $is_rsubf == 1 ) {
	      $outer_exp = "(${outer_rtl}:${mode} ${outer_arg2}
                 ${inner_exp})";
	  } else {
	      $outer_exp = "(${outer_rtl}:${mode} ${inner_exp}
                 ${outer_arg2})";
	  }
	  if ( $outer_inv == 1 ) {
	      $outer_exp = "(not:${mode} $outer_exp)";
	  }

	  $insn =  <<"EOF";

;; $ftype fusion pattern generated by gen_logical_addsubf
;; $kind $inner_op -> $outer_name
(define_insn "*fuse_${inner_op}_${outer_name}"
  [(set (match_operand:${mode} 3 "${pred}" "=&0,&1,&${constraint},${constraint}")
        ${outer_exp})
   (clobber (match_scratch:${mode} 4 "=X,X,X,&${constraint}"))]
  "(TARGET_P10_FUSION)"
  "@
   ${inner_op} %3,%1,%0\\;${outer_op} %3,${outer_32}
   ${inner_op} %3,%1,%0\\;${outer_op} %3,${outer_32}
   ${inner_op} %3,%1,%0\\;${outer_op} %3,${outer_32}
   ${inner_op} %4,%1,%0\\;${outer_op} %3,${outer_42}"
  [(set_attr "type" "$fuse_type")
   (set_attr "cost" "6")
   (set_attr "length" "8")])
EOF

	  print $insn;
      }
    }
  }
}

sub gen_addadd
{
    my ($kind, $vchr, $op, $type, $mode, $pred, $constraint);
    foreach $kind ('scalar','vector') {
      if ( $kind eq 'vector' ) {
	  $vchr = "v";
	  $op = "vaddudm";
	  $type = "fused_vector";
	  $mode = "V2DI";
	  $pred = "altivec_register_operand";
	  $constraint = "v";
      } else {
	  $vchr = "";
	  $op = "add";
	  $type = "fused_arith_logical";
	  $mode = "GPR";
	  $pred = "gpc_reg_operand";
	  $constraint = "r";
      }
    my $c4 = "${constraint},${constraint},${constraint},${constraint}";
    print <<"EOF";

;; ${op}-${op} fusion pattern generated by gen_addadd
(define_insn "*fuse_${op}_${op}"
  [(set (match_operand:${mode} 3 "${pred}" "=&0,&1,&${constraint},${constraint}")
        (plus:${mode}
           (plus:${mode} (match_operand:${mode} 0 "${pred}" "${c4}")
                     (match_operand:${mode} 1 "${pred}" "%${c4}"))
           (match_operand:${mode} 2 "${pred}" "${c4}")))
   (clobber (match_scratch:${mode} 4 "=X,X,X,&${constraint}"))]
  "(TARGET_P10_FUSION)"
  "@
   ${op} %3,%1,%0\\;${op} %3,%3,%2
   ${op} %3,%1,%0\\;${op} %3,%3,%2
   ${op} %3,%1,%0\\;${op} %3,%3,%2
   ${op} %4,%1,%0\\;${op} %3,%4,%2"
  [(set_attr "type" "${type}")
   (set_attr "cost" "6")
   (set_attr "length" "8")])
EOF
  }
}

gen_ld_cmpi_p10();
gen_logical_addsubf();
gen_addadd;

exit(0);

