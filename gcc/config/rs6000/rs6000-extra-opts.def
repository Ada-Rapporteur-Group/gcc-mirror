/* Definitions of target machine for GNU compiler, for IBM RS/6000.
   Copyright (C) 2018 Free Software Foundation, Inc.
   Contributed by Michael Meissner <meissner@linux.vnet.ibm.com>

   This file is part of GCC.

   GCC is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published
   by the Free Software Foundation; either version 3, or (at your
   option) any later version.

   GCC is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   Under Section 7 of GPL version 3, you are granted additional
   permissions described in the GCC Runtime Library Exception, version
   3.1, as published by the Free Software Foundation.

   You should have received a copy of the GNU General Public License and
   a copy of the GCC Runtime Library Exception along with this program;
   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
   <http://www.gnu.org/licenses/>.  */

/*
 * This file provides options that are defined in terms of other options.  It
 * creates an array of booleans.  In the option handling function in rs6000.c,
 * these booleans are set based on the normal options.
 */

#ifndef EXTRA_OPTS_OPTION
#error "EXTRA_OPTS_OPTION must be defined."
#endif

/* Whether the LDBRX instruction can be generated.  */
EXTRA_OPTS_OPTION(EXTRA_OPTS_LDBRX,
		  TARGET_POPCNTD || rs6000_cpu == PROCESSOR_CELL)

#define TARGET_LDBRX	rs6000_extra_opts (EXTRA_OPTS_LDBRX)

/* ISA 2.01 allowed FCFID to be done in 32-bit, previously it was 64-bit only.
   Enable 32-bit fcfid's on any of the switches for newer ISA machines or
   XILINX.  */
EXTRA_OPTS_OPTION(EXTRA_OPTS_FCFID,
		  TARGET_POWERPC64
		  || TARGET_PPC_GPOPT		/* 970/power4 */
		  || TARGET_POPCNTB		/* ISA 2.02 */
		  || TARGET_CMPB		/* ISA 2.05 */
		  || TARGET_POPCNTD		/* ISA 2.06 */
		  || TARGET_XILINX_FPU)

#define TARGET_FCFID	rs6000_extra_opts (EXTRA_OPTS_FCFID)
#define TARGET_FCTIDZ	TARGET_FCFID

/* Simple redefinitions of existing target switches to support specific
   instructions.  */
#define TARGET_STFIWX		TARGET_PPC_GFXOPT	/* power6.  */
#define TARGET_LFIWAX		TARGET_CMPB		/* power6.  */
#define TARGET_LFIWZX		TARGET_POPCNTD		/* power7.  */
#define TARGET_FCFIDS		TARGET_POPCNTD		/* power7.  */
#define TARGET_FCFIDU		TARGET_POPCNTD		/* power7.  */
#define TARGET_FCFIDUS		TARGET_POPCNTD		/* power7.  */
#define TARGET_FCTIDUZ		TARGET_POPCNTD		/* power7.  */
#define TARGET_FCTIWUZ		TARGET_POPCNTD		/* power7.  */
#define TARGET_XSCVDPSPN	TARGET_P8_VECTOR	/* power8 vector.  */
#define TARGET_XSCVSPDPN	TARGET_P8_VECTOR	/* power8 vector.  */
#define TARGET_CTZ		TARGET_MODULO		/* power9 GPR.  */

/* Whether we can generate ISA 3.0 (power9) GPR instructions in 64-bit
   mode.  */
EXTRA_OPTS_OPTION(EXTRA_OPTS_P9_GPR_64BIT,
		  TARGET_MODULO && TARGET_POWERPC64)

#define TARGET_P9_GPR_64BIT rs6000_extra_opts (EXTRA_OPTS_P9_GPR_64BIT)

#define TARGET_EXTSWSLI	TARGET_P9_GPR_64BIT
#define TARGET_MADDLD	TARGET_P9_GPR_64BIT

/* Whether we can generate ISA 2.07 (power8) vector instructions in 64-bit
   mode.  */
EXTRA_OPTS_OPTION(EXTRA_OPTS_P8_VECTOR_64BIT,
		  TARGET_P8_VECTOR && TARGET_POWERPC64)

#define TARET_P8_VECTOR_64BIT	rs6000_extra_opts (EXTRA_OPTS_P8_VECTOR_64BIT)
#define TARGET_VADDUQM		rs6000_extra_opts (EXTRA_OPTS_P8_VECTOR_64BIT)

/* Whether we can geneate 1 instruction to move 64-bit values from GPRs to a
   single vector and 2 isntructions to move one vector regsiter to 2 GPRs.  */
EXTRA_OPTS_OPTION(EXTRA_OPTS_DIRECT_MOVE_128,
		  TARGET_P9_VECTOR
		  && TARGET_DIRECT_MOVE
		  && TARGET_POWERPC64)

#define TARGET_DIRECT_MOVE_128	rs6000_extra_opts (EXTRA_OPTS_DIRECT_MOVE_128)
#define TARGET_VEXTRACTUB	rs6000_extra_opts (EXTRA_OPTS_DIRECT_MOVE_128)

/* Macro to say whether we can do optimizations where we need to do parts of
   the calculation in 64-bit GPRs and then is transfered to the vector
   registers.  Do not allow -maltivec=be for these optimizations, because it
   adds to the complexity of the code.  */
EXTRA_OPTS_OPTION(EXTRA_OPTS_DIRECT_MOVE_64BIT,
		  TARGET_DIRECT_MOVE
		  && TARGET_P8_VECTOR
		  && TARGET_POWERPC64
		  && (rs6000_altivec_element_order != 2))

#define TARGET_DIRECT_MOVE_64BIT rs6000_extra_opts (EXTRA_OPTS_DIRECT_MOVE_64BIT)

/* Whether we should avoid (SUBREG:SI (REG:SF) and (SUBREG:SF (REG:SI).  */
#define TARGET_NO_SF_SUBREG	TARGET_DIRECT_MOVE_64BIT
#define TARGET_ALLOW_SF_SUBREG	(!TARGET_DIRECT_MOVE_64BIT)

/* This wants to be set for p8 and newer.  On p7, overlapping unaligned
   loads are slow. */
#define TARGET_EFFICIENT_OVERLAPPING_UNALIGNED TARGET_EFFICIENT_UNALIGNED_VSX

/* Byte/char syncs were added as phased in for ISA 2.06B, but are not present
   in power7, so conditionalize them on p8 features.  TImode syncs need quad
   memory support.  */
EXTRA_OPTS_OPTION(EXTRA_OPTS_SYNC_HI_QI,
		  TARGET_QUAD_MEMORY
		  || TARGET_QUAD_MEMORY_ATOMIC
		  || TARGET_DIRECT_MOVE)

#define TARGET_SYNC_HI_QI	rs6000_extra_opts (EXTRA_OPTS_SYNC_HI_QI)
#define TARGET_SYNC_TI		TARGET_QUAD_MEMORY_ATOMIC

/* Power7 has both 32-bit load and store integer for the FPRs, so we don't need
   to allocate the SDmode stack slot to get the value into the proper location
   in the register.  */
EXTRA_OPTS_OPTION(EXTRA_OPTS_NO_SDMODE_STACK,
		  TARGET_LFIWZX
		  && TARGET_STFIWX
		  && TARGET_DFP)

#define TARGET_NO_SDMODE_STACK	rs6000_extra_opts (EXTRA_OPTS_NO_SDMODE_STACK)

/* ISA 3.0 has new min/max functions that don't need fast math that are being
   phased in.  Min/max using FSEL or XSMAXDP/XSMINDP do not return the correct
   answers if the arguments are not in the normal range.  */
EXTRA_OPTS_OPTION(EXTRA_OPTS_MINMAX_SF,
		  TARGET_SF_FPR && TARGET_PPC_GFXOPT
		  && (TARGET_P9_MINMAX || !flag_trapping_math))

EXTRA_OPTS_OPTION(EXTRA_OPTS_MINMAX_DF,
		  TARGET_DF_FPR && TARGET_PPC_GFXOPT
		  && (TARGET_P9_MINMAX || !flag_trapping_math))

#define TARGET_MINMAX_SF	rs6000_extra_opts (EXTRA_OPTS_MINMAX_SF)
#define TARGET_MINMAX_DF	rs6000_extra_opts (EXTRA_OPTS_MINMAX_DF)

/* For power systems, we want to enable Altivec and VSX builtins even if the
   user did not use -maltivec or -mvsx to allow the builtins to be used inside
   of #pragma GCC target or the target attribute to change the code level for a
   given system.  The Paired builtins are only enabled if you configure the
   compiler for those builtins, and those machines don't support altivec or
   VSX.  */
EXTRA_OPTS_OPTION(EXTRA_OPTS_EXTRA_BUILTINS,
		  !TARGET_PAIRED_FLOAT
		  && ((TARGET_POWERPC64
		       || TARGET_PPC_GPOPT	/* 970/power4 */
		       || TARGET_POPCNTB	/* ISA 2.02 */
		       || TARGET_CMPB		/* ISA 2.05 */
		       || TARGET_POPCNTD	/* ISA 2.06 */
		       || TARGET_ALTIVEC
		       || TARGET_VSX
		       || TARGET_HARD_FLOAT)))

#define TARGET_EXTRA_BUILTINS	rs6000_extra_opts (EXTRA_OPTS_EXTRA_BUILTINS)

/* E500 cores only support plain "sync", not lwsync.  */
EXTRA_OPTS_OPTION(EXTRA_OPTS_NO_LWSYNC,
		  rs6000_cpu == PROCESSOR_PPC8540
		  || rs6000_cpu == PROCESSOR_PPC8548)

#define TARGET_NO_LWSYNC	rs6000_extra_opts (EXTRA_OPTS_NO_LWSYNC)

/* Whether SF/DF operations are supported by the normal floating point unit
   (or the vector/scalar unit).  */
EXTRA_OPTS_OPTION(EXTRA_OPTS_SF_FPR, TARGET_HARD_FLOAT && TARGET_SINGLE_FLOAT)
EXTRA_OPTS_OPTION(EXTRA_OPTS_DF_FPR, TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT)

#define TARGET_SF_FPR		rs6000_extra_opts (EXTRA_OPTS_SF_FPR)
#define TARGET_DF_FPR		rs6000_extra_opts (EXTRA_OPTS_DF_FPR)

/* Whether SF/DF operations are supported by any hardware.  */
#define TARGET_SF_INSN		TARGET_SF_FPR
#define TARGET_DF_INSN		TARGET_DF_FPR

/* Whether SF/DF operations are supported by the normal floating point unit (or
   the vector/scalar unit) on 64-bit or 32-bit specific systems.  */
EXTRA_OPTS_OPTION(EXTRA_OPTS_SF_FPR_64BIT,
		  TARGET_HARD_FLOAT
		  && TARGET_SINGLE_FLOAT
		  && TARGET_POWERPC64)

EXTRA_OPTS_OPTION(EXTRA_OPTS_DF_FPR_64BIT,
		  TARGET_HARD_FLOAT
		  && TARGET_DOUBLE_FLOAT
		  && TARGET_POWERPC64)

EXTRA_OPTS_OPTION(EXTRA_OPTS_SF_FPR_32BIT,
		  TARGET_HARD_FLOAT
		  && TARGET_SINGLE_FLOAT
		  && !TARGET_POWERPC64)

EXTRA_OPTS_OPTION(EXTRA_OPTS_DF_FPR_32BIT,
		  TARGET_HARD_FLOAT
		  && TARGET_DOUBLE_FLOAT
		  && !TARGET_POWERPC64)

#define TARGET_SF_FPR_64BIT	rs6000_extra_opts (EXTRA_OPTS_SF_FPR_64BIT)
#define TARGET_DF_FPR_64BIT	rs6000_extra_opts (EXTRA_OPTS_DF_FPR_64BIT)

#define TARGET_SF_FPR_32BIT	rs6000_extra_opts (EXTRA_OPTS_SF_FPR_32BIT)
#define TARGET_DF_FPR_32BIT	rs6000_extra_opts (EXTRA_OPTS_DF_FPR_32BIT)

/* Whether SF/DF operations are supported by the normal floating point unit (or
   the vector/scalar unit) and NaNs are allowed or disallowed.  */
EXTRA_OPTS_OPTION(EXTRA_OPTS_SF_FPR_NAN,
		  TARGET_HARD_FLOAT
		  && TARGET_SINGLE_FLOAT
		  && HONOR_SNANS (SFmode))

EXTRA_OPTS_OPTION(EXTRA_OPTS_DF_FPR_NAN,
		  TARGET_HARD_FLOAT
		  && TARGET_DOUBLE_FLOAT
		  && HONOR_SNANS (DFmode))

EXTRA_OPTS_OPTION(EXTRA_OPTS_SF_FPR_NO_NAN,
		  TARGET_HARD_FLOAT
		  && TARGET_SINGLE_FLOAT
		  && !HONOR_SNANS (SFmode))

EXTRA_OPTS_OPTION(EXTRA_OPTS_DF_FPR_NO_NAN,
		  TARGET_HARD_FLOAT
		  && TARGET_DOUBLE_FLOAT
		  && !HONOR_SNANS (DFmode))

#define TARGET_SF_FPR_NAN	rs6000_extra_opts (EXTRA_OPTS_SF_FPR_NAN)
#define TARGET_DF_FPR_NAN	rs6000_extra_opts (EXTRA_OPTS_DF_FPR_NAN)

#define TARGET_SF_FPR_NO_NAN	rs6000_extra_opts (EXTRA_OPTS_SF_FPR_NO_NAN)
#define TARGET_DF_FPR_NO_NAN	rs6000_extra_opts (EXTRA_OPTS_DF_FPR_NO_NAN)

/* Whether SF/DF operations are supported by the normal floating point unit (or
   the vector/scalar unit) on 64-bit systems and the update instructions are
   allowed.  */
EXTRA_OPTS_OPTION(EXTRA_OPTS_SF_FPR_UPDATE,
		  TARGET_HARD_FLOAT
		  && TARGET_SINGLE_FLOAT
		  && TARGET_UPDATE)

EXTRA_OPTS_OPTION(EXTRA_OPTS_DF_FPR_UPDATE,
		  TARGET_HARD_FLOAT
		  && TARGET_DOUBLE_FLOAT
		  && TARGET_UPDATE)

#define TARGET_SF_FPR_UPDATE	rs6000_extra_opts (EXTRA_OPTS_SF_FPR_UPDATE)
#define TARGET_DF_FPR_UPDATE	rs6000_extra_opts (EXTRA_OPTS_DF_FPR_UPDATE)

/* Whether long double 128 (either IBM extended double or IEEE 128) are done on
   machines with hardware support.  */
EXTRA_OPTS_OPTION(EXTRA_OPTS_128BIT_FPR,
		  TARGET_HARD_FLOAT
		  && TARGET_LONG_DOUBLE_128)

#define TARGET_128BIT_FPR	rs6000_extra_opts (EXTRA_OPTS_128BIT_FPR)

/* Whether IF/TF/KFmode is IBM extended double or IEEE 128-bit.  We define
   TARGET_IF_IEEE128 and TARGET_KF_IBM128 to be 0 to allow their use in
   generator patterns that take all 3 128-bit floating point types.  */
EXTRA_OPTS_OPTION(EXTRA_OPTS_KF_IEEE128,
		  TARGET_HARD_FLOAT
		  && TARGET_LONG_DOUBLE_128
		  && TARGET_FLOAT128_TYPE)

EXTRA_OPTS_OPTION(EXTRA_OPTS_TF_IEEE128,
		  TARGET_HARD_FLOAT
		  && TARGET_LONG_DOUBLE_128
		  && TARGET_IEEEQUAD)

EXTRA_OPTS_OPTION(EXTRA_OPTS_KF_IEEE128_HW,
		  TARGET_HARD_FLOAT
		  && TARGET_LONG_DOUBLE_128
		  && TARGET_FLOAT128_TYPE
		  && TARGET_FLOAT128_HW)

EXTRA_OPTS_OPTION(EXTRA_OPTS_TF_IEEE128_HW,
		  TARGET_HARD_FLOAT
		  && TARGET_LONG_DOUBLE_128
		  && TARGET_IEEEQUAD
		  && TARGET_FLOAT128_HW)

EXTRA_OPTS_OPTION(EXTRA_OPTS_KF_IEEE128_SW,
		  TARGET_HARD_FLOAT
		  && TARGET_LONG_DOUBLE_128
		  && TARGET_FLOAT128_TYPE
		  && !TARGET_FLOAT128_HW)

EXTRA_OPTS_OPTION(EXTRA_OPTS_TF_IEEE128_SW,
		  TARGET_HARD_FLOAT
		  && TARGET_LONG_DOUBLE_128
		  && TARGET_IEEEQUAD
		  && !TARGET_FLOAT128_HW)

EXTRA_OPTS_OPTION(EXTRA_OPTS_IF_IBM128,
		  TARGET_HARD_FLOAT
		  && TARGET_LONG_DOUBLE_128)

EXTRA_OPTS_OPTION(EXTRA_OPTS_TF_IBM128,
		  TARGET_HARD_FLOAT
		  && TARGET_LONG_DOUBLE_128
		  && !TARGET_IEEEQUAD)

#define TARGET_IF_IEEE128	0
#define TARGET_KF_IEEE128	rs6000_extra_opts (EXTRA_OPTS_KF_IEEE128)
#define TARGET_TF_IEEE128	rs6000_extra_opts (EXTRA_OPTS_TF_IEEE128)

#define TARGET_IF_IEEE128_HW	0
#define TARGET_KF_IEEE128_HW	rs6000_extra_opts (EXTRA_OPTS_KF_IEEE128_HW)
#define TARGET_TF_IEEE128_HW	rs6000_extra_opts (EXTRA_OPTS_TF_IEEE128_HW)

#define TARGET_IF_IEEE128_SW	0
#define TARGET_KF_IEEE128_SW	rs6000_extra_opts (EXTRA_OPTS_KF_IEEE128_SW)
#define TARGET_TF_IEEE128_SW	rs6000_extra_opts (EXTRA_OPTS_TF_IEEE128_SW)

#define TARGET_IF_IBM128	rs6000_extra_opts (EXTRA_OPTS_IF_IBM128)
#define TARGET_KF_IBM128	0
#define TARGET_TF_IBM128	rs6000_extra_opts (EXTRA_OPTS_TF_IBM128)

/* Which machine supports the various reciprocal estimate instructions.  */
EXTRA_OPTS_OPTION(EXTRA_OPTS_FRES,
		  TARGET_HARD_FLOAT
		  && TARGET_PPC_GFXOPT
		  && TARGET_SINGLE_FLOAT)

EXTRA_OPTS_OPTION(EXTRA_OPTS_FRE,
		  TARGET_HARD_FLOAT
		  && TARGET_DOUBLE_FLOAT 
		  && TARGET_POPCNTB)

EXTRA_OPTS_OPTION(EXTRA_OPTS_FRSQRTES,
		  TARGET_HARD_FLOAT
		  && TARGET_POPCNTB
		  && TARGET_PPC_GFXOPT
		  && TARGET_SINGLE_FLOAT)

EXTRA_OPTS_OPTION(EXTRA_OPTS_FRSQRTE,
		  TARGET_HARD_FLOAT
		  && TARGET_DOUBLE_FLOAT
		  && TARGET_PPC_GFXOPT)

#define TARGET_FRES	rs6000_extra_opts (EXTRA_OPTS_FRES)
#define TARGET_FRE	rs6000_extra_opts (EXTRA_OPTS_FRE)
#define TARGET_FRSQRTES	rs6000_extra_opts (EXTRA_OPTS_FRSQRTES)
#define TARGET_FRSQRTE	rs6000_extra_opts (EXTRA_OPTS_FRSQRTE)

/* Conditions to allow TOC fusion for loading/storing integers.  */
EXTRA_OPTS_OPTION(EXTRA_OPTS_TOC_FUSION_INT,
		  TARGET_P8_FUSION
		  && TARGET_TOC_FUSION
		  && (TARGET_CMODEL != CMODEL_SMALL)
		  && TARGET_POWERPC64)

#define TARGET_TOC_FUSION_INT	rs6000_extra_opts (EXTRA_OPTS_TOC_FUSION_INT)

/* Conditions to allow TOC fusion for loading/storing floating point.  */
EXTRA_OPTS_OPTION(EXTRA_OPTS_TOC_FUSION_FP,
		  TARGET_P9_FUSION
		  && TARGET_TOC_FUSION
		  && (TARGET_CMODEL != CMODEL_SMALL)
		  && TARGET_POWERPC64
		  && TARGET_HARD_FLOAT
		  && TARGET_SINGLE_FLOAT
		  && TARGET_DOUBLE_FLOAT)

#define TARGET_TOC_FUSION_FP	rs6000_extra_opts (EXTRA_OPTS_TOC_FUSION_FP)

