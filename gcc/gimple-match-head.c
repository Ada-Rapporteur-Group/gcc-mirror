/* Preamble and helpers for the autogenerated gimple-match.c file.
   Copyright (C) 2014 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING3.  If not see
<http://www.gnu.org/licenses/>.  */

#include "config.h"
#include "system.h"
#include "coretypes.h"
#include "tree.h"
#include "stringpool.h"
#include "stor-layout.h"
#include "flags.h"
#include "function.h"
#include "basic-block.h"
#include "tree-ssa-alias.h"
#include "internal-fn.h"
#include "gimple-expr.h"
#include "is-a.h"
#include "gimple.h"
#include "gimple-ssa.h"
#include "tree-ssanames.h"
#include "gimple-fold.h"
#include "gimple-iterator.h"

#define INTEGER_CST_P(node) (TREE_CODE(node) == INTEGER_CST)
#define integral_op_p(node) INTEGRAL_TYPE_P(TREE_TYPE(node))
#define REAL_CST_P(node) (TREE_CODE(node) == REAL_CST)


/* Helper to transparently allow tree codes and builtin function codes
   exist in one storage entity.  */
class code_helper
{
public:
  code_helper () {}
  code_helper (tree_code code) : rep ((int) code) {}
  code_helper (built_in_function fn) : rep (-(int) fn) {}
  operator tree_code () const { return (tree_code) rep; }
  operator built_in_function () const { return (built_in_function) -rep; }
  bool is_tree_code () const { return rep > 0; }
  bool is_fn_code () const { return rep < 0; }
private:
  int rep;
};

/* Forward declarations of the private auto-generated matchers.  */
static bool gimple_match_and_simplify (code_helper, tree, tree,
				       code_helper *, tree *,
				       gimple_seq *, tree (*)(tree));
static bool gimple_match_and_simplify (code_helper, tree, tree, tree,
				       code_helper *, tree *,
				       gimple_seq *, tree (*)(tree));
static bool gimple_match_and_simplify (code_helper, tree, tree, tree, tree,
				       code_helper *, tree *,
				       gimple_seq *, tree (*)(tree));


/* Helper that matches and simplifies the toplevel result from
   a gimple_match_and_simplify run (where we don't want to build
   a stmt in case it's used in in-place folding).  Replaces
   *RES_CODE and *RES_OPS with a simplified and/or canonicalized
   result.  */

static void
gimple_resimplify1 (gimple_seq *seq,
		    code_helper *res_code, tree type, tree *res_ops,
		    tree (*valueize)(tree))
{
  if (CONSTANT_CLASS_P (res_ops[0]))
    {
      tree tem;
      if (res_code->is_tree_code ())
	tem = fold_unary_to_constant (*res_code, type, res_ops[0]);
      else
	{
	  tree decl = builtin_decl_implicit (*res_code);
	  tem = fold_builtin_n (UNKNOWN_LOCATION, decl, res_ops, 1, false);
	}
      if (tem != NULL_TREE
	  && CONSTANT_CLASS_P (tem))
	{
	  res_ops[0] = tem;
	  *res_code = TREE_CODE (res_ops[0]);
	  return;
	}
    }

  code_helper res_code2;
  tree res_ops2[3] = {};
  if (gimple_match_and_simplify (*res_code, type, res_ops[0],
				 &res_code2, res_ops2, seq, valueize))
    {
      *res_code = res_code2;
      res_ops[0] = res_ops2[0];
      res_ops[1] = res_ops2[1];
      res_ops[2] = res_ops2[2];
    }
}

/* Helper that matches and simplifies the toplevel result from
   a gimple_match_and_simplify run (where we don't want to build
   a stmt in case it's used in in-place folding).  Replaces
   *RES_CODE and *RES_OPS with a simplified and/or canonicalized
   result.  */

static void
gimple_resimplify2 (gimple_seq *seq,
		    code_helper *res_code, tree type, tree *res_ops,
		    tree (*valueize)(tree))
{
  if (CONSTANT_CLASS_P (res_ops[0]) && CONSTANT_CLASS_P (res_ops[1]))
    {
      tree tem;
      if (res_code->is_tree_code ())
	tem = fold_binary_to_constant (*res_code, type,
				       res_ops[0], res_ops[1]);
      else
	{
	  tree decl = builtin_decl_implicit (*res_code);
	  tem = fold_builtin_n (UNKNOWN_LOCATION, decl, res_ops, 2, false);
	}
      if (tem != NULL_TREE)
	{
	  res_ops[0] = tem;
	  *res_code = TREE_CODE (res_ops[0]);
	  return;
	}
    }

  /* Canonicalize operand order.  */
  if (res_code->is_tree_code ()
      && commutative_tree_code (*res_code)
      && tree_swap_operands_p (res_ops[0], res_ops[1], false))
    {
      tree tem = res_ops[0];
      res_ops[0] = res_ops[1];
      res_ops[1]= tem;
    }

  code_helper res_code2;
  tree res_ops2[3] = {};
  if (gimple_match_and_simplify (*res_code, type, res_ops[0], res_ops[1],
				 &res_code2, res_ops2, seq, valueize))
    {
      *res_code = res_code2;
      res_ops[0] = res_ops2[0];
      res_ops[1] = res_ops2[1];
      res_ops[2] = res_ops2[2];
    }
}

/* Helper that matches and simplifies the toplevel result from
   a gimple_match_and_simplify run (where we don't want to build
   a stmt in case it's used in in-place folding).  Replaces
   *RES_CODE and *RES_OPS with a simplified and/or canonicalized
   result.  */

static void
gimple_resimplify3 (gimple_seq *seq,
		    code_helper *res_code, tree type, tree *res_ops,
		    tree (*valueize)(tree))
{
  if (CONSTANT_CLASS_P (res_ops[0]) && CONSTANT_CLASS_P (res_ops[1])
      && CONSTANT_CLASS_P (res_ops[2]))
    {
      tree tem;
      if (res_code->is_tree_code ())
	tem = fold_ternary/*_to_constant*/ (*res_code, type, res_ops[0],
					    res_ops[1], res_ops[2]);
      else
	{
	  tree decl = builtin_decl_implicit (*res_code);
	  tem = fold_builtin_n (UNKNOWN_LOCATION, decl, res_ops, 3, false);
	}
      if (tem != NULL_TREE
	  && CONSTANT_CLASS_P (tem))
	{
	  res_ops[0] = tem;
	  *res_code = TREE_CODE (res_ops[0]);
	  return;
	}
    }

  /* Canonicalize operand order.  */
  if (res_code->is_tree_code ()
      && commutative_ternary_tree_code (*res_code)
      && tree_swap_operands_p (res_ops[0], res_ops[1], false))
    {
      tree tem = res_ops[0];
      res_ops[0] = res_ops[1];
      res_ops[1]= tem;
    }

  code_helper res_code2;
  tree res_ops2[3] = {};
  if (gimple_match_and_simplify (*res_code, type,
				 res_ops[0], res_ops[1], res_ops[2],
				 &res_code2, res_ops2, seq, valueize))
    {
      *res_code = res_code2;
      res_ops[0] = res_ops2[0];
      res_ops[1] = res_ops2[1];
      res_ops[2] = res_ops2[2];
    }
}


/* Push the exploded expression described by RCODE, TYPE and OPS
   as a statement to SEQ if necessary and return a gimple value
   denoting the value of the expression.  If RES is not NULL
   then the result will be always RES and even gimple values are
   pushed to SEQ.  */

static tree
maybe_push_res_to_seq (code_helper rcode, tree type, tree *ops,
		       gimple_seq *seq, tree res = NULL_TREE)
{
  if (rcode.is_tree_code ())
    {
      if (!res
	  && TREE_CODE_LENGTH ((tree_code) rcode) == 0
	  && is_gimple_val (ops[0]))
	return ops[0];
      if (!seq)
	return NULL_TREE;
      if (!res)
	res = make_ssa_name (type, NULL);
      gimple new_stmt = gimple_build_assign_with_ops (rcode, res,
						      ops[0], ops[1], ops[2]);
      gimple_seq_add_stmt_without_update (seq, new_stmt);
      return res;
    }
  else
    {
      if (!seq)
	return NULL_TREE;
      if (!res)
	res = make_ssa_name (type, NULL);
      tree decl = builtin_decl_implicit (rcode);
      unsigned nargs = type_num_arguments (TREE_TYPE (decl));
      gcc_assert (nargs <= 3);
      gimple new_stmt = gimple_build_call (decl, nargs, ops[0], ops[1], ops[2]);
      gimple_call_set_lhs (new_stmt, res);
      gimple_seq_add_stmt_without_update (seq, new_stmt);
      return res;
    }
}

tree
gimple_match_and_simplify (enum tree_code code, tree type,
			   tree op0,
			   gimple_seq *seq, tree (*valueize)(tree))
{
  if (CONSTANT_CLASS_P (op0))
    {
      tree res = fold_unary_to_constant (code, type, op0);
      if (res != NULL_TREE)
	return res;
    }

  code_helper rcode;
  tree ops[3] = {};
  if (!gimple_match_and_simplify (code, type, op0,
				  &rcode, ops, seq, valueize))
    return NULL_TREE;
  return maybe_push_res_to_seq (rcode, type, ops, seq);
}

tree
gimple_match_and_simplify (enum tree_code code, tree type,
			   tree op0, tree op1,
			   gimple_seq *seq, tree (*valueize)(tree))
{
  if (CONSTANT_CLASS_P (op0) && CONSTANT_CLASS_P (op1))
    {
      tree res = fold_binary_to_constant (code, type, op0, op1);
      /* ???  We can't assert that we fold this to a constant as
	 for example we can't fold things like 1 / 0.  */
      if (res != NULL_TREE)
	return res;
    }

  /* Canonicalize operand order both for matching and fallback stmt
     generation.  */
  if (commutative_tree_code (code)
      && tree_swap_operands_p (op0, op1, false))
    {
      tree tem = op0;
      op0 = op1;
      op1 = tem;
    }

  code_helper rcode;
  tree ops[3] = {};
  if (!gimple_match_and_simplify (code, type, op0, op1,
				  &rcode, ops, seq, valueize))
    return NULL_TREE;
  return maybe_push_res_to_seq (rcode, type, ops, seq);
}

tree
gimple_match_and_simplify (enum tree_code code, tree type,
			   tree op0, tree op1, tree op2,
			   gimple_seq *seq, tree (*valueize)(tree))
{
  if (CONSTANT_CLASS_P (op0) && CONSTANT_CLASS_P (op1)
      && CONSTANT_CLASS_P (op2))
    {
      tree res = fold_ternary/*_to_constant */ (code, type, op0, op1, op2);
      if (res != NULL_TREE
	  && CONSTANT_CLASS_P (res))
	return res;
    }

  /* Canonicalize operand order both for matching and fallback stmt
     generation.  */
  if (commutative_ternary_tree_code (code)
      && tree_swap_operands_p (op0, op1, false))
    {
      tree tem = op0;
      op0 = op1;
      op1 = tem;
    }

  code_helper rcode;
  tree ops[3] = {};
  if (!gimple_match_and_simplify (code, type, op0, op1, op2,
				  &rcode, ops, seq, valueize))
    return NULL_TREE;
  return maybe_push_res_to_seq (rcode, type, ops, seq);
}

tree
gimple_match_and_simplify (enum built_in_function fn, tree type,
			   tree arg0,
			   gimple_seq *seq, tree (*valueize)(tree))
{
  if (CONSTANT_CLASS_P (arg0))
    {
      tree decl = builtin_decl_implicit (fn);
      tree res = fold_builtin_n (UNKNOWN_LOCATION, decl, &arg0, 1, false);
      if (res != NULL_TREE
	  && CONSTANT_CLASS_P (res))
	return res;
    }

  code_helper rcode;
  tree ops[3] = {};
  if (!gimple_match_and_simplify (fn, type, arg0,
				  &rcode, ops, seq, valueize))
    return NULL_TREE;
  return maybe_push_res_to_seq (rcode, type, ops, seq);
}

static bool
gimple_match_and_simplify (gimple stmt,
			   code_helper *rcode, tree *ops,
			   gimple_seq *seq, tree (*valueize)(tree))
{
  if (is_gimple_assign (stmt))
    {
      enum tree_code code = gimple_assign_rhs_code (stmt);
      tree type = TREE_TYPE (gimple_assign_lhs (stmt));
      switch (gimple_assign_rhs_class (stmt))
	{
	case GIMPLE_SINGLE_RHS:
	  if (code == REALPART_EXPR
	      || code == IMAGPART_EXPR
	      || code == VIEW_CONVERT_EXPR)
	    {
	      tree op0 = TREE_OPERAND (gimple_assign_rhs1 (stmt), 0);
	      if (valueize && TREE_CODE (op0) == SSA_NAME)
		{
		  op0 = valueize (op0);
		  if (!op0)
		    return false;
		}
	      return gimple_match_and_simplify (code, type, op0,
						rcode, ops,
						seq, valueize);
	    }
	  else if (code == BIT_FIELD_REF)
	    {
	      tree rhs1 = gimple_assign_rhs1 (stmt);
	      tree op0 = TREE_OPERAND (rhs1, 0);
	      if (valueize && TREE_CODE (op0) == SSA_NAME)
		{
		  op0 = valueize (op0);
		  if (!op0)
		    return false;
		}
	      return gimple_match_and_simplify (code, type, op0,
						TREE_OPERAND (rhs1, 1),
						TREE_OPERAND (rhs1, 2),
						rcode, ops,
						seq, valueize);
	    }
	  break;
	case GIMPLE_UNARY_RHS:
	  {
	    tree rhs1 = gimple_assign_rhs1 (stmt);
	    if (valueize && TREE_CODE (rhs1) == SSA_NAME)
	      {
		rhs1 = valueize (rhs1);
		if (!rhs1)
		  return false;
	      }
	    return gimple_match_and_simplify (code, type, rhs1,
					      rcode, ops,
					      seq, valueize);
	  }
	case GIMPLE_BINARY_RHS:
	  {
	    tree rhs1 = gimple_assign_rhs1 (stmt);
	    if (valueize && TREE_CODE (rhs1) == SSA_NAME)
	      {
		rhs1 = valueize (rhs1);
		if (!rhs1)
		  return false;
	      }
	    tree rhs2 = gimple_assign_rhs2 (stmt);
	    if (valueize && TREE_CODE (rhs2) == SSA_NAME)
	      {
		rhs2 = valueize (rhs2);
		if (!rhs2)
		  return false;
	      }
	    return gimple_match_and_simplify (code, type, rhs1, rhs2,
					      rcode, ops,
					      seq, valueize);
	  }
	case GIMPLE_TERNARY_RHS:
	  {
	    tree rhs1 = gimple_assign_rhs1 (stmt);
	    if (valueize && TREE_CODE (rhs1) == SSA_NAME)
	      {
		rhs1 = valueize (rhs1);
		if (!rhs1)
		  return false;
	      }
	    tree rhs2 = gimple_assign_rhs2 (stmt);
	    if (valueize && TREE_CODE (rhs2) == SSA_NAME)
	      {
		rhs2 = valueize (rhs2);
		if (!rhs2)
		  return false;
	      }
	    tree rhs3 = gimple_assign_rhs3 (stmt);
	    if (valueize && TREE_CODE (rhs3) == SSA_NAME)
	      {
		rhs3 = valueize (rhs3);
		if (!rhs3)
		  return false;
	      }
	    return gimple_match_and_simplify (code, type, rhs1, rhs2, rhs3,
					      rcode, ops,
					      seq, valueize);
	  }
	default:
	  gcc_unreachable ();
	}
    }
  else if (is_gimple_call (stmt)
	   && gimple_call_builtin_p (stmt, BUILT_IN_NORMAL)
	   && gimple_call_lhs (stmt) != NULL_TREE)
    {
      tree decl = gimple_call_fndecl (stmt);
      tree type = TREE_TYPE (gimple_call_lhs (stmt));
      switch (gimple_call_num_args (stmt))
	{
	case 1:
	  {
	    tree arg1 = gimple_call_arg (stmt, 0);
	    if (valueize && TREE_CODE (arg1) == SSA_NAME)
	      {
		arg1 = valueize (arg1);
		if (!arg1)
		  return false;
	      }
	    return gimple_match_and_simplify (DECL_FUNCTION_CODE (decl),
					      type, arg1,
					      rcode, ops,
					      seq, valueize);
	  }
	case 2:
	  {
	    tree arg1 = gimple_call_arg (stmt, 0);
	    if (valueize && TREE_CODE (arg1) == SSA_NAME)
	      {
		arg1 = valueize (arg1);
		if (!arg1)
		  return false;
	      }
	    tree arg2 = gimple_call_arg (stmt, 0);
	    if (valueize && TREE_CODE (arg2) == SSA_NAME)
	      {
		arg2 = valueize (arg2);
		if (!arg2)
		  return false;
	      }
	    return gimple_match_and_simplify (DECL_FUNCTION_CODE (decl),
					      type, arg1, arg2,
					      rcode, ops,
					      seq, valueize);
	  }
	default:
	  return false;
	}
    }

  return false;
}


/* Match and simplify on the defining statement of NAME using VALUEIZE
   if not NULL to valueize SSA names in expressions.  NAME is expected
   to be valueized already.  Appends statements for complex expression
   results to SEQ or fails if that would be required and SEQ is NULL.
   Returns the simplified value (which might be defined by stmts in
   SEQ) or NULL_TREE if no simplification was possible.  */

tree
gimple_match_and_simplify (tree name, gimple_seq *seq, tree (*valueize)(tree))
{
  if (TREE_CODE (name) != SSA_NAME)
    return NULL_TREE;

  gimple stmt = SSA_NAME_DEF_STMT (name);
  code_helper rcode;
  tree ops[3] = {};
  if (!gimple_match_and_simplify (stmt, &rcode, ops, seq, valueize))
    return NULL_TREE;
  return maybe_push_res_to_seq (rcode, TREE_TYPE (name), ops, seq);
}

/* Match and simplify on *GSI and replace that with the simplified stmt
   sequence.  */

bool
gimple_match_and_simplify (gimple_stmt_iterator *gsi, tree (*valueize)(tree))
{
  gimple stmt = gsi_stmt (*gsi);
  gimple_seq seq = NULL;
  code_helper rcode;
  tree ops[3] = {};
  if (!gimple_match_and_simplify (stmt, &rcode, ops, &seq, valueize))
    return false;

  if (is_gimple_assign (stmt)
      && rcode.is_tree_code ())
    {
      gimple_assign_set_rhs_with_ops_1 (gsi, rcode, ops[0], ops[1], ops[2]);
      update_stmt (gsi_stmt (*gsi));
    }
  else if (gimple_has_lhs (stmt))
    {
      gimple_seq tail = NULL;
      tree lhs = gimple_get_lhs (stmt);
      maybe_push_res_to_seq (rcode, TREE_TYPE (lhs),
			     ops, &tail, lhs);
      gcc_assert (gimple_seq_singleton_p (tail));
      gimple with = gimple_seq_first_stmt (tail);
      gimple_set_vdef (with, gimple_vdef (stmt));
      gimple_set_vuse (with, gimple_vuse (stmt));
      gsi_replace (gsi, with, false);
    }
  else
    /* Handle for example GIMPLE_COND, etc.  */
    gcc_unreachable ();

  gsi_insert_seq_before (gsi, seq, GSI_SAME_STMT);
  return true;
}

