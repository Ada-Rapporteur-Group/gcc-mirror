/* match-and-simplify patterns for simplify_bitwise_binary
   Copyright (C) 2014 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING3.  If not see
<http://www.gnu.org/licenses/>.  */


/* End of known transform origin.  Note that some bitwise transforms
   are handled in match-constant-folding.pd.  */

/* ~x & ~y -> ~(x | y) */
(simplify
  (bit_and (bit_not @0) (bit_not @1))
  (bit_not (bit_ior @0 @1)))

/* ~x | ~y -> ~(x & y) */
(simplify
  (bit_ior (bit_not @0) (bit_not @1))
  (bit_not (bit_and @0 @1)))

/* Simple association cases that cancel one operand.  */

/* ((a OP b) & ~a) -> (b & ~a) OP 0  */
(for bitop (bit_and bit_ior bit_xor)
 (simplify
  (bit_and:c (bitop:c @0 @1) (bit_not@2 @0))
  (bitop (bit_and @1 @2) { build_zero_cst (type); })))

/* From fold-const.c:fold_binary_loc, in order of appearance.  */

/* If we are XORing two BIT_AND_EXPR's, both of which are and'ing
   with a constant, and the two constants have no bits in common,
   we should treat this as a BIT_IOR_EXPR since this may produce more
   simplifications.  */
(simplify
 (bit_xor (bit_and @0 INTEGER_CST@1) (bit_and @2 INTEGER_CST@3))
 (if (wi::bit_and (@1, @3) == 0)
   (bit_ior (bit_and @0 @1) (bit_and @2 @3))))

/* ((a | b) ^ a) -> b & ~a  */
(simplify
 (bit_xor:c (bit_ior:c @0 @1) @0)
 (bit_and @1 (bit_not @0)))

/* Convert ~X ^ ~Y to X ^ Y.  */
(simplify
 (bit_xor (bit_not @0) (bit_not @1))
 (bit_xor @0 @1))

/* Convert ~X ^ C to X ^ ~C.  */
(simplify
 (bit_xor (bit_not @0) INTEGER_CST@1)
 (bit_xor @0 (bit_not @1)))

/* Fold (X & 1) ^ 1 as (X & 1) == 0.  */
/* Questionable on GIMPLE as the equality compare can't have a
   type different from boolean_type_node.  */

/* Fold (X & Y) ^ Y as ~X & Y.  */
(simplify
 (bit_xor:c (bit_and:c @0 @1) @1)
 (bit_and (bit_not @0) @1))


/* PR61559.  Transforms for gcc.dg/builtin-bswap-8.c  */
(for bswap (BUILT_IN_BSWAP16 BUILT_IN_BSWAP32 BUILT_IN_BSWAP64)
  (simplify
    (bswap (bswap @0))
    @0)
  (simplify
    (bswap (bit_not (bswap @0)))
    (bit_not @0))
  (for bitop (bit_xor bit_ior bit_and)
    /* This might not be profitable if the inner bswaps are
       free because @0 and @1 are memory operands and the
       target has an instruction for load+bswap.  */
    (simplify
      (bitop (bswap @0) (bswap @1))
      (bswap (bitop @0 @1)))
    (simplify
      (bswap (bitop:c (bswap @0) @1))
      (bitop @0 (bswap @1)))))

/* Similar transform for vector permute.
   ???  Missing an easy way to check if a mask is a reverse
   operation of another mask (most masks are not reversible).  */
(for bitop (bit_xor bit_ior bit_and)
  (simplify
    (bitop (vec_perm @1 @2 @0) (vec_perm @3 @4 @0))
    (vec_perm (bitop @1 @3) (bitop @2 @4) @0)))

