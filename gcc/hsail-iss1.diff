diff --git a/CMakeLists.txt b/CMakeLists.txt
index 91275e4..d7f8ebc 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -20,11 +20,12 @@ if (IS_X86)
   set(CMAKE_CXX_FLAGS "-msse3 ${CMAKE_CXX_FLAGS}")
 endif(IS_X86)
 
+set(CMAKE_C_FLAGS "-g ${CMAKE_C_FLAGS} -I/usr/include/libdwarf")
+set(CMAKE_CXX_FLAGS "-g ${CMAKE_CXX_FLAGS} -I/usr/include/libdwarf")
 set(CMAKE_C_FLAGS "-std=gnu99 ${CMAKE_C_FLAGS}")
-set(CMAKE_CXX_FLAGS "-DTEST_PATH=${PROJECT_SOURCE_DIR}/test ${CMAKE_CXX_FLAGS}")
-set(CMAKE_CXX_FLAGS "-DBIN_PATH=${PROJECT_BINARY_DIR}/HSAIL-Tools ${CMAKE_CXX_FLAGS}")
-set(CMAKE_CXX_FLAGS "-DOBJ_PATH=${PROJECT_BINARY_DIR}/test ${CMAKE_CXX_FLAGS}")
-set(CMAKE_CXX_FLAGS "-I/usr/include/libdwarf ${CMAKE_CXX_FLAGS}")
+add_definitions(-DTEST_PATH=${PROJECT_SOURCE_DIR}/test)
+add_definitions(-DBIN_PATH=${PROJECT_BINARY_DIR}/HSAIL-Tools)
+add_definitions(-DOBJ_PATH=${PROJECT_BINARY_DIR}/test)
 
 set(CMAKE_CXX_FLAGS_RELEASE "-O3 -UNDEBUG")
 
@@ -171,6 +172,13 @@ set(fib_SOURCES demo/fib.cc)
 add_executable(fib ${fib_SOURCES})
 target_link_libraries(fib hsa brig2llvm)
 
+set(fib-c_SOURCES demo/fib-c.c)
+add_executable(fib-c ${fib-c_SOURCES})
+target_link_libraries(fib-c gcchsa)
+
+add_library(gcchsa SHARED demo/hsa-c.cc)
+target_link_libraries(gcchsa hsa brig2llvm)
+
 set(barrierTest_SOURCES demo/barrierTest.cc)
 add_executable(barrierTest ${barrierTest_SOURCES})
 target_link_libraries(barrierTest hsa brig2llvm)
diff --git a/demo/fib-c.c b/demo/fib-c.c
new file mode 100644
index 0000000..99acb1d
--- /dev/null
+++ b/demo/fib-c.c
@@ -0,0 +1,42 @@
+#include <stdio.h>
+#include "hsa-c.h"
+
+#define STR(X) #X
+#define XSTR(X) STR(X)
+
+int main(int argc, char **argv)
+{
+#if 0
+  if (__hsa_init () < 0)
+    return -1;
+  void * program = __hsa_load_program (XSTR(OBJ_PATH) "/fib.o");
+  if (!program)
+    return -1;
+  void * kernel = __hsa_load_kernel (program, "&fibKernel");
+  if (!kernel)
+    return -1;
+#endif
+
+  printf ("Fib sequence: ");
+
+  int *r = (int *) __hsa_allocate_global_memory (sizeof(int), sizeof(int));
+  if (!r)
+    return -1;
+
+  __hsa_launch_attrs attrs
+    = { 0, {1,1,1}, {1,1,1} };
+  __hsa_kernelarg args[2] = { { r }, { 0 } };
+  __hsa_kernel_desc desc = { XSTR(OBJ_PATH) "/fib.o", "&fibKernel", 2, NULL };
+
+  for (int i = 1; i < 20; ++i) {
+    args[1].s32value = i;
+    __hsa_launch_kernel (&desc, &attrs, args);
+    printf ("%d ", *r);
+  }
+  printf ("\n");
+
+  __hsa_free_global_memory (r);
+
+/*  __hsa_deinit (); */
+  return 0;
+}
diff --git a/demo/hsa-c.cc b/demo/hsa-c.cc
new file mode 100644
index 0000000..32e1d3a
--- /dev/null
+++ b/demo/hsa-c.cc
@@ -0,0 +1,173 @@
+// Header files the HSA runtime implicitly depends on
+#include <cstdio>
+#include <cstdlib>
+#include <cstring>
+
+// The HSA runtime
+#include "hsa.h"
+
+#include "hsa-c.h"
+
+// Use LLVM for portable IO
+#include "llvm/ADT/OwningPtr.h"
+#include "llvm/Support/FileSystem.h"
+#include "llvm/Support/MemoryBuffer.h"
+#include "llvm/Support/raw_ostream.h"
+
+static hsa::RuntimeApi *__hsaRT;
+static uint32_t __hsa_ndevices;
+static hsa::vector<hsa::Device *> __hsa_devices;
+static hsa::vector<hsa::Program *> __hsa_programs;
+static hsa::Queue *__hsa_queue; /* XXX needs to be per device and
+				   perhaps exposed to outside */
+static hsa::Program * __hsa_main_program;
+
+int
+__hsa_init (void)
+{
+  __hsaRT = hsa::getRuntime();
+  if (!__hsaRT) return -1;
+  __hsa_ndevices = __hsaRT->getDeviceCount();
+  if (!__hsa_ndevices) return -1;
+  __hsa_devices = __hsaRT->getDevices();
+  __hsa_queue = __hsa_devices[0]->createQueue (1);
+  if (!__hsa_queue) return -1;
+  return 0;
+}
+
+static int
+__hsa_maybe_init (void)
+{
+  if (__hsa_main_program)
+    return 0;
+  if (!__hsaRT)
+    {
+      int r = __hsa_init ();
+      if (r < 0)
+	return r;
+    }
+  void * main_prog = __hsa_load_program ("/proc/self/exe");
+  if (!main_prog)
+    main_prog = __hsa_load_program ("hsakernel.o");
+  if (!main_prog)
+    __hsa_main_program = (hsa::Program *)-1;
+  else
+    __hsa_main_program = (hsa::Program *)main_prog;
+  return 0;
+}
+
+void
+__hsa_deinit (void)
+{
+  // XXX empty __hsa_programs
+  if (__hsa_queue)
+    delete __hsa_queue;
+  if (__hsaRT)
+    delete __hsaRT;
+}
+
+void *
+__hsa_load_program (const char *fname)
+{
+  // XXX rewrite to fread
+  llvm::OwningPtr<llvm::MemoryBuffer> file;
+  llvm::error_code ec =
+    llvm::MemoryBuffer::getFile(fname, file);
+  if (ec) return NULL;
+  hsa::Program *program =
+    __hsaRT->createProgram(const_cast<char *>(file->getBufferStart()),
+                         file->getBufferSize(),
+                         &__hsa_devices);
+  if (!program) return NULL;
+  // XXX make returned value only an ID (vec index) instead of
+  // same pointer as program itself?
+  __hsa_programs.push_back( program );
+  return program;
+}
+
+void
+__hsa_unload_program (void * _program)
+{
+  hsa::Program *program = (hsa::Program *)_program;
+  delete program;
+}
+
+// XXX merge load_program and compile_kernel (lazily loading
+// program if not yet loaded)
+void *
+__hsa_load_kernel (void * _program, const char *name)
+{
+  hsa::Program *program = (hsa::Program *)_program;
+  hsa::Kernel *kernel = program->compileKernel(name, "");
+  if (!kernel) return NULL;
+  // XXX store kernel somewhere so that it can be deleted
+  // at deinit
+  return kernel;
+}
+
+void
+__hsa_unload_kernel (__hsa_kernel_desc * _kernel)
+{
+  hsa::Kernel *kernel = (hsa::Kernel *)_kernel->kernel;
+  delete kernel;
+  _kernel->kernel = NULL;
+}
+
+void *
+__hsa_launch_kernel (__hsa_kernel_desc * _kd, __hsa_launch_attrs *attrs, __hsa_kernelarg *args)
+{
+  if (!_kd->kernel)
+    {
+      if (__hsa_maybe_init () < 0)
+	return NULL;
+      if (_kd->filename[0] == 0)
+	{
+	  if (__hsa_main_program == (hsa::Program *)-1)
+	    return NULL;
+	  _kd->kernel = __hsa_load_kernel (__hsa_main_program, _kd->name);
+	}
+      else
+	{
+	  void *program = __hsa_load_program (_kd->filename);
+	  if (!program)
+	    return NULL;
+	  _kd->kernel = __hsa_load_kernel (program, _kd->name);
+	}
+      if (!_kd->kernel)
+	return NULL;
+    }
+  hsa::Kernel *kernel = (hsa::Kernel *)_kd->kernel;
+  hsacommon::vector<hsa::Event *> deps;
+  hsa::LaunchAttributes la;
+  static __hsa_launch_attrs default_attrs = { 0, {1,1,1}, {1,1,1} };
+  if (!attrs)
+    attrs = &default_attrs;
+  la.grid[0] = attrs->grid[0];
+  la.grid[1] = attrs->grid[1];
+  la.grid[2] = attrs->grid[2];
+  la.grid[0] = attrs->group[0];
+  la.grid[1] = attrs->group[1];
+  la.grid[2] = attrs->group[2];
+
+  hsacommon::vector<hsa::KernelArg> vargs;
+  for (unsigned i = 0; i < _kd->nargs; i++)
+    {
+      hsa::KernelArg a = {args[i].addr};
+      vargs.push_back (a);
+    }
+  return __hsa_queue->dispatch(kernel, la, deps, vargs);
+}
+
+void *
+__hsa_allocate_global_memory (size_t size, size_t alignment)
+{
+  __hsa_maybe_init ();
+  return __hsaRT->allocateGlobalMemory (size, alignment);
+}
+
+void
+__hsa_free_global_memory (void *p)
+{
+  __hsaRT->freeGlobalMemory (p);
+}
+
diff --git a/demo/hsa-c.h b/demo/hsa-c.h
new file mode 100644
index 0000000..2e1df87
--- /dev/null
+++ b/demo/hsa-c.h
@@ -0,0 +1,46 @@
+#include <stdlib.h>
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef union __hsa_kernelarg_
+{
+    void* addr;             ///< pointer to a buffer
+    int32_t s32value;       ///< signed 32 bit value
+    uint32_t u32value;      ///< unsigned 32 bit value
+    float fvalue;           ///< float value
+    double dvalue;          ///< double value
+    int64_t s64value;       ///< signed 64 bit value
+    uint64_t u64value;      ///< unsigned 64 bit value
+} __hsa_kernelarg;
+
+typedef struct __hsa_launch_attrs_
+{
+  uint64_t flags;
+  uint64_t grid[3];
+  uint64_t group[3];
+} __hsa_launch_attrs;
+
+typedef struct __hsa_kernel_desc_
+{
+  const char *filename;
+  const char *name;
+  uint64_t nargs;
+  void *kernel;
+} __hsa_kernel_desc;
+
+int __hsa_init (void);
+void __hsa_deinit (void);
+void * __hsa_load_program (const char *fname);
+void __hsa_unload_program (void * _program);
+void * __hsa_load_kernel (void * _program, const char *name);
+void __hsa_unload_kernel (__hsa_kernel_desc *);
+void * __hsa_launch_kernel (__hsa_kernel_desc *, __hsa_launch_attrs *attrs, __hsa_kernelarg *args);
+void * __hsa_allocate_global_memory (size_t size, size_t alignment);
+void __hsa_free_global_memory (void *p);
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/src/brig2llvm/brig_reader.cc b/src/brig2llvm/brig_reader.cc
index 419004c..ec28af9 100644
--- a/src/brig2llvm/brig_reader.cc
+++ b/src/brig2llvm/brig_reader.cc
@@ -68,7 +68,7 @@ BrigReader *BrigReader::createBrigReader(llvm::object::ObjectFile *objFile) {
       if (it->getContents(debug)) return NULL;
     } else if (name == ".brig_strtab" || name == ".strtab" ||
               name == ".strings") {
-      if (it->getContents(strings)) return NULL;
+      if (!strings.size() && it->getContents(strings)) return NULL;
     }
   }
 
