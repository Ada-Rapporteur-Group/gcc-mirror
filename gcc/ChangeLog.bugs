==================== Branch work206-bugs, patch #115 ====================

Update tests.

2025-05-22  Michael Meissner  <meissner@linux.ibm.com>

gcc/testsuite/

	PR target/118541
	* gcc.target/powerpc/p9-minmax-2.c: Delete test.
	* gcc.target/powerpc/float128-minmax-3.c: Use -Ofast, not -O2.

==================== Branch work206-bugs, patch #114 ====================

Disable fp cmove on power9

2025-05-22  Michael Meissner  <meissner@linux.ibm.com>

gcc/

	PR target/118541
	* config/rs6000/rs6000.cc (have_compare_and_set_mask): Disable unless
	NaNs are disabled.

==================== Branch work206-bugs, patch #113 ====================

Fix PR 118541, do not generate unordered fp cmoves for IEEE compares.

In bug PR target/118541 on power9, power10, and power11 systems, for the
function:

        extern double __ieee754_acos (double);

        double
        __acospi (double x)
        {
          double ret = __ieee754_acos (x) / 3.14;
          return __builtin_isgreater (ret, 1.0) ? 1.0 : ret;
        }

GCC currently generates the following code:

        Power9                          Power10 and Power11
        ======                          ===================
        bl __ieee754_acos               bl __ieee754_acos@notoc
        nop                             plfd 0,.LC0@pcrel
        addis 9,2,.LC2@toc@ha           xxspltidp 12,1065353216
        addi 1,1,32                     addi 1,1,32
        lfd 0,.LC2@toc@l(9)             ld 0,16(1)
        addis 9,2,.LC0@toc@ha           fdiv 0,1,0
        ld 0,16(1)                      mtlr 0
        lfd 12,.LC0@toc@l(9)            xscmpgtdp 1,0,12
        fdiv 0,1,0                      xxsel 1,0,12,1
        mtlr 0                          blr
        xscmpgtdp 1,0,12
        xxsel 1,0,12,1
        blr

This is because ifcvt.c optimizes the conditional floating point move to use the
XSCMPGTDP instruction.

However, the XSCMPGTDP instruction traps if one of the arguments is a signaling
NaN.  This patch disables generating XSCMP{EQ,GT,GE}{DP,QP} instructions unless
-ffinite-math-only is in effect so that we do not get a trap.

2025-05-22  Michael Meissner  <meissner@linux.ibm.com>

gcc/

	PR target/118541
	* config/rs6000/rs6000.md (mov<SFDF:mode><SFDF2:mode>cc_p9): Disable
	generating XSCMP{EQ,GT,GE}{DP,QP} unless -ffinite-math-only is in
	effect.
	(mov<SFDF:mode><SFDF2:mode>cc_invert_p9): Likewise.
	(fpmask<mode>, SFDF iterator): Likewise.
	(xxsel<mode>, SFDF iterator): Likewise.
	(mov<mode>cc, IEEE128 iterator): Likewise.
	(mov<mode>cc_p10): Likewise.
	(mov<mode>cc_invert_p10): Likewise.
	(fpmask<mode>, IEEE128 iterator): Likewise.
	(xxsel<mode>, IEEE128 iterator): Likewise.

gcc/testsuite/

	PR target/118541
	* gcc.target/powerpc/float128-cmove.c: Change optimization flag to
	-Ofast instead of -O2.

==================== Branch work206-bugs, patch #112 was reverted ====================
==================== Branch work206-bugs, patch #111 was reverted ====================
==================== Branch work206-bugs, patch #110 was reverted ====================

==================== Branch work206-bugs, patch #101 ====================

PR 99293: Optimize splat of a V2DF/V2DI extract with constant element

We had optimizations for splat of a vector extract for the other vector
types, but we missed having one for V2DI and V2DF.  This patch adds a
combiner insn to do this optimization.

In looking at the source, we had similar optimizations for V4SI and V4SF
extract and splats, but we missed doing V2DI/V2DF.

Without the patch for the code:

	vector long long splat_dup_l_0 (vector long long v)
	{
	  return __builtin_vec_splats (__builtin_vec_extract (v, 0));
	}

the compiler generates (on a little endian power9):

	splat_dup_l_0:
		mfvsrld 9,34
	        mtvsrdd 34,9,9
		blr

Now it generates:

	splat_dup_l_0:
		xxpermdi 34,34,34,3
	        blr

2025-05-19  Michael Meissner  <meissner@linux.ibm.com>

gcc/

	PR target/99293
	* config/rs6000/vsx.md (vsx_splat_extract_<mode>): New insn.

gcc/testsuite/

	PR target/99293
	* gcc.target/powerpc/builtins-1.c: Adjust insn count.
	* gcc.target/powerpc/pr99293.c: New test.

==================== Branch work206-bugs, patch #100 ====================

PR target/108958 -- use mtvsrdd to zero extend GPR DImode to VSX TImode

Previously GCC would zero externd a DImode GPR value to TImode by first zero
extending the DImode value into a GPR TImode value, and then do a MTVSRDD to
move this value to a VSX register.

This patch does the move directly, since if the middle argument to MTVSRDD is 0,
it does the zero extend.

If the DImode value is already in a vector register, it does a XXSPLTIB and
XXPERMDI to get the value into the bottom 64-bits of the register.

I have built GCC with the patches in this patch set applied on both little and
big endian PowerPC systems and there were no regressions.  Can I apply this
patch to GCC 15?

2025-05-19  Michael Meissner  <meissner@linux.ibm.com>

gcc/

	PR target/108598
	* gcc/config/rs6000/rs6000.md (zero_extendditi2): New insn.

gcc/testsuite/

	PR target/108598
	* gcc.target/powerpc/pr108958.c: New test.

==================== Branch work206-bugs, baseline ====================

Add ChangeLog.bugs and update REVISION.

2025-05-19  Michael Meissner  <meissner@linux.ibm.com>

gcc/

	* ChangeLog.bugs: New file for branch.
	* REVISION: Update.

2025-05-19   Michael Meissner  <meissner@linux.ibm.com>

	Clone branch
