/* match-and-simplify patterns for builtin functions
   Copyright (C) 2014 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free
Software Foundation; either version 3, or (at your option) any later
version.

GCC is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License
along with GCC; see the file COPYING3.  If not see
<http://www.gnu.org/licenses/>.  */


(define_operator_list POW BUILT_IN_POWF BUILT_IN_POW BUILT_IN_POWL)
(define_operator_list SQRT BUILT_IN_SQRTF BUILT_IN_SQRT BUILT_IN_SQRTL)
(define_operator_list CBRT BUILT_IN_CBRTF BUILT_IN_CBRT BUILT_IN_CBRTL)
(define_operator_list CABS BUILT_IN_CABSF BUILT_IN_CABS BUILT_IN_CABSL)


/* From fold_builtin_cabs.  */
/* If either part is zero, cabs is fabs of the other.  */
(simplify
 (CABS (complex:c @0 real_zerop))
 (abs @0))
/* cabs(x+xi) -> fabs(x)*sqrt(2).  */
(if (flag_unsafe_math_optimizations)
 (simplify
  (CABS (complex @0 @0))
  (mult (abs @0) { build_real (TREE_TYPE (@0), real_value_truncate (TYPE_MODE (TREE_TYPE (@0)), dconst_sqrt2 ())); })))
/* Optimize cabs(-z) and cabs(conj(z)) as cabs(z).  */
(for op (negate conj)
 (simplify
  (CABS (op @0))
  (CABS @0)))
/* Don't do this when optimizing for size.  */
(if (flag_unsafe_math_optimizations && optimize_function_for_speed_p (cfun))
 (simplify
  (CABS @0)
  (SQRT (plus
	 (mult (realpart@1 @0) @1)
	 (mult (imagpart@2 @0) @2)))))

/* From fold_binary.  */
/* Optimize x*pow(x,c) as pow(x,c+1).  */
(if (flag_unsafe_math_optimizations
     /* ???  fold-const.c does not check for flag_errno_math, but without
        this transform wouldn't be correct and we'd leave the original
	pow around for its side-effect (single-use would be another thing
	to consider requiring, maybe with another expression flag like :s
	which should also allow zero uses if re-simplifying).  */
     && !flag_errno_math)
  (simplify
   (mult:c (POW @0 REAL_CST@1) @0)
   (POW @0 (plus @1 { build_one_cst (TREE_TYPE (@1)); }))))

/* From fold_builtin_fabs and fold_builtin_abs.  */
/* Fold a call to fabs, fabsf or fabsl, to abs, labs, llabs or imaxabs.  */
(for fn (BUILT_IN_FABS BUILT_IN_FABSF BUILT_IN_FABSL BUILT_IN_ABS BUILT_IN_LABS BUILT_IN_LLABS BUILT_IN_IMAXABS)
 (simplify
  (fn @0)
  (abs @0)))

/* From fold_builtin_pow.  */

/* Optimize pow(1.0,y) = 1.0.  */
(simplify
 (POW real_onep@0 @1)
 @0)

(simplify
 (POW @0 REAL_CST@1)
 (with { REAL_VALUE_TYPE c = TREE_REAL_CST (@1); }
  /* Optimize pow(x,0.0) = 1.0.  */
  (if (REAL_VALUES_EQUAL (c, dconst0))
   { build_real (type, dconst1); })
  /* Optimize pow(x,1.0) = x.  */
  (if (REAL_VALUES_EQUAL (c, dconst1))
   @0)
  /* Optimize pow(x,-1.0) = 1.0/x.  */
  (if (REAL_VALUES_EQUAL (c, dconstm1))
   (rdiv { build_real (type, dconst1); } @0))
  /* Optimize pow(x,0.5) = sqrt(x).  */
  (if (flag_unsafe_math_optimizations
       && REAL_VALUES_EQUAL (c, dconsthalf))
   (SQRT @0))
  /* Optimize pow(x,1.0/3.0) = cbrt(x).  */
  (with
   { const REAL_VALUE_TYPE dconstroot
       = real_value_truncate (TYPE_MODE (type), dconst_third ()); }
   (if (flag_unsafe_math_optimizations
	&& REAL_VALUES_EQUAL (c, dconstroot))
    (CBRT @0)))))

/* Strip sign ops from even integer powers.
   ???  The code in builtins.c manages to perform this recursively
   through the whole expression in arg0 of pow.  */
(for sgnop (abs negate)
 (simplify
  (POW (sgnop @0) REAL_CST@1)
   (with
     { 
       REAL_VALUE_TYPE c = TREE_REAL_CST (@1);
       HOST_WIDE_INT n = real_to_integer (&c);
       REAL_VALUE_TYPE cint;
       real_from_integer (&cint, VOIDmode, n, SIGNED);
     }
    (if (real_identical (&c, &cint)
	 && (n & 1) == 0
	 && flag_unsafe_math_optimizations)
     (POW @0 @1)))))

/* From fold_builtin_sqrt.  */
(if (flag_unsafe_math_optimizations)
 /* Optimize sqrt(expN(x)) = expN(x*0.5).  */
 (for expfn (BUILT_IN_EXP10F BUILT_IN_EXP10 BUILT_IN_EXP10L
	     BUILT_IN_POW10F BUILT_IN_POW10 BUILT_IN_POW10L
	     BUILT_IN_EXPF BUILT_IN_EXP BUILT_IN_EXPL
	     BUILT_IN_EXP2F BUILT_IN_EXP2 BUILT_IN_EXP2L)
      SQRTs (SQRT)
  (simplify
   (SQRTs (expfn @0))
   (expfn (mult @0 { build_real (type, dconsthalf); }))))
 /* Optimize sqrt(Nroot(x)) -> pow(x,1/(2*N)).  */
 (for rootfn (BUILT_IN_SQRTF BUILT_IN_SQRT BUILT_IN_SQRTL
	      BUILT_IN_CBRTF BUILT_IN_CBRT BUILT_IN_CBRTL)
      SQRTs (SQRT)
      POWs (POW)
  (simplify
   (SQRTs (rootfn @0))
   (with
    { REAL_VALUE_TYPE dconstroot;
      if (BUILTIN_SQRT_P (rootfn)) dconstroot = dconsthalf;
      else dconstroot = dconst_third ();
      /* Adjust for the outer root.  */
      SET_REAL_EXP (&dconstroot, REAL_EXP (&dconstroot) - 1);
      dconstroot = real_value_truncate (TYPE_MODE (type), dconstroot); }
    (POWs @0 { build_real (type, dconstroot); }))))
 /* Optimize sqrt(pow(x,y)) = pow(|x|,y*0.5).  */
 (simplify
  (SQRT (POW @0 @1))
  (POW (abs @0) (mult @1 { build_real (TREE_TYPE (@1), dconsthalf); }))))
