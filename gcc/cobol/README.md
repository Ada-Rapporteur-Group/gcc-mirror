# A COBOL front end for GCC.

## Description of the repository

- The `master+cobol` branch is where you found this file.  It is the Cobolworx development branch; it's the one that should always work.  *Don't break the build!*  Pretty much everything added by this branch is found in `./gcc/cobol`.

`master+cobol` was based on `master` and is re-synchronized from time to time with the main gcc repository.

The state of `master+cobol` is normally "working as expected", meaning no regression: all tests pass now that ever did pass. Occasionally (for hours at a time) `master+cobol` will possibly not build or not run correctly; in that case, the log message will so indicate. That policy will probably be refined as community participation rises above zero, but for now that's how it is.

- You will almost certainly see a `bobdev` branch.  That's the branch Bob Dubner uses to do development work on his local machine.  He usually saves intermediate versions every day, even non-working ones, to avoid losses when he screws up or when machines crash.  When he has something that works, he merges it into the `cobol` branch.

## CI/CD

The Cobol compiler is built and tested on each commit using the Gitlab CD/CD pipeline.  If you know how, you can verify the current commit passed the last check.

Later on, when we get to something that has releases, this will be formalized.

## This repository is a clone of GCC.

The only changes to GCC's core have been to `gcc\Makefile.in` and `gcc/gimplify.c`.  Those changes include the `gcc/print-tree-dubner.c` and `gcc/print-tree-dubner.h` files into the build.  Those changes cause the `rjd_print_tree()` routine to be called when the `gimplify_function_tree(fndecl)` routine is invoked.  The `rjd_print_tree(fndecl)` call itself does nothing unless the environment variable `GCC_PRINT_TREE=1` is defined, in which case the file `<routine>.tags` is created. The name `<routine>` is extracted from the function declaration specified by the pointer `fndecl`.  So, a simple "hello, world" program generates the file `main.tags`, which contains the tree of tags for the `main()` function .  Should the compilation also involve, for example, a function `foo()`, a `foo.tags` file is also created.

That function is so disturbingly useful it's hard to understand why GCC doesn't have one built in.

The `COBOL` front end is implemented in `./gcc/cobol`.  The code and definitions for all front ends are found in `./gcc/<language>`, where `<language>` is specified in the GCC `./configure --enable-languages=...` list, as seen below.  That's where you should start your adventure in understanding how the `COBOL` front end is created.

## Building for development and debugging the GCOBOL front end

There are four in-tree prerequisites not included in the repository:

*Note that these download locations were true once upon a time.  They probably are no longer true because time marches on and what was new and wonderful becomes old and obsolete, and I don't rebuild from absolute scratch any more often than anybody else does, so I am not aware they are obsolete.  So, if you do the wget fetches check https://gcc.gnu.org/pub/gcc/infrastructure/ for the latest packages.  Or use your systems package managers to install the packages.*

    wget https://gcc.gnu.org/pub/gcc/infrastructure/gmp-6.1.0.tar.bz2
    wget https://gcc.gnu.org/pub/gcc/infrastructure/isl-0.18.tar.bz2
    wget https://gcc.gnu.org/pub/gcc/infrastructure/mpc-1.0.3.tar.gz
    wget https://gcc.gnu.org/pub/gcc/infrastructure/mpfr-3.1.4.tar.bz2

With Ubuntu, you can alternatively use:

    apt install -y libgmp-dev libisl-dev libmpc-dev libmpfr-dev

Tools you will want:
```
$ (flex --version && bison --version && gcc --version) | grep [0-9]$

flex 2.6.4
bison (GNU Bison) 3.8
gcc (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0
```

Once that's done, you may choose to create a debuggable set of GCC executables.  The executables generated by the resulting version of GCC are relatively slow because of `--enable-checking` along with `-O0`, but the compilation of GCC is relatively rapid because of `--disable-bootstrap`

```
mkdir build
cd build
CFLAGS="-ggdb -O0" CXXFLAGS="-ggdb -O0" ../configure --prefix=/usr/local/gcobol --with-pkgversion='debuggable gcc with COBOL front end' --disable-bootstrap --enable-checking --enable-languages=c,c++,cobol
```

On a physical Ubuntu 18.04 system (four cores, 3.4 GHz, 12GB RAM, SSD hard drive), compiling from scratch takes about sixteen minutes with `make -j8`.  Subsequent builds after modifying a single source file takes about 45 seconds to do a `make -j8`.

## Building a GCOBOL front end you can actually use

If your intention is to *use* the **gcobol** compiler (more than hacking the compiler itself), you'll likely want a slightly different set of commands. This isn't really a release version because of the `--disable-bootstrap`. But because of the default `-O2` optimization level and the lack of the `--enable-checking` switch, it compiles COBOL programs more rapidly than the debug build does:

```
mkdir build
cd build
../configure --prefix=/usr/local/gcobol --with-pkgversion='gcc with COBOL front end' --disable-bootstrap --enable-languages=c,c++,cobol
make install
```

At this writing, compiling a standalone source code module to produce a standalone executable needs an instruction like this:

```
/usr/local/gcobol/bin/gcobol -main -o module module.cbl /usr/local/gcobol/lib/libgcobol.a -lm -ldl -lstdc++ -rdynamic
```

Creating a .o object file to be linked in with other code is done like this:

```
/usr/local/gcobol/bin/gcobol -c -o module.o module.cbl /usr/local/gcobol/lib/libgcobol.a -lm -ldl -lstdc++ -rdynamic
```

For your purposes, you undoubtedly will create suitable scripts, or makefiles, that contain that basic framework.

At some point we will streamline the library loading; ultimately, compiling a program should be no harder than `gcobol program.cbl`.  But we aren't there yet.

## Testing

The compiler was first developed against the example programs in
[Beginning COBOL for Programmers][book]. With minor adjustments, all those programs are expected to work. (Cobolworx has a repository containing those adjustments. Feel free to contact us for details; it's just a question of time and interest.)

On-going development is against the 1985 NIST Cobol Compiler Verification Suite (CCVS-85), available from the NIST website. To install and run those tests, see the  `gcc/cobol/nist` directory. The command `make nc` should do the following:

- download the suite
- configure it
- build the main module, **EXEC85** (a COBOL program)
- run **EXEC85**, producing `nist/NC/.archive`, a file of COBOL programs
- extract COBOL programs to `nist/NC`
- begin compiling those programs

The build stops at the first compilation error, at which point you've arrived at the pinnacle of progress.

To run the programs that build successfully, `make ncx`. Each execution produces an associated `.out` file.  For example, `nist/NC/NC101A.cbl` produces the `nist/NC/NC101A` executable which, when run, creates the `nist/NC/NC101A.out` report.

## NIST Status

The tests do not *fail* in the OS sense: the test program exits with a status of 0. Each program performs numerous tests, the results of which are described in the report.  The report is an old-fashioned recitation of the tests run and any anomalous results, with a summary at the end.

To see a report summary, use `make report`.  That process compiles (if needed) all programs marked *OK* in the `catalog` file, and runs them, producing a `.rpt` file for each one.  It then scans the report files for anomalous output, and writes a summary to standard output.


[book]: https://github.com/Apress/beg-cobol-for-programmers

