==================== work095, patch #18

Mangle __ibm128 into u8__ibm128.

This patch changes the mangling of __ibm128 when long double uses the IBM
128-bit encoding.  This change is necessary due to the change where __ibm128 and
long double no longer share the same internal type node.

2022-07-29   Michael Meissner  <meissner@linux.ibm.com>

gcc/

	PR target/85657
	* config/rs6000/rs600.cc (rs6000_mangle_type): Mangle __ibm128 into
	"u8__ibm128".

==================== work095, patch #17

Make __ibm128 and __float128 separate types from long double.

This patch changes GCC so that __float128 and __ibm128 use different types
internally than long double.  In the past, GCC would use the long double type
for __float128 if -mabi=ieeelongdouble was used, and it would use the long
double type for __ibm128 if -mabi=ibmlongdouble was used.

The rs6000 internal ieee128_float_type_node is deleted in favor of using the
standard float128_type_node.

I deleted the code in rs6000_expand_builtin which used to convert some built-in
functions that used KFmode arguments to the equivalent built-in functions that
used TFmode arguments if -mabi=ieeelongdouble.  I also deleted the code that
converted the built-ins that used IFmode arguments to the equivalant functions
that used TFmode arguments if -mabi=ibmlongdouble.

I changed rs6000_builtin_type_compatible so that if the types are both IEEE
128-bit floating point or both IBM 128-bit floating point have compatible
types.

I deleted the translate mode attribute hook which is no longer need with these
changes.

I changed how complex 128-bit long double multiply and divide are done.  The
previous code indrectly depended on the type mode for __float128 being long
double, and it no longer works when __float128 always has a unique type.  To do
this, I had to create two new functions (__multc3_ieee128 and divtc3_ieee128)
which are called in this case.  I added support in libgcc to make the ifunc
support for these functions use the __mulkc3 and __divkc3 functions.

I split the define_insn_and_splits for converting between two IEEE 128-bit types
or two IBM 128-bit types into separate insns, one for converting between IEEE
128-bit types, and the other for converting between IBM 128-bit types.  One
benefit of doing this is that we can get the type and length attributes correct
for each move.

2022-07-29   Michael Meissner  <meissner@linux.ibm.com>

gcc/

	* config/rs6000/rs6000-builtin.cc (rs6000_type_string): Replace
	ieee128_float_type_node with float128_type_node.
	(rs6000_init_builtins): Use the float128_type_node for __float128 even
	if long double uses the IEEE 128-bit encoding.  The type node for
	__ibm128 is a unqiue type node even if long double uses the IBM 128-bit
	encoding.
	(rs6000_expand_builtin): Delete code that converted built-in functions
	using KFmode to the equivalant built-in function using TFmode if
	-mabi=ieeelongdouble.  Delete code that coverted built-in functions
	using IFmode to the equivalent built-in function using TFmode if
	-mabi=ibmlongdouble.
	* config/rs6000/rs6000-c.c (rs6000_target_modify_macros): Delete
	reference to ieee128_float_type_node.
	(rs6000_cpu_cpp_builtins): Delete reference to ieee128_float_type_node.
	Use TARGET_IBM128 for checking if __ibm128 is supported.
	(is_float128_p): Delete.
	(rs6000_builtin_type_compatible): For 128-bit floating point, check if
	both types have the same encoding.
	* config/rs6000/rs6000.cc (TARGET_TRANSLATE_MODE_ATTRIBUTE): Delete.
	(init_float128_ieee): Delete creation of complex long double multiply
	and divide here and move the implemention to rs6000_init_libfuncs.
	(rs6000_init_libfuncs): Rework complex long double multiply and divide
	support here if long double uses IEEE 128-bit encoding.
	(rs6000_translate_mode_attribute): Delete.
	(rs6000_libgcc_floating_mode_supported_p): Remove code that used TFmode
	if long double used the IEEE 128-bit encoding.
	(rs6000_floatn_mode): Likewise.
	(rs6000_c_mode_for_suffix): Likewise.
	* config/rs6000/rs6000.h (RS6000_BTI_ieee128_float): Delete.
	(ieee128_float_type_node): Delete.
	* config/rs6000/rs6000.md (IFKF): Delete.
	(IFKF_reg): Delete.
	(extendkfif2): New insn.
	(trunckfif2): New insn.
	(extend<mode>tf2_internal): Delete combined extend mode, and split it
	into separate insns that either just handle IEEE 128-bit to IEEE 128-bit
	conversions or IBM 128-bit to IBM 128-bit conversions.
	(extendtf<mode>2_internal): Likewise.
	(extendkftf2_internal): New insn.
	(extendtfkf2_internal): New insn.
	(extendiftf2_internal): New insn.
	(extendtfif2_internal): New insn.

gcc/testsuite/

	* gcc.target/powerpc/divkc3-2: Update test to track compiler changes.
	* gcc.target/powerpc/mulkc3-2: Likewise.

libgcc/

	* config/rs6000/float128-ifunc.c (__multc3_ieee128): New ifunc handler.
	(__divtc3_ieee128): Likewise.
	* config/rs6000/quad-float128.h (__multc3_ieee128): Add declaration.
	(__divtc3_ieee128): Likewise.

==================== work095, patch #16

Allow __ibm128 even if IEEE 128-bit floating point is not supported.

This set of patches changes the GCC compiler to allow the use of the __ibm128
keyword if we have IEEE 128-bit floating point support enabled or if long double
is 128-bits.

2022-07-29   Michael Meissner  <meissner@linux.ibm.com>

gcc/

	* config/rs6000/rs6000-builtins.cc (rs6000_init_builtins): Create
	__ibm128 on older machines without IEEE 128-bit support.
	* config/rs6000/rs600.cc (init_float128_ibm): Remove checks for hardware
	floating point for the IBM 128-bit comparisons.
	(rs6000_init_libfuncs): Create IBM 128-bit floating point support even
	if we don't support IEEE 128-bit floating point.
	(rs6000_scalar_mode_supported_p): Allow __ibm128 even if we don't
	support _Float128.
	* config/rs6000/rs6000.h (FLOAT128_IBM_P): Remove checks for
	-mhard-float.
	(TARGET_IBM128): New macro.
	* config/rs6000/rs6000.md (@extenddf<mode>2_fprs): Allow IFmode to be
	converted even if long double is not 128-bits.
	(extenddf<mode>2_vsx): Likewise.
	(extendtfif2): Allow conversion if we have __ibm128 but not IEEE 128-bit
	floating point.
	(trunckftf2): Likewise.

==================== work095, patch #15 was reverted.

==================== work095, patch #14 was reverted.

==================== work095, patch #13 was reverted.

==================== work095, patch #12 was reverted.

==================== work095, patch #11 was reverted.

==================== work095, patch #10.

Allow IBM 128-bit  to do offset addressing.

I noticed that we didn't enable offset addressing for IBM 128-bit floating
point.

2022-07-22   Michael Meissner  <meissner@linux.ibm.com>

gcc/

	* config/rs6000/rs6000.cc (rs6000_setup_reg_addr_masks): Allow
	IFmode and possibly TFmode to use offset addressing.
	(reg_offset_addressing_ok_p): IBM 128-bit floating point modes can do
	offset addressing.

==================== work095, patch #9.

Do not enable -mblock-ops-vector-pair.

Testing has shown that using the load vector pair and store vector pair
instructions for block moves has some performance issues on power10.

A patch on June 11th modified the code so that GCC would not set
-mblock-ops-vector-pair by default if we are tuning for power10, but it
would set the option if we were tuning for a different machine and have
load and store vector pair instructions enabled.

This patch just eliminates the code setting -mblock-ops-vector-pair at
all.


2022-07-22   Michael Meissner  <meissner@linux.ibm.com>

gcc/

	* config/rs6000/rs6000.cc (rs6000_option_override_internal):
	Do not enable -mblock-ops-vector-pair by default on power10.

==================== work095, patch #8.

Support IEEE 128-bit overload test data built-in functions.

This patch adds support for overloading the IEEE 128-bit test data and
test data negate built-in functions bewteeen KFmode and TFmode arguments.

2022-07-21   Michael Meissner  <meissner@linux.ibm.com>

gcc/

	* config/rs6000/rs6000-builtins.def
	(__builtin_vsx_scalar_test_data_class_qp_kf): Rename KFmode IEEE
	128-bit test data built-in functions to have a KF suffix to allow
	overloading.
	(__builtin_vsx_scalar_test_neg_qp_kf): Likewise.
	(__builtin_vsx_scalar_test_data_class_qp_tf): Add TFmode variants
	for IEEE 128-bit insert and extract support.
	(__builtin_vsx_scalar_test_neg_qp_tf): Likewise.
	* config/rs6000/rs6000-overload.def
	(__builtin_vec_scalar_test_data_class): Add TFmode overloads.
	(__builtin_vec_scalar_test_neg): Likewise.
	(__builtin_vec_scalar_test_neg_qp): Likewise.
	(__builtin_vec_scalar_test_data_class_qp): Likewise.

gcc/testsuite/

	* gcc.target/powerpc/bfp/scalar-test-data-class-11.c:  Update the
	expected error message.
	* gcc.target/powerpc/bfp/scalar-test-neg-5.c: Likewise.

==================== work095, patch #7.

Support IEEE 128-bit overload extract and insert built-in functions.

This patch adds support for overloading the IEEE 128-bit extract and
insert built-in functions bewteeen KFmode and TFmode arguments.

2022-07-21   Michael Meissner  <meissner@linux.ibm.com>

gcc/

	* config/rs6000/rs6000-builtins.def
	(__builtin_vsx_scalar_extract_expq_kf): Rename KFmode IEEE 128-bit
	insert and extract built-in functions to have a KF suffix to allow
	overloading.
	(__builtin_vsx_scalar_extract_sigq_kf): Likewise.
	(__builtin_vsx_scalar_insert_exp_qp_kf): Likewise.
	(__builtin_vsx_scalar_extract_expq_tf): Add TFmode variants for
	IEEE 128-bit insert and extract support.
	(__builtin_vsx_scalar_extract_sigq_tf): Likewise.
	(__builtin_vsx_scalar_insert_exp_qp_tf): Likewise.
	* config/rs6000/rs6000-c.cc (altivec_resolve_overloaded_builtin):
	Add support for having KFmode and TFmode variants of VSIEQPF.
	* config/rs6000/rs6000-overload.def
	(__builtin_vec_scalar_extract_exp): Add TFmode overloads.
	(__builtin_vec_scalar_extract_sig): Likewise.
	(__builtin_vec_scalar_insert_exp): Likewise.

gcc/testsuite/

	* gcc.target/powerpc/bfp/scalar-extract-exp-4.c:  Update the
	expected error message.
	* gcc.target/powerpc/bfp/scalar-extract-sig-4.c: Likewise.
	* gcc.target/powerpc/bfp/scalar-insert-exp-10.c: Likewise.

==================== work095, patch #6.

Support IEEE 128-bit overload comparison built-in functions.

This patch adds support for overloading the IEEE 128-bit comparison
built-in functions bewteeen KFmode and TFmode arguments.

2022-07-21   Michael Meissner  <meissner@linux.ibm.com>

gcc/

	* config/rs6000/rs6000-builtins.def
	(__builtin_vsx_scalar_cmp_exp_qp_eq_kf): Rename KFmode comparison
	built-in functions to have a KF suffix to allow overloading.
	(__builtin_vsx_scalar_cmp_exp_qp_gt_kf): Likewise.
	(__builtin_vsx_scalar_cmp_exp_qp_lt_kf): Likewise.
	(__builtin_vsx_scalar_cmp_exp_qp_unordered_kf): Likewise.
	(__builtin_vsx_scalar_cmp_exp_qp_eq_tf): Add TFmode comparison
	built-in functions.
	(__builtin_vsx_scalar_cmp_exp_qp_gt_tf): Likewise.
	(__builtin_vsx_scalar_cmp_exp_qp_lt_tf): Likewise.
	(__builtin_vsx_scalar_cmp_exp_qp_unordered_tf): Likewise.
	* config/rs6000/rs6000-overload.def
	(__builtin_vec_scalar_cmp_exp_eq): Add TFmode overloaded
	functions.
	(__builtin_vec_scalar_cmp_exp_gt): Likewise.
	(__builtin_vec_scalar_cmp_exp_lt): Likewise.
	(__builtin_vec_scalar_cmp_exp_unordered): Likewise.

==================== work095, patch #5.

Support IEEE 128-bit overload round_to_odd built-in functions.

This patch adds support for overloading the IEEE 128-bit round to odd
built-in functions bewteeen KFmode and TFmode arguments.

2022-07-21   Michael Meissner  <meissner@linux.ibm.com>

gcc/

	* config/rs6000/rs6000-builtins.def
	(__builtin_addf128_round_to_odd_kf): Rename KFmode round to odd
	built-in functions with a KF suffix to allow overloading.
	(__builtin_divf128_round_to_odd_kf): Likewise.
	(__builtin_fmaf128_round_to_odd_kf): Likewise.
	(__builtin_mulf128_round_to_odd_kf): Likewise.
	(__builtin_sqrtf128_round_to_odd_kf): Likewise.
	(__builtin_subf128_round_to_odd_kf): Likewise.
	(__builtin_truncf128_round_to_odd_kf): Likewise.
	(__builtin_addf128_round_to_odd_tf): Add TFmode round to odd
	built-in functions.
	(__builtin_fmaf128_round_to_odd_tf): Likewise.
	(__builtin_mulf128_round_to_odd_tf): Likewise.
	(__builtin_sqrtf128_round_to_odd_tf): Likewise.
	(__builtin_subf128_round_to_odd_tf): Likewise.
	(__builtin_truncf128_round_to_odd_tf): Likewise.
	* config/rs6000/rs6000-overload.def
	(__builtin_addf128_round_to_odd): Make IEEE 128-bit round to odd
	built-in functions overloaded.
	(__builtin_divf128_round_to_odd): Likewise.
	(__builtin_fmaf128_round_to_odd): Likewise.
	(__builtin_mulf128_round_to_odd): Likewise.
	(__builtin_sqrtf128_round_to_odd): Likewise.
	(__builtin_subf128_round_to_odd): Likewise.
	(__builtin_truncf128_round_to_odd): Likewise.

==================== work095, patch #4.

IEEE 128-bit built-in support.

This patch lays the ground work that future patches will use to add
builtin support (both normal and overloaded) for the case where long
double uses the IEEE 128-bit encoding.

This adds a new stanza (ieee128-hw-ld) for when we have IEEE 128-bit
hardware support and long double uses the IEEE 128-bit encoding.

A new type attribute (ieeeld) is added for long double if long double uses
the IEEE 128-bit encoding.

2022-07-21   Michael Meissner  <meissner@linux.ibm.com>


gcc/

	* config/rs6000/rs6000-builtin.cc (rs6000_invalid_builtin): Add
	support for ibm128-hw-ld stanza.
	(rs6000_builtin_is_supported): Likewise.
	(rs6000_init_builtins): Likewise.
	(rs6000_expand_builtin): Add support for IEEE128_HW_LD.  Add
	support for ieeeld.
	* config/rs6000/rs6000-builtins.def (toplevel): Add comment about
	the new ieeeld attribute.
	* config/rs6000/rs6000-gen-builtins.cc (enum bif_stanza): Add
	BSTZ_IEEE128_HW_LD.
	(stanza_map): Likewise.
	(enable_string): Likewise.
	(attrinfo): Add isieeeld.
	(parse_bif_attrs): Parse ieeeld.  Add printing ieeeld to the debug
	print.
	(write_decls): Add support for ibm128-hw-ld stanza and ieeeld
	attribute.
	(write_bif_static_init): Add support for ieeeld attribute.

==================== work095, patch #3 was reverted.

==================== work095, patch #2 was reverted.

==================== work095, patch #1 was reverted.

==================== work095, branch setup.

2022-07-18   Michael Meissner  <meissner@linux.ibm.com>

	Clone branch

