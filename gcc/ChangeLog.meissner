==================== work098, patch #7

Add ibm128_operand.

Since we have 2 modes for IBM 128-bit (IFmode and TFmode if long double is IBM
128-bit), this patch provides a new predicate (ibm128_operand) that allows
combining a conversion from one mode to another.

2022-08-17   Michael Meissner  <meissner@linux.ibm.com>

gcc/

	* config/rs6000/predicates.md (ibm128_operand): New predicate.
	* config/rs6000/rs6000.md (extendiftf2_internal): Add GPR registers in
	case -msoft-float is used.
	(extendtfif2_internal): Likewise.
	(unpack<mode>): Use ibm128_operand.
	(unpack<mode>_dm): Likewise.
	(unpack<mode>_nodm): Likewise.

==================== work098, patch #5

Add ieee128_operand.

Since we have 2 modes for IEEE 128-bit (KFmode and TFmode if long double is IEEE
128-bit), this patch provides a new predicate (ieee128_operand) that allows
combining a conversion from one mode to another.

2022-08-17   Michael Meissner  <meissner@linux.ibm.com>

gcc/

	* config/rs6000/predicates.md (ieee128_operand): New predicate.
	* config/rs6000/rs6000.md (trunc<mode>sf2_hw): Use ieee128_operand.
	(round<mode>2): Likewise.
	(add<mode>3_odd): Likewise.
	(sub<mode>3_odd): Likewise.
	(mul<mode>3_odd): Likewise.
	(div<mode>3_odd): Likewise.
	(sqrt<mode>2_odd): Likewise.
	(fma<mode>4_odd): Likewise.
	(fms<mode>4_odd): Likewise.
	(nfma<mode>4_odd): Likewise.
	(nfms<mode>4_odd): Likewise.
	(trunc<mode>df2_odd): Likewise.
	* config/rs6000/vsx.md (xsxexpqp_<mode>): Likewise.
	(xsxsigqp_<mode>): Likewise.
	(xsiexpqpf_<mode>): Likewise.
	(xscmpexpqp_<code>_<mode): Likewise.
	(xscmpexpqp_<code>_<mode>): Likewise.
	(xststdcqp_<mode>): Likewise.
	(xststdcnegqp_<mode>): Likewise.
	(xststdcqp_<mode>): Likewise.

==================== work098, patch #5

Improve converting between 128-bit modes that use the same format.

This patch improves the insns used for converting between two modes using
the 128-bit floating point format (i.e. converting between KFmode and TFmode if
-mabi=ieeelongdouble is used, and converting between IFmode and TFmode if
-mabi=ibmlongdouble is used).  The new insns have the correct insn type and
instruction length for the move involved.

2022-08-17   Michael Meissner  <meissner@linux.ibm.com>

gcc/

	* config/rs6000/rs6000.md (IFKF): Delete.
	(IFKF_reg): Delete.
	(extendkfif2): New define_expand.
	(trunckfif2): New define_expand.
	(extend<mode>tf2_internal): Split into extendiftf2_internal and
	extendkftf2_internal.  Update the insns to use the correct insn type and
	length attributes based on whether KFmode or IFmode is used.
	(extendiftf2_internal): Likewise.
	(extendkftf2_internal): Likewise.
	(extendtf<mode>2_internal): Split into extendtfif2_internal and
	extendtfkf2_internal.  Update the insns to use the correct insn type and
	length attributes based on whether KFmode or IFmode is used.
	(extendtfif2_internal): Likewise.
	(extendtfkf2_internal): Likewise.

==================== work098, patch #4

Rework 128-bit complex multiply and divide.

This function reworks how the complex multiply and divide built-in functions are
done.  Previously we created built-in declarations for doing long double complex
multiply and divide when long double is IEEE 128-bit.  The old code also did not
support __ibm128 complex multiply and divide if long double is IEEE 128-bit.

In terms of history, I wrote the original code just as I was starting to test
GCC on systems where IEEE 128-bit long double was the default.  At the time, we
had not yet started mangling the built-in function names as a way to bridge
going from a system with 128-bit IBM long double to 128-bin IEEE long double.

The original code depends on there only being two 128-bit types invovled.  With
some of the changes that I plan on making, this assumption will no longer be
true in the future.

The problem is we cannot create two separate built-in functions that resolve to
the same name.  This is a requirement of add_builtin_function and the C front
end.  That means for the 3 possible modes (IFmode, KFmode, and TFmode), you can
only use 2 of them.

This code does not create the built-in declaration with the changed name.
Instead, it uses the TARGET_MANGLE_DECL_ASSEMBLER_NAME hook to change the name
before it is written out to the assembler file like it now does for all of the
other long double built-in functions.

We need to disable using this mapping when we are building libgcc, which is
creating the multiply and divide functions.  The flag that is used when libgcc
is built (-fbuilding-libcc) is only available in the C/C++ front ends.  We need
to remember that we are building libgcc in the rs6000-c.cc support to be able to
use this later to decided whether to mangle the decl assembler name or not.

When I wrote these patches, I discovered that __ibm128 complex multiply and
divide had originally not been supported if long double is IEEE 128-bit as it
would generate calls to __mulic3 and __divic3.  I added tests in the testsuite
to verify that the correct name (i.e. __multc3 and __divtc3) is used in this
case.

2022-08-17   Michael Meissner  <meissner@linux.ibm.com>

gcc/

	* config/rs6000/rs6000-c.cc (rs6000_cpu_cpp_builtins): Set
	building_libgcc.
	* config/rs6000/rs6000.cc (create_complex_muldiv): Delete.
	(init_float128_ieee): Delete code to switch complex multiply and divide
	for long double.
	(complex_multiply_builtin_code): New helper function.
	(complex_divide_builtin_code): Likewise.
	(rs6000_mangle_decl_assembler_name): Add support for mangling the name
	of complex 128-bit multiply and divide built-in functions.
	* config/rs6000/rs6000.opt (building_libgcc): New target variable.

gcc/testsuite/

	* gcc.target/powerpc/divic3-1.c: New test.
	* gcc.target/powerpc/divic3-2.c: Likewise.
	* gcc.target/powerpc/mulic3-1.c: Likewise.
	* gcc.target/powerpc/mulic3-2.c: Likewise.

==================== work098, patch #3

Add 'w' suffix for __ibm128 constants.

In the documentation, we mention that 'w' or 'W' can be used as a suffix for
__ibm128 constants.  We never implemented this.  This patch fixes that.

2022-08-17   Michael Meissner  <meissner@linux.ibm.com>

gcc/

	* config/rs6000/rs6000.cc (rs6000_c_mode_for_suffix): Allow 'w' or 'W'
	for __ibm128 constants.

gcc/testsuite/

	* gcc.target/powerpc/ibm128-suffix.c: New test.

==================== work098, patch #2

Allow __ibm128 with -msoft-float (PR target/105334)

This patch allows __ibm128 to be used on systems with software floating point
enabled.  Previously, we required hardware floating point to be enabled to use
the __builtin_pack_ibm128 and __builtin_unpack_libm128 built-in functions.  This
fixes PR target/105334.


2022-08-17   Michael Meissner  <meissner@linux.ibm.com>

gcc/

	PR target/105334
	* config/rs6000/rs6000-builtins.cc (rs6000_init_builtins): Enable using
	the__ibm128 keyword on systems that either use the 128-bit IBM long
	double format for long double or support IEEE 128-bit.
	* config/rs6000/rs6000.cc (rs6000_init_libfuncs): Create IBM 128-bit
	floating point support functions on systems that support the __ibm128
	keyword.
	(rs6000_scalar_mode_supported_p): Likewise.
	* config/rs6000/rs6000.h (TARGET_IBM128): New macro.
	* config/rs6000/rs6000.md (@extenddf<mode>2_fprs): Allow IFmode to be
	converted even if long double is not 128-bits.
	(extenddf<mode>2_vsx): Likewise.
	(extendiftf2):Allow conversion on systems that support the __ibm128
	keyword.
	(extendtfif2): Likewise.
	(trunciftf2): Likewise.
	(trunctfif2): Likewise.

==================== work098, patch #1

Allow __ibm128 even if IEEE 128-bit floating point is not supported.

This set of patches changes the GCC compiler to allow the use of the __ibm128
keyword if we have IEEE 128-bit floating point support enabled or if long double
is 128-bits.

2022-08-17   Michael Meissner  <meissner@linux.ibm.com>

gcc/

	* config/rs6000/rs6000-builtins.cc (rs6000_init_builtins): Enable using
	the__ibm128 keyword on systems that either use the 128-bit IBM long
	double format for long double or support IEEE 128-bit.
	* config/rs6000/rs6000.cc (rs6000_init_libfuncs): Create IBM 128-bit
	floating point support functions on systems that support the __ibm128
	keyword.
	(rs6000_scalar_mode_supported_p): Likewise.
	* config/rs6000/rs6000.h (TARGET_IBM128): New macro.
	* config/rs6000/rs6000.md (@extenddf<mode>2_fprs): Allow IFmode to be
	converted even if long double is not 128-bits.
	(extenddf<mode>2_vsx): Likewise.
	(extendiftf2):Allow conversion on systems that support the __ibm128
	keyword.
	(extendtfif2): Likewise.
	(trunciftf2): Likewise.
	(trunctfif2): Likewise.

==================== work098, start branch

2022-08-16   Michael Meissner  <meissner@linux.ibm.com>

	Clone branch

