==================== work098, patch #17

Make __float128 use the _Float128 type.

Currently GCC uses the long double type node for __float128 if long double is
IEEE 128-bit.  It did not use the node for _Float128.

This showed up if you call the nansq function to make a signaling NaN (nansq is
mapped to nansf128).  Because the type node for _Float128 is different from
__float128, the machine independent code converts signaling NaNs to quiet NaNs
if the types are  not compatible.  The following tests used to fail when run on
a system where long double is IEEE 128-bit:

	gcc.dg/torture/float128-nan.c
	gcc.target/powerpc/nan128-1.c

This patch makes both __float128 and _Float128 use the same type node.  A
consequence of this change is that _Float128 and __float128 now must always use
the KFmode mode, and not use TFmode if long double is IEEE 128-bit.


2022-08-17   Michael Meissner  <meissner@linux.ibm.com>

gcc/

	* config/rs6000/rs6000-builtin.cc (rs6000_init_builtins): Always use the
	_Float128 type for __float128.  Don't use the long double type.
	* config/rs6000/rs6000.cc (rs6000_libgcc_floating_mode_supported_p):
	Always use KFmode for Float128 mode.
	(rs6000_floatn_mode): Likewise.

==================== work098, patch #16

Update switching between equivalent 128-bit FP in builtins

This patch looks to see if the caller function was passed TFmode.  If it was
passed TFmode and the built-in function uses KFmode, switch the built-in
function to the equivalent TFmode built-in.  Similarly, if it was passed TFmode
and the built-in functions uses IFmode, switch the built-in function to the
equivalent TFmode built-in.

In the past the code would do the conversion based on what 128-bit floating
point format was used.  This patch changes this to look at the 	arguments.  If
any of the arguments use TFmode instead of KFmode or IFmode, it will do the
conversion.

2022-08-17   Michael Meissner  <meissner@linux.ibm.com>

gcc/

	* config/rs6000/rs6000-builtin.cc (rs6000_expand_builtin): Update
	switching from KFmode/IFmode built-in functions to TFmode built-in
	functions.

==================== work098, patch #15

Add ieee128_operand.

Since we have 2 modes for IEEE 128-bit (KFmode and TFmode if long double is IEEE
128-bit), this patch provides a new predicate (ieee128_operand) that allows
combining a conversion from one mode to another.

2022-08-17   Michael Meissner  <meissner@linux.ibm.com>

gcc/

	* config/rs6000/predicates.md (ieee128_operand): New predicate.
	* config/rs6000/rs6000.md (trunc<mode>sf2_hw): Use ieee128_operand.
	(round<mode>2): Likewise.
	(add<mode>3_odd): Likewise.
	(sub<mode>3_odd): Likewise.
	(mul<mode>3_odd): Likewise.
	(div<mode>3_odd): Likewise.
	(sqrt<mode>2_odd): Likewise.
	(fma<mode>4_odd): Likewise.
	(fms<mode>4_odd): Likewise.
	(nfma<mode>4_odd): Likewise.
	(nfms<mode>4_odd): Likewise.
	(trunc<mode>df2_odd): Likewise.
	* config/rs6000/vsx.md (xsxexpqp_<mode>): Likewise.
	(xsxsigqp_<mode>): Likewise.
	(xsiexpqpf_<mode>): Likewise.
	(xscmpexpqp_<code>_<mode): Likewise.
	(xscmpexpqp_<code>_<mode>): Likewise.
	(xststdcqp_<mode>): Likewise.
	(xststdcnegqp_<mode>): Likewise.
	(xststdcqp_<mode>): Likewise.

==================== work098, patch #14

Improve converting between 128-bit modes that use the same format.

This patch improves the insns used for converting between two modes using
the 128-bit floating point format (i.e. converting between KFmode and TFmode if
-mabi=ieeelongdouble is used, and converting between IFmode and TFmode if
-mabi=ibmlongdouble is used).  The new insns have the correct insn type and
instruction length for the move involved.

Previously, the two different moves were lumped together (i.e. converting
between IEEE 128-bit and IEEE 128-bit was matched by the same insns as
converting between IBM 128-bit and IBM 128-bit moves).

2022-08-17   Michael Meissner  <meissner@linux.ibm.com>

gcc/

	* config/rs6000/rs6000.md (IFKF): Delete.
	(IFKF_reg): Delete.
	(extendkfif2): New define_expand.
	(trunckfif2): New define_expand.
	(extend<mode>tf2_internal): Split into extendiftf2_internal and
	extendkftf2_internal.  Update the insns to use the correct insn type and
	length attributes based on whether the move uses IEEE 128-bit floating
	point or IBM 128-bit floating point type.
	(extendiftf2_internal): Likewise.
	(extendkftf2_internal): Likewise.
	(extendtf<mode>2_internal): Split into extendtfif2_internal and
	extendtfkf2_internal.  Update the insns to use the correct insn type and
	length attributes based on whether the move uses IEEE 128-bit floating e
	point or IBM 128-bit floating point type.
	(extendtfif2_internal): Likewise.
	(extendtfkf2_internal): Likewise.

==================== work098, patch #13

Rework 128-bit complex multiply and divide.

This function reworks how the complex multiply and divide built-in functions are
done.  Previously we created built-in declarations for doing long double complex
multiply and divide when long double is IEEE 128-bit.  The old code also did not
support __ibm128 complex multiply and divide if long double is IEEE 128-bit.

In terms of history, I wrote the original code just as I was starting to test
GCC on systems where IEEE 128-bit long double was the default.  At the time, we
had not yet started mangling the built-in function names as a way to bridge
going from a system with 128-bit IBM long double to 128-bin IEEE long double.

The original code depends on there only being two 128-bit types invovled.  With
some of the changes that I plan on making, this assumption will no longer be
true in the future.

The problem is we cannot create two separate built-in functions that resolve to
the same name.  This is a requirement of add_builtin_function and the C front
end.  That means for the 3 possible modes (IFmode, KFmode, and TFmode), you can
only use 2 of them.

This code does not create the built-in declaration with the changed name.
Instead, it uses the TARGET_MANGLE_DECL_ASSEMBLER_NAME hook to change the name
before it is written out to the assembler file like it now does for all of the
other long double built-in functions.

We need to disable using this mapping when we are building libgcc, which is
creating the multiply and divide functions.  The flag that is used when libgcc
is built (-fbuilding-libcc) is only available in the C/C++ front ends.  We need
to remember that we are building libgcc in the rs6000-c.cc support to be able to
use this later to decided whether to mangle the decl assembler name or not.

When I wrote these patches, I discovered that __ibm128 complex multiply and
divide had originally not been supported if long double is IEEE 128-bit as it
would generate calls to __mulic3 and __divic3.  I added tests in the testsuite
to verify that the correct name (i.e. __multc3 and __divtc3) is used in this
case.

2022-08-17   Michael Meissner  <meissner@linux.ibm.com>

gcc/

	* config/rs6000/rs6000-c.cc (rs6000_cpu_cpp_builtins): Set
	building_libgcc.
	* config/rs6000/rs6000.cc (create_complex_muldiv): Delete.
	(init_float128_ieee): Delete code to switch complex multiply and divide
	for long double.
	(complex_multiply_builtin_code): New helper function.
	(complex_divide_builtin_code): Likewise.
	(rs6000_mangle_decl_assembler_name): Add support for mangling the name
	of complex 128-bit multiply and divide built-in functions.
	* config/rs6000/rs6000.opt (building_libgcc): New target variable.

gcc/testsuite/

	* gcc.target/powerpc/divic3-1.c: New test.
	* gcc.target/powerpc/divic3-2.c: Likewise.
	* gcc.target/powerpc/mulic3-1.c: Likewise.
	* gcc.target/powerpc/mulic3-2.c: Likewise.

==================== work098, patch #12

Add 'w' suffix for __ibm128 constants.

In the documentation, we mention that 'w' or 'W' can be used as a suffix for
__ibm128 constants.  We never implemented this.  This patch fixes that.

In addition, the 'q' and 'Q' suffix were changed to use the mode used for the
__float128 type, instead of knowing whether to use KFmode or TFmode explicitly.
This will be used in a future patch where we change the mode used for __float128
on systems where long double is IEEE 128-bit.

2022-08-17   Michael Meissner  <meissner@linux.ibm.com>

gcc/

	* config/rs6000/rs6000.cc (rs6000_c_mode_for_suffix): Allow 'w' or 'W'
	for __ibm128 constants.

gcc/testsuite/

	* gcc.target/powerpc/ibm128-suffix.c: New test.

==================== work098, patch #11

Allow __ibm128 with -msoft-float (PR target/105334)

This patch allows __ibm128 to be used on systems with software floating point
enabled.  Previously, we required hardware floating point to be enabled to use
__ibm128 keyword and the __ibm128 built-in functions.  This patch fixes PR
target/105334.

2022-08-17   Michael Meissner  <meissner@linux.ibm.com>

gcc/

	PR target/105334
	* config/rs6000/rs6000.cc (init_float128_ibm): Do not require hardware
	floating point for the IBM 128-bit floating point comparison functions.
	* config/rs6000/rs6000.h (FLOAT128_IBM_P): Do not require hardware
	floating point to enable recognizing IBM 128-bit floating point modes.

==================== work098, patch #10

Allow __ibm128 even if IEEE 128-bit floating point is not supported.

This set of patches changes the GCC compiler to allow the use of the __ibm128
keyword if we have IEEE 128-bit floating point support enabled or if long double
is 128-bits.

2022-08-17   Michael Meissner  <meissner@linux.ibm.com>

gcc/

	* config/rs6000/rs6000-builtins.cc (rs6000_init_builtins): Enable using
	the__ibm128 keyword on systems that either use the 128-bit IBM long
	double format for long double or support IEEE 128-bit.
	* config/rs6000/rs6000.cc (rs6000_init_libfuncs): Create IBM 128-bit
	floating point support functions on systems that support the __ibm128
	keyword.
	(rs6000_scalar_mode_supported_p): Likewise.
	* config/rs6000/rs6000.h (TARGET_IBM128): New macro.
	* config/rs6000/rs6000.md (@extenddf<mode>2_fprs): Allow IFmode to be
	converted even if long double is not 128-bits.
	(extenddf<mode>2_vsx): Likewise.
	(extendiftf2):Allow conversion on systems that support the __ibm128
	keyword.
	(extendtfif2): Likewise.
	(trunciftf2): Likewise.
	(trunctfif2): Likewise.

==================== work098, patch #9 was reverted.

==================== work098, patch #8 was reverted.

==================== work098, patch #7 was reverted.

==================== work098, patch #6 was reverted.

==================== work098, patch #5 was reverted.

==================== work098, patch #4 was reverted.

==================== work098, patch #3 was reverted.

==================== work098, patch #2 was reverted.

==================== work098, patch #1 was reverted.

==================== work098, start branch

2022-08-16   Michael Meissner  <meissner@linux.ibm.com>

	Clone branch

