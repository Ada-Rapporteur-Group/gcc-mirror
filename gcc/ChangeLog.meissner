==================== Work082, patch #11:
Allow vsx_extract_<mode> to use Altivec registers

In looking at PR target/99293, I noticed that the vsx_extract_<mode>
pattern for V2DImode and V2DFmode only allowed traditional floating point
registers, and it did not allow Altivec registers.  The original code was
written a few years ago when we used the old register allocator, and
support for scalar floating point in Altivec registers was just being
added to GCC.

2022-03-24   Michael Meissner  <meissner@linux.ibm.com>

gcc/
	PR target/99392
	* config/rs6000/rs6000.md (vsx_extract_<mode>): Allow destination
	to be an Altivec register.

==================== Work082, patch #10:
Improve vsx_extract_<mode>

In looking at PR target/99293, I noticed that the insn "type" attribute is
incorrect.  This patch fixes those attributes.

2022-03-24   Michael Meissner  <meissner@linux.ibm.com>

gcc/
	PR target/99392
	* config/rs6000/rs6000.md (vsx_extract_<mode>): Use the correct
	insn type for the alternatives.

==================== Work082, patch #9 (reverted):

==================== Work082, patch #8:
Improve vsx_splat_<mode>_reg

In looking at PR target/99293, I noticed that the code in
vsx_splat_<mode>_reg used "vecmove" as the "type" insn attribute when the
"mtvsrdd" is generated.  It should use "mfvsr".  I also added a "p9v" isa
attribute for that alternative.

2022-03-23   Michael Meissner  <meissner@linux.ibm.com>

gcc/
	PR target/99392
	* config/rs6000/rs6000.md (vsx_splat_<mode>_reg): Use the correct
	insn type attribute.  Add "p9v" isa attribute as needed.


==================== Work082, patch #7 (reverted):

==================== Work082, patch #6:
Optimize vec_splats of constant vec_extract for V2DI/V2DF.

In PR target/99293, it was pointed out that doing:

	vector long long dest0, dest1, src;
	/* ... */
	dest0 = vec_splats (vec_extract (src, 0));
	dest1 = vec_splats (vec_extract (src, 1));

would generate slower code.

It generates the following code on power8:

	;; vec_splats (vec_extract (src, 0))
	xxpermdi 0,34,34,3
	xxpermdi 34,0,0,0

	;; vec_splats (vec_extract (src, 1))
	xxlor 0,34,34
	xxpermdi 34,0,0,0

However on power9 and power10 it generates:

	;; vec_splats (vec_extract (src, 0))
	mfvsld 3,34
	mtvsrdd 34,9,9

	;; vec_splats (vec_extract (src, 1))
	mfvsrd 9,34
	mtvsrdd 34,9,9

This is due to the power9 having the mfvsrld instruction which can extract
either 64-bit element into a GPR.

However in this case, it is better to have a single combiner pattern that
can generate a single xxpermdi, instead of 2 insnsn.

2022-03-23   Michael Meissner  <meissner@linux.ibm.com>

gcc/
	PR target/99392
	* config/rs6000/vsx.md (vsx_splat_const_extract_<mode>): New
	insn.

gcc/testsuite:
	PR target/99392
	* gcc.target/powerpc/pr99293.c: New test.

==================== Work082, patch #5:
Generate vadduqm and vsubuqm for TImode add/subtract

If the TImode variable is in an Altivec register instead of a GPR
register, then generate vadduqm and vsubuqm instead of having to move the
value to the GPR registers and doing the add and subtract with carry
instructions.  To do this, we have to delay the splitting of the addition
and subtraction until after register allocation.

2022-03-22   Michael Meissner  <meissner@linux.ibm.com>

gcc/
	* config/rs6000/rs6000.md (addti3): Generate vadduqm if we are
	using the Altivec registers.
	(subti3): Generate vsubuqm if we using the Altivec registers.
	(negti3): New insn.

==================== Work082, patch #4:

Optimize multiply/add of DImode extended to TImode.

On power9 and power10 systems, we have instructions that support doing
64-bit integers converted to 128-bit integers and producing 128-bit
results.  This patch adds support to generate these instructions.

Previously we had define_expands to handle conversion of the 64-bit extend
to 128-bit and multiply.  This patch changes these define_expands to
define_insn_and_split and then it provides combiner patterns to generate
thes multiply/add instructions.

To support using this optimization on power9, we extend the sign extend
DImode to TImode to also run on power9 (added for PR target/104698).

We add support for doing an unsigned DImode to TImode conversion.  We need
these conversions to exist on power9 so that the combiner can properly
combine the extend, multiply, and add instructions.

2022-03-22   Michael Meissner  <meissner@linux.ibm.com>

gcc/
	PR target/103109
	* config/rs6000/rs6000.md (su_int32): New code attribute.
	(<u>mul<mode><dmode>3): Convert from define_expand to
	define_insn_and_split.
	(maddld<mode>4): Add generator function.
	(<u>mulditi3_<u>adddi3): New insn.
	(<u>mulditi3_add_const): New insn.
	(<u>mulditi3_<u>adddi3_upper): New insn.

gcc/testsuite/
	PR target/103109
	* gcc.target/powerpc/pr103109.c: New test.


==================== Work082, patch #3:

Make addti3/subti3 be define_insn_and_split, instead of define_expand

This patch makes addti3 and subti3 be define_insn_and_split instead of
define_expand.  This patch will be a building block to support in a future
patch PR target/103109 which wants to optimize 128-bit some integer
multiply-add combinations to use the power9 maddld, maddhd, maddhdu
instructions.  In order to support recognizing the multiply and add
combination, we need to keep the addti3 and subti3 as complete insns
through the combiner phase.

2022-03-22   Michael Meissner  <meissner@linux.ibm.com>

gcc/
	* config/rs6000/rs6000.md (addti3): Don't immediately expand the
	insn, delay expansion until the split passes.
	(subti3): Likewise.

==================== Work082, patch #2:

Add zero_extendditi2 for power9.

This patch provides a zero_extendditi2 pattern for power9 and power10.  On
power8 and previous systems, the generic machine indepenent code will be
used.  This patch will be a building block to support in a future patch PR
target/103109 which wants to optimize 128-bit some integer multiply-add
combinations to use the power9 maddld, maddhd, maddhdu instructions.

2022-03-18   Michael Meissner  <meissner@linux.ibm.com>

gcc/
	* config/rs6000/vsx.md (zero_extendditi2): New insn.

==================== Work082, patch #1:

Improve extendditi2 on PowerPC.

This patch allows using extenditi2 on power9 systems as well as power10
systems.  On power8 and previous systems, the generic machine indepenent
code will be used.  This patch will be a building block to support in a
future patch PR target/103109 which wants to optimize 128-bit some integer
multiply-add combinations to use the power9 maddld, maddhd, maddhdu
instructions.

This patch improves code generation when extending a GPR to a vector
register by generating the sign extend part in a GPR register before
moving the value over to the vector register with the mtvsrdd
instruction.

2022-03-18   Michael Meissner  <meissner@linux.ibm.com>

gcc/
	* config/rs6000/vsx.md (extendditi2): Add power9 support.  Improve
	code generation when doing direct moves.

gcc/testsuite/
	* gcc.target/powerpc/pr104698-2.c: Update insn counts.


==================== Initial:

2022-03-17   Michael Meissner  <meissner@linux.ibm.com>

	Clone branch

