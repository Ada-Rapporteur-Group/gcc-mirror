==================== work097, patch008

Make __float128 use the _Float128 type.

2022-08-11   Michael Meissner  <meissner@linux.ibm.com>

gcc/

	* config/rs6000/rs6000-builtin.cc (rs6000_init_builtins): Always use the
	_Float128 type for __float128.  Don't use the long double type.

==================== work097, patch007

Add predicates to inter-mix 128-bit floating point modes.

This patch adds two new predicates (ieee128_operand and ibm128_operand) that
allow KFmode and TFmode to be used inter-changeably when long double is IEEE
128-bit, and IFmode and TFmode to be used inter-changeabily with long double is
IBM 128-bit.

The various built-in functions that use KFmode or IFmode have been modified to
use these new predicates.

The code in rs6000_expand_builtin that switched between the KFmode and TFmode
built-in functions and the code that switched between the IFmode and TFmode
built-in functions has been modified so it looks at the argument type.  If a
TFmode argument was passed, it will convert the built-in to from using KFmode or
IFmode to one using TFmode.

The nop conversion functions between IFmode and TFmode when long double uses IBM
128-bit have been extended so that they take GPR registers as well as FPR
registers.  This is to allow the test "pr105334.c" to pass.  This test wants to
use -msoft-float along with the __ibm128 pack/unpack functions.

2022-08-11   Michael Meissner  <meissner@linux.ibm.com>

gcc/

	* config/rs6000/predicates.md (ieee128_operand): New predicate.
	(ibm128_operand): Likewise.
	* config/rs6000/rs6000-builtin.cc (rs6000_expand_builtin): Rework code
	that switches KFmode and IFmode built-in functions to TFmode to look at
	the argument's mode, and not just use the switch.
	* config/rs6000/rs6000.md (extendkftf2_internal): Add support for using
	GPR registers.
	(extendtfkf2_internal): Likewise.
	(extendiftf2_internal): Likewise.
	(extendtfif2_internal): Likewise.
	(unpack<mode>): Use ibm128_operand for TFmode/IFmode operands.
	(unpack<mode>_dm): Likewise.
	(unpack<mode>_nodm): Likewise.
	(pack<mode>_hard): Likewise.
	(unpack<mode>): Likewise.
	(pack<mode>): Likewise.
	(trunc<mode>sf2_hw): Use ieee128_operand for TFmode/KFmode operands.
	(add<mode>3_odd): Likewise.
	(sub<mode>3_odd): Likewise.
	(mul<mode>3_odd): Likewise.
	(div<mode>3_odd): Likewise.
	(sqrt<mode>2_odd): Likewise.
	(fma<mode>4_odd): Likewise.
	(fms<mode>4_odd): Likewise.
	(nfma<mode>4_odd): Likewise.
	(nfms<mode>4_odd): Likewise.
	(trunc<mode>df2_odd): Likewise.
	(cmp<mode>_hw): Likewise.
	* config/rs6000/vsx.md (xsxexpqp_<mode>): Likewise.
	(xsxsigqp_<mode>): Likewise.
	(xsiexpqpf_<mode): Likewise.
	(xsiexpqp_<mode>): Likewise.
	(xscmpexpqp_<code>_<mode>): Likewise.
	(xscmpexpqp_<code>_<mode>): Likewise.
	(xststdcqp_<mode>): Likewise.
	(xststdcnegqp_<mode): Likewise.
	(xststdcqp_<mode): Likewise.

==================== work097, patch006 was reverted

==================== work097, patch005

Improve converting between 128-bit modes that use the same format.

This patch improves the insns used for converting between two modes using
the 128-bit floating point format (i.e. converting between KFmode and TFmode if
-mabi=ieeelongdouble is used, and converting between IFmode and TFmode if
-mabi=ibmlongdouble is used).  The new insns have the correct insn type and
instruction length for the move involved.

2022-08-10   Michael Meissner  <meissner@linux.ibm.com>

gcc/

	* config/rs6000/rs6000.md (IFKF): Delete.
	(IFKF_reg): Delete.
	(extendkfif2): New define_expand.
	(trunckfif2): New define_expand.
	(extend<mode>tf2_internal): Split into extendiftf2_internal and
	extendkftf2_internal.  Update the insns to use the correct insn type and
	length attributes based on whether KFmode or IFmode is used.
	(extendiftf2_internal): Likewise.
	(extendkftf2_internal): Likewise.
	(extendtf<mode>2_internal): Split into extendtfif2_internal and
	extendtfkf2_internal.  Update the insns to use the correct insn type and
	length attributes based on whether KFmode or IFmode is used.
	(extendtfif2_internal): Likewise.
	(extendtfkf2_internal): Likewise.

==================== work097, patch004 was reverted

==================== work097, patch003 was reverted

==================== work097, patch002

Rework 128-bit complex multiply and divide.

This function reworks how the complex multiply and divide built-in functions are
done.  Previously we created built-in declarations for doing long double complex
multiply and divide when long double is IEEE 128-bit.  The old code also did not
support __ibm128 complex multiply and divide if long double is IEEE 128-bit.

One of the problems with this approach is that the add_builtin_function would
abort if we used the same name for two different built-in functions.

This code does not create the built-in declaration.  Instead, it uses the
TARGET_MANGLE_DECL_ASSEMBLER_NAME hook to change the name before it is written
out to the assembler file.

2022-08-09   Michael Meissner  <meissner@linux.ibm.com>

gcc/

	* config/rs6000/rs6000-c.cc (rs6000_cpu_cpp_builtins): Set
	building_libgcc.
	* config/rs6000/rs6000.cc (create_complex_muldiv): Delete.
	(init_float128_ieee): Delete code to switch complex multiply and divide
	for long double.
	(complex_multiply_builtin_code): New helper function.
	(complex_divide_builtin_code): Likewise.
	(rs6000_mangle_decl_assembler_name): Add support for mangling the name
	of complex 128-bit multiply and divide built-in functions.
	* config/rs6000/rs6000.opt (building_libgcc): New target variable.

==================== work097, patch001

Allow __ibm128 even if IEEE 128-bit floating point is not supported.

This set of patches changes the GCC compiler to allow the use of the __ibm128
keyword if we have IEEE 128-bit floating point support enabled or if long double
is 128-bits.

In addition, checks for requiring hardware floating point to use __ibm128 have
been removed.  This fixes PR target/105534.

2022-08-09   Michael Meissner  <meissner@linux.ibm.com>

gcc/

	PR target/105534
	* config/rs6000/rs6000-builtins.cc (rs6000_init_builtins): Create
	__ibm128 on older machines without IEEE 128-bit support.
	* config/rs6000/rs600.cc (init_float128_ibm): Remove checks for hardware
	floating point for the IBM 128-bit comparisons.
	(rs6000_init_libfuncs): Create IBM 128-bit floating point support even
	if we don't support IEEE 128-bit floating point.
	(rs6000_scalar_mode_supported_p): Allow __ibm128 even if we don't
	support _Float128.
	* config/rs6000/rs6000.h (FLOAT128_IBM_P): Remove checks for
	-mhard-float.
	(TARGET_IBM128): New macro.
	* config/rs6000/rs6000.md (@extenddf<mode>2_fprs): Allow IFmode to be
	converted even if long double is not 128-bits.
	(extenddf<mode>2_vsx): Likewise.
	(extendtfif2): Allow conversion if we have __ibm128 but not IEEE 128-bit
	floating point.
	(trunckftf2): Likewise.

==================== work097, create branch

2022-08-08   Michael Meissner  <meissner@linux.ibm.com>

	Clone branch

