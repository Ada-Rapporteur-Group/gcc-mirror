==================== Work092, patch #6

Allow __ibm128 on systems that support 128-bit long double.

2022-06-27   Michael Meissner  <meissner@linux.ibm.com>

gcc/

	* config/rs6000/rs6000.cc (init_float128_ibm): Allow -msoft-float
	with __ibm128.
	(rs6000_scalar_mode_supported_p): Allow __ibm128 on systems that
	support 128-bit long double.
	* config/rs6000/rs6000.h (FLOAT128_IBM_P): Allow -msoft-float with
	__ibm128.
	* config/rs6000/rs6000.md (unpack<mode>_dm): Likewise.
	(unpack<mode>_nodm): Likewise.

==================== Work092, patch #5

Remove code that depends on __float128 or __ibm128 using the long double type.

2022-06-24   Michael Meissner  <meissner@linux.ibm.com>

gcc/

	* config/rs6000/rs6000-builtin.cc (rs6000_expand_builtin): Remove
	code that assumed __float128 and __ibm128 used the long double
	type if long double uses 128-bit IEEE or IBM encodings
	respectively.

==================== Work092, patch #4

Add __float128 to __ibm128 conversations.

In the past, GCC used the long double type for __ibm128 if long double
used the IBM 128-bit encoding.  Now that we always use a separate internal
type for __ibm128, it exposed that some conversions were missing.

2022-06-24   Michael Meissner  <meissner@linux.ibm.com>

gcc/

	* config/rs6000/rs6000.md (extendkfif2): New insn.
	(trunckfif2): Likewise.

==================== Work092, patch #3

Fix IEEE 128-bit long double Complex multiply and divide tests.

2022-06-23   Michael Meissner  <meissner@linux.ibm.com>

gcc/testsuite/

	* gcc.target/powerpc/mulkd3-2.c: Update test.
	* gcc.target/powerpc/divkd3-2.c: Likewise.

==================== Work092, patch #2

Iterate on getting long double complex multiply and divide working.

2022-06-23   Michael Meissner  <meissner@linux.ibm.com>

gcc/
	* config/rs6000/rs6000-builtin.cc (rs6000_type_string): The type
	for __float128 is __float128, not __ieee128.
	* config/rs6000/rs6000.cc (create_complex_muldiv): Add function
	back in.
	(rs6000_init_libfuncs): Move the IEEE 128-bit complex long double
	multiply and divide support here.  Use the names __multc3_ieee128
	and __divtc3_ieee128.

libgcc/
	* config/rs6000/float128-ifunc.c (__multc3_ieee128): Add
	ifunc support.
	(__divtc3_ieee128): Likewise.
	* config/rs6000/quad-float128.h (__multc3_ieee128): Add
	Declaration.
	(__divtc3_ieee128): Likewise.

==================== Work092, patch #1

__float128 and __ibm128 always gets different internal types.

2022-06-22   Michael Meissner  <meissner@linux.ibm.com>

gcc/
	* config/rs6000/rs6000-builtin.cc (rs6000_init_builtins): Always
	create a new tree node for __ibm128, even if long double uses the
	IBM 128-bit format.  Always create a new tree node for __float128,
	even if long double uses the IEEE 128-bit format.  Change the
	keyword create for IEEE 128-bit to be '__float128', not
	'__ieee128'.
	* config/rs6000/rs6000-c.cc (rs6000_target_modify_macros): Define
	__ieee128 compatibility macro.
	* config/rs6000/rs600.cc (reg_offset_addressing_ok_p): Allow
	IFmode to use offset addresses.
	(create_complex_muldiv): Delete.
	(init_float128_ieee): Do not create __mulkc3 and __divkc3 since
	__float128 always creates these functions.
	(rs6000_libgcc_floating_mode_supported_p): Always allow KFmode.
	(rs6000_floatn_mode): Always return KFmode for IEEE 128-bit.  Do
	not return TFmode, even if long double uses the IEEE 128-bit
	format.
	(rs6000_c_mode_for_suffix): The 'q' suffix always uses KFmode,
	even if long double uses the IEEE 128-bit encoding.

==================== Branch creation

2022-06-22   Michael Meissner  <meissner@linux.ibm.com>

	Clone branch

