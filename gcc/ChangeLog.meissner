==================== Work092, patch #3

Fix IEEE 128-bit long double Complex multiply and divide tests.

2022-06-23   Michael Meissner  <meissner@linux.ibm.com>

gcc/testsuite/

	* gcc.target/powerpc/mulkd3-2.c: Update test.
	* gcc.target/powerpc/divkd3-2.c: Likewise.

==================== Work092, patch #2

Iterate on getting long double complex multiply and divide working.

2022-06-23   Michael Meissner  <meissner@linux.ibm.com>

gcc/
	* config/rs6000/rs6000-builtin.cc (rs6000_type_string): The type
	for __float128 is __float128, not __ieee128.
	* config/rs6000/rs6000.cc (create_complex_muldiv): Add function
	back in.
	(rs6000_init_libfuncs): Move the IEEE 128-bit complex long double
	multiply and divide support here.  Use the names __multc3_ieee128
	and __divtc3_ieee128.

libgcc/
	* config/rs6000/float128-ifunc.c (__multc3_ieee128): Add
	ifunc support.
	(__divtc3_ieee128): Likewise.
	* config/rs6000/quad-float128.h (__multc3_ieee128): Add
	Declaration.
	(__divtc3_ieee128): Likewise.

==================== Work092, patch #1

__float128 and __ibm128 always gets different internal types.

2022-06-22   Michael Meissner  <meissner@linux.ibm.com>

gcc/
	* config/rs6000/rs6000-builtin.cc (rs6000_init_builtins): Always
	create a new tree node for __ibm128, even if long double uses the
	IBM 128-bit format.  Always create a new tree node for __float128,
	even if long double uses the IEEE 128-bit format.  Change the
	keyword create for IEEE 128-bit to be '__float128', not
	'__ieee128'.
	* config/rs6000/rs6000-c.cc (rs6000_target_modify_macros): Define
	__ieee128 compatibility macro.
	* config/rs6000/rs600.cc (reg_offset_addressing_ok_p): Allow
	IFmode to use offset addresses.
	(create_complex_muldiv): Delete.
	(init_float128_ieee): Do not create __mulkc3 and __divkc3 since
	__float128 always creates these functions.
	(rs6000_libgcc_floating_mode_supported_p): Always allow KFmode.
	(rs6000_floatn_mode): Always return KFmode for IEEE 128-bit.  Do
	not return TFmode, even if long double uses the IEEE 128-bit
	format.
	(rs6000_c_mode_for_suffix): The 'q' suffix always uses KFmode,
	even if long double uses the IEEE 128-bit encoding.

==================== Branch creation

2022-06-22   Michael Meissner  <meissner@linux.ibm.com>

	Clone branch

