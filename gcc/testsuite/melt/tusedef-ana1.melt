;; file tusedef-ana1.melt -*- lisp -*-
;; this sample code is in the public domain
#| run in buildir/gcc
 ln -s $GCCMELT_SOURCE/gcc/testsuite/melt/tusedef-ana1.melt
 ln -s $GCCMELT_SOURCE/gcc/testsuite/melt/tusedef-code1.c

 ./cc1 -fmelt-mode=runfile,usedef @meltbuild-common.args -Iinclude/ \
    -fmelt-init=@melt-default-modules.quicklybuilt -fmelt-arg=tusedef-ana1.melt \
     tusedef-code1.c

or in a MELT module

gcc -fplugin=melt -fplugin-arg-melt-mode=runfile,usedef @meltbuild-common.args \
    -fplugin-arg-melt-init=@melt-default-modules.quicklybuilt -fplugin-arg-melt-arg=tusedef-ana1.melt \
     -c tusedef-code1.c -o /dev/null
|#
(module_is_gpl_compatible "public domain")
(defclass class_usedef_data
  :super class_proped
  :fields (usedef_seen_cfun
	   usedef_visited_ssaname	   
	   )
  )


(defvar usedef_count)

(setq usedef_count (box 0))

(defun usedef_gate (pass)
  (debug "usedef_gate usedef_count=" usedef_count)
  (let ( (udata (get_field :gccpass_data pass))
	 (useenf (get_field :usedef_seen_cfun udata))
	 )
    (assert_msg "check udata" (is_a udata class_usedef_data))
    (assert_msg "check useenf" (is_maptree useenf) useenf)
    (with_cfun_decl
     ()
     (:tree cfundecl)
     (debug "usedef_gate cfundecl=" cfundecl " useenf=" useenf)
     (when (maptree_get useenf cfundecl)
       (return ()))
     (let ( (:long cnt (get_int usedef_count))
	    )
       (put_int usedef_count (+i cnt 1))
       (maptree_put useenf cfundecl (constant_box cnt))
       (debug "usedef_gate updated useenf=" useenf)
       (return :true)
     ))))


(defun usedef_walker (data :tree tr :gimple g)
  (debug "usedef_walker data=" data " tr=" tr " g=" g)
  (inform_at (box g) "usedef tree $1 gimple $2" tr g)
  (return :true))

(defun usedef_process_set (data :basic_block bb :gimple g :tree lhs)
  (debug "usedef_process_set data=" data " bb=" bb " g=" g " lhs=" lhs)
  (assert_msg "check udata" (is_a data class_usedef_data))
  (let ( (udmap (get_field :usedef_visited_ssaname data))
	 )
    (assert_msg "check udmap" (is_maptree udmap) udmap)
    (inform_at (box g) "usedef processing gimple $1" g)
    (melt_walk_use_def_chains usedef_walker data lhs)
    (debug "usedef_process_set end lhs=" lhs " g=" g)
    )
  )

(defun usedef_exec (pass)
  (debug "usedef_exec pass=" pass " cfundecl=" (cfun_decl))
  (shortbacktrace_dbg "usedef_exec" 15)
  (let ( (udata (get_field :gccpass_data pass))
	 (udmap (get_field :usedef_visited_ssaname udata))
	 )
    (assert_msg "check udata" (is_a udata class_usedef_data))
    (assert_msg "check udmap" (is_maptree udmap) udmap)
    (with_cfun_decl
     ()
     (:tree cfundecl)
     (debug "usedef_exec cfundecl=" cfundecl)
     (each_bb_current_fun
      ()
      (:basic_block bb)
      (debug "usedef_exec bb=" bb)
      (eachgimple_in_basicblock
       (bb)
       (:gimple g)
       (debug "usedef_exec g=" g)
       (match g
	      (?(gimple_call ?lhs ?fn ?nbargs)
		(debug "usedef_exec gimple_call lhs=" lhs " fn=" fn " nbargs=" nbargs)
		(usedef_process_set udata bb g lhs)
		(void)
		)
	      (?(gimple_assign_to ?lhs)
		(debug "usedef_exec gimple_assign_to lhs=" lhs)
		(usedef_process_set udata bb g lhs)
		)
	      (?_
	       (debug "usedef_exec other g=" g)
	       )
	      )
       )
      )
     (debug "end usedef_exec pass=" pass " cfundecl=" cfundecl)
     (return :true)
     )))


(defun usedef_docmd (cmd moduldata)
  (let ( (udata (instance class_usedef_data
			  :usedef_seen_cfun (make_maptree discr_map_trees 11)
			  :usedef_visited_ssaname (make_maptree discr_map_trees
								19)))
	 (usedefpass
	  (instance class_gcc_gimple_pass
		    :named_name '"melt_usedef_pass"
		    :gccpass_gate usedef_gate
		    :gccpass_exec usedef_exec
		    :gccpass_data udata))
	 )
    (debug "usedef_docmd usedefpass=" usedefpass)
    (install_melt_pass_in_gcc usedefpass :after '"phiopt" 0)
    (return :true)
    ))
    



(definstance usedef_mode
  class_melt_mode
  :named_name '"usedef"
  :meltmode_help '"test for walk usedef"
  :meltmode_fun usedef_docmd
)
(install_melt_mode usedef_mode)
;; eof tusedef-ana1.melt
