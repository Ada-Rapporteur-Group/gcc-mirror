;; file tmulsort.melt -*- lisp -*-

#| run in buildir/gcc
 ln -s $GCCMELT_SOURCE/gcc/testsuite/melt/tmulsort.melt 

 ./cc1plus -fmelt-mode=runfile @meltbuild-common.args \
    -fmelt-init=@warmelt.quicklybuilt -fmelt-arg=tmulsort.melt \
    -fmelt-debugging=mode  meltbuild-empty-file.c
|#


;; a compare function for named which compares only the first four characters
(defun named_less4 (v1 v2)
  (debug "named_less4 start v1=" v1 " v2=" v2)
  (shortbacktrace_dbg "named_less4" 8)
  (let ( (n1 (get_field :named_name v1))
	 (n2 (get_field :named_name v2))
	 (cmpless ())
	 )
    (if (is_string n1)
	(if (is_string n2)
	    (let ( (:long cmp 0)
		   )
	      (debug "named_less4 bothstrings n1=" n1 " n2=" n2)
	      (code_chunk cmp4char_chk
			  #{ /* named_less4 $CMP4CHAR_CHK */
			  $CMP = strncmp(melt_string_str($N1), melt_string_str($N2), 4);
			  }#)
	      (debug "named_less4 cmp=" cmp)
	      (setq cmpless (if (<i cmp 0) :true ()))
	      ))
      (if (is_string n2)
	  (setq cmpless :true)))
    (debug "named_less4 v1=" v1 " v2=" v2 " result cmpless=" cmpless)
    (return cmpless)))
	
;; run our tests	 
(let ( (mytup (tuple 'atom '23 'atomic :true (list 'a 'b)))
       )
  (debug "mytup=" mytup)
  ;;
  (let ( (x 'atom)
	 (y '23))
    (debug "x=" x " y=" y)
    (let ( (ltxy (named_less4 x y))
	   )
      (debug "ltxy=" ltxy)))
  ;;
  (let ( (u 'atom)
	 (v 'atomic))
    (debug "u=" u " v=" v)
    (let ( (ltuv (named_less4 u v))
	   )
      (debug "ltuv=" ltuv)))
  ;;
  (let ( (uu 'atoll)
	 (vv 'atomic))
    (debug "uu=" uu " vv=" vv)
    (let ( (ltuuvv (named_less4 uu vv))
	   )
      (debug "ltuuvv=" ltuuvv)))
  ;;
  (debug "before newsort mytup=" mytup)
  (let ( (newsortedtup (multiple_sort mytup named_less4))
	 )
    (debug "after newsort newsortedtup=" newsortedtup "\n ... mytup=" mytup)
    ))

;; eof tmulsort.melt
