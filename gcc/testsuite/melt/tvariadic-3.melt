; -*- lisp -*-
;; file tvariadic-3.melt


;; in svn rev 181574 the melt_debug_fun failed to compile when
;; uncommenting out faulty code near line 338; we rewrite it with bad
;; added in names to avoid mixing with debug itself..

#| run in buildir/gcc
 ./cc1 -fmelt-mode=runfile -fmelt-module-path=melt-stage3:.    -fmelt-source-path=melt-stage3:. \
    -fmelt-tempdir=/tmp -fmelt-workdir=melt-workdir -fmelt-init=@warmelt \
    -fmelt-arg=$GCCMELT_SOURCE/gcc/testsuite/melt/tvariadic-3.melt \
    -fmelt-module-makefile=$GCCMELT_SOURCE/gcc/melt-module.mk \
    -fmelt-debug empty-file-for-melt.c
|#
(definstance tree_debug_funcontbad class_container)
(definstance gimple_debug_funcontbad class_container)
(definstance gimpleseq_debug_funcontbad class_container)
(definstance edge_debug_funcontbad class_container)
(definstance basicblock_debug_funcontbad class_container)
(definstance loop_debug_funcontbad class_container)
;;; the debug_fun is usually called thru the debug macro.
(defun badmelt_debug_fun (nothing :long count :cstring filename :long lineno :rest)
  (if (melt_need_dbg 0) 
      (let ( (:long dbgcounter 0)
	     (dumpf (get_field :sysdata_dumpfile initial_system_data)) 
	     (stderrf (get_field :sysdata_stderr initial_system_data)) 
	     (out dumpf)
	     (occmap (make_mapobject discr_map_objects 50))
	     (boxedmaxdepth (make_integerbox discr_integer (debug_depth))) ;;;; @@@ DEBUGDEPTH
	     )
	(code_chunk getdbgcounter 
		    #{/*$GETDBGCOUNTER*/ $dbgcounter = melt_dbgcounter ;
		    }#)
	;; if we don't have a dumpfile, use stderr; this may also
	;; happens when the dumpf exists, but its dump_file is null.
	(code_chunk ensuregoodout #{/*$ENSUREGOODOUT*/
		    static int nbwarn	;
		    if (melt_get_file ($OUT) == NULL) {
		    gcc_assert (melt_get_file ($STDERRF) == stderr) ;
		    $OUT = $STDERRF				    ;
		    if (nbwarn++ <= 0) {
		    inform (UNKNOWN_LOCATION, 
			    "MELT debug output goes to stderr because we have no dump_file.") ;
		    }
		    }
		    }#)
	(if (null out)
	    (setq out (get_field :sysdata_stderr initial_system_data)))
	;; it may happen that OUT is null, e.g. because the dumpfile &
	;; the stderr are not yet initialized in
	;; initial_system_data...
	(if (null out)
	    (setq out (make_strbuf discr_strbuf)))
	(assert_msg "check good out" (is_out out))
	(let ( 
	      (dbgi (instance class_debug_information
			      :dbgi_out out
			      :dbgi_occmap occmap
			      :dbgi_maxdepth boxedmaxdepth))
	      (:long framdepth (the_framedepth)) 
	      (:long outlen (output_length out)) 
	      (:long laststroutlen outlen)
	      )
	  (add2out out "!!!!****####" dbgcounter "#^"  (-i framdepth 1) ":")
	  (if filename
	      (add2out out filename ":" lineno ":"))
	  (if (>i count 0) 
	      (progn
		(add2out out " !" count ": ")))
	  (forever 
	   argloop
	   (variadic 
	    ( ()
	      (exit argloop))
	    ( (:long l)
	      (add2out_longdec out l))
	    ( (:cstring s)
	      (let ( (:long curoutlen (output_length out)) 
		     )
		(match s
		       ( ?(cstring_prefixed " ")
			  (if (>i curoutlen (+i laststroutlen 70))
			      (add2out_indentnl out 0)))
		       ( ?_ (void)))
		)
	      (setq laststroutlen (output_length out))
	      (add2out_strconst out s)
	      )
	    ( (:value val)
	      (add2out_strconst out " ")
	      (cond 
	       ( (null val)
		 (add2out_strconst out "(**nil**)"))
	       ( (== (discrim val) discr_debug_closure)
		 (variadic
		  ( ()
		    ;; if a debug closure is the last variadic, we
		    ;; output it as an ordinary value
		    (dbg_out val dbgi 0)
		    )
		  ( (:value vv)
		    (val dbgi vv))
		  ;;; with ggs, it works, with gs already used in containing variadic, it crash the translator
		  ( (:gimple_seq gs)	;gs or ggs?
		    (val dbgi gs))      ;  ""
		  ( (:long ll)
		    (val dbgi ll))
#|
		  ( (:tree tt)
		    (val dbgi tt))
		  ( (:gimple g)
		    (val dbgi g))
		  ( (:edge ed)
		    (val dbgi ed))
		  ( (:loop lo)
		    (val dbgi lo))
|#
		 )
		 (void)
		 )
	       (:else
		 (dbg_out val dbgi 0))))
	    ( (:tree tr)
	      (let ( (tdf !tree_debug_funcontbad)
		     )
		(if (is_closure tdf)
		    (tdf dbgi tr)
		  (if tr
		      (add2out_strconst out " ?*tree*?")
		    (add2out_strconst out " ?*nulltree*?")))))
	    ( (:gimple gi)
	      (let ( (gdf !gimple_debug_funcontbad)
		     )
		(if (is_closure gdf)
		    (gdf dbgi gi)
		  (if gi 
		      (add2out_strconst out " ?*gimple*?") 
		    (add2out_strconst out " ?*nullgimple*?")))))
	    ( (:gimple_seq gs)
	      (let ( (gsdf !gimpleseq_debug_funcontbad)
		     )
		(if (is_closure gsdf)
		    (gsdf dbgi gs)
		  (if gs
		      (add2out_strconst out " ?*gimpleseq*?") 
		    (add2out_strconst out " ?*nullgimpleseq*?")))))
	    ( (:edge ed)
	      (let ( (edf !edge_debug_funcontbad)
		     )
		(if (is_closure edf)
		    (edf dbgi ed)
		  (if ed
		      (add2out_strconst out " ?*edge*?") 
		    (add2out_strconst out " ?*nulledge*?")))))
	    ( (:basic_block bb)
	      (let ( (bdf !basicblock_debug_funcontbad)
		     )
		(if (is_closure bdf)
		    (bdf dbgi bb)
		  (if bb
		      (add2out_strconst out " ?*basicblock*?") 
		    (add2out_strconst out " ?*nullbasicblock*?")))))
	    ( (:loop lo)
	      (let ( (ldf !loop_debug_funcontbad)
		     )
		(if (is_closure ldf)
		    (ldf dbgi lo)
		  (if lo
		      (add2out_strconst out " ?*loop*?") 
		    (add2out_strconst out " ?*loop*?")))))
	    (:else
	     (let ( (vctyp (variadic_ctype 0))
		    (vctypname (get_field :named_name vctyp))
		    )
	       (code_chunk warnbadctype
			   #{/* $WARNBADCTYPE */ 
			   warning (0,
				    "MELT invalid ctype %s in (DEBUG ...) file %s line %d",
				    melt_string_str ((melt_ptr_t) $VCTYPNAME),
				    $FILENAME, $LINENO) ;
			   }#)
	       (add2out out "??:" (get_field :ctype_keyword vctyp) "?? ")
	       )))
	   (setq outlen (output_length out))
	   )
	  (add2out_indentnl out 0)
	  ))))


;; eof tvariadic-3.melt
