=== 0342-ARC-Propagate-uncached-type-attribute-to-each-member.patch ===
From 62a715c706d8482560dadfa9ead0766f3c20e434 Mon Sep 17 00:00:00 2001
From: Claudiu Zissulescu <claziss@gmail.com>
Date: Mon, 27 Jan 2020 14:51:03 +0200
Subject: [PATCH 0342/2034] [ARC] Propagate uncached type attribute to each
 member of a struct.

Like `packed` type attribute, the ARC's `uncached` type attribute
needs to be propagated to each member of the struct where it is used,
triggering the .di flag for any access of the struct members. However,
any complex CFG manipulation may drop memory pointer type attributes,
leading to the impossibility to discriminate the direct accesses from
normal ones. To solve this issue, we will treat the direct memory
accessed specially via unspecs.

gcc/
xxxx-xx-xx  Claudiu Zissulescu  <claziss@synopsys.com>
	Petro Karashchenko  <petro.karashchenko@ring.com>

	* config/arc/arc.c (arc_is_uncached_mem_p): Check struct
	attributes if needed.
	(prepare_move_operands): Generate special
	unspec instruction for direct access.
	(arc_isuncached_mem_p): Propagate uncached attribute to each
	structure member.
	* config/arc/arc.md (VUNSPEC_ARC_LDDI): Define.
	(VUNSPEC_ARC_STDI): Likewise.
	(ALLI): New mode iterator.
	(mALLI): New mode attribute.
	(lddi): New instruction pattern.
	(stdi): Likewise.
	(stdidi_split): Split instruction for architectures which are not
	supporting ll64 option.
	(lddidi_split): Likewise.

testsuite/
xxxx-xx-xx  Claudiu Zissulescu  <claziss@synopsys.com>
	Petro Karashchenko  <petro.karashchenko@ring.com>

	* gcc.target/arc/uncached-1.c: Update test.
	* gcc.target/arc/uncached-2.c: Likewise.
	* gcc.target/arc/uncached-3.c: New test.
	* gcc.target/arc/uncached-4.c: Likewise.
	* gcc.target/arc/uncached-5.c: Likewise.
	* gcc.target/arc/uncached-6.c: Likewise.
	* gcc.target/arc/uncached-7.c: Likewise.
	* gcc.target/arc/uncached-8.c: Likewise.
	* gcc.target/arc/arc.exp (ll64): New predicate.
---
 gcc/ChangeLog                             |  19 ++++
 gcc/config/arc/arc.c                      | 118 ++++++++++++++--------
 gcc/config/arc/arc.md                     |  60 +++++++++++
 gcc/testsuite/ChangeLog                   |  11 ++
 gcc/testsuite/gcc.target/arc/arc.exp      |   9 ++
 gcc/testsuite/gcc.target/arc/uncached-1.c |   2 +-
 gcc/testsuite/gcc.target/arc/uncached-2.c |   2 +-
 gcc/testsuite/gcc.target/arc/uncached-3.c |  22 ++++
 gcc/testsuite/gcc.target/arc/uncached-4.c |  42 ++++++++
 gcc/testsuite/gcc.target/arc/uncached-5.c |  29 ++++++
 gcc/testsuite/gcc.target/arc/uncached-6.c |  35 +++++++
 gcc/testsuite/gcc.target/arc/uncached-7.c |  11 ++
 gcc/testsuite/gcc.target/arc/uncached-8.c |  33 ++++++
 13 files changed, 351 insertions(+), 42 deletions(-)
 create mode 100644 gcc/testsuite/gcc.target/arc/uncached-3.c
 create mode 100644 gcc/testsuite/gcc.target/arc/uncached-4.c
 create mode 100644 gcc/testsuite/gcc.target/arc/uncached-5.c
 create mode 100644 gcc/testsuite/gcc.target/arc/uncached-6.c
 create mode 100644 gcc/testsuite/gcc.target/arc/uncached-7.c
 create mode 100644 gcc/testsuite/gcc.target/arc/uncached-8.c

diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 91dfcd71a4b..2cc61d68cf3 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,22 @@
+2020-01-27  Claudiu Zissulescu  <claziss@synopsys.com>
+	    Petro Karashchenko  <petro.karashchenko@ring.com>
+
+	* config/arc/arc.c (arc_is_uncached_mem_p): Check struct
+	attributes if needed.
+	(prepare_move_operands): Generate special unspec instruction for
+	direct access.
+	(arc_isuncached_mem_p): Propagate uncached attribute to each
+	structure member.
+	* config/arc/arc.md (VUNSPEC_ARC_LDDI): Define.
+	(VUNSPEC_ARC_STDI): Likewise.
+	(ALLI): New mode iterator.
+	(mALLI): New mode attribute.
+	(lddi): New instruction pattern.
+	(stdi): Likewise.
+	(stdidi_split): Split instruction for architectures which are not
+	supporting ll64 option.
+	(lddidi_split): Likewise.
+
 2020-01-27  Richard Sandiford  <richard.sandiford@arm.com>
 
 	PR rtl-optimization/92989
diff --git a/gcc/config/arc/arc.c b/gcc/config/arc/arc.c
index 22475f2732e..e1a865f02e6 100644
--- a/gcc/config/arc/arc.c
+++ b/gcc/config/arc/arc.c
@@ -9091,49 +9091,71 @@ arc_get_aux_arg (rtx pat, int *auxr)
 bool
 prepare_move_operands (rtx *operands, machine_mode mode)
 {
-  /* First handle aux attribute.  */
-  if (mode == SImode
-      && (MEM_P (operands[0]) || MEM_P (operands[1])))
+  if ((MEM_P (operands[0]) || MEM_P (operands[1]))
+      && SCALAR_INT_MODE_P (mode))
     {
-      rtx tmp;
-      int auxr = 0;
-      if (MEM_P (operands[0]) && arc_is_aux_reg_p (operands[0]))
+      /* First handle aux attribute.  */
+      if (mode == SImode)
 	{
-	  /* Save operation.  */
-	  if (arc_get_aux_arg (operands[0], &auxr))
+	  rtx tmp;
+	  int auxr = 0;
+	  if (MEM_P (operands[0]) && arc_is_aux_reg_p (operands[0]))
 	    {
-	      tmp = gen_reg_rtx (SImode);
-	      emit_move_insn (tmp, GEN_INT (auxr));
+	      /* Save operation.  */
+	      if (arc_get_aux_arg (operands[0], &auxr))
+		{
+		  tmp = gen_reg_rtx (SImode);
+		  emit_move_insn (tmp, GEN_INT (auxr));
+		}
+	      else
+		tmp = XEXP (operands[0], 0);
+
+	      operands[1] = force_reg (SImode, operands[1]);
+	      emit_insn (gen_rtx_UNSPEC_VOLATILE
+			 (VOIDmode, gen_rtvec (2, operands[1], tmp),
+			  VUNSPEC_ARC_SR));
+	      return true;
 	    }
-	  else
+	  if (MEM_P (operands[1]) && arc_is_aux_reg_p (operands[1]))
 	    {
-	      tmp = XEXP (operands[0], 0);
+	      if (arc_get_aux_arg (operands[1], &auxr))
+		{
+		  tmp = gen_reg_rtx (SImode);
+		  emit_move_insn (tmp, GEN_INT (auxr));
+		}
+	      else
+		{
+		  tmp = XEXP (operands[1], 0);
+		  gcc_assert (GET_CODE (tmp) == SYMBOL_REF);
+		}
+	      /* Load operation.  */
+	      gcc_assert (REG_P (operands[0]));
+	      emit_insn (gen_rtx_SET (operands[0],
+				      gen_rtx_UNSPEC_VOLATILE
+				      (SImode, gen_rtvec (1, tmp),
+				       VUNSPEC_ARC_LR)));
+	      return true;
 	    }
-
-	  operands[1] = force_reg (SImode, operands[1]);
+	}
+      /* Second, we check for the uncached.  */
+      if (arc_is_uncached_mem_p (operands[0]))
+	{
+	  if (!REG_P (operands[1]))
+	    operands[1] = force_reg (mode, operands[1]);
 	  emit_insn (gen_rtx_UNSPEC_VOLATILE
-		     (VOIDmode, gen_rtvec (2, operands[1], tmp),
-		      VUNSPEC_ARC_SR));
+		     (VOIDmode, gen_rtvec (2, operands[0], operands[1]),
+		      VUNSPEC_ARC_STDI));
 	  return true;
 	}
-      if (MEM_P (operands[1]) && arc_is_aux_reg_p (operands[1]))
+      if (arc_is_uncached_mem_p (operands[1]))
 	{
-	  if (arc_get_aux_arg (operands[1], &auxr))
-	    {
-	      tmp = gen_reg_rtx (SImode);
-	      emit_move_insn (tmp, GEN_INT (auxr));
-	    }
-	  else
-	    {
-	      tmp = XEXP (operands[1], 0);
-	      gcc_assert (GET_CODE (tmp) == SYMBOL_REF);
-	    }
-	  /* Load operation.  */
-	  gcc_assert (REG_P (operands[0]));
-	  emit_insn (gen_rtx_SET (operands[0],
-				  gen_rtx_UNSPEC_VOLATILE
-				  (SImode, gen_rtvec (1, tmp),
-				   VUNSPEC_ARC_LR)));
+	  if (MEM_P (operands[0]))
+	    operands[0] = force_reg (mode, operands[0]);
+	  emit_insn (gen_rtx_SET
+		     (operands[0],
+		      gen_rtx_UNSPEC_VOLATILE
+		      (mode, gen_rtvec (1, operands[1]),
+		       VUNSPEC_ARC_LDDI)));
 	  return true;
 	}
     }
@@ -11162,24 +11184,40 @@ arc_is_uncached_mem_p (rtx pat)
     return false;
 
   /* Get the attributes.  */
-  if (TREE_CODE (addr) == MEM_REF)
+  if (TREE_CODE (addr) == MEM_REF
+      || TREE_CODE (addr) == VAR_DECL)
     {
       attrs = TYPE_ATTRIBUTES (TREE_TYPE (addr));
       if (lookup_attribute ("uncached", attrs))
 	return true;
-
+    }
+  if (TREE_CODE (addr) == MEM_REF)
+    {
       attrs = TYPE_ATTRIBUTES (TREE_TYPE (TREE_OPERAND (addr, 0)));
       if (lookup_attribute ("uncached", attrs))
 	return true;
-    }
-
-  /* For COMPONENT_REF, use the FIELD_DECL from tree operand 1.  */
-  if (TREE_CODE (addr) == COMPONENT_REF)
-    {
       attrs = TYPE_ATTRIBUTES (TREE_TYPE (TREE_OPERAND (addr, 1)));
       if (lookup_attribute ("uncached", attrs))
 	return true;
     }
+
+  /* Check the definitions of the structs.  */
+  while (handled_component_p (addr))
+    {
+      if (TREE_CODE (addr) == COMPONENT_REF)
+	{
+	  attrs = TYPE_ATTRIBUTES (TREE_TYPE (addr));
+	  if (lookup_attribute ("uncached", attrs))
+	    return true;
+	  attrs = TYPE_ATTRIBUTES (TREE_TYPE (TREE_OPERAND (addr, 0)));
+	  if (lookup_attribute ("uncached", attrs))
+	    return true;
+	  attrs = TYPE_ATTRIBUTES (TREE_TYPE (TREE_OPERAND (addr, 1)));
+	  if (lookup_attribute ("uncached", attrs))
+	    return true;
+	}
+      addr = TREE_OPERAND (addr, 0);
+    }
   return false;
 }
 
diff --git a/gcc/config/arc/arc.md b/gcc/config/arc/arc.md
index cf7aa8d83c9..46cb254ed28 100644
--- a/gcc/config/arc/arc.md
+++ b/gcc/config/arc/arc.md
@@ -164,6 +164,8 @@ (define_c_enum "unspec" [
   VUNSPEC_ARC_BLOCKAGE
   VUNSPEC_ARC_EH_RETURN
   VUNSPEC_ARC_ARC600_RTIE
+  VUNSPEC_ARC_LDDI
+  VUNSPEC_ARC_STDI
   ])
 
 (define_constants
@@ -4682,6 +4684,64 @@ (define_insn "sr"
   [(set_attr "length" "8,4,8,4")
    (set_attr "type" "sr,sr,sr,sr")])
 
+(define_mode_iterator ALLI [QI HI SI (DI "TARGET_LL64")])
+(define_mode_attr mALLI [(QI "b") (HI "%_") (SI "") (DI "d")])
+
+(define_insn "lddi<mode>"
+  [(set (match_operand:ALLI 0 "register_operand" "=r")
+	(unspec_volatile:ALLI [(match_operand:ALLI 1 "memory_operand" "m")]
+			      VUNSPEC_ARC_LDDI))]
+  ""
+  "ld<mALLI>%U1.di\\t%0,%1"
+  [(set_attr "type" "load")])
+
+(define_insn "stdi<mode>"
+  [(unspec_volatile [(match_operand:ALLI 0 "memory_operand"    "m,m,Usc")
+		     (match_operand:ALLI 1 "nonmemory_operand" "r,Cm3,i")]
+		    VUNSPEC_ARC_STDI)]
+  ""
+  "st<mALLI>%U0.di\\t%1,%0"
+  [(set_attr "length" "*,*,8")
+   (set_attr "type" "store")])
+
+(define_insn_and_split "*stdidi_split"
+  [(unspec_volatile [(match_operand:DI 0 "memory_operand"   "m")
+		     (match_operand:DI 1 "register_operand" "r")]
+		    VUNSPEC_ARC_STDI)]
+  "!TARGET_LL64"
+  "#"
+  "&& reload_completed"
+  [(unspec_volatile:SI [(match_dup 2) (match_dup 3)] VUNSPEC_ARC_STDI)
+   (unspec_volatile:SI [(match_dup 4) (match_dup 5)] VUNSPEC_ARC_STDI)]
+  "
+  {
+   operands[3] = gen_lowpart (SImode, operands[1]);
+   operands[5] = gen_highpart_mode (SImode, DImode, operands[1]);
+   operands[2] = gen_lowpart (SImode, operands[0]);
+   operands[4] = gen_highpart (SImode, operands[0]);
+  }
+  "
+  )
+
+(define_insn_and_split "*lddidi_split"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(unspec_volatile:DI [(match_operand:DI 1 "memory_operand" "m")]
+			    VUNSPEC_ARC_LDDI))]
+  "!TARGET_LL64"
+  "#"
+  "&& reload_completed"
+  [(set (match_dup 2) (unspec_volatile:SI [(match_dup 3)] VUNSPEC_ARC_LDDI))
+   (set (match_dup 4) (unspec_volatile:SI [(match_dup 5)] VUNSPEC_ARC_LDDI))]
+  "
+  {
+   operands[3] = gen_lowpart (SImode, operands[1]);
+   operands[5] = gen_highpart (SImode, operands[1]);
+   operands[2] = gen_lowpart (SImode, operands[0]);
+   operands[4] = gen_highpart (SImode, operands[0]);
+  }
+  "
+  )
+
 (define_insn "trap_s"
   [(unspec_volatile [(match_operand:SI 0 "immediate_operand" "L,Cal")]
 		   VUNSPEC_ARC_TRAP_S)]
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 16ddef07516..991934272e0 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,14 @@
+2020-01-27  Claudiu Zissulescu  <claziss@synopsys.com>
+	    Petro Karashchenko  <petro.karashchenko@ring.com>
+
+	* gcc.target/arc/uncached-3.c: New test.
+	* gcc.target/arc/uncached-4.c: Likewise.
+	* gcc.target/arc/uncached-5.c: Likewise.
+	* gcc.target/arc/uncached-6.c: Likewise.
+	* gcc.target/arc/uncached-7.c: Likewise.
+	* gcc.target/arc/uncached-8.c: Likewise.
+	* gcc.target/arc/arc.exp (ll64): New predicate.
+
 2020-01-27  Richard Sandiford  <richard.sandiford@arm.com>
 
 	* gcc.dg/torture/pr93170.c: New test.
diff --git a/gcc/testsuite/gcc.target/arc/arc.exp b/gcc/testsuite/gcc.target/arc/arc.exp
index 8d1844edd22..501d4589c53 100644
--- a/gcc/testsuite/gcc.target/arc/arc.exp
+++ b/gcc/testsuite/gcc.target/arc/arc.exp
@@ -122,6 +122,15 @@ proc check_effective_target_dpfp { } {
     }]
 }
 
+# Return 1 if this is a compiler supporting LL64 option.
+proc check_effective_target_ll64 { } {
+    return [check_no_compiler_messages ll64 assembly {
+	#if !defined(__ARC_LL64__)
+	#error No ARC LL64
+	#endif
+    }]
+}
+
 # If a testcase doesn't have special options, use these.
 global DEFAULT_CFLAGS
 if ![info exists DEFAULT_CFLAGS] then {
diff --git a/gcc/testsuite/gcc.target/arc/uncached-1.c b/gcc/testsuite/gcc.target/arc/uncached-1.c
index 7a6bade81c4..fa5ecb7b7d3 100644
--- a/gcc/testsuite/gcc.target/arc/uncached-1.c
+++ b/gcc/testsuite/gcc.target/arc/uncached-1.c
@@ -8,4 +8,4 @@ int get_stat (void)
   return *status;
 }
 
-/* { dg-final { scan-assembler-times "ld\.di" 1 } } */
+/* { dg-final { scan-assembler-times "ld\.di" 2 } } */
diff --git a/gcc/testsuite/gcc.target/arc/uncached-2.c b/gcc/testsuite/gcc.target/arc/uncached-2.c
index 89eed326e01..9d6bfbbb50e 100644
--- a/gcc/testsuite/gcc.target/arc/uncached-2.c
+++ b/gcc/testsuite/gcc.target/arc/uncached-2.c
@@ -6,4 +6,4 @@ void clkgen_switch(unsigned int base, unsigned int offset, int val)
     (volatile unsigned int __attribute__ ((uncached)) *) (base + offset);
   *dest = val;
 }
-/* { dg-final { scan-assembler-times "st\.di" 1 } } */
+/* { dg-final { scan-assembler-times "st\.di" 2 } } */
diff --git a/gcc/testsuite/gcc.target/arc/uncached-3.c b/gcc/testsuite/gcc.target/arc/uncached-3.c
new file mode 100644
index 00000000000..f2a317b2816
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arc/uncached-3.c
@@ -0,0 +1,22 @@
+/* { dg-do compile } */
+
+typedef volatile struct {
+    int a;
+    char *b;
+} __attribute__((uncached)) my_type_t;
+
+my_type_t x;
+
+void foo (my_type_t *p)
+{
+    p->a = 10;
+    p->b = 0;
+}
+
+void bar (void)
+{
+    x.a = 10;
+    x.b = 0;
+}
+
+/* { dg-final { scan-assembler-times "st\.di" 4 } } */
diff --git a/gcc/testsuite/gcc.target/arc/uncached-4.c b/gcc/testsuite/gcc.target/arc/uncached-4.c
new file mode 100644
index 00000000000..fecb16648b8
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arc/uncached-4.c
@@ -0,0 +1,42 @@
+/* { dg-do compile } */
+
+#include <stddef.h>
+
+typedef enum
+{
+ e1,
+ e2
+} my_enum_t;
+
+typedef struct
+{
+  int a;
+  int *p;
+} my_struct_t;
+
+typedef volatile struct
+{
+  my_enum_t a;
+  my_struct_t b;
+} __attribute__((uncached)) my_type_t;
+
+my_type_t x;
+
+void foo (my_type_t *p)
+{
+  p->a = e2;
+  p->b.a = 10;
+  p->b.p = NULL;
+  *p->b.p = 10;
+}
+
+void bar (void)
+{
+  x.a = e2;
+  x.b.a = 10;
+  x.b.p = NULL;
+  *x.b.p = 10;
+}
+
+/* { dg-final { scan-assembler-times "st\.di" 6 } } */
+/* { dg-final { scan-assembler-times "ld\.di" 2 } } */
diff --git a/gcc/testsuite/gcc.target/arc/uncached-5.c b/gcc/testsuite/gcc.target/arc/uncached-5.c
new file mode 100644
index 00000000000..4fe0464fdde
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arc/uncached-5.c
@@ -0,0 +1,29 @@
+/* { dg-options "-O1" } */
+/* { dg-do compile } */
+
+#define RegWrSI(a,v)  (*(volatile __attribute__((uncached)) int *)(a)=(v))
+#define RegWrQI(a,v)  (*(volatile __attribute__((uncached)) char *)(a)=(v))
+#define RegWrHI(a,v)  (*(volatile __attribute__((uncached)) short *)(a)=(v))
+#define RegWrDI(a,v)  (*(volatile __attribute__((uncached)) long long *)(a)=(v))
+
+void foo (int arg, void *p)
+{
+  RegWrDI (p  , arg);
+  RegWrHI (p++, arg);
+  RegWrSI (p++, arg);
+  RegWrQI (p++, arg);
+}
+
+void bar (void)
+{
+  RegWrQI (0x40000, 1);
+  RegWrHI (0x40010, 2);
+  RegWrSI (0x40020, 4);
+  RegWrDI (0x40040, 8);
+}
+
+/* { dg-final { scan-assembler-times "stb\.di" 2 } } */
+/* { dg-final { scan-assembler-times "st\[hw\]\.di" 2 } } */
+/* { dg-final { scan-assembler-times "std\.di" 2 { target { ll64 } } } } */
+/* { dg-final { scan-assembler-times "st\.di" 2 { target { ll64 } } } } */
+/* { dg-final { scan-assembler-times "st\.di" 6 { target { ! { ll64 } } } } } */
diff --git a/gcc/testsuite/gcc.target/arc/uncached-6.c b/gcc/testsuite/gcc.target/arc/uncached-6.c
new file mode 100644
index 00000000000..581a9eccb3b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arc/uncached-6.c
@@ -0,0 +1,35 @@
+/* { dg-options "-O1" } */
+/* { dg-do compile } */
+
+#define RegRdSI(v,a) ((v) = *(volatile __attribute__((uncached)) int *)(a))
+#define RegRdQI(v,a) ((v) = *(volatile __attribute__((uncached)) char *)(a))
+#define RegRdHI(v,a) ((v) = *(volatile __attribute__((uncached)) short *)(a))
+#define RegRdDI(v,a) \
+  ((v) = *(volatile __attribute__((uncached)) long long *)(a))
+
+char a0;
+short a1;
+int a2;
+long long a3;
+
+void foox (void *p)
+{
+  RegRdQI (a0, p++);
+  RegRdHI (a1, p++);
+  RegRdSI (a2, p++);
+  RegRdDI (a3, p  );
+}
+
+void barx (int arg)
+{
+  RegRdQI (a0, 0x40000);
+  RegRdHI (a1, 0x40010);
+  RegRdSI (a2, 0x40020);
+  RegRdDI (a3, 0x40040);
+}
+
+/* { dg-final { scan-assembler-times "ldb\.di" 2 } } */
+/* { dg-final { scan-assembler-times "ld\[hw\]\.di" 2 } } */
+/* { dg-final { scan-assembler-times "ldd\.di" 2 { target { ll64 } } } } */
+/* { dg-final { scan-assembler-times "ld\.di" 2 { target { ll64 } } } } */
+/* { dg-final { scan-assembler-times "ld\.di" 6 { target { ! { ll64 } } } } } */
diff --git a/gcc/testsuite/gcc.target/arc/uncached-7.c b/gcc/testsuite/gcc.target/arc/uncached-7.c
new file mode 100644
index 00000000000..4001b8bd821
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arc/uncached-7.c
@@ -0,0 +1,11 @@
+/* { dg-options "-O1" } */
+/* { dg-do compile } */
+
+volatile __attribute__((uncached)) int s[20];
+
+void s_acc(void)
+{
+    s[10] = 15;
+}
+
+/* { dg-final { scan-assembler-times "st\.di" 1 } } */
diff --git a/gcc/testsuite/gcc.target/arc/uncached-8.c b/gcc/testsuite/gcc.target/arc/uncached-8.c
new file mode 100644
index 00000000000..060229b11df
--- /dev/null
+++ b/gcc/testsuite/gcc.target/arc/uncached-8.c
@@ -0,0 +1,33 @@
+/* { dg-do compile } */
+
+#include <stddef.h>
+
+typedef struct
+{
+  int a;
+} my_structB_t;
+
+typedef struct
+{
+  my_structB_t b;
+} __attribute__((uncached))  my_structA_t;
+
+typedef volatile struct
+{
+  my_structA_t c;
+} my_type_t;
+
+my_type_t x;
+
+void foo (my_type_t *p)
+{
+  p->c.b.a = 10;
+}
+
+void bar (void)
+{
+  x.c.b.a = 10;
+}
+
+/* { dg-final { scan-assembler-times "st\.di" 1 } } */
+/* { dg-final { scan-assembler-times "st\.as\.di" 1 } } */
-- 
2.26.1

=== 0814-sra-Avoid-totally-scalarizing-overallping-field_decl.patch ===
From 665c5bad168ab63629b29ed2ce08ed042c088dc2 Mon Sep 17 00:00:00 2001
From: Martin Jambor <mjambor@suse.cz>
Date: Wed, 19 Feb 2020 11:08:40 +0100
Subject: [PATCH 0814/2034] sra: Avoid totally scalarizing overallping
 field_decls (PR 93667)

[[no_unique_address]] C++ attribute can cause two fields of a
RECORD_TYPE overlap, which currently confuses the totally scalarizing
code into creating invalid access tree.  For GCC 10, I'd like to
simply disable total scalarization of types where this happens.

For GCC 11 I'll write down a TODO item to enable total scalarization
of cases like this where the problematic fields are basically empty -
despite having a non-zero size - i.e. when they are just RECORD_TYPEs
without any data fields.

2020-02-19  Martin Jambor  <mjambor@suse.cz>

	gcc/

	PR tree-optimization/93667
	* tree-sra.c (scalarizable_type_p): Return false if record fields
	do not follow wach other.

	gcc/testsuite/

	PR tree-optimization/93667
	* g++.dg/tree-ssa/pr93667.C: New test.
---
 gcc/ChangeLog                           |  6 ++++++
 gcc/testsuite/ChangeLog                 |  5 +++++
 gcc/testsuite/g++.dg/tree-ssa/pr93667.C | 11 +++++++++++
 gcc/tree-sra.c                          | 14 ++++++++++++++
 4 files changed, 36 insertions(+)
 create mode 100644 gcc/testsuite/g++.dg/tree-ssa/pr93667.C

diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 77c2a9ad810..6b53f9a2f07 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,9 @@
+2020-02-19  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/93667
+	* tree-sra.c (scalarizable_type_p): Return false if record fields
+	do not follow wach other.
+
 2020-01-21  Kito Cheng  <kito.cheng@sifive.com>
 
 	* config/riscv/riscv.c (riscv_output_move) Using fmv.x.w/fmv.w.x
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 9b4fe11a6f6..8033fa0a3bb 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,8 @@
+2020-02-19  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/93667
+	* g++.dg/tree-ssa/pr93667.C: New test.
+
 2020-02-19  Hongtao Liu  <hongtao.liu@intel.com>
 
 	* g++.dg/other/i386-2.C: add -mavx512vbmi2
diff --git a/gcc/testsuite/g++.dg/tree-ssa/pr93667.C b/gcc/testsuite/g++.dg/tree-ssa/pr93667.C
new file mode 100644
index 00000000000..d875f53d9ec
--- /dev/null
+++ b/gcc/testsuite/g++.dg/tree-ssa/pr93667.C
@@ -0,0 +1,11 @@
+// { dg-do compile }
+// { dg-options "-O2 -std=c++2a" } */
+
+struct a {};
+struct b { [[no_unique_address]] a aq; };
+struct c {
+  int d;
+  [[no_unique_address]] b e;
+};
+c f() {return {};}
+void g() { f(); }
diff --git a/gcc/tree-sra.c b/gcc/tree-sra.c
index 0cfac0a8192..4c7d651e6b9 100644
--- a/gcc/tree-sra.c
+++ b/gcc/tree-sra.c
@@ -958,6 +958,9 @@ scalarizable_type_p (tree type, bool const_decl)
   if (type_contains_placeholder_p (type))
     return false;
 
+  bool have_predecessor_field = false;
+  HOST_WIDE_INT prev_pos = 0;
+
   switch (TREE_CODE (type))
   {
   case RECORD_TYPE:
@@ -966,6 +969,17 @@ scalarizable_type_p (tree type, bool const_decl)
 	{
 	  tree ft = TREE_TYPE (fld);
 
+	  if (zerop (DECL_SIZE (fld)))
+	    continue;
+
+	  HOST_WIDE_INT pos = int_bit_position (fld);
+	  if (have_predecessor_field
+	      && pos <= prev_pos)
+	    return false;
+
+	  have_predecessor_field = true;
+	  prev_pos = pos;
+
 	  if (DECL_BIT_FIELD (fld))
 	    return false;
 
-- 
2.26.1

=== 0413-SRA-Total-scalarization-after-access-propagation-PR9.patch ===
From 636e80eea24b780f1d5f4c14c58fc00001df8508 Mon Sep 17 00:00:00 2001
From: Martin Jambor <mjambor@suse.cz>
Date: Wed, 29 Jan 2020 13:13:13 +0100
Subject: [PATCH 0413/2034] SRA: Total scalarization after access propagation
 [PR92706]

2020-01-29  Martin Jambor  <mjambor@suse.cz>

	PR tree-optimization/92706
	* tree-sra.c (struct access): Adjust comment of
	grp_total_scalarization.
	(find_access_in_subtree): Look for single children spanning an entire
	access.
	(scalarizable_type_p): Allow register accesses, adjust callers.
	(completely_scalarize): Remove function.
	(scalarize_elem): Likewise.
	(create_total_scalarization_access): Likewise.
	(sort_and_splice_var_accesses): Do not track total scalarization
	flags.
	(analyze_access_subtree): New parameter totally, adjust to new meaning
	of grp_total_scalarization.
	(analyze_access_trees): Pass new parameter to analyze_access_subtree.
	(can_totally_scalarize_forest_p): New function.
	(create_total_scalarization_access): Likewise.
	(create_total_access_and_reshape): Likewise.
	(total_should_skip_creating_access): Likewise.
	(totally_scalarize_subtree): Likewise.
	(analyze_all_variable_accesses): Perform total scalarization after
	subaccess propagation using the new functions above.
	(initialize_constant_pool_replacements): Output initializers by
	traversing the access tree.

	testsuite/
	* gcc.dg/tree-ssa/pr92706-2.c: New test.
	* gcc.dg/guality/pr59776.c: Xfail tests for s2.g.
---
 gcc/ChangeLog                             |  26 +
 gcc/testsuite/ChangeLog                   |   6 +
 gcc/testsuite/gcc.dg/guality/pr59776.c    |   4 +-
 gcc/testsuite/gcc.dg/tree-ssa/pr92706-2.c |  19 +
 gcc/tree-sra.c                            | 666 ++++++++++++++++------
 5 files changed, 537 insertions(+), 184 deletions(-)
 create mode 100644 gcc/testsuite/gcc.dg/tree-ssa/pr92706-2.c

diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 16247a59304..61da54df346 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,29 @@
+2020-01-29  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/92706
+	* tree-sra.c (struct access): Adjust comment of
+	grp_total_scalarization.
+	(find_access_in_subtree): Look for single children spanning an entire
+	access.
+	(scalarizable_type_p): Allow register accesses, adjust callers.
+	(completely_scalarize): Remove function.
+	(scalarize_elem): Likewise.
+	(create_total_scalarization_access): Likewise.
+	(sort_and_splice_var_accesses): Do not track total scalarization
+	flags.
+	(analyze_access_subtree): New parameter totally, adjust to new meaning
+	of grp_total_scalarization.
+	(analyze_access_trees): Pass new parameter to analyze_access_subtree.
+	(can_totally_scalarize_forest_p): New function.
+	(create_total_scalarization_access): Likewise.
+	(create_total_access_and_reshape): Likewise.
+	(total_should_skip_creating_access): Likewise.
+	(totally_scalarize_subtree): Likewise.
+	(analyze_all_variable_accesses): Perform total scalarization after
+	subaccess propagation using the new functions above.
+	(initialize_constant_pool_replacements): Output initializers by
+	traversing the access tree.
+
 2020-01-29  Martin Jambor  <mjambor@suse.cz>
 
 	* tree-sra.c (verify_sra_access_forest): New function.
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 05518848829..38758207989 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,9 @@
+2020-01-29  Martin Jambor  <mjambor@suse.cz>
+
+	PR tree-optimization/92706
+	* gcc.dg/tree-ssa/pr92706-2.c: New test.
+	* gcc.dg/guality/pr59776.c: Xfail tests for s2.g.
+
 2020-01-28  Jan Hubicka  <hubicka@ucw.cz>
 
 	* gcc.dg/tree-prof/indir-call-prof-2.c: New testcase.
diff --git a/gcc/testsuite/gcc.dg/guality/pr59776.c b/gcc/testsuite/gcc.dg/guality/pr59776.c
index 382abb622bb..6c1c8165b70 100644
--- a/gcc/testsuite/gcc.dg/guality/pr59776.c
+++ b/gcc/testsuite/gcc.dg/guality/pr59776.c
@@ -12,11 +12,11 @@ foo (struct S *p)
   struct S s1, s2;			/* { dg-final { gdb-test pr59776.c:17 "s1.f" "5.0" } } */
   s1 = *p;				/* { dg-final { gdb-test pr59776.c:17 "s1.g" "6.0" } } */
   s2 = s1;				/* { dg-final { gdb-test pr59776.c:17 "s2.f" "0.0" } } */
-  *(int *) &s2.f = 0;			/* { dg-final { gdb-test pr59776.c:17 "s2.g" "6.0" } } */
+  *(int *) &s2.f = 0;			/* { dg-final { gdb-test pr59776.c:17 "s2.g" "6.0" { xfail *-*-* } } } */
   asm volatile (NOP : : : "memory");	/* { dg-final { gdb-test pr59776.c:20 "s1.f" "5.0" } } */
   asm volatile (NOP : : : "memory");	/* { dg-final { gdb-test pr59776.c:20 "s1.g" "6.0" } } */
   s2 = s1;				/* { dg-final { gdb-test pr59776.c:20 "s2.f" "5.0" } } */
-  asm volatile (NOP : : : "memory");	/* { dg-final { gdb-test pr59776.c:20 "s2.g" "6.0" } } */
+  asm volatile (NOP : : : "memory");	/* { dg-final { gdb-test pr59776.c:20 "s2.g" "6.0" { xfail *-*-* } } } */
   asm volatile (NOP : : : "memory");
 }
 
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/pr92706-2.c b/gcc/testsuite/gcc.dg/tree-ssa/pr92706-2.c
new file mode 100644
index 00000000000..37ab9765db0
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/tree-ssa/pr92706-2.c
@@ -0,0 +1,19 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-esra" } */
+
+typedef __UINT64_TYPE__ uint64_t;
+typedef __UINT32_TYPE__ uint32_t;
+struct S { uint32_t i[2]; } __attribute__((aligned(__alignof__(uint64_t))));
+typedef uint64_t my_int64 __attribute__((may_alias));
+uint64_t load (void *p)
+{
+  struct S u, v, w;
+  uint64_t tem;
+  tem = *(my_int64 *)p;
+  *(my_int64 *)&v = tem;
+  u = v;
+  w = u;
+  return *(my_int64 *)&w;
+}
+
+/* { dg-final { scan-tree-dump "Created a replacement for v" "esra" } } */
diff --git a/gcc/tree-sra.c b/gcc/tree-sra.c
index 36106fecaf1..2b0849858de 100644
--- a/gcc/tree-sra.c
+++ b/gcc/tree-sra.c
@@ -211,8 +211,11 @@ struct access
      is not propagated in the access tree in any direction.  */
   unsigned grp_scalar_write : 1;
 
-  /* Is this access an artificial one created to scalarize some record
-     entirely? */
+  /* In a root of an access tree, true means that the entire tree should be
+     totally scalarized - that all scalar leafs should be scalarized and
+     non-root grp_total_scalarization accesses should be honored.  Otherwise,
+     non-root accesses with grp_total_scalarization should never get scalar
+     replacements.  */
   unsigned grp_total_scalarization : 1;
 
   /* Other passes of the analysis use this bit to make function
@@ -485,6 +488,15 @@ find_access_in_subtree (struct access *access, HOST_WIDE_INT offset,
       access = child;
     }
 
+  /* Total scalarization does not replace single field structures with their
+     single field but rather creates an access for them underneath.  Look for
+     it.  */
+  if (access)
+    while (access->first_child
+	   && access->first_child->offset == offset
+	   && access->first_child->size == size)
+      access = access->first_child;
+
   return access;
 }
 
@@ -856,7 +868,8 @@ create_access (tree expr, gimple *stmt, bool write)
 static bool
 scalarizable_type_p (tree type, bool const_decl)
 {
-  gcc_assert (!is_gimple_reg_type (type));
+  if (is_gimple_reg_type (type))
+    return true;
   if (type_contains_placeholder_p (type))
     return false;
 
@@ -871,8 +884,7 @@ scalarizable_type_p (tree type, bool const_decl)
 	  if (DECL_BIT_FIELD (fld))
 	    return false;
 
-	  if (!is_gimple_reg_type (ft)
-	      && !scalarizable_type_p (ft, const_decl))
+	  if (!scalarizable_type_p (ft, const_decl))
 	    return false;
 	}
 
@@ -902,8 +914,7 @@ scalarizable_type_p (tree type, bool const_decl)
 	return false;
 
       tree elem = TREE_TYPE (type);
-      if (!is_gimple_reg_type (elem)
-	  && !scalarizable_type_p (elem, const_decl))
+      if (!scalarizable_type_p (elem, const_decl))
 	return false;
       return true;
     }
@@ -912,114 +923,6 @@ scalarizable_type_p (tree type, bool const_decl)
   }
 }
 
-static void scalarize_elem (tree, HOST_WIDE_INT, HOST_WIDE_INT, bool, tree, tree);
-
-/* Create total_scalarization accesses for all scalar fields of a member
-   of type DECL_TYPE conforming to scalarizable_type_p.  BASE
-   must be the top-most VAR_DECL representing the variable; within that,
-   OFFSET locates the member and REF must be the memory reference expression for
-   the member.  */
-
-static void
-completely_scalarize (tree base, tree decl_type, HOST_WIDE_INT offset, tree ref)
-{
-  switch (TREE_CODE (decl_type))
-    {
-    case RECORD_TYPE:
-      for (tree fld = TYPE_FIELDS (decl_type); fld; fld = DECL_CHAIN (fld))
-	if (TREE_CODE (fld) == FIELD_DECL)
-	  {
-	    HOST_WIDE_INT pos = offset + int_bit_position (fld);
-	    tree ft = TREE_TYPE (fld);
-	    tree nref = build3 (COMPONENT_REF, ft, ref, fld, NULL_TREE);
-
-	    scalarize_elem (base, pos, tree_to_uhwi (DECL_SIZE (fld)),
-			    TYPE_REVERSE_STORAGE_ORDER (decl_type),
-			    nref, ft);
-	  }
-      break;
-    case ARRAY_TYPE:
-      {
-	tree elemtype = TREE_TYPE (decl_type);
-	tree elem_size = TYPE_SIZE (elemtype);
-	gcc_assert (elem_size && tree_fits_shwi_p (elem_size));
-	HOST_WIDE_INT el_size = tree_to_shwi (elem_size);
-	gcc_assert (el_size > 0);
-
-	tree minidx = TYPE_MIN_VALUE (TYPE_DOMAIN (decl_type));
-	gcc_assert (TREE_CODE (minidx) == INTEGER_CST);
-	tree maxidx = TYPE_MAX_VALUE (TYPE_DOMAIN (decl_type));
-	/* Skip (some) zero-length arrays; others have MAXIDX == MINIDX - 1.  */
-	if (maxidx)
-	  {
-	    gcc_assert (TREE_CODE (maxidx) == INTEGER_CST);
-	    tree domain = TYPE_DOMAIN (decl_type);
-	    /* MINIDX and MAXIDX are inclusive, and must be interpreted in
-	       DOMAIN (e.g. signed int, whereas min/max may be size_int).  */
-	    offset_int idx = wi::to_offset (minidx);
-	    offset_int max = wi::to_offset (maxidx);
-	    if (!TYPE_UNSIGNED (domain))
-	      {
-		idx = wi::sext (idx, TYPE_PRECISION (domain));
-		max = wi::sext (max, TYPE_PRECISION (domain));
-	      }
-	    for (int el_off = offset; idx <= max; ++idx)
-	      {
-		tree nref = build4 (ARRAY_REF, elemtype,
-				    ref,
-				    wide_int_to_tree (domain, idx),
-				    NULL_TREE, NULL_TREE);
-		scalarize_elem (base, el_off, el_size,
-				TYPE_REVERSE_STORAGE_ORDER (decl_type),
-				nref, elemtype);
-		el_off += el_size;
-	      }
-	  }
-      }
-      break;
-    default:
-      gcc_unreachable ();
-    }
-}
-
-/* Create total_scalarization accesses for a member of type TYPE, which must
-   satisfy either is_gimple_reg_type or scalarizable_type_p.  BASE must be the
-   top-most VAR_DECL representing the variable; within that, POS and SIZE locate
-   the member, REVERSE gives its torage order. and REF must be the reference
-   expression for it.  */
-
-static void
-scalarize_elem (tree base, HOST_WIDE_INT pos, HOST_WIDE_INT size, bool reverse,
-		tree ref, tree type)
-{
-  if (is_gimple_reg_type (type))
-  {
-    struct access *access = create_access_1 (base, pos, size);
-    access->expr = ref;
-    access->type = type;
-    access->grp_total_scalarization = 1;
-    access->reverse = reverse;
-    /* Accesses for intraprocedural SRA can have their stmt NULL.  */
-  }
-  else
-    completely_scalarize (base, type, pos, ref);
-}
-
-/* Create a total_scalarization access for VAR as a whole.  VAR must be of a
-   RECORD_TYPE or ARRAY_TYPE conforming to scalarizable_type_p.  */
-
-static void
-create_total_scalarization_access (tree var)
-{
-  HOST_WIDE_INT size = tree_to_uhwi (DECL_SIZE (var));
-  struct access *access;
-
-  access = create_access_1 (var, 0, size);
-  access->expr = var;
-  access->type = TREE_TYPE (var);
-  access->grp_total_scalarization = 1;
-}
-
 /* Return true if REF has an VIEW_CONVERT_EXPR somewhere in it.  */
 
 static inline bool
@@ -2029,7 +1932,6 @@ sort_and_splice_var_accesses (tree var)
       bool grp_assignment_read = access->grp_assignment_read;
       bool grp_assignment_write = access->grp_assignment_write;
       bool multiple_scalar_reads = false;
-      bool total_scalarization = access->grp_total_scalarization;
       bool grp_partial_lhs = access->grp_partial_lhs;
       bool first_scalar = is_gimple_reg_type (access->type);
       bool unscalarizable_region = access->grp_unscalarizable_region;
@@ -2081,7 +1983,6 @@ sort_and_splice_var_accesses (tree var)
 	  grp_assignment_write |= ac2->grp_assignment_write;
 	  grp_partial_lhs |= ac2->grp_partial_lhs;
 	  unscalarizable_region |= ac2->grp_unscalarizable_region;
-	  total_scalarization |= ac2->grp_total_scalarization;
 	  relink_to_new_repr (access, ac2);
 
 	  /* If there are both aggregate-type and scalar-type accesses with
@@ -2122,9 +2023,7 @@ sort_and_splice_var_accesses (tree var)
       access->grp_scalar_write = grp_scalar_write;
       access->grp_assignment_read = grp_assignment_read;
       access->grp_assignment_write = grp_assignment_write;
-      access->grp_hint = total_scalarization
-	|| (multiple_scalar_reads && !constant_decl_p (var));
-      access->grp_total_scalarization = total_scalarization;
+      access->grp_hint = multiple_scalar_reads && !constant_decl_p (var);
       access->grp_partial_lhs = grp_partial_lhs;
       access->grp_unscalarizable_region = unscalarizable_region;
       access->grp_same_access_path = grp_same_access_path;
@@ -2420,15 +2319,16 @@ expr_with_var_bounded_array_refs_p (tree expr)
 }
 
 /* Analyze the subtree of accesses rooted in ROOT, scheduling replacements when
-   both seeming beneficial and when ALLOW_REPLACEMENTS allows it.  Also set all
-   sorts of access flags appropriately along the way, notably always set
-   grp_read and grp_assign_read according to MARK_READ and grp_write when
-   MARK_WRITE is true.
+   both seeming beneficial and when ALLOW_REPLACEMENTS allows it.  If TOTALLY
+   is set, we are totally scalarizing the aggregate.  Also set all sorts of
+   access flags appropriately along the way, notably always set grp_read and
+   grp_assign_read according to MARK_READ and grp_write when MARK_WRITE is
+   true.
 
    Creating a replacement for a scalar access is considered beneficial if its
-   grp_hint is set (this means we are either attempting total scalarization or
-   there is more than one direct read access) or according to the following
-   table:
+   grp_hint ot TOTALLY is set (this means either that there is more than one
+   direct read access or that we are attempting total scalarization) or
+   according to the following table:
 
    Access written to through a scalar type (once or more times)
    |
@@ -2459,7 +2359,7 @@ expr_with_var_bounded_array_refs_p (tree expr)
 
 static bool
 analyze_access_subtree (struct access *root, struct access *parent,
-			bool allow_replacements)
+			bool allow_replacements, bool totally)
 {
   struct access *child;
   HOST_WIDE_INT limit = root->offset + root->size;
@@ -2477,8 +2377,6 @@ analyze_access_subtree (struct access *root, struct access *parent,
 	root->grp_write = 1;
       if (parent->grp_assignment_write)
 	root->grp_assignment_write = 1;
-      if (parent->grp_total_scalarization)
-	root->grp_total_scalarization = 1;
       if (!parent->grp_same_access_path)
 	root->grp_same_access_path = 0;
     }
@@ -2493,10 +2391,10 @@ analyze_access_subtree (struct access *root, struct access *parent,
     {
       hole |= covered_to < child->offset;
       sth_created |= analyze_access_subtree (child, root,
-					     allow_replacements && !scalar);
+					     allow_replacements && !scalar,
+					     totally);
 
       root->grp_unscalarized_data |= child->grp_unscalarized_data;
-      root->grp_total_scalarization &= child->grp_total_scalarization;
       if (child->grp_covered)
 	covered_to += child->size;
       else
@@ -2504,7 +2402,9 @@ analyze_access_subtree (struct access *root, struct access *parent,
     }
 
   if (allow_replacements && scalar && !root->first_child
-      && (root->grp_hint
+      && (totally || !root->grp_total_scalarization)
+      && (totally
+	  || root->grp_hint
 	  || ((root->grp_scalar_read || root->grp_assignment_read)
 	      && (root->grp_scalar_write || root->grp_assignment_write))))
     {
@@ -2546,6 +2446,7 @@ analyze_access_subtree (struct access *root, struct access *parent,
     {
       if (allow_replacements
 	  && scalar && !root->first_child
+	  && !root->grp_total_scalarization
 	  && (root->grp_scalar_write || root->grp_assignment_write)
 	  && !bitmap_bit_p (cannot_scalarize_away_bitmap,
 			    DECL_UID (root->base)))
@@ -2566,7 +2467,7 @@ analyze_access_subtree (struct access *root, struct access *parent,
 	root->grp_total_scalarization = 0;
     }
 
-  if (!hole || root->grp_total_scalarization)
+  if (!hole || totally)
     root->grp_covered = 1;
   else if (root->grp_write || comes_initialized_p (root->base))
     root->grp_unscalarized_data = 1; /* not covered and written to */
@@ -2582,7 +2483,8 @@ analyze_access_trees (struct access *access)
 
   while (access)
     {
-      if (analyze_access_subtree (access, NULL, true))
+      if (analyze_access_subtree (access, NULL, true,
+				  access->grp_total_scalarization))
 	ret = true;
       access = access->next_grp;
     }
@@ -2855,6 +2757,369 @@ propagate_all_subaccesses (void)
     }
 }
 
+/* Return true if the forest beginning with ROOT does not contain
+   unscalarizable regions or non-byte aligned accesses.  */
+
+static bool
+can_totally_scalarize_forest_p (struct access *root)
+{
+  struct access *access = root;
+  do
+    {
+      if (access->grp_unscalarizable_region
+	  || (access->offset % BITS_PER_UNIT) != 0
+	  || (access->size % BITS_PER_UNIT) != 0
+	  || (is_gimple_reg_type (access->type)
+	      && access->first_child))
+	return false;
+
+      if (access->first_child)
+	access = access->first_child;
+      else if (access->next_sibling)
+	access = access->next_sibling;
+      else
+	{
+	  while (access->parent && !access->next_sibling)
+	    access = access->parent;
+	  if (access->next_sibling)
+	    access = access->next_sibling;
+	  else
+	    {
+	      gcc_assert (access == root);
+	      root = root->next_grp;
+	      access = root;
+	    }
+	}
+    }
+  while (access);
+  return true;
+}
+
+/* Create and return an ACCESS in PARENT spanning from POS with SIZE, TYPE and
+   reference EXPR for total scalarization purposes and mark it as such.  Within
+   the children of PARENT, link it in between PTR and NEXT_SIBLING.  */
+
+static struct access *
+create_total_scalarization_access (struct access *parent, HOST_WIDE_INT pos,
+				   HOST_WIDE_INT size, tree type, tree expr,
+				   struct access **ptr,
+				   struct access *next_sibling)
+{
+  struct access *access = access_pool.allocate ();
+  memset (access, 0, sizeof (struct access));
+  access->base = parent->base;
+  access->offset = pos;
+  access->size = size;
+  access->expr = expr;
+  access->type = type;
+  access->parent = parent;
+  access->grp_write = parent->grp_write;
+  access->grp_total_scalarization = 1;
+  access->grp_hint = 1;
+  access->grp_same_access_path = path_comparable_for_same_access (expr);
+  access->reverse = reverse_storage_order_for_component_p (expr);
+
+  access->next_sibling = next_sibling;
+  *ptr = access;
+  return access;
+}
+
+/* Create and return an ACCESS in PARENT spanning from POS with SIZE, TYPE and
+   reference EXPR for total scalarization purposes and mark it as such, link it
+   at *PTR and reshape the tree so that those elements at *PTR and their
+   siblings which fall within the part described by POS and SIZE are moved to
+   be children of the new access.  If a partial overlap is detected, return
+   NULL.  */
+
+static struct access *
+create_total_access_and_reshape (struct access *parent, HOST_WIDE_INT pos,
+				 HOST_WIDE_INT size, tree type, tree expr,
+				 struct access **ptr)
+{
+  struct access **p = ptr;
+
+  while (*p && (*p)->offset < pos + size)
+    {
+      if ((*p)->offset + (*p)->size > pos + size)
+	return NULL;
+      p = &(*p)->next_sibling;
+    }
+
+  struct access *next_child = *ptr;
+  struct access *new_acc
+    = create_total_scalarization_access (parent, pos, size, type, expr,
+					 ptr, *p);
+  if (p != ptr)
+    {
+      new_acc->first_child = next_child;
+      *p = NULL;
+      for (struct access *a = next_child; a; a = a->next_sibling)
+	a->parent = new_acc;
+    }
+  return new_acc;
+}
+
+static bool totally_scalarize_subtree (struct access *root);
+
+/* Return true if INNER is either the same type as OUTER or if it is the type
+   of a record field in OUTER at offset zero, possibly in nested
+   sub-records.  */
+
+static bool
+access_and_field_type_match_p (tree outer, tree inner)
+{
+  if (TYPE_MAIN_VARIANT (outer) == TYPE_MAIN_VARIANT (inner))
+    return true;
+  if (TREE_CODE (outer) != RECORD_TYPE)
+    return false;
+  tree fld = TYPE_FIELDS (outer);
+  while (fld)
+    {
+     if (TREE_CODE (fld) == FIELD_DECL)
+       {
+	if (!zerop (DECL_FIELD_OFFSET (fld)))
+	  return false;
+	if (TYPE_MAIN_VARIANT (TREE_TYPE (fld)) == inner)
+	  return true;
+	if (TREE_CODE (TREE_TYPE (fld)) == RECORD_TYPE)
+	  fld = TYPE_FIELDS (TREE_TYPE (fld));
+	else
+	  return false;
+       }
+     else
+       fld = DECL_CHAIN (fld);
+    }
+  return false;
+}
+
+/* Return type of total_should_skip_creating_access indicating whether a total
+   scalarization access for a field/element should be created, whether it
+   already exists or whether the entire total scalarization has to fail.  */
+
+enum total_sra_field_state {TOTAL_FLD_CREATE, TOTAL_FLD_DONE, TOTAL_FLD_FAILED};
+
+/* Do all the necessary steps in total scalarization when the given aggregate
+   type has a TYPE at POS with the given SIZE should be put into PARENT and
+   when we have processed all its siblings with smaller offsets up until and
+   including LAST_SEEN_SIBLING (which can be NULL).
+
+   If some further siblings are to be skipped, set *LAST_SEEN_SIBLING as
+   appropriate.  Return TOTAL_FLD_CREATE id the caller should carry on with
+   creating a new access, TOTAL_FLD_DONE if access or accesses capable of
+   representing the described part of the aggregate for the purposes of total
+   scalarization already exist or TOTAL_FLD_FAILED if there is a problem which
+   prevents total scalarization from happening at all.  */
+
+static enum total_sra_field_state
+total_should_skip_creating_access (struct access *parent,
+				   struct access **last_seen_sibling,
+				   tree type, HOST_WIDE_INT pos,
+				   HOST_WIDE_INT size)
+{
+  struct access *next_child;
+  if (!*last_seen_sibling)
+    next_child = parent->first_child;
+  else
+    next_child = (*last_seen_sibling)->next_sibling;
+
+  /* First, traverse the chain of siblings until it points to an access with
+     offset at least equal to POS.  Check all skipped accesses whether they
+     span the POS boundary and if so, return with a failure.  */
+  while (next_child && next_child->offset < pos)
+    {
+      if (next_child->offset + next_child->size > pos)
+	return TOTAL_FLD_FAILED;
+      *last_seen_sibling = next_child;
+      next_child = next_child->next_sibling;
+    }
+
+  /* Now check whether next_child has exactly the right POS and SIZE and if so,
+     whether it can represent what we need and can be totally scalarized
+     itself.  */
+  if (next_child && next_child->offset == pos
+      && next_child->size == size)
+    {
+      if (!is_gimple_reg_type (next_child->type)
+	  && (!access_and_field_type_match_p (type, next_child->type)
+	      || !totally_scalarize_subtree (next_child)))
+	return TOTAL_FLD_FAILED;
+
+      *last_seen_sibling = next_child;
+      return TOTAL_FLD_DONE;
+    }
+
+  /* If the child we're looking at would partially overlap, we just cannot
+     totally scalarize.  */
+  if (next_child
+      && next_child->offset < pos + size
+      && next_child->offset + next_child->size > pos + size)
+    return TOTAL_FLD_FAILED;
+
+  if (is_gimple_reg_type (type))
+    {
+      /* We don't scalarize accesses that are children of other scalar type
+	 accesses, so if we go on and create an access for a register type,
+	 there should not be any pre-existing children.  There are rare cases
+	 where the requested type is a vector but we already have register
+	 accesses for all its elements which is equally good.  Detect that
+	 situation or whether we need to bail out.  */
+
+      HOST_WIDE_INT covered = pos;
+      bool skipping = false;
+      while (next_child
+	     && next_child->offset + next_child->size <= pos + size)
+	{
+	  if (next_child->offset != covered
+	      || !is_gimple_reg_type (next_child->type))
+	    return TOTAL_FLD_FAILED;
+
+	  covered += next_child->size;
+	  *last_seen_sibling = next_child;
+	  next_child = next_child->next_sibling;
+	  skipping = true;
+	}
+
+      if (skipping)
+	{
+	  if (covered != pos + size)
+	    return TOTAL_FLD_FAILED;
+	  else
+	    return TOTAL_FLD_DONE;
+	}
+    }
+
+  return TOTAL_FLD_CREATE;
+}
+
+/* Go over sub-tree rooted in ROOT and attempt to create scalar accesses
+   spanning all uncovered areas covered by ROOT, return false if the attempt
+   failed.  All created accesses will have grp_unscalarizable_region set (and
+   should be ignored if the function returns false).  */
+
+static bool
+totally_scalarize_subtree (struct access *root)
+{
+  gcc_checking_assert (!root->grp_unscalarizable_region);
+  gcc_checking_assert (!is_gimple_reg_type (root->type));
+
+  struct access *last_seen_sibling = NULL;
+
+  switch (TREE_CODE (root->type))
+    {
+    case RECORD_TYPE:
+      for (tree fld = TYPE_FIELDS (root->type); fld; fld = DECL_CHAIN (fld))
+	if (TREE_CODE (fld) == FIELD_DECL)
+	  {
+	    tree ft = TREE_TYPE (fld);
+	    HOST_WIDE_INT fsize = tree_to_uhwi (DECL_SIZE (fld));
+	    if (!fsize)
+	      continue;
+
+	    HOST_WIDE_INT pos = root->offset + int_bit_position (fld);
+	    enum total_sra_field_state
+	      state = total_should_skip_creating_access (root,
+							 &last_seen_sibling,
+							 ft, pos, fsize);
+	    switch (state)
+	      {
+	      case TOTAL_FLD_FAILED:
+		return false;
+	      case TOTAL_FLD_DONE:
+		continue;
+	      case TOTAL_FLD_CREATE:
+		break;
+	      default:
+		gcc_unreachable ();
+	      }
+
+	    struct access **p = (last_seen_sibling
+				 ? &last_seen_sibling->next_sibling
+				 : &root->first_child);
+	    tree nref = build3 (COMPONENT_REF, ft, root->expr, fld, NULL_TREE);
+	    struct access *new_child
+	      = create_total_access_and_reshape (root, pos, fsize, ft, nref, p);
+	    if (!new_child)
+	      return false;
+
+	    if (!is_gimple_reg_type (ft)
+		&& !totally_scalarize_subtree (new_child))
+	      return false;
+	    last_seen_sibling = new_child;
+	  }
+      break;
+    case ARRAY_TYPE:
+      {
+	tree elemtype = TREE_TYPE (root->type);
+	tree elem_size = TYPE_SIZE (elemtype);
+	gcc_assert (elem_size && tree_fits_shwi_p (elem_size));
+	HOST_WIDE_INT el_size = tree_to_shwi (elem_size);
+	gcc_assert (el_size > 0);
+
+	tree minidx = TYPE_MIN_VALUE (TYPE_DOMAIN (root->type));
+	gcc_assert (TREE_CODE (minidx) == INTEGER_CST);
+	tree maxidx = TYPE_MAX_VALUE (TYPE_DOMAIN (root->type));
+	/* Skip (some) zero-length arrays; others have MAXIDX == MINIDX - 1.  */
+	if (!maxidx)
+	  goto out;
+	gcc_assert (TREE_CODE (maxidx) == INTEGER_CST);
+	tree domain = TYPE_DOMAIN (root->type);
+	/* MINIDX and MAXIDX are inclusive, and must be interpreted in
+	   DOMAIN (e.g. signed int, whereas min/max may be size_int).  */
+	offset_int idx = wi::to_offset (minidx);
+	offset_int max = wi::to_offset (maxidx);
+	if (!TYPE_UNSIGNED (domain))
+	  {
+	    idx = wi::sext (idx, TYPE_PRECISION (domain));
+	    max = wi::sext (max, TYPE_PRECISION (domain));
+	  }
+	for (HOST_WIDE_INT pos = root->offset;
+	     idx <= max;
+	     pos += el_size, ++idx)
+	  {
+	    enum total_sra_field_state
+	      state = total_should_skip_creating_access (root,
+							 &last_seen_sibling,
+							 elemtype, pos,
+							 el_size);
+	    switch (state)
+	      {
+	      case TOTAL_FLD_FAILED:
+		return false;
+	      case TOTAL_FLD_DONE:
+		continue;
+	      case TOTAL_FLD_CREATE:
+		break;
+	      default:
+		gcc_unreachable ();
+	      }
+
+	    struct access **p = (last_seen_sibling
+				 ? &last_seen_sibling->next_sibling
+				 : &root->first_child);
+	    tree nref = build4 (ARRAY_REF, elemtype, root->expr,
+				wide_int_to_tree (domain, idx),
+				NULL_TREE, NULL_TREE);
+	    struct access *new_child
+	      = create_total_access_and_reshape (root, pos, el_size, elemtype,
+						 nref, p);
+	    if (!new_child)
+	      return false;
+
+	    if (!is_gimple_reg_type (elemtype)
+		&& !totally_scalarize_subtree (new_child))
+	      return false;
+	    last_seen_sibling = new_child;
+	  }
+      }
+      break;
+    default:
+      gcc_unreachable ();
+    }
+
+ out:
+  return true;
+}
+
 /* Go through all accesses collected throughout the (intraprocedural) analysis
    stage, exclude overlapping ones, identify representatives and build trees
    out of them, making decisions about scalarization on the way.  Return true
@@ -2867,8 +3132,22 @@ analyze_all_variable_accesses (void)
   bitmap tmp = BITMAP_ALLOC (NULL);
   bitmap_iterator bi;
   unsigned i;
-  bool optimize_speed_p = !optimize_function_for_size_p (cfun);
 
+  bitmap_copy (tmp, candidate_bitmap);
+  EXECUTE_IF_SET_IN_BITMAP (tmp, 0, i, bi)
+    {
+      tree var = candidate (i);
+      struct access *access;
+
+      access = sort_and_splice_var_accesses (var);
+      if (!access || !build_access_trees (access))
+	disqualify_candidate (var,
+			      "No or inhibitingly overlapping accesses.");
+    }
+
+  propagate_all_subaccesses ();
+
+  bool optimize_speed_p = !optimize_function_for_size_p (cfun);
   /* If the user didn't set PARAM_SRA_MAX_SCALARIZATION_SIZE_<...>,
      fall back to a target default.  */
   unsigned HOST_WIDE_INT max_scalarization_size
@@ -2884,7 +3163,6 @@ analyze_all_variable_accesses (void)
       if (global_options_set.x_param_sra_max_scalarization_size_size)
 	max_scalarization_size = param_sra_max_scalarization_size_size;
     }
-
   max_scalarization_size *= BITS_PER_UNIT;
 
   EXECUTE_IF_SET_IN_BITMAP (candidate_bitmap, 0, i, bi)
@@ -2892,46 +3170,56 @@ analyze_all_variable_accesses (void)
 	&& !bitmap_bit_p (cannot_scalarize_away_bitmap, i))
       {
 	tree var = candidate (i);
+	if (!VAR_P (var))
+	  continue;
 
-	if (VAR_P (var) && scalarizable_type_p (TREE_TYPE (var),
-						constant_decl_p (var)))
+	if (tree_to_uhwi (TYPE_SIZE (TREE_TYPE (var))) > max_scalarization_size)
 	  {
-	    if (tree_to_uhwi (TYPE_SIZE (TREE_TYPE (var)))
-		<= max_scalarization_size)
-	      {
-		create_total_scalarization_access (var);
-		completely_scalarize (var, TREE_TYPE (var), 0, var);
-		statistics_counter_event (cfun,
-					  "Totally-scalarized aggregates", 1);
-		if (dump_file && (dump_flags & TDF_DETAILS))
-		  {
-		    fprintf (dump_file, "Will attempt to totally scalarize ");
-		    print_generic_expr (dump_file, var);
-		    fprintf (dump_file, " (UID: %u): \n", DECL_UID (var));
-		  }
-	      }
-	    else if (dump_file && (dump_flags & TDF_DETAILS))
+	    if (dump_file && (dump_flags & TDF_DETAILS))
 	      {
 		fprintf (dump_file, "Too big to totally scalarize: ");
 		print_generic_expr (dump_file, var);
 		fprintf (dump_file, " (UID: %u)\n", DECL_UID (var));
 	      }
+	    continue;
 	  }
-      }
 
-  bitmap_copy (tmp, candidate_bitmap);
-  EXECUTE_IF_SET_IN_BITMAP (tmp, 0, i, bi)
-    {
-      tree var = candidate (i);
-      struct access *access;
+	bool all_types_ok = true;
+	for (struct access *access = get_first_repr_for_decl (var);
+	     access;
+	     access = access->next_grp)
+	  if (!can_totally_scalarize_forest_p (access)
+	      || !scalarizable_type_p (access->type, constant_decl_p (var)))
+	    {
+	      all_types_ok = false;
+	      break;
+	    }
+	if (!all_types_ok)
+	  continue;
 
-      access = sort_and_splice_var_accesses (var);
-      if (!access || !build_access_trees (access))
-	disqualify_candidate (var,
-			      "No or inhibitingly overlapping accesses.");
-    }
+	if (dump_file && (dump_flags & TDF_DETAILS))
+	  {
+	    fprintf (dump_file, "Will attempt to totally scalarize ");
+	    print_generic_expr (dump_file, var);
+	    fprintf (dump_file, " (UID: %u): \n", DECL_UID (var));
+	  }
+	bool scalarized = true;
+	for (struct access *access = get_first_repr_for_decl (var);
+	     access;
+	     access = access->next_grp)
+	  if (!is_gimple_reg_type (access->type)
+	      && !totally_scalarize_subtree (access))
+	    {
+	      scalarized = false;
+	      break;
+	    }
 
-  propagate_all_subaccesses ();
+	if (scalarized)
+	  for (struct access *access = get_first_repr_for_decl (var);
+	       access;
+	       access = access->next_grp)
+	    access->grp_total_scalarization = true;
+      }
 
   if (flag_checking)
     verify_all_sra_access_forests ();
@@ -3804,25 +4092,39 @@ initialize_constant_pool_replacements (void)
       tree var = candidate (i);
       if (!constant_decl_p (var))
 	continue;
-      vec<access_p> *access_vec = get_base_access_vector (var);
-      if (!access_vec)
-	continue;
-      for (unsigned i = 0; i < access_vec->length (); i++)
+
+      struct access *access = get_first_repr_for_decl (var);
+
+      while (access)
 	{
-	  struct access *access = (*access_vec)[i];
-	  if (!access->replacement_decl)
-	    continue;
-	  gassign *stmt
-	    = gimple_build_assign (get_access_replacement (access),
-				   unshare_expr (access->expr));
-	  if (dump_file && (dump_flags & TDF_DETAILS))
+	  if (access->replacement_decl)
 	    {
-	      fprintf (dump_file, "Generating constant initializer: ");
-	      print_gimple_stmt (dump_file, stmt, 0);
-	      fprintf (dump_file, "\n");
+	      gassign *stmt
+		= gimple_build_assign (get_access_replacement (access),
+				       unshare_expr (access->expr));
+	      if (dump_file && (dump_flags & TDF_DETAILS))
+		{
+		  fprintf (dump_file, "Generating constant initializer: ");
+		  print_gimple_stmt (dump_file, stmt, 0);
+		  fprintf (dump_file, "\n");
+		}
+	      gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);
+	      update_stmt (stmt);
+	    }
+
+	  if (access->first_child)
+	    access = access->first_child;
+	  else if (access->next_sibling)
+	    access = access->next_sibling;
+	  else
+	    {
+	      while (access->parent && !access->next_sibling)
+		access = access->parent;
+	      if (access->next_sibling)
+		access = access->next_sibling;
+	      else
+		access = access->next_grp;
 	    }
-	  gsi_insert_after (&gsi, stmt, GSI_NEW_STMT);
-	  update_stmt (stmt);
 	}
     }
 
-- 
2.26.1

=== 0334-Do-not-generate-a-unique-fnname-for-resolver.patch ===
From c2bd2b4664be8b73f8fd58a64dec1e93871797cc Mon Sep 17 00:00:00 2001
From: Martin Liska <mliska@suse.cz>
Date: Mon, 27 Jan 2020 10:48:18 +0100
Subject: [PATCH 0334/2034] Do not generate a unique fnname for resolver.

	PR target/93274
	* config/i386/i386-features.c (make_resolver_func):
	Align the code with ppc64 target implementation.
	Do not generate a unique name for resolver function.
	PR target/93274
	* gcc.target/i386/pr81213.c: Adjust to not expect
	a globally unique name.
---
 gcc/ChangeLog                           |  7 +++++++
 gcc/config/i386/i386-features.c         | 19 ++++---------------
 gcc/testsuite/ChangeLog                 |  6 ++++++
 gcc/testsuite/gcc.target/i386/pr81213.c |  4 ++--
 4 files changed, 19 insertions(+), 17 deletions(-)

diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 45075840824..59806baa757 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,10 @@
+2020-01-27  Martin Liska  <mliska@suse.cz>
+
+	PR target/93274
+	* config/i386/i386-features.c (make_resolver_func):
+	Align the code with ppc64 target implementation.
+	Do not generate a unique name for resolver function.
+
 2020-01-27  Richard Biener  <rguenther@suse.de>
 
 	PR tree-optimization/93397
diff --git a/gcc/config/i386/i386-features.c b/gcc/config/i386/i386-features.c
index e580b26b995..b49e6f8d408 100644
--- a/gcc/config/i386/i386-features.c
+++ b/gcc/config/i386/i386-features.c
@@ -2738,26 +2738,16 @@ make_resolver_func (const tree default_decl,
 		    const tree ifunc_alias_decl,
 		    basic_block *empty_bb)
 {
-  char *resolver_name;
-  tree decl, type, decl_name, t;
+  tree decl, type, t;
 
-  /* IFUNC's have to be globally visible.  So, if the default_decl is
-     not, then the name of the IFUNC should be made unique.  */
-  if (TREE_PUBLIC (default_decl) == 0)
-    {
-      char *ifunc_name = make_unique_name (default_decl, "ifunc", true);
-      symtab->change_decl_assembler_name (ifunc_alias_decl,
-					  get_identifier (ifunc_name));
-      XDELETEVEC (ifunc_name);
-    }
-
-  resolver_name = make_unique_name (default_decl, "resolver", false);
+  /* Create resolver function name based on default_decl.  */
+  tree decl_name = clone_function_name (default_decl, "resolver");
+  const char *resolver_name = IDENTIFIER_POINTER (decl_name);
 
   /* The resolver function should return a (void *). */
   type = build_function_type_list (ptr_type_node, NULL_TREE);
 
   decl = build_fn_decl (resolver_name, type);
-  decl_name = get_identifier (resolver_name);
   SET_DECL_ASSEMBLER_NAME (decl, decl_name);
 
   DECL_NAME (decl) = decl_name;
@@ -2809,7 +2799,6 @@ make_resolver_func (const tree default_decl,
 
   /* Create the alias for dispatch to resolver here.  */
   cgraph_node::create_same_body_alias (ifunc_alias_decl, decl);
-  XDELETEVEC (resolver_name);
   return decl;
 }
 
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 2de060843d9..22a37dd1ab2 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,9 @@
+2020-01-27  Martin Liska  <mliska@suse.cz>
+
+	PR target/93274
+	* gcc.target/i386/pr81213.c: Adjust to not expect
+	a globally unique name.
+
 2020-01-27  Richard Biener  <rguenther@suse.de>
 
 	PR tree-optimization/93397
diff --git a/gcc/testsuite/gcc.target/i386/pr81213.c b/gcc/testsuite/gcc.target/i386/pr81213.c
index 13e15d5fef0..89c47529861 100644
--- a/gcc/testsuite/gcc.target/i386/pr81213.c
+++ b/gcc/testsuite/gcc.target/i386/pr81213.c
@@ -14,6 +14,6 @@ int main()
   return foo();
 }
 
-/* { dg-final { scan-assembler "\t.globl\tfoo\\..*\\.ifunc" } } */
+/* { dg-final { scan-assembler "\t.globl\tfoo" } } */
 /* { dg-final { scan-assembler "foo.resolver:" } } */
-/* { dg-final { scan-assembler "foo\\..*\\.ifunc, @gnu_indirect_function" } } */
+/* { dg-final { scan-assembler "foo\\, @gnu_indirect_function" } } */
-- 
2.26.1

=== 1850-List-valid-pairs-for-new-and-delete-operators.patch ===
From d7a65edb629a010f7ef907d457343abcb569fab7 Mon Sep 17 00:00:00 2001
From: Martin Liska <mliska@suse.cz>
Date: Thu, 16 Apr 2020 15:39:22 +0200
Subject: [PATCH 1850/2034] List valid pairs for new and delete operators.

	PR c++/94314
	* cgraphclones.c (set_new_clone_decl_and_node_flags): Drop
	DECL_IS_REPLACEABLE_OPERATOR during cloning.
	* tree-ssa-dce.c (valid_new_delete_pair_p): New function.
	(propagate_necessity): Check operator names.

	PR c++/94314
	* g++.dg/pr94314.C: Do not use dg-additional-options
	and remove not needed stdio.h include.
	* g++.dg/pr94314-2.C: Likewise.
	* g++.dg/pr94314-3.C: Likewise.
	* g++.dg/pr94314-4.C: New test.

Co-Authored-By: Jakub Jelinek <jakub@redhat.com>
---
 gcc/ChangeLog                    |  9 +++
 gcc/cgraphclones.c               |  2 +
 gcc/testsuite/ChangeLog          | 10 ++++
 gcc/testsuite/g++.dg/pr94314-2.C |  5 +-
 gcc/testsuite/g++.dg/pr94314-3.C |  5 +-
 gcc/testsuite/g++.dg/pr94314-4.C | 30 ++++++++++
 gcc/testsuite/g++.dg/pr94314.C   |  5 +-
 gcc/tree-ssa-dce.c               | 98 ++++++++++++++++++++++++++++----
 8 files changed, 142 insertions(+), 22 deletions(-)
 create mode 100644 gcc/testsuite/g++.dg/pr94314-4.C

diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 74dbeeb44c6..9e499ec9c86 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,12 @@
+2020-04-16  Martin Liska  <mliska@suse.cz>
+	    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/94314
+	* cgraphclones.c (set_new_clone_decl_and_node_flags): Drop
+	DECL_IS_REPLACEABLE_OPERATOR during cloning.
+	* tree-ssa-dce.c (valid_new_delete_pair_p): New function.
+	(propagate_necessity): Check operator names.
+
 2020-04-16  Richard Sandiford  <richard.sandiford@arm.com>
 
 	PR rtl-optimization/94605
diff --git a/gcc/cgraphclones.c b/gcc/cgraphclones.c
index c73b8f810f0..8f541a28b6e 100644
--- a/gcc/cgraphclones.c
+++ b/gcc/cgraphclones.c
@@ -165,6 +165,7 @@ set_new_clone_decl_and_node_flags (cgraph_node *new_node)
   DECL_STATIC_DESTRUCTOR (new_node->decl) = 0;
   DECL_SET_IS_OPERATOR_NEW (new_node->decl, 0);
   DECL_SET_IS_OPERATOR_DELETE (new_node->decl, 0);
+  DECL_IS_REPLACEABLE_OPERATOR (new_node->decl) = 0;
 
   new_node->externally_visible = 0;
   new_node->local = 1;
@@ -1030,6 +1031,7 @@ cgraph_node::create_version_clone_with_body
   DECL_STATIC_DESTRUCTOR (new_decl) = 0;
   DECL_SET_IS_OPERATOR_NEW (new_decl, 0);
   DECL_SET_IS_OPERATOR_DELETE (new_decl, 0);
+  DECL_IS_REPLACEABLE_OPERATOR (new_decl) = 0;
 
   /* Create the new version's call-graph node.
      and update the edges of the new node. */
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 756f1d759e6..94d2312022d 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,13 @@
+2020-04-16  Martin Liska  <mliska@suse.cz>
+	    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/94314
+	* g++.dg/pr94314.C: Do not use dg-additional-options
+	and remove not needed stdio.h include.
+	* g++.dg/pr94314-2.C: Likewise.
+	* g++.dg/pr94314-3.C: Likewise.
+	* g++.dg/pr94314-4.C: New test.
+
 2020-04-16  Patrick Palka  <ppalka@redhat.com>
 
 	PR c++/94475
diff --git a/gcc/testsuite/g++.dg/pr94314-2.C b/gcc/testsuite/g++.dg/pr94314-2.C
index 36b93ed6d4d..998ce601767 100644
--- a/gcc/testsuite/g++.dg/pr94314-2.C
+++ b/gcc/testsuite/g++.dg/pr94314-2.C
@@ -1,9 +1,6 @@
 /* PR c++/94314.  */
 /* { dg-do run } */
-/* { dg-options "-O2 -fdump-tree-cddce-details" } */
-/* { dg-additional-options "-fdelete-null-pointer-checks" } */
-
-#include <stdio.h>
+/* { dg-options "-O2 -fdump-tree-cddce-details -fdelete-null-pointer-checks" } */
 
 struct A
 {
diff --git a/gcc/testsuite/g++.dg/pr94314-3.C b/gcc/testsuite/g++.dg/pr94314-3.C
index 575ba9d8ad8..846a5d6a3d8 100644
--- a/gcc/testsuite/g++.dg/pr94314-3.C
+++ b/gcc/testsuite/g++.dg/pr94314-3.C
@@ -1,9 +1,6 @@
 /* PR c++/94314.  */
 /* { dg-do run } */
-/* { dg-options "-O2 --param early-inlining-insns=100 -fdump-tree-cddce-details" } */
-/* { dg-additional-options "-fdelete-null-pointer-checks" } */
-
-#include <stdio.h>
+/* { dg-options "-O2 --param early-inlining-insns=100 -fdump-tree-cddce-details -fdelete-null-pointer-checks" } */
 
 volatile int idx;
 
diff --git a/gcc/testsuite/g++.dg/pr94314-4.C b/gcc/testsuite/g++.dg/pr94314-4.C
new file mode 100644
index 00000000000..d097f29d4ad
--- /dev/null
+++ b/gcc/testsuite/g++.dg/pr94314-4.C
@@ -0,0 +1,30 @@
+/* PR c++/94314.  */
+/* { dg-do run { target c++11 } } */
+/* { dg-options "-O2 -fdump-tree-cddce-details -fdelete-null-pointer-checks" } */
+
+int count = 0;
+
+__attribute__((malloc, noinline)) void* operator new[](__SIZE_TYPE__ sz) {
+  ++count;
+  return ::operator new(sz);
+}
+
+void operator delete[](void* ptr) noexcept {
+  --count;
+  ::operator delete(ptr);
+}
+
+void operator delete[](void* ptr, __SIZE_TYPE__ sz) noexcept {
+  --count;
+  ::operator delete(ptr, sz);
+}
+
+int main() {
+  delete[] new int[1];
+  if (count != 0)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump-not "Deleting : operator delete" "cddce1"} } */
diff --git a/gcc/testsuite/g++.dg/pr94314.C b/gcc/testsuite/g++.dg/pr94314.C
index 86e651d10ba..4e5ae122e9f 100644
--- a/gcc/testsuite/g++.dg/pr94314.C
+++ b/gcc/testsuite/g++.dg/pr94314.C
@@ -1,9 +1,6 @@
 /* PR c++/94314.  */
 /* { dg-do run } */
-/* { dg-options "-O2 -fdump-tree-cddce-details" } */
-/* { dg-additional-options "-fdelete-null-pointer-checks" } */
-
-#include <stdio.h>
+/* { dg-options "-O2 -fdump-tree-cddce-details -fdelete-null-pointer-checks" } */
 
 struct A
 {
diff --git a/gcc/tree-ssa-dce.c b/gcc/tree-ssa-dce.c
index fd5f24c746c..757cfad5b5e 100644
--- a/gcc/tree-ssa-dce.c
+++ b/gcc/tree-ssa-dce.c
@@ -646,6 +646,77 @@ degenerate_phi_p (gimple *phi)
   return true;
 }
 
+/* Return that NEW_CALL and DELETE_CALL are a valid pair of new
+   and delete  operators.  */
+
+static bool
+valid_new_delete_pair_p (gimple *new_call, gimple *delete_call)
+{
+  tree new_asm = DECL_ASSEMBLER_NAME (gimple_call_fndecl (new_call));
+  tree delete_asm = DECL_ASSEMBLER_NAME (gimple_call_fndecl (delete_call));
+  const char *new_name = IDENTIFIER_POINTER (new_asm);
+  const char *delete_name = IDENTIFIER_POINTER (delete_asm);
+  unsigned int new_len = IDENTIFIER_LENGTH (new_asm);
+  unsigned int delete_len = IDENTIFIER_LENGTH (delete_asm);
+
+  if (new_len < 5 || delete_len < 6)
+    return false;
+  if (new_name[0] == '_')
+    ++new_name, --new_len;
+  if (new_name[0] == '_')
+    ++new_name, --new_len;
+  if (delete_name[0] == '_')
+    ++delete_name, --delete_len;
+  if (delete_name[0] == '_')
+    ++delete_name, --delete_len;
+  if (new_len < 4 || delete_len < 5)
+    return false;
+  /* *_len is now just the length after initial underscores.  */
+  if (new_name[0] != 'Z' || new_name[1] != 'n')
+    return false;
+  if (delete_name[0] != 'Z' || delete_name[1] != 'd')
+    return false;
+  /* _Znw must match _Zdl, _Zna must match _Zda.  */
+  if ((new_name[2] != 'w' || delete_name[2] != 'l')
+      && (new_name[2] != 'a' || delete_name[2] != 'a'))
+    return false;
+  /* 'j', 'm' and 'y' correspond to size_t.  */
+  if (new_name[3] != 'j' && new_name[3] != 'm' && new_name[3] != 'y')
+    return false;
+  if (delete_name[3] != 'P' || delete_name[4] != 'v')
+    return false;
+  if (new_len == 4
+      || (new_len == 18 && !memcmp (new_name + 4, "RKSt9nothrow_t", 14)))
+    {
+      /* _ZnXY or _ZnXYRKSt9nothrow_t matches
+	 _ZdXPv, _ZdXPvY and _ZdXPvRKSt9nothrow_t.  */
+      if (delete_len == 5)
+	return true;
+      if (delete_len == 6 && delete_name[5] == new_name[3])
+	return true;
+      if (delete_len == 19 && !memcmp (delete_name + 5, "RKSt9nothrow_t", 14))
+	return true;
+    }
+  else if ((new_len == 19 && !memcmp (new_name + 4, "St11align_val_t", 15))
+	   || (new_len == 33
+	       && !memcmp (new_name + 4, "St11align_val_tRKSt9nothrow_t", 29)))
+    {
+      /* _ZnXYSt11align_val_t or _ZnXYSt11align_val_tRKSt9nothrow_t matches
+	 _ZdXPvSt11align_val_t or _ZdXPvYSt11align_val_t or  or
+	 _ZdXPvSt11align_val_tRKSt9nothrow_t.  */
+      if (delete_len == 20 && !memcmp (delete_name + 5, "St11align_val_t", 15))
+	return true;
+      if (delete_len == 21
+	  && delete_name[5] == new_name[3]
+	  && !memcmp (delete_name + 6, "St11align_val_t", 15))
+	return true;
+      if (delete_len == 34
+	  && !memcmp (delete_name + 5, "St11align_val_tRKSt9nothrow_t", 29))
+	return true;
+    }
+  return false;
+}
+
 /* Propagate necessity using the operands of necessary statements.
    Process the uses on each statement in the worklist, and add all
    feeding statements which contribute to the calculation of this
@@ -824,16 +895,23 @@ propagate_necessity (bool aggressive)
 			   || DECL_FUNCTION_CODE (def_callee) == BUILT_IN_CALLOC))
 		      || DECL_IS_REPLACEABLE_OPERATOR_NEW_P (def_callee)))
 		{
-		  /* Delete operators can have alignment and (or) size as next
-		     arguments.  When being a SSA_NAME, they must be marked
-		     as necessary.  */
-		  if (is_delete_operator && gimple_call_num_args (stmt) >= 2)
-		    for (unsigned i = 1; i < gimple_call_num_args (stmt); i++)
-		      {
-			tree arg = gimple_call_arg (stmt, i);
-			if (TREE_CODE (arg) == SSA_NAME)
-			  mark_operand_necessary (arg);
-		      }
+		  if (is_delete_operator)
+		    {
+		      if (!valid_new_delete_pair_p (def_stmt, stmt))
+			mark_operand_necessary (gimple_call_arg (stmt, 0));
+
+		      /* Delete operators can have alignment and (or) size
+			 as next arguments.  When being a SSA_NAME, they
+			 must be marked as necessary.  */
+		      if (gimple_call_num_args (stmt) >= 2)
+			for (unsigned i = 1; i < gimple_call_num_args (stmt);
+			     i++)
+			  {
+			    tree arg = gimple_call_arg (stmt, i);
+			    if (TREE_CODE (arg) == SSA_NAME)
+			      mark_operand_necessary (arg);
+			  }
+		    }
 
 		  continue;
 		}
-- 
2.26.1

=== 0085-Daily-bump.patch ===
From 03647d2e26176bb874460b67deab0c30aa715d59 Mon Sep 17 00:00:00 2001
From: GCC Administrator <gccadmin@gcc.gnu.org>
Date: Thu, 16 Jan 2020 00:16:32 +0000
Subject: [PATCH 0085/2034] Daily bump.

---
 gcc/DATESTAMP | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/gcc/DATESTAMP b/gcc/DATESTAMP
index ba948c594d4..62611957f86 100644
--- a/gcc/DATESTAMP
+++ b/gcc/DATESTAMP
@@ -1 +1 @@
-20200115
+20200116
-- 
2.26.1

=== 0040-PR90916-ICE-in-retrieve-specialization.patch ===
From a5a3c2dcf73aa245b0eb6f6cf56c4d03ab6056da Mon Sep 17 00:00:00 2001
From: Nathan Sidwell <nathans@fb.com>
Date: Tue, 14 Jan 2020 11:12:40 -0800
Subject: [PATCH 0040/2034] [PR90916] ICE in retrieve specialization

https://gcc.gnu.org/ml/gcc-patches/2020-01/msg00809.html
	PR c++/90916
	* pt.c (retrieve_specialization): Get the TI from the decl or the
	classtype as appropriate.
---
 gcc/cp/ChangeLog                        |  6 ++++++
 gcc/cp/pt.c                             | 15 ++++++++++-----
 gcc/testsuite/g++.dg/template/pr90916.C |  8 ++++++++
 3 files changed, 24 insertions(+), 5 deletions(-)
 create mode 100644 gcc/testsuite/g++.dg/template/pr90916.C

diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
index 004ce0fdcdf..3cc7c48b490 100644
--- a/gcc/cp/ChangeLog
+++ b/gcc/cp/ChangeLog
@@ -1,3 +1,9 @@
+2020-01-14  Nathan Sidwell  <nathan@acm.org>
+
+	PR c++/90916
+	* pt.c (retrieve_specialization): Get the TI from the decl or the
+	classtype as appropriate.
+
 2020-01-14  David Malcolm  <dmalcolm@redhat.com>
 
 	* cp-gimplify.c (source_location_table_entry_hash::empty_zero_p):
diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
index fa82ecad233..4fdc74f9ca8 100644
--- a/gcc/cp/pt.c
+++ b/gcc/cp/pt.c
@@ -1252,11 +1252,16 @@ retrieve_specialization (tree tmpl, tree args, hashval_t hash)
       for (ovl_iterator iter (fns); iter; ++iter)
 	{
 	  tree fn = *iter;
-	  if (DECL_TEMPLATE_INFO (fn) && DECL_TI_TEMPLATE (fn) == tmpl
-	      /* using-declarations can add base methods to the method vec,
-		 and we don't want those here.  */
-	      && DECL_CONTEXT (fn) == class_specialization)
-	    return fn;
+	  if (tree ti = (TREE_CODE (fn) == TYPE_DECL && !TYPE_DECL_ALIAS_P (fn)
+			 ? TYPE_TEMPLATE_INFO (TREE_TYPE (fn))
+			 : DECL_TEMPLATE_INFO (fn)))
+	    if (TI_TEMPLATE (ti) == tmpl
+		/* using-declarations can bring in a different
+		   instantiation of tmpl as a member of a different
+		   instantiation of tmpl's class.  We don't want those
+		   here.  */
+		&& DECL_CONTEXT (fn) == class_specialization)
+	      return fn;
 	}
       return NULL_TREE;
     }
diff --git a/gcc/testsuite/g++.dg/template/pr90916.C b/gcc/testsuite/g++.dg/template/pr90916.C
new file mode 100644
index 00000000000..bdb7e7b58ef
--- /dev/null
+++ b/gcc/testsuite/g++.dg/template/pr90916.C
@@ -0,0 +1,8 @@
+// PR c++/90916 ICE in retrieve_specialization
+
+template <typename> struct S
+{
+  struct A;
+  struct f A ();
+};
+template class S <int>;
-- 
2.26.1

=== 2004-amdgcn-Check-HSA-return-codes-PR94629.patch ===
From 966de09be91c639d66d252c9ae6ab8da5ebfca18 Mon Sep 17 00:00:00 2001
From: Andrew Stubbs <ams@codesourcery.com>
Date: Mon, 20 Apr 2020 15:25:31 +0100
Subject: [PATCH 2004/2034] amdgcn: Check HSA return codes [PR94629]

Ensure that the returned status values are not ignored.  The old code was
not broken, but this is both safer and satisfies static analysis.

2020-04-23  Andrew Stubbs  <ams@codesourcery.com>

	PR other/94629

	libgomp/
	* plugin/plugin-gcn.c (init_hsa_context): Check return value from
	hsa_iterate_agents.
	(GOMP_OFFLOAD_init_device): Check return values from both calls to
	hsa_agent_iterate_regions.
---
 libgomp/ChangeLog           | 9 +++++++++
 libgomp/plugin/plugin-gcn.c | 8 ++++++++
 2 files changed, 17 insertions(+)

diff --git a/libgomp/ChangeLog b/libgomp/ChangeLog
index c524abbbfb6..ee1764d4ae3 100644
--- a/libgomp/ChangeLog
+++ b/libgomp/ChangeLog
@@ -1,3 +1,12 @@
+2020-04-23  Andrew Stubbs  <ams@codesourcery.com>
+
+	PR other/94629
+
+	* plugin/plugin-gcn.c (init_hsa_context): Check return value from
+	hsa_iterate_agents.
+	(GOMP_OFFLOAD_init_device): Check return values from both calls to
+	hsa_agent_iterate_regions.
+
 2020-04-20  Thomas Schwinge  <thomas@codesourcery.com>
 
 	PR middle-end/94635
diff --git a/libgomp/plugin/plugin-gcn.c b/libgomp/plugin/plugin-gcn.c
index dc72c90962c..4c6a4c03b6e 100644
--- a/libgomp/plugin/plugin-gcn.c
+++ b/libgomp/plugin/plugin-gcn.c
@@ -1508,6 +1508,8 @@ init_hsa_context (void)
     = GOMP_PLUGIN_malloc_cleared (hsa_context.agent_count
 				  * sizeof (struct agent_info));
   status = hsa_fns.hsa_iterate_agents_fn (assign_agent_ids, &agent_index);
+  if (status != HSA_STATUS_SUCCESS)
+    return hsa_error ("Scanning compute agents failed", status);
   if (agent_index != hsa_context.agent_count)
     {
       GOMP_PLUGIN_error ("Failed to assign IDs to all GCN agents");
@@ -3473,6 +3475,9 @@ GOMP_OFFLOAD_init_device (int n)
   status = hsa_fns.hsa_agent_iterate_regions_fn (agent->id,
 						 get_kernarg_memory_region,
 						 &agent->kernarg_region);
+  if (status != HSA_STATUS_SUCCESS
+      && status != HSA_STATUS_INFO_BREAK)
+    hsa_error ("Scanning memory regions failed", status);
   if (agent->kernarg_region.handle == (uint64_t) -1)
     {
       GOMP_PLUGIN_error ("Could not find suitable memory region for kernel "
@@ -3486,6 +3491,9 @@ GOMP_OFFLOAD_init_device (int n)
   status = hsa_fns.hsa_agent_iterate_regions_fn (agent->id,
 						 get_data_memory_region,
 						 &agent->data_region);
+  if (status != HSA_STATUS_SUCCESS
+      && status != HSA_STATUS_INFO_BREAK)
+    hsa_error ("Scanning memory regions failed", status);
   if (agent->data_region.handle == (uint64_t) -1)
     {
       GOMP_PLUGIN_error ("Could not find suitable memory region for device "
-- 
2.26.1

=== 0198-Change-recursive-prepare_block_for_update-to-use-a-w.patch ===
From 6fc2f9337311c11dabcc464c808cbef205f17a52 Mon Sep 17 00:00:00 2001
From: Andrew Pinski <apinski@marvell.com>
Date: Tue, 21 Jan 2020 08:34:42 +0000
Subject: [PATCH 0198/2034] Change recursive prepare_block_for_update to use a
 worklist

Reported as PR 93321, prepare_block_for_update with some huge
recusive inlining can go past the stack limit. Transforming this
recursive into worklist improves the stack usage here and we no
longer seg fault for the testcase.  Note the order we walk the siblings
change.

ChangeLog:
	PR tree-opt/93321
	* tree-into-ssa.c (prepare_block_for_update_1): Split out from ...
	(prepare_block_for_update): This.  Use a worklist instead of recursing.
---
 gcc/ChangeLog       |  8 ++++++
 gcc/tree-into-ssa.c | 59 ++++++++++++++++++++++++++++++++++++---------
 2 files changed, 55 insertions(+), 12 deletions(-)

diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 8c17e5992d2..262f0d6506f 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,11 @@
+2020-01-21  Andrew Pinski  <apinski@marvel.com>
+
+	PR tree-opt/93321
+	* tree-into-ssa.c (prepare_block_for_update_1): Split out
+	from ...
+	(prepare_block_for_update): This.  Use a worklist instead of
+	recursing.
+
 2020-01-21  Mihail-Calin Ionescu  <mihail.ionescu@arm.com>
 
 	* gcc/config/arm/arm.c (clear_operation_p):
diff --git a/gcc/tree-into-ssa.c b/gcc/tree-into-ssa.c
index c27bf2ce121..6528acac31a 100644
--- a/gcc/tree-into-ssa.c
+++ b/gcc/tree-into-ssa.c
@@ -2593,11 +2593,9 @@ mark_use_interesting (tree var, gimple *stmt, basic_block bb,
     }
 }
 
-
-/* Do a dominator walk starting at BB processing statements that
-   reference symbols in SSA operands.  This is very similar to
-   mark_def_sites, but the scan handles statements whose operands may
-   already be SSA names.
+/* Processing statements in BB that reference symbols in SSA operands.
+   This is very similar to mark_def_sites, but the scan handles
+   statements whose operands may already be SSA names.
 
    If INSERT_PHI_P is true, mark those uses as live in the
    corresponding block.  This is later used by the PHI placement
@@ -2610,9 +2608,8 @@ mark_use_interesting (tree var, gimple *stmt, basic_block bb,
 	   that.  */
 
 static void
-prepare_block_for_update (basic_block bb, bool insert_phi_p)
+prepare_block_for_update_1 (basic_block bb, bool insert_phi_p)
 {
-  basic_block son;
   edge e;
   edge_iterator ei;
 
@@ -2694,13 +2691,51 @@ prepare_block_for_update (basic_block bb, bool insert_phi_p)
 	}
     }
 
-  /* Now visit all the blocks dominated by BB.  */
-  for (son = first_dom_son (CDI_DOMINATORS, bb);
-       son;
-       son = next_dom_son (CDI_DOMINATORS, son))
-    prepare_block_for_update (son, insert_phi_p);
 }
 
+/* Do a dominator walk starting at BB processing statements that
+   reference symbols in SSA operands.  This is very similar to
+   mark_def_sites, but the scan handles statements whose operands may
+   already be SSA names.
+
+   If INSERT_PHI_P is true, mark those uses as live in the
+   corresponding block.  This is later used by the PHI placement
+   algorithm to make PHI pruning decisions.
+
+   FIXME.  Most of this would be unnecessary if we could associate a
+	   symbol to all the SSA names that reference it.  But that
+	   sounds like it would be expensive to maintain.  Still, it
+	   would be interesting to see if it makes better sense to do
+	   that.  */
+static void
+prepare_block_for_update (basic_block bb, bool insert_phi_p)
+{
+  size_t sp = 0;
+  basic_block *worklist;
+
+  /* Allocate the worklist.  */
+  worklist = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));
+  /* Add the BB to the worklist.  */
+  worklist[sp++] = bb;
+
+  while (sp)
+    {
+      basic_block bb;
+      basic_block son;
+
+      /* Pick a block from the worklist.  */
+      bb = worklist[--sp];
+
+      prepare_block_for_update_1 (bb, insert_phi_p);
+
+      /* Now add all the blocks dominated by BB to the worklist.  */
+      for (son = first_dom_son (CDI_DOMINATORS, bb);
+	   son;
+	   son = next_dom_son (CDI_DOMINATORS, son))
+	worklist[sp++] = son;
+    }
+  free (worklist);
+}
 
 /* Helper for prepare_names_to_update.  Mark all the use sites for
    NAME as interesting.  BLOCKS and INSERT_PHI_P are as in
-- 
2.26.1

=== 0184-PR-80005-Fix-__has_include.patch ===
From ad1a3914ae8d67c94b0d2428e3f9672e7db491a1 Mon Sep 17 00:00:00 2001
From: Nathan Sidwell <nathan@acm.org>
Date: Mon, 20 Jan 2020 05:39:59 -0800
Subject: [PATCH 0184/2034] [PR 80005]  Fix __has_include

__has_include is funky in that it is macro-like from the POV of #ifdef and
friends, but lexes its parenthesize argument #include-like.  We were
failing the second part of that, because we used a forwarding macro to an
internal name, and hence always lexed the argument in macro-parameter
context.  We componded that by not setting the right flag when lexing, so
it didn't even know.  Mostly users got lucky.

This reimplements the handline.
1) Remove the forwarding, but declare object-like macros that
expand to themselves.  This satisfies the #ifdef requirement

2) Correctly set angled_brackets when lexing the parameter.  This tells
the lexer (a) <...> is a header name and (b) "..." is too (not a string).

3) Remove the in__has_include lexer state, just tell find_file that that's
what's happenning, so it doesn't emit an error.

We lose the (undocumented) ability to #undef __has_include.  That may well
have been an accident of implementation.  There are no tests for it.

We gain __has_include behaviour for all users of the preprocessors -- not
just the C-family ones that defined a forwarding macro.

	libcpp/
	PR preprocessor/80005
	* include/cpplib.h (BT_HAS_ATTRIBUTE): Fix comment.
	* internal.h (struct lexer_state): Delete in__has_include field.
	(struct spec_nodes): Rename n__has_include{,_next}__ fields.
	(_cpp_defined_macro_p): New.
	(_cpp_find_file): Add has_include parm.
	* directives.c (lex_macro_node): Combine defined,
	__has_inline{,_next} checking.
	(do_ifdef, do_ifndef): Use _cpp_defined_macro_p.
	(_cpp_init_directives): Refactor.
	* expr.c (parse_defined): Use _cpp_defined_macro_p.
	(eval_token): Adjust parse_has_include calls.
	(parse_has_include): Add OP parameter.  Reimplement.
	* files.c (_cpp_find_file): Add HAS_INCLUDE parm.  Use it to
	inhibit error message.
	(_cpp_stack_include): Adjust _cpp_find_file call.
	(_cpp_fake_include, _cpp_compare_file_date): Likewise.
	(open_file_failed): Remove in__has_include check.
	(_cpp_has_header): Adjust _cpp_find_file call.
	* identifiers.c (_cpp_init_hashtable): Don't init
	__has_include{,_next} here ...
	* init.c (cpp_init_builtins): ... init them here.  Define as
	macros.
	(cpp_read_main_file): Adjust _cpp_find_file call.
	* pch.c (cpp_read_state): Adjust __has_include{,_next} access.
	* traditional.c (_cpp_scan_out_locgical_line): Likewise.

	gcc/c-family/
	PR preprocessor/80005
	* c-cppbuiltins.c (c_cpp_builtins): Don't define __has_include{,_next}.

	gcc/testsuite/
	PR preprocessor/80005
	* g++.dg/cpp1y/feat-cxx14.C: Adjust.
	* g++.dg/cpp1z/feat-cxx17.C: Adjust.
	* g++.dg/cpp2a/feat-cxx2a.C: Adjust.
	* g++.dg/cpp/pr80005.C: New.
---
 gcc/c-family/ChangeLog                  |  5 ++++
 gcc/c-family/c-cppbuiltin.c             |  6 -----
 gcc/testsuite/ChangeLog                 |  8 +++++++
 gcc/testsuite/g++.dg/cpp/pr80005.C      | 24 +++++++++++++++++++
 gcc/testsuite/g++.dg/cpp1y/feat-cxx14.C | 10 ++------
 gcc/testsuite/g++.dg/cpp1z/feat-cxx1z.C | 10 ++------
 gcc/testsuite/g++.dg/cpp2a/feat-cxx2a.C | 10 ++------
 libcpp/ChangeLog                        | 29 +++++++++++++++++++++-
 libcpp/directives.c                     | 29 ++++++++--------------
 libcpp/expr.c                           | 32 ++++++++++++-------------
 libcpp/files.c                          | 27 +++++++++++----------
 libcpp/identifiers.c                    |  3 +--
 libcpp/include/cpplib.h                 |  2 +-
 libcpp/init.c                           | 14 ++++++++++-
 libcpp/internal.h                       | 20 +++++++++++-----
 libcpp/pch.c                            |  4 ++--
 libcpp/traditional.c                    |  8 +++----
 17 files changed, 146 insertions(+), 95 deletions(-)
 create mode 100644 gcc/testsuite/g++.dg/cpp/pr80005.C

diff --git a/gcc/c-family/ChangeLog b/gcc/c-family/ChangeLog
index 09ba2c8b40f..fdddb98a74d 100644
--- a/gcc/c-family/ChangeLog
+++ b/gcc/c-family/ChangeLog
@@ -1,3 +1,8 @@
+2020-01-20  Nathan Sidwell  <nathan@acm.org>
+
+	PR preprocessor/80005
+	* c-cppbuiltins.c (c_cpp_builtins): Don't define __has_include{,_next}.
+
 2020-01-18  Iain Sandoe  <iain@sandoe.co.uk>
 
 	* c-common.c (co_await, co_yield, co_return): New.
diff --git a/gcc/c-family/c-cppbuiltin.c b/gcc/c-family/c-cppbuiltin.c
index a6308921dc9..70a12055e27 100644
--- a/gcc/c-family/c-cppbuiltin.c
+++ b/gcc/c-family/c-cppbuiltin.c
@@ -876,12 +876,6 @@ c_cpp_builtins (cpp_reader *pfile)
   /* For stddef.h.  They require macros defined in c-common.c.  */
   c_stddef_cpp_builtins ();
 
-  /* Set include test macros for all C/C++ (not for just C++11 etc.)
-     The builtins __has_include__ and __has_include_next__ are defined
-     in libcpp.  */
-  cpp_define (pfile, "__has_include(STR)=__has_include__(STR)");
-  cpp_define (pfile, "__has_include_next(STR)=__has_include_next__(STR)");
-
   if (c_dialect_cxx ())
     {
       if (flag_weak && SUPPORTS_ONE_ONLY)
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index a526e32ac89..67d5f2e9e28 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,11 @@
+2020-01-20  Nathan Sidwell  <nathan@acm.org>
+
+	PR preprocessor/80005
+	* g++.dg/cpp1y/feat-cxx14.C: Adjust.
+	* g++.dg/cpp1z/feat-cxx17.C: Adjust.
+	* g++.dg/cpp2a/feat-cxx2a.C: Adjust.
+	* g++.dg/cpp/pr80005.C: New.
+
 2020-01-20  Mark Eggleston  <mark.eggleston@codethink.com>
 
 	* gfortran.dg/pr93263_1.f90: Change scan-tree-dump-not to
diff --git a/gcc/testsuite/g++.dg/cpp/pr80005.C b/gcc/testsuite/g++.dg/cpp/pr80005.C
new file mode 100644
index 00000000000..cc752616782
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp/pr80005.C
@@ -0,0 +1,24 @@
+// PR preprocessor/80005
+// { dg-do preprocess }
+
+#undef vector
+#define vector NOPE
+#ifdef __has_include
+
+#if !__has_include (<vector>)
+#error "Header 'vector' could not be found"
+#endif
+#define F(X) __has_include (X)
+#if !F (<vector>)
+#error "Header 'vector' could not be found" // { dg-error "not be found" }
+#endif
+
+#if __has_include ("not an escape! \")	// comment
+#endif
+
+#if F ("is an escape \") gibberish ")
+#endif
+
+#else
+#error "No __has_include"
+#endif
diff --git a/gcc/testsuite/g++.dg/cpp1y/feat-cxx14.C b/gcc/testsuite/g++.dg/cpp1y/feat-cxx14.C
index a2a93f437b3..a78b6a36f36 100644
--- a/gcc/testsuite/g++.dg/cpp1y/feat-cxx14.C
+++ b/gcc/testsuite/g++.dg/cpp1y/feat-cxx14.C
@@ -236,20 +236,14 @@
 #  error "__has_include"
 #endif
 
-//  Quoted complex.h should find at least the bracket version (use operator).
-#if __has_include__ "complex.h"
-#else
-#  error "complex.h"
-#endif
-
 //  Try known bracket header (use operator).
-#if __has_include__(<complex>)
+#if __has_include (<complex>)
 #else
 #  error "<complex>"
 #endif
 
 //  Define and use a macro to invoke the operator.
-#define sluggo(TXT) __has_include__(TXT)
+#define sluggo(TXT) __has_include(TXT)
 
 #if sluggo(<complex>)
 #else
diff --git a/gcc/testsuite/g++.dg/cpp1z/feat-cxx1z.C b/gcc/testsuite/g++.dg/cpp1z/feat-cxx1z.C
index 55e56a06fe8..e6f456b2415 100644
--- a/gcc/testsuite/g++.dg/cpp1z/feat-cxx1z.C
+++ b/gcc/testsuite/g++.dg/cpp1z/feat-cxx1z.C
@@ -225,20 +225,14 @@
 #  error "__has_include"
 #endif
 
-//  Quoted complex.h should find at least the bracket version (use operator).
-#if __has_include__ "complex.h"
-#else
-#  error "complex.h"
-#endif
-
 //  Try known bracket header (use operator).
-#if __has_include__(<complex>)
+#if __has_include (<complex>)
 #else
 #  error "<complex>"
 #endif
 
 //  Define and use a macro to invoke the operator.
-#define sluggo(TXT) __has_include__(TXT)
+#define sluggo(TXT) __has_include(TXT)
 
 #if sluggo(<complex>)
 #else
diff --git a/gcc/testsuite/g++.dg/cpp2a/feat-cxx2a.C b/gcc/testsuite/g++.dg/cpp2a/feat-cxx2a.C
index dd15cd6af3c..82fd602f9f1 100644
--- a/gcc/testsuite/g++.dg/cpp2a/feat-cxx2a.C
+++ b/gcc/testsuite/g++.dg/cpp2a/feat-cxx2a.C
@@ -224,20 +224,14 @@
 #  error "__has_include"
 #endif
 
-//  Quoted complex.h should find at least the bracket version (use operator).
-#if __has_include__ "complex.h"
-#else
-#  error "complex.h"
-#endif
-
 //  Try known bracket header (use operator).
-#if __has_include__(<complex>)
+#if __has_include (<complex>)
 #else
 #  error "<complex>"
 #endif
 
 //  Define and use a macro to invoke the operator.
-#define sluggo(TXT) __has_include__(TXT)
+#define sluggo(TXT) __has_include(TXT)
 
 #if sluggo(<complex>)
 #else
diff --git a/libcpp/ChangeLog b/libcpp/ChangeLog
index 3249b93fe88..27a841bbdce 100644
--- a/libcpp/ChangeLog
+++ b/libcpp/ChangeLog
@@ -1,4 +1,31 @@
-2020-01-17  Nathan Sidwell  <nathan@acm.org>
+2020-01-20  Nathan Sidwell  <nathan@acm.org>
+
+	PR preprocessor/80005
+	* include/cpplib.h (BT_HAS_ATTRIBUTE): Fix comment.
+	* internal.h (struct lexer_state): Delete in__has_include field.
+	(struct spec_nodes): Rename n__has_include{,_next}__ fields.
+	(_cpp_defined_macro_p): New.
+	(_cpp_find_file): Add has_include parm.
+	* directives.c (lex_macro_node): Combine defined,
+	__has_inline{,_next} checking.
+	(do_ifdef, do_ifndef): Use _cpp_defined_macro_p.
+	(_cpp_init_directives): Refactor.
+	* expr.c (parse_defined): Use _cpp_defined_macro_p.
+	(eval_token): Adjust parse_has_include calls.
+	(parse_has_include): Add OP parameter.  Reimplement.
+	* files.c (_cpp_find_file): Add HAS_INCLUDE parm.  Use it to
+	inhibit error message.
+	(_cpp_stack_include): Adjust _cpp_find_file call.
+	(_cpp_fake_include, _cpp_compare_file_date): Likewise.
+	(open_file_failed): Remove in__has_include check.
+	(_cpp_has_header): Adjust _cpp_find_file call.
+	* identifiers.c (_cpp_init_hashtable): Don't init
+	__has_include{,_next} here ...
+	* init.c (cpp_init_builtins): ... init them here.  Define as
+	macros.
+	(cpp_read_main_file): Adjust _cpp_find_file call.
+	* pch.c (cpp_read_state): Adjust __has_include{,_next} access.
+	* traditional.c (_cpp_scan_out_locgical_line): Likewise.
 
 	PR preprocessor/93306
 	* expr.c (parse_has_include): Refactor.  Check skip_eval before
diff --git a/libcpp/directives.c b/libcpp/directives.c
index 983206a5838..10735c8c668 100644
--- a/libcpp/directives.c
+++ b/libcpp/directives.c
@@ -595,14 +595,13 @@ lex_macro_node (cpp_reader *pfile, bool is_def_or_undef)
     {
       cpp_hashnode *node = token->val.node.node;
 
-      if (is_def_or_undef && node == pfile->spec_nodes.n_defined)
+      if (is_def_or_undef
+	  && (node == pfile->spec_nodes.n_defined
+	      || node == pfile->spec_nodes.n__has_include
+	      || node == pfile->spec_nodes.n__has_include_next))
 	cpp_error (pfile, CPP_DL_ERROR,
-		   "\"defined\" cannot be used as a macro name");
-      else if (is_def_or_undef
-	    && (node == pfile->spec_nodes.n__has_include__
-	     || node == pfile->spec_nodes.n__has_include_next__))
-	cpp_error (pfile, CPP_DL_ERROR,
-		   "\"__has_include__\" cannot be used as a macro name");
+		   "\"%s\" cannot be used as a macro name",
+		   NODE_NAME (node));
       else if (! (node->flags & NODE_POISONED))
 	return node;
     }
@@ -1966,11 +1965,7 @@ do_ifdef (cpp_reader *pfile)
 
       if (node)
 	{
-	  /* Do not treat conditional macros as being defined.  This is due to
-	     the powerpc port using conditional macros for 'vector', 'bool',
-	     and 'pixel' to act as conditional keywords.  This messes up tests
-	     like #ifndef bool.  */
-	  skip = !cpp_macro_p (node) || (node->flags & NODE_CONDITIONAL);
+	  skip = !_cpp_defined_macro_p (node);
 	  _cpp_mark_macro_used (node);
 	  _cpp_maybe_notify_macro_use (pfile, node);
 	  if (pfile->cb.used)
@@ -1999,8 +1994,7 @@ do_ifndef (cpp_reader *pfile)
 	     the powerpc port using conditional macros for 'vector', 'bool',
 	     and 'pixel' to act as conditional keywords.  This messes up tests
 	     like #ifndef bool.  */
-	  skip = (cpp_macro_p (node)
-		  && !(node->flags & NODE_CONDITIONAL));
+	  skip = _cpp_defined_macro_p (node);
 	  _cpp_mark_macro_used (node);
 	  _cpp_maybe_notify_macro_use (pfile, node);
 	  if (pfile->cb.used)
@@ -2638,12 +2632,9 @@ _cpp_pop_buffer (cpp_reader *pfile)
 void
 _cpp_init_directives (cpp_reader *pfile)
 {
-  unsigned int i;
-  cpp_hashnode *node;
-
-  for (i = 0; i < (unsigned int) N_DIRECTIVES; i++)
+  for (int i = 0; i < N_DIRECTIVES; i++)
     {
-      node = cpp_lookup (pfile, dtable[i].name, dtable[i].length);
+      cpp_hashnode *node = cpp_lookup (pfile, dtable[i].name, dtable[i].length);
       node->is_directive = 1;
       node->directive_index = i;
     }
diff --git a/libcpp/expr.c b/libcpp/expr.c
index 317faf50208..df21a4b9fb9 100644
--- a/libcpp/expr.c
+++ b/libcpp/expr.c
@@ -64,7 +64,7 @@ static unsigned int interpret_float_suffix (cpp_reader *, const uchar *, size_t)
 static unsigned int interpret_int_suffix (cpp_reader *, const uchar *, size_t);
 static void check_promotion (cpp_reader *, const struct op *);
 
-static cpp_num parse_has_include (cpp_reader *, enum include_type);
+static cpp_num parse_has_include (cpp_reader *, cpp_hashnode *, include_type);
 
 /* Token type abuse to create unary plus and minus operators.  */
 #define CPP_UPLUS ((enum cpp_ttype) (CPP_LAST_CPP_OP + 1))
@@ -1088,8 +1088,7 @@ parse_defined (cpp_reader *pfile)
   result.unsignedp = false;
   result.high = 0;
   result.overflow = false;
-  result.low = (node && cpp_macro_p (node)
-		&& !(node->flags & NODE_CONDITIONAL));
+  result.low = node && _cpp_defined_macro_p (node);
   return result;
 }
 
@@ -1160,10 +1159,10 @@ eval_token (cpp_reader *pfile, const cpp_token *token,
     case CPP_NAME:
       if (token->val.node.node == pfile->spec_nodes.n_defined)
 	return parse_defined (pfile);
-      else if (token->val.node.node == pfile->spec_nodes.n__has_include__)
-	return parse_has_include (pfile, IT_INCLUDE);
-      else if (token->val.node.node == pfile->spec_nodes.n__has_include_next__)
-	return parse_has_include (pfile, IT_INCLUDE_NEXT);
+      else if (token->val.node.node == pfile->spec_nodes.n__has_include)
+	return parse_has_include (pfile, token->val.node.node, IT_INCLUDE);
+      else if (token->val.node.node == pfile->spec_nodes.n__has_include_next)
+	return parse_has_include (pfile, token->val.node.node, IT_INCLUDE_NEXT);
       else if (CPP_OPTION (pfile, cplusplus)
 	       && (token->val.node.node == pfile->spec_nodes.n_true
 		   || token->val.node.node == pfile->spec_nodes.n_false))
@@ -2190,9 +2189,9 @@ num_div_op (cpp_reader *pfile, cpp_num lhs, cpp_num rhs, enum cpp_ttype op,
   return lhs;
 }
 
-/* Handle meeting "__has_include__" in a preprocessor expression.  */
+/* Handle meeting "__has_include" in a preprocessor expression.  */
 static cpp_num
-parse_has_include (cpp_reader *pfile, enum include_type type)
+parse_has_include (cpp_reader *pfile, cpp_hashnode *op, include_type type)
 {
   cpp_num result;
 
@@ -2201,12 +2200,15 @@ parse_has_include (cpp_reader *pfile, enum include_type type)
   result.overflow = false;
   result.low = 0;
 
-  pfile->state.in__has_include__++;
-
+  pfile->state.angled_headers = true;
   const cpp_token *token = cpp_get_token (pfile);
   bool paren = token->type == CPP_OPEN_PAREN;
   if (paren)
     token = cpp_get_token (pfile);
+  else
+    cpp_error (pfile, CPP_DL_ERROR,
+	       "missing '(' before \"%s\" operand", NODE_NAME (op));
+  pfile->state.angled_headers = false;
 
   bool bracket = token->type != CPP_STRING;
   cpp_hashnode *node = NULL;
@@ -2222,7 +2224,7 @@ parse_has_include (cpp_reader *pfile, enum include_type type)
     fname = _cpp_bracket_include (pfile);
   else
     cpp_error (pfile, CPP_DL_ERROR,
-	       "operator \"__has_include__\" requires a header string");
+	       "operator \"%s\" requires a header-name", NODE_NAME (op));
 
   if (fname)
     {
@@ -2237,14 +2239,10 @@ parse_has_include (cpp_reader *pfile, enum include_type type)
 
   if (paren && !SEEN_EOL () && cpp_get_token (pfile)->type != CPP_CLOSE_PAREN)
     cpp_error (pfile, CPP_DL_ERROR,
-	       "missing ')' after \"__has_include__\"");
+	       "missing ')' after \"%s\" operand", NODE_NAME (op));
 
-  /* A possible controlling macro of the form #if !__has_include__ ().
-     _cpp_parse_expr checks there was no other junk on the line.  */
   if (node)
     pfile->mi_ind_cmacro = node;
 
-  pfile->state.in__has_include__--;
-
   return result;
 }
diff --git a/libcpp/files.c b/libcpp/files.c
index 7abae7ae6ec..260e787c329 100644
--- a/libcpp/files.c
+++ b/libcpp/files.c
@@ -504,7 +504,8 @@ _cpp_find_failed (_cpp_file *file)
 
 _cpp_file *
 _cpp_find_file (cpp_reader *pfile, const char *fname, cpp_dir *start_dir,
-		bool fake, int angle_brackets, bool implicit_preinclude,
+		int angle_brackets,
+		bool fake, bool implicit_preinclude, bool has_include,
 		location_t loc)
 {
   struct cpp_file_hash_entry *entry;
@@ -592,7 +593,8 @@ _cpp_find_file (cpp_reader *pfile, const char *fname, cpp_dir *start_dir,
 		return NULL;
 	      }
 
-	    open_file_failed (pfile, file, angle_brackets, loc);
+	    if (!has_include)
+	      open_file_failed (pfile, file, angle_brackets, loc);
 	    break;
 	  }
 
@@ -1046,8 +1048,8 @@ _cpp_stack_include (cpp_reader *pfile, const char *fname, int angle_brackets,
   if (!dir)
     return false;
 
-  _cpp_file *file = _cpp_find_file (pfile, fname, dir, false, angle_brackets,
-				    type == IT_DEFAULT, loc);
+  _cpp_file *file = _cpp_find_file (pfile, fname, dir, angle_brackets,
+				    false, type == IT_DEFAULT, false, loc);
   if (type == IT_DEFAULT && file == NULL)
     return false;
 
@@ -1062,9 +1064,6 @@ open_file_failed (cpp_reader *pfile, _cpp_file *file, int angle_brackets,
   int sysp = pfile->line_table->highest_line > 1 && pfile->buffer ? pfile->buffer->sysp : 0;
   bool print_dep = CPP_OPTION (pfile, deps.style) > (angle_brackets || !!sysp);
 
-  if (pfile->state.in__has_include__)
-    return;
-
   errno = file->err_no;
   if (print_dep && CPP_OPTION (pfile, deps.missing_files) && errno == ENOENT)
     {
@@ -1343,7 +1342,8 @@ cpp_clear_file_cache (cpp_reader *pfile)
 void
 _cpp_fake_include (cpp_reader *pfile, const char *fname)
 {
-  _cpp_find_file (pfile, fname, pfile->buffer->file->dir, true, 0, false, 0);
+  _cpp_find_file (pfile, fname, pfile->buffer->file->dir,
+		  0, true, false, false, 0);
 }
 
 /* Not everyone who wants to set system-header-ness on a buffer can
@@ -1461,7 +1461,8 @@ _cpp_compare_file_date (cpp_reader *pfile, const char *fname,
   if (!dir)
     return -1;
 
-  file = _cpp_find_file (pfile, fname, dir, false, angle_brackets, false, 0);
+  file = _cpp_find_file (pfile, fname, dir, angle_brackets,
+			 false, false, false, 0);
   if (file->err_no)
     return -1;
 
@@ -2004,9 +2005,11 @@ _cpp_has_header (cpp_reader *pfile, const char *fname, int angle_brackets,
 		 enum include_type type)
 {
   cpp_dir *start_dir = search_path_head (pfile, fname, angle_brackets, type);
-  _cpp_file *file = _cpp_find_file (pfile, fname, start_dir,
-				    /*fake=*/false, angle_brackets,
-				    /*implicit_preinclude=*/false, 0);
+  _cpp_file *file = _cpp_find_file (pfile, fname, start_dir, angle_brackets,
+				    /*fake=*/false,
+				    /*implicit_preinclude=*/false,
+				    /*has_include=*/true,
+				    0);
   return file->err_no != ENOENT;
 }
 
diff --git a/libcpp/identifiers.c b/libcpp/identifiers.c
index 562d8fee3b5..9627e1bf4b0 100644
--- a/libcpp/identifiers.c
+++ b/libcpp/identifiers.c
@@ -72,8 +72,7 @@ _cpp_init_hashtable (cpp_reader *pfile, cpp_hash_table *table)
   s->n__VA_ARGS__->flags |= NODE_DIAGNOSTIC;
   s->n__VA_OPT__        = cpp_lookup (pfile, DSC("__VA_OPT__"));
   s->n__VA_OPT__->flags |= NODE_DIAGNOSTIC;
-  s->n__has_include__   = cpp_lookup (pfile, DSC("__has_include__"));
-  s->n__has_include_next__ = cpp_lookup (pfile, DSC("__has_include_next__"));
+  /* __has_include{,_next} are inited in cpp_init_builtins.  */
 }
 
 /* Tear down the identifier hash table.  */
diff --git a/libcpp/include/cpplib.h b/libcpp/include/cpplib.h
index 1c26c365347..56cbbd82750 100644
--- a/libcpp/include/cpplib.h
+++ b/libcpp/include/cpplib.h
@@ -859,7 +859,7 @@ enum cpp_builtin_type
   BT_PRAGMA,			/* `_Pragma' operator */
   BT_TIMESTAMP,			/* `__TIMESTAMP__' */
   BT_COUNTER,			/* `__COUNTER__' */
-  BT_HAS_ATTRIBUTE,		/* `__has_attribute__(x)' */
+  BT_HAS_ATTRIBUTE,		/* `__has_attribute(x)' */
   BT_HAS_BUILTIN		/* `__has_builtin(x)' */
 };
 
diff --git a/libcpp/init.c b/libcpp/init.c
index 2b4923e1451..e798140ef8b 100644
--- a/libcpp/init.c
+++ b/libcpp/init.c
@@ -578,6 +578,17 @@ cpp_init_builtins (cpp_reader *pfile, int hosted)
 
   if (CPP_OPTION (pfile, objc))
     _cpp_define_builtin (pfile, "__OBJC__ 1");
+
+  /* These two behave as macros for #ifdef, but are evaluated
+     specially inside #if.  */
+  _cpp_define_builtin (pfile, "__has_include __has_include");
+  _cpp_define_builtin (pfile, "__has_include_next __has_include_next");
+  pfile->spec_nodes.n__has_include
+    = cpp_lookup (pfile, DSC("__has_include"));
+  pfile->spec_nodes.n__has_include->flags |= NODE_DIAGNOSTIC;
+  pfile->spec_nodes.n__has_include_next
+    = cpp_lookup (pfile, DSC("__has_include_next"));
+  pfile->spec_nodes.n__has_include_next->flags |= NODE_DIAGNOSTIC;
 }
 
 /* Sanity-checks are dependent on command-line options, so it is
@@ -672,7 +683,8 @@ cpp_read_main_file (cpp_reader *pfile, const char *fname)
     }
 
   pfile->main_file
-    = _cpp_find_file (pfile, fname, &pfile->no_search_path, false, 0, false,
+    = _cpp_find_file (pfile, fname, &pfile->no_search_path, /*angle=*/0,
+		      /*fake=*/false, /*preinclude=*/false, /*hasinclude=*/false,
 		      loc);
   if (_cpp_find_failed (pfile->main_file))
     return NULL;
diff --git a/libcpp/internal.h b/libcpp/internal.h
index 3623baf8191..5453c3bff85 100644
--- a/libcpp/internal.h
+++ b/libcpp/internal.h
@@ -268,9 +268,6 @@ struct lexer_state
   /* Nonzero when parsing arguments to a function-like macro.  */
   unsigned char parsing_args;
 
-  /* Nonzero if in a __has_include__ or __has_include_next__ statement.  */
-  unsigned char in__has_include__;
-
   /* Nonzero if prevent_expansion is true only because output is
      being discarded.  */
   unsigned char discarding_output;
@@ -293,8 +290,8 @@ struct spec_nodes
   cpp_hashnode *n_false;		/* C++ keyword false */
   cpp_hashnode *n__VA_ARGS__;		/* C99 vararg macros */
   cpp_hashnode *n__VA_OPT__;		/* C++ vararg macros */
-  cpp_hashnode *n__has_include__;	/* __has_include__ operator */
-  cpp_hashnode *n__has_include_next__;	/* __has_include_next__ operator */
+  cpp_hashnode *n__has_include;		/* __has_include operator */
+  cpp_hashnode *n__has_include_next;	/* __has_include_next operator */
 };
 
 typedef struct _cpp_line_note _cpp_line_note;
@@ -641,6 +638,16 @@ cpp_in_primary_file (cpp_reader *pfile)
   return pfile->line_table->depth == 1;
 }
 
+/* True if NODE is a macro for the purposes of ifdef, defined etc.  */
+inline bool _cpp_defined_macro_p (cpp_hashnode *node)
+{
+  /* Do not treat conditional macros as being defined.  This is due to
+     the powerpc port using conditional macros for 'vector', 'bool',
+     and 'pixel' to act as conditional keywords.  This messes up tests
+     like #ifndef bool.  */
+  return cpp_macro_p (node) && !(node->flags & NODE_CONDITIONAL);
+}
+
 /* In macro.c */
 extern void _cpp_notify_macro_use (cpp_reader *pfile, cpp_hashnode *node);
 inline void _cpp_maybe_notify_macro_use (cpp_reader *pfile, cpp_hashnode *node)
@@ -674,7 +681,8 @@ extern void _cpp_destroy_hashtable (cpp_reader *);
 /* In files.c */
 typedef struct _cpp_file _cpp_file;
 extern _cpp_file *_cpp_find_file (cpp_reader *, const char *, cpp_dir *,
-				  bool, int, bool, location_t);
+				  int angle, bool fake, bool preinclude,
+				  bool has_include, location_t);
 extern bool _cpp_find_failed (_cpp_file *);
 extern void _cpp_mark_file_once_only (cpp_reader *, struct _cpp_file *);
 extern void _cpp_fake_include (cpp_reader *, const char *);
diff --git a/libcpp/pch.c b/libcpp/pch.c
index 607f805bebe..e631050936b 100644
--- a/libcpp/pch.c
+++ b/libcpp/pch.c
@@ -811,8 +811,8 @@ cpp_read_state (cpp_reader *r, const char *name, FILE *f,
     s->n_false		= cpp_lookup (r, DSC("false"));
     s->n__VA_ARGS__     = cpp_lookup (r, DSC("__VA_ARGS__"));
     s->n__VA_OPT__      = cpp_lookup (r, DSC("__VA_OPT__"));
-    s->n__has_include__ = cpp_lookup (r, DSC("__has_include__"));
-    s->n__has_include_next__ = cpp_lookup (r, DSC("__has_include_next__"));
+    s->n__has_include   = cpp_lookup (r, DSC("__has_include"));
+    s->n__has_include_next = cpp_lookup (r, DSC("__has_include_next"));
   }
 
   old_state = r->state;
diff --git a/libcpp/traditional.c b/libcpp/traditional.c
index 21c63b47dd5..ff06d31a897 100644
--- a/libcpp/traditional.c
+++ b/libcpp/traditional.c
@@ -78,8 +78,8 @@ enum ls {ls_none = 0,		/* Normal state.  */
 	 ls_hash,		/* After # in preprocessor conditional.  */
 	 ls_predicate,		/* After the predicate, maybe paren?  */
 	 ls_answer,		/* In answer to predicate.  */
-	 ls_has_include,	/* After __has_include__.  */
-	 ls_has_include_close};	/* Looking for ')' of __has_include__.  */
+	 ls_has_include,	/* After __has_include.  */
+	 ls_has_include_close};	/* Looking for ')' of __has_include.  */
 
 /* Lexing TODO: Maybe handle space in escaped newlines.  Stop lex.c
    from recognizing comments and directives during its lexing pass.  */
@@ -565,8 +565,8 @@ _cpp_scan_out_logical_line (cpp_reader *pfile, cpp_macro *macro,
 		  continue;
 		}
 	      else if (pfile->state.in_expression
-		       && (node == pfile->spec_nodes.n__has_include__
-			|| node == pfile->spec_nodes.n__has_include_next__))
+		       && (node == pfile->spec_nodes.n__has_include
+			|| node == pfile->spec_nodes.n__has_include_next))
 		{
 		  lex_state = ls_has_include;
 		  continue;
-- 
2.26.1

=== long-lines.patch ===
From eb7c7c524556df5364f03adc20f6a9db20858484 Mon Sep 17 00:00:00 2001
From: Jakub Jelinek <jakub@redhat.com>
Date: Mon, 13 Jan 2020 14:14:57 +0100
Subject: [PATCH 0004/2034] tree-opt: Fix bootstrap failure in
 tree-ssa-forwprop.c some more PR90838

2020-01-13  Jakub Jelinek  <jakub@redhat.com>

	PR tree-optimization/90838
	* tree-ssa-forwprop.c (simplify_count_trailing_zeroes): Use
	SCALAR_INT_TYPE_MODE directly in CTZ_DEFINED_VALUE_AT_ZERO macro and and SCALAR_INT_TYPE_MODE directly in and so
	argument rather than to initialize temporary for targets that
	don't use the mode argument at all.  Initialize ctzval to avoid
	warning at -O0.
---
 gcc/ChangeLog           | 9 +++++++++
 gcc/tree-ssa-forwprop.c | 6 +++---
 2 files changed, 12 insertions(+), 3 deletions(-)

diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index a195863212e..f7df07343d1 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,12 @@
+2020-01-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/90838
+	* tree-ssa-forwprop.c (simplify_count_trailing_zeroes): Use
+	SCALAR_INT_TYPE_MODE directly in CTZ_DEFINED_VALUE_AT_ZERO macro
+	argument rather than to initialize temporary for targets that
+	don't use the mode argument at all.  Initialize ctzval to avoid
+	warning at -O0.
+
 2020-01-10  Thomas Schwinge  <thomas@codesourcery.com>
 
 	* tree.h (OMP_CLAUSE_USE_DEVICE_PTR_IF_PRESENT): New definition.
diff --git a/gcc/tree-ssa-forwprop.c b/gcc/tree-ssa-forwprop.c
index aac31d02b6c..56c470f6ecf 100644
--- a/gcc/tree-ssa-forwprop.c
+++ b/gcc/tree-ssa-forwprop.c
@@ -1920,10 +1920,10 @@ simplify_count_trailing_zeroes (gimple_stmt_iterator *gsi)
 				      res_ops[1], res_ops[2], zero_val))
     {
       tree type = TREE_TYPE (res_ops[0]);
-      HOST_WIDE_INT ctzval;
+      HOST_WIDE_INT ctzval = 0;
       HOST_WIDE_INT type_size = tree_to_shwi (TYPE_SIZE (type));
-      scalar_int_mode mode = SCALAR_INT_TYPE_MODE (type);
-      bool zero_ok = CTZ_DEFINED_VALUE_AT_ZERO (mode, ctzval) == 2;
+      bool zero_ok
+	= CTZ_DEFINED_VALUE_AT_ZERO (SCALAR_INT_TYPE_MODE (type), ctzval) == 2;
 
       /* Skip if there is no value defined at zero, or if we can't easily
 	 return the correct value for zero.  */
-- 
2.26.1

=== 0735-PR-87488-Add-with-diagnostics-urls-configuration-opt.patch ===
From 458c8d6459c4005fc9886b6e25d168a6535ac415 Mon Sep 17 00:00:00 2001
From: Bernd Edlinger <bernd.edlinger@hotmail.de>
Date: Wed, 29 Jan 2020 15:31:10 +0100
Subject: [PATCH 0735/2034] PR 87488: Add --with-diagnostics-urls configuration
 option

2020-02-15  David Malcolm  <dmalcolm@redhat.com>
	    Bernd Edlinger  <bernd.edlinger@hotmail.de>

	PR 87488
	PR other/93168
	* config.in (DIAGNOSTICS_URLS_DEFAULT): New define.
	* configure.ac (--with-diagnostics-urls): New configuration
	option, based on --with-diagnostics-color.
	(DIAGNOSTICS_URLS_DEFAULT): New define.
	* config.h: Regenerate.
	* configure: Regenerate.
	* diagnostic.c (diagnostic_urls_init): Handle -1 for
	DIAGNOSTICS_URLS_DEFAULT from configure-time
	--with-diagnostics-urls=auto-if-env by querying for a GCC_URLS
	and TERM_URLS environment variable.
	* diagnostic-url.h (diagnostic_url_format): New enum type.
	(diagnostic_urls_enabled_p): rename to...
	(determine_url_format): ... this, and change return type.
	* diagnostic-color.c (parse_env_vars_for_urls): New helper function.
	(auto_enable_urls): Disable URLs on xfce4-terminal, gnome-terminal,
	the linux console, and mingw.
	(diagnostic_urls_enabled_p): rename to...
	(determine_url_format): ... this, and adjust.
	* pretty-print.h (pretty_printer::show_urls): rename to...
	(pretty_printer::url_format): ... this, and change to enum.
	* pretty-print.c (pretty_printer::pretty_printer,
	pp_begin_url, pp_end_url, test_urls): Adjust.
	* doc/install.texi (--with-diagnostics-urls): Document the new
	configuration option.
	(--with-diagnostics-color): Document the existing interaction
	with GCC_COLORS better.
	* doc/invoke.texi (-fdiagnostics-urls): Add GCC_URLS and TERM_URLS
	vindex reference.  Update description of defaults based on the above.
	(-fdiagnostics-color): Update description of how -fdiagnostics-color
	interacts with GCC_COLORS.
---
 gcc/ChangeLog          |  36 +++++++++++++++
 gcc/config.in          |   6 +++
 gcc/configure          |  41 ++++++++++++++++-
 gcc/configure.ac       |  28 ++++++++++++
 gcc/diagnostic-color.c | 101 ++++++++++++++++++++++++++++++++++++++---
 gcc/diagnostic-url.h   |  18 +++++++-
 gcc/diagnostic.c       |  21 +++++++--
 gcc/doc/install.texi   |  15 ++++--
 gcc/doc/invoke.texi    |  39 ++++++++++++++--
 gcc/pretty-print.c     |  44 +++++++++++++++---
 gcc/pretty-print.h     |   5 +-
 11 files changed, 328 insertions(+), 26 deletions(-)

diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index e6eb6ab4c21..22f990a3088 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,39 @@
+2020-02-15  David Malcolm  <dmalcolm@redhat.com>
+	    Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	PR 87488
+	PR other/93168
+	* config.in (DIAGNOSTICS_URLS_DEFAULT): New define.
+	* configure.ac (--with-diagnostics-urls): New configuration
+	option, based on --with-diagnostics-color.
+	(DIAGNOSTICS_URLS_DEFAULT): New define.
+	* config.h: Regenerate.
+	* configure: Regenerate.
+	* diagnostic.c (diagnostic_urls_init): Handle -1 for
+	DIAGNOSTICS_URLS_DEFAULT from configure-time
+	--with-diagnostics-urls=auto-if-env by querying for a GCC_URLS
+	and TERM_URLS environment variable.
+	* diagnostic-url.h (diagnostic_url_format): New enum type.
+	(diagnostic_urls_enabled_p): rename to...
+	(determine_url_format): ... this, and change return type.
+	* diagnostic-color.c (parse_env_vars_for_urls): New helper function.
+	(auto_enable_urls): Disable URLs on xfce4-terminal, gnome-terminal,
+	the linux console, and mingw.
+	(diagnostic_urls_enabled_p): rename to...
+	(determine_url_format): ... this, and adjust.
+	* pretty-print.h (pretty_printer::show_urls): rename to...
+	(pretty_printer::url_format): ... this, and change to enum.
+	* pretty-print.c (pretty_printer::pretty_printer,
+	pp_begin_url, pp_end_url, test_urls): Adjust.
+	* doc/install.texi (--with-diagnostics-urls): Document the new
+	configuration option.
+	(--with-diagnostics-color): Document the existing interaction
+	with GCC_COLORS better.
+	* doc/invoke.texi (-fdiagnostics-urls): Add GCC_URLS and TERM_URLS
+	vindex reference.  Update description of defaults based on the above.
+	(-fdiagnostics-color): Update description of how -fdiagnostics-color
+	interacts with GCC_COLORS.
+
 2020-02-14  Eric Botcazou  <ebotcazou@adacore.com>
 
 	PR target/93704
diff --git a/gcc/config.in b/gcc/config.in
index 48292861842..01fb18dbbb5 100644
--- a/gcc/config.in
+++ b/gcc/config.in
@@ -76,6 +76,12 @@
 #endif
 
 
+/* The default for -fdiagnostics-urls option */
+#ifndef USED_FOR_TARGET
+#undef DIAGNOSTICS_URLS_DEFAULT
+#endif
+
+
 /* Define 0/1 if static analyzer feature is enabled. */
 #ifndef USED_FOR_TARGET
 #undef ENABLE_ANALYZER
diff --git a/gcc/configure b/gcc/configure
index 5fa565a40a4..f55cdb8c77f 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -1015,6 +1015,7 @@ enable_host_shared
 enable_libquadmath_support
 with_linker_hash_style
 with_diagnostics_color
+with_diagnostics_urls
 enable_default_pie
 '
       ac_precious_vars='build_alias
@@ -1836,6 +1837,11 @@ Optional Packages:
                           auto-if-env stands for -fdiagnostics-color=auto if
                           GCC_COLOR environment variable is present and
                           -fdiagnostics-color=never otherwise
+  --with-diagnostics-urls={never,auto,auto-if-env,always}
+                          specify the default of -fdiagnostics-urls option
+                          auto-if-env stands for -fdiagnostics-urls=auto if
+                          GCC_URLS or TERM_URLS environment variable is
+                          present and -fdiagnostics-urls=never otherwise
 
 Some influential environment variables:
   CC          C compiler command
@@ -18974,7 +18980,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 18977 "configure"
+#line 18983 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -19080,7 +19086,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 19083 "configure"
+#line 19089 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -30575,6 +30581,37 @@ cat >>confdefs.h <<_ACEOF
 _ACEOF
 
 
+# Specify what should be the default of -fdiagnostics-urls option.
+
+# Check whether --with-diagnostics-urls was given.
+if test "${with_diagnostics_urls+set}" = set; then :
+  withval=$with_diagnostics_urls; case x"$withval" in
+   xnever)
+     DIAGNOSTICS_URLS_DEFAULT=DIAGNOSTICS_URL_NO
+     ;;
+   xauto)
+     DIAGNOSTICS_URLS_DEFAULT=DIAGNOSTICS_URL_AUTO
+     ;;
+   xauto-if-env)
+     DIAGNOSTICS_URLS_DEFAULT=-1
+     ;;
+   xalways)
+     DIAGNOSTICS_URLS_DEFAULT=DIAGNOSTICS_URL_YES
+     ;;
+   *)
+     as_fn_error $? "$withval is an invalid option to --with-diagnostics-urls" "$LINENO" 5
+     ;;
+ esac
+else
+  DIAGNOSTICS_URLS_DEFAULT=DIAGNOSTICS_URL_AUTO
+fi
+
+
+cat >>confdefs.h <<_ACEOF
+#define DIAGNOSTICS_URLS_DEFAULT $DIAGNOSTICS_URLS_DEFAULT
+_ACEOF
+
+
 # Generate gcc-driver-name.h containing GCC_DRIVER_NAME for the benefit
 # of jit/jit-playback.c.
 gcc_driver_version=`eval "${get_gcc_base_ver} $srcdir/BASE-VER"`
diff --git a/gcc/configure.ac b/gcc/configure.ac
index 671b9a67d81..0e6e475950d 100644
--- a/gcc/configure.ac
+++ b/gcc/configure.ac
@@ -6741,6 +6741,34 @@ AC_ARG_WITH([diagnostics-color],
 AC_DEFINE_UNQUOTED(DIAGNOSTICS_COLOR_DEFAULT, $DIAGNOSTICS_COLOR_DEFAULT,
 		   [The default for -fdiagnostics-color option])
 
+# Specify what should be the default of -fdiagnostics-urls option.
+AC_ARG_WITH([diagnostics-urls],
+[AC_HELP_STRING([--with-diagnostics-urls={never,auto,auto-if-env,always}],
+                [specify the default of -fdiagnostics-urls option
+                 auto-if-env stands for -fdiagnostics-urls=auto if
+                 GCC_URLS or TERM_URLS environment variable is present and
+                 -fdiagnostics-urls=never otherwise])],
+[case x"$withval" in
+   xnever)
+     DIAGNOSTICS_URLS_DEFAULT=DIAGNOSTICS_URL_NO
+     ;;
+   xauto)
+     DIAGNOSTICS_URLS_DEFAULT=DIAGNOSTICS_URL_AUTO
+     ;;
+   xauto-if-env)
+     DIAGNOSTICS_URLS_DEFAULT=-1
+     ;;
+   xalways)
+     DIAGNOSTICS_URLS_DEFAULT=DIAGNOSTICS_URL_YES
+     ;;
+   *)
+     AC_MSG_ERROR([$withval is an invalid option to --with-diagnostics-urls])
+     ;;
+ esac],
+[DIAGNOSTICS_URLS_DEFAULT=DIAGNOSTICS_URL_AUTO])
+AC_DEFINE_UNQUOTED(DIAGNOSTICS_URLS_DEFAULT, $DIAGNOSTICS_URLS_DEFAULT,
+		   [The default for -fdiagnostics-urls option])
+
 # Generate gcc-driver-name.h containing GCC_DRIVER_NAME for the benefit
 # of jit/jit-playback.c.
 gcc_driver_version=`eval "${get_gcc_base_ver} $srcdir/BASE-VER"`
diff --git a/gcc/diagnostic-color.c b/gcc/diagnostic-color.c
index d5547952921..b1baded2c9e 100644
--- a/gcc/diagnostic-color.c
+++ b/gcc/diagnostic-color.c
@@ -216,6 +216,7 @@ should_colorize (void)
 	  && GetConsoleMode (h, &m);
 #else
   char const *t = getenv ("TERM");
+  /* emacs M-x shell sets TERM="dumb".  */
   return t && strcmp (t, "dumb") != 0 && isatty (STDERR_FILENO);
 #endif
 }
@@ -239,20 +240,108 @@ colorize_init (diagnostic_color_rule_t rule)
     }
 }
 
-/* Determine if URLs should be enabled, based on RULE.
+/* Return URL_FORMAT_XXX which tells how we should emit urls
+   when in always mode.
+   We use GCC_URLS and if that is not defined TERM_URLS.
+   If neither is defined the feature is enabled by default.  */
+
+static diagnostic_url_format
+parse_env_vars_for_urls ()
+{
+  const char *p;
+
+  p = getenv ("GCC_URLS"); /* Plural! */
+  if (p == NULL)
+    p = getenv ("TERM_URLS");
+
+  if (p == NULL)
+    return URL_FORMAT_DEFAULT;
+
+  if (*p == '\0')
+    return URL_FORMAT_NONE;
+
+  if (!strcmp (p, "no"))
+    return URL_FORMAT_NONE;
+
+  if (!strcmp (p, "st"))
+    return URL_FORMAT_ST;
+
+  if (!strcmp (p, "bel"))
+    return URL_FORMAT_BEL;
+
+  return URL_FORMAT_DEFAULT;
+}
+
+/* Return true if we should use urls when in auto mode, false otherwise.  */
+
+static bool
+auto_enable_urls ()
+{
+#ifdef __MINGW32__
+  return false;
+#else
+  const char *term, *colorterm;
+
+  /* First check the terminal is capable of printing color escapes,
+     if not URLs won't work either.  */
+  if (!should_colorize ())
+    return false;
+
+  /* xfce4-terminal is known to not implement URLs at this time.
+     Recently new installations (0.8) will safely ignore the URL escape
+     sequences, but a large number of legacy installations (0.6.3) print
+     garbage when URLs are printed.  Therefore we lose nothing by
+     disabling this feature for that specific terminal type.  */
+  colorterm = getenv ("COLORTERM");
+  if (colorterm && !strcmp (colorterm, "xfce4-terminal"))
+    return false;
+
+  /* Old versions of gnome-terminal where URL escapes cause screen
+     corruptions set COLORTERM="gnome-terminal", recent versions
+     with working URL support set this to "truecolor".  */
+  if (colorterm && !strcmp (colorterm, "gnome-terminal"))
+    return false;
+
+  /* Since the following checks are less specific than the ones
+     above, let GCC_URLS and TERM_URLS override the decision.  */
+  if (getenv ("GCC_URLS") || getenv ("TERM_URLS"))
+    return true;
+
+  /* In an ssh session the COLORTERM is not there, but TERM=xterm
+     can be used as an indication of a incompatible terminal while
+     TERM=xterm-256color appears to be a working terminal.  */
+  term = getenv ("TERM");
+  if (!colorterm && term && !strcmp (term, "xterm"))
+    return false;
+
+  /* When logging in a linux over serial line, we see TERM=linux
+     and no COLORTERM, it is unlikely that the URL escapes will
+     work in that environmen either.  */
+  if (!colorterm && term && !strcmp (term, "linux"))
+    return false;
+
+  return true;
+#endif
+}
+
+/* Determine if URLs should be enabled, based on RULE,
+   and, if so, which format to use.
    This reuses the logic for colorization.  */
 
-bool
-diagnostic_urls_enabled_p (diagnostic_url_rule_t rule)
+diagnostic_url_format
+determine_url_format (diagnostic_url_rule_t rule)
 {
   switch (rule)
     {
     case DIAGNOSTICS_URL_NO:
-      return false;
+      return URL_FORMAT_NONE;
     case DIAGNOSTICS_URL_YES:
-      return true;
+      return parse_env_vars_for_urls ();
     case DIAGNOSTICS_URL_AUTO:
-      return should_colorize ();
+      if (auto_enable_urls ())
+	return parse_env_vars_for_urls ();
+      else
+	return URL_FORMAT_NONE;
     default:
       gcc_unreachable ();
     }
diff --git a/gcc/diagnostic-url.h b/gcc/diagnostic-url.h
index 6be056941f1..d28460b928b 100644
--- a/gcc/diagnostic-url.h
+++ b/gcc/diagnostic-url.h
@@ -31,6 +31,22 @@ typedef enum
   DIAGNOSTICS_URL_AUTO     = 2
 } diagnostic_url_rule_t;
 
-extern bool diagnostic_urls_enabled_p (diagnostic_url_rule_t);
+/* Tells whether URLs should be emitted, and, if so, how to
+   terminate strings within the escape sequence.   */
+enum diagnostic_url_format
+{
+  /* No URLs shall be emitted.  */
+  URL_FORMAT_NONE,
+
+  /* Use ST string termination.  */
+  URL_FORMAT_ST,
+
+  /* Use BEL string termination.  */
+  URL_FORMAT_BEL
+};
+
+const diagnostic_url_format URL_FORMAT_DEFAULT = URL_FORMAT_BEL;
+
+extern diagnostic_url_format determine_url_format (diagnostic_url_rule_t);
 
 #endif /* ! GCC_DIAGNOSTIC_URL_H */
diff --git a/gcc/diagnostic.c b/gcc/diagnostic.c
index 3386f070256..e4a08f76def 100644
--- a/gcc/diagnostic.c
+++ b/gcc/diagnostic.c
@@ -260,11 +260,26 @@ diagnostic_color_init (diagnostic_context *context, int value /*= -1 */)
 void
 diagnostic_urls_init (diagnostic_context *context, int value /*= -1 */)
 {
+  /* value == -1 is the default value.  */
   if (value < 0)
-    value = DIAGNOSTICS_COLOR_DEFAULT;
+    {
+      /* If DIAGNOSTICS_URLS_DEFAULT is -1, default to
+	 -fdiagnostics-urls=auto if GCC_URLS or TERM_URLS is in the
+	 environment, otherwise default to -fdiagnostics-urls=never,
+	 for other values default to that
+	 -fdiagnostics-urls={never,auto,always}.  */
+      if (DIAGNOSTICS_URLS_DEFAULT == -1)
+	{
+	  if (!getenv ("GCC_URLS") && !getenv ("TERM_URLS"))
+	    return;
+	  value = DIAGNOSTICS_URL_AUTO;
+	}
+      else
+	value = DIAGNOSTICS_URLS_DEFAULT;
+    }
 
-  context->printer->show_urls
-    = diagnostic_urls_enabled_p ((diagnostic_url_rule_t) value);
+  context->printer->url_format
+    = determine_url_format ((diagnostic_url_rule_t) value);
 }
 
 /* Do any cleaning up required after the last diagnostic is emitted.  */
diff --git a/gcc/doc/install.texi b/gcc/doc/install.texi
index 6ffafacff50..8ddebbb6267 100644
--- a/gcc/doc/install.texi
+++ b/gcc/doc/install.texi
@@ -2095,11 +2095,20 @@ GLIBC 2.11 or above, otherwise disabled.
 Tells GCC to use @var{choice} as the default for @option{-fdiagnostics-color=}
 option (if not used explicitly on the command line).  @var{choice}
 can be one of @samp{never}, @samp{auto}, @samp{always}, and @samp{auto-if-env}
-where @samp{auto} is the default.  @samp{auto-if-env} means that
-@option{-fdiagnostics-color=auto} will be the default if @code{GCC_COLORS}
-is present and non-empty in the environment, and
+where @samp{auto} is the default.  @samp{auto-if-env} makes
+@option{-fdiagnostics-color=auto} the default if @env{GCC_COLORS}
+is present and non-empty in the environment of the compiler, and
 @option{-fdiagnostics-color=never} otherwise.
 
+@item --with-diagnostics-urls=@var{choice}
+Tells GCC to use @var{choice} as the default for @option{-fdiagnostics-urls=}
+option (if not used explicitly on the command line).  @var{choice}
+can be one of @samp{never}, @samp{auto}, @samp{always}, and @samp{auto-if-env}
+where @samp{auto} is the default.  @samp{auto-if-env} makes
+@option{-fdiagnostics-urls=auto} the default if @env{GCC_URLS}
+or @env{TERM_URLS} is present and non-empty in the environment of the
+compiler, and @option{-fdiagnostics-urls=never} otherwise.
+
 @item --enable-lto
 @itemx --disable-lto
 Enable support for link-time optimization (LTO).  This is enabled by
diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
index bd9ecebf103..597151670be 100644
--- a/gcc/doc/invoke.texi
+++ b/gcc/doc/invoke.texi
@@ -3920,7 +3920,8 @@ or @samp{auto}.  The default depends on how the compiler has been configured,
 it can be any of the above @var{WHEN} options or also @samp{never}
 if @env{GCC_COLORS} environment variable isn't present in the environment,
 and @samp{auto} otherwise.
-@samp{auto} means to use color only when the standard error is a terminal.
+@samp{auto} makes GCC use color only when the standard error is a terminal,
+and when not executing in an emacs shell.
 The forms @option{-fdiagnostics-color} and @option{-fno-diagnostics-color} are
 aliases for @option{-fdiagnostics-color=always} and
 @option{-fdiagnostics-color=never}, respectively.
@@ -4033,14 +4034,46 @@ arguments in the C++ frontend.
 @item -fdiagnostics-urls[=@var{WHEN}]
 @opindex fdiagnostics-urls
 @cindex urls
+@vindex GCC_URLS @r{environment variable}
+@vindex TERM_URLS @r{environment variable}
 Use escape sequences to embed URLs in diagnostics.  For example, when
 @option{-fdiagnostics-show-option} emits text showing the command-line
 option controlling a diagnostic, embed a URL for documentation of that
 option.
 
 @var{WHEN} is @samp{never}, @samp{always}, or @samp{auto}.
-The default is @samp{auto}, which means to use URL escape sequences only
-when the standard error is a terminal.
+@samp{auto} makes GCC use URL escape sequences only when the standard error
+is a terminal, and when not executing in an emacs shell or any graphical
+terminal which is known to be incompatible with this feature, see below.
+
+The default depends on how the compiler has been configured.
+It can be any of the above @var{WHEN} options.
+
+GCC can also be configured (via the
+@option{--with-diagnostics-urls=auto-if-env} configure-time option)
+so that the default is affected by environment variables.
+Under such a configuration, GCC defaults to using @samp{auto}
+if either @env{GCC_URLS} or @env{TERM_URLS} environment variables are
+present and non-empty in the environment of the compiler, or @samp{never}
+if neither are.
+
+However, even with @option{-fdiagnostics-urls=always} the behavior is
+dependent on those environment variables:
+If @env{GCC_URLS} is set to empty or @samp{no}, do not embed URLs in
+diagnostics.  If set to @samp{st}, URLs use ST escape sequences.
+If set to @samp{bel}, the default, URLs use BEL escape sequences.
+Any other non-empty value enables the feature.
+If @env{GCC_URLS} is not set, use @env{TERM_URLS} as a fallback.
+Note: ST is an ANSI escape sequence, string terminator @samp{ESC \},
+BEL is an ASCII character, CTRL-G that usually sounds like a beep.
+
+At this time GCC tries to detect also a few terminals that are known to
+not implement the URL feature, and have bugs or at least had bugs in
+some versions that are still in use, where the URL escapes are likely
+to misbehave, i.e. print garbage on the screen.
+That list is currently xfce4-terminal, certain known to be buggy
+gnome-terminal versions, the linux console, and mingw.
+This check can be skipped with the @option{-fdiagnostics-urls=always}.
 
 @item -fno-diagnostics-show-option
 @opindex fno-diagnostics-show-option
diff --git a/gcc/pretty-print.c b/gcc/pretty-print.c
index 817c1059e08..dde138b0533 100644
--- a/gcc/pretty-print.c
+++ b/gcc/pretty-print.c
@@ -1647,7 +1647,7 @@ pretty_printer::pretty_printer (int maximum_length)
     need_newline (),
     translate_identifiers (true),
     show_color (),
-    show_urls (false)
+    url_format (URL_FORMAT_NONE)
 {
   pp_line_cutoff (this) = maximum_length;
   /* By default, we emit prefixes once per message.  */
@@ -1670,7 +1670,7 @@ pretty_printer::pretty_printer (const pretty_printer &other)
   need_newline (other.need_newline),
   translate_identifiers (other.translate_identifiers),
   show_color (other.show_color),
-  show_urls (other.show_urls)
+  url_format (other.url_format)
 {
   pp_line_cutoff (this) = maximum_length;
   /* By default, we emit prefixes once per message.  */
@@ -2171,8 +2171,19 @@ identifier_to_locale (const char *ident)
 void
 pp_begin_url (pretty_printer *pp, const char *url)
 {
-  if (pp->show_urls)
+  switch (pp->url_format)
+  {
+  case URL_FORMAT_NONE:
+    break;
+  case URL_FORMAT_ST:
+    pp_printf (pp, "\33]8;;%s\33\\", url);
+    break;
+  case URL_FORMAT_BEL:
     pp_printf (pp, "\33]8;;%s\a", url);
+    break;
+  default:
+    gcc_unreachable ();
+  }
 }
 
 /* If URL-printing is enabled, write a "close URL" escape sequence to PP.  */
@@ -2180,8 +2191,19 @@ pp_begin_url (pretty_printer *pp, const char *url)
 void
 pp_end_url (pretty_printer *pp)
 {
-  if (pp->show_urls)
+  switch (pp->url_format)
+  {
+  case URL_FORMAT_NONE:
+    break;
+  case URL_FORMAT_ST:
+    pp_string (pp, "\33]8;;\33\\");
+    break;
+  case URL_FORMAT_BEL:
     pp_string (pp, "\33]8;;\a");
+    break;
+  default:
+    gcc_unreachable ();
+  }
 }
 
 #if CHECKING_P
@@ -2490,7 +2512,7 @@ test_urls ()
 {
   {
     pretty_printer pp;
-    pp.show_urls = false;
+    pp.url_format = URL_FORMAT_NONE;
     pp_begin_url (&pp, "http://example.com");
     pp_string (&pp, "This is a link");
     pp_end_url (&pp);
@@ -2500,7 +2522,17 @@ test_urls ()
 
   {
     pretty_printer pp;
-    pp.show_urls = true;
+    pp.url_format = URL_FORMAT_ST;
+    pp_begin_url (&pp, "http://example.com");
+    pp_string (&pp, "This is a link");
+    pp_end_url (&pp);
+    ASSERT_STREQ ("\33]8;;http://example.com\33\\This is a link\33]8;;\33\\",
+		  pp_formatted_text (&pp));
+  }
+
+  {
+    pretty_printer pp;
+    pp.url_format = URL_FORMAT_BEL;
     pp_begin_url (&pp, "http://example.com");
     pp_string (&pp, "This is a link");
     pp_end_url (&pp);
diff --git a/gcc/pretty-print.h b/gcc/pretty-print.h
index 001468c966e..22892f12ab7 100644
--- a/gcc/pretty-print.h
+++ b/gcc/pretty-print.h
@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see
 #define GCC_PRETTY_PRINT_H
 
 #include "obstack.h"
+#include "diagnostic-url.h"
 
 /* Maximum number of format string arguments.  */
 #define PP_NL_ARGMAX   30
@@ -278,8 +279,8 @@ public:
   /* Nonzero means that text should be colorized.  */
   bool show_color;
 
-  /* Nonzero means that URLs should be emitted.  */
-  bool show_urls;
+  /* Whether URLs should be emitted, and which terminator to use.  */
+  diagnostic_url_format url_format;
 };
 
 static inline const char *
-- 
2.26.1

=== 0031-Fix-typo-and-avoid-possible-memory-leak-in-average_n.patch ===
From b38e86ddb7a9b6d7e87d7cc0b23983d027fcbd96 Mon Sep 17 00:00:00 2001
From: Kewen Lin <linkw@linux.ibm.com>
Date: Tue, 14 Jan 2020 02:34:10 -0600
Subject: [PATCH 0031/2034] Fix typo and avoid possible memory leak in
 average_num_loop_insns

Function average_num_loop_insns forgets to free loop body in early
return.  Besides, overflow comparison checks 1000000 (e6) but the
return value is 100000 (e5), fix this typo.

gcc/ChangeLog

2020-01-14  Kewen Lin  <linkw@gcc.gnu.org>

    * cfgloopanal.c (average_num_loop_insns): Free bbs when early
    return, fix typo on return value.
---
 gcc/ChangeLog     | 5 +++++
 gcc/cfgloopanal.c | 5 ++++-
 2 files changed, 9 insertions(+), 1 deletion(-)

diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 07e5bebe909..f3301b16464 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,8 @@
+2020-01-14  Kewen Lin  <linkw@gcc.gnu.org>
+
+	* cfgloopanal.c (average_num_loop_insns): Free bbs when early return,
+	fix typo on return value.
+
 2020-01-14  Xiong Hu Luo  <luoxhu@linux.ibm.com>
 
 	PR ipa/69678
diff --git a/gcc/cfgloopanal.c b/gcc/cfgloopanal.c
index 392b1c337c4..0b33e8272a7 100644
--- a/gcc/cfgloopanal.c
+++ b/gcc/cfgloopanal.c
@@ -219,7 +219,10 @@ average_num_loop_insns (const class loop *loop)
       ninsns += (sreal)binsns * bb->count.to_sreal_scale (loop->header->count);
       /* Avoid overflows.   */
       if (ninsns > 1000000)
-	return 100000;
+	{
+	  free (bbs);
+	  return 1000000;
+	}
     }
   free (bbs);
 
-- 
2.26.1

=== 0735-PR-87488-Add-with-diagnostics-urls-configuration-opt.patch ===
From 458c8d6459c4005fc9886b6e25d168a6535ac415 Mon Sep 17 00:00:00 2001
From: Bernd Edlinger <bernd.edlinger@hotmail.de>
Date: Wed, 29 Jan 2020 15:31:10 +0100
Subject: [PATCH 0735/2034] PR 87488: Add --with-diagnostics-urls configuration
 option

2020-02-15  David Malcolm  <dmalcolm@redhat.com>
	    Bernd Edlinger  <bernd.edlinger@hotmail.de>

	PR 87488
	PR other/93168
	* config.in (DIAGNOSTICS_URLS_DEFAULT): New define.
	* configure.ac (--with-diagnostics-urls): New configuration
	option, based on --with-diagnostics-color.
	(DIAGNOSTICS_URLS_DEFAULT): New define.
	* config.h: Regenerate.
	* configure: Regenerate.
	* diagnostic.c (diagnostic_urls_init): Handle -1 for
	DIAGNOSTICS_URLS_DEFAULT from configure-time
	--with-diagnostics-urls=auto-if-env by querying for a GCC_URLS
	and TERM_URLS environment variable.
	* diagnostic-url.h (diagnostic_url_format): New enum type.
	(diagnostic_urls_enabled_p): rename to...
	(determine_url_format): ... this, and change return type.
	* diagnostic-color.c (parse_env_vars_for_urls): New helper function.
	(auto_enable_urls): Disable URLs on xfce4-terminal, gnome-terminal,
	the linux console, and mingw.
	(diagnostic_urls_enabled_p): rename to...
	(determine_url_format): ... this, and adjust.
	* pretty-print.h (pretty_printer::show_urls): rename to...
	(pretty_printer::url_format): ... this, and change to enum.
	* pretty-print.c (pretty_printer::pretty_printer,
	pp_begin_url, pp_end_url, test_urls): Adjust.
	* doc/install.texi (--with-diagnostics-urls): Document the new
	configuration option.
	(--with-diagnostics-color): Document the existing interaction
	with GCC_COLORS better.
	* doc/invoke.texi (-fdiagnostics-urls): Add GCC_URLS and TERM_URLS
	vindex reference.  Update description of defaults based on the above.
	(-fdiagnostics-color): Update description of how -fdiagnostics-color
	interacts with GCC_COLORS.
---
 gcc/ChangeLog          |  36 +++++++++++++++
 gcc/config.in          |   6 +++
 gcc/configure          |  41 ++++++++++++++++-
 gcc/configure.ac       |  28 ++++++++++++
 gcc/diagnostic-color.c | 101 ++++++++++++++++++++++++++++++++++++++---
 gcc/diagnostic-url.h   |  18 +++++++-
 gcc/diagnostic.c       |  21 +++++++--
 gcc/doc/install.texi   |  15 ++++--
 gcc/doc/invoke.texi    |  39 ++++++++++++++--
 gcc/pretty-print.c     |  44 +++++++++++++++---
 gcc/pretty-print.h     |   5 +-
 11 files changed, 328 insertions(+), 26 deletions(-)

diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index e6eb6ab4c21..22f990a3088 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,39 @@
+2020-02-15  David Malcolm  <dmalcolm@redhat.com>
+	    Bernd Edlinger  <bernd.edlinger@hotmail.de>
+
+	PR 87488
+	PR other/93168
+	* config.in (DIAGNOSTICS_URLS_DEFAULT): New define.
+	* configure.ac (--with-diagnostics-urls): New configuration
+	option, based on --with-diagnostics-color.
+	(DIAGNOSTICS_URLS_DEFAULT): New define.
+	* config.h: Regenerate.
+	* configure: Regenerate.
+	* diagnostic.c (diagnostic_urls_init): Handle -1 for
+	DIAGNOSTICS_URLS_DEFAULT from configure-time
+	--with-diagnostics-urls=auto-if-env by querying for a GCC_URLS
+	and TERM_URLS environment variable.
+	* diagnostic-url.h (diagnostic_url_format): New enum type.
+	(diagnostic_urls_enabled_p): rename to...
+	(determine_url_format): ... this, and change return type.
+	* diagnostic-color.c (parse_env_vars_for_urls): New helper function.
+	(auto_enable_urls): Disable URLs on xfce4-terminal, gnome-terminal,
+	the linux console, and mingw.
+	(diagnostic_urls_enabled_p): rename to...
+	(determine_url_format): ... this, and adjust.
+	* pretty-print.h (pretty_printer::show_urls): rename to...
+	(pretty_printer::url_format): ... this, and change to enum.
+	* pretty-print.c (pretty_printer::pretty_printer,
+	pp_begin_url, pp_end_url, test_urls): Adjust.
+	* doc/install.texi (--with-diagnostics-urls): Document the new
+	configuration option.
+	(--with-diagnostics-color): Document the existing interaction
+	with GCC_COLORS better.
+	* doc/invoke.texi (-fdiagnostics-urls): Add GCC_URLS and TERM_URLS
+	vindex reference.  Update description of defaults based on the above.
+	(-fdiagnostics-color): Update description of how -fdiagnostics-color
+	interacts with GCC_COLORS.
+
 2020-02-14  Eric Botcazou  <ebotcazou@adacore.com>
 
 	PR target/93704
diff --git a/gcc/config.in b/gcc/config.in
index 48292861842..01fb18dbbb5 100644
--- a/gcc/config.in
+++ b/gcc/config.in
@@ -76,6 +76,12 @@
 #endif
 
 
+/* The default for -fdiagnostics-urls option */
+#ifndef USED_FOR_TARGET
+#undef DIAGNOSTICS_URLS_DEFAULT
+#endif
+
+
 /* Define 0/1 if static analyzer feature is enabled. */
 #ifndef USED_FOR_TARGET
 #undef ENABLE_ANALYZER
diff --git a/gcc/configure b/gcc/configure
index 5fa565a40a4..f55cdb8c77f 100755
--- a/gcc/configure
+++ b/gcc/configure
@@ -1015,6 +1015,7 @@ enable_host_shared
 enable_libquadmath_support
 with_linker_hash_style
 with_diagnostics_color
+with_diagnostics_urls
 enable_default_pie
 '
       ac_precious_vars='build_alias
@@ -1836,6 +1837,11 @@ Optional Packages:
                           auto-if-env stands for -fdiagnostics-color=auto if
                           GCC_COLOR environment variable is present and
                           -fdiagnostics-color=never otherwise
+  --with-diagnostics-urls={never,auto,auto-if-env,always}
+                          specify the default of -fdiagnostics-urls option
+                          auto-if-env stands for -fdiagnostics-urls=auto if
+                          GCC_URLS or TERM_URLS environment variable is
+                          present and -fdiagnostics-urls=never otherwise
 
 Some influential environment variables:
   CC          C compiler command
@@ -18974,7 +18980,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 18977 "configure"
+#line 18983 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -19080,7 +19086,7 @@ else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 19083 "configure"
+#line 19089 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -30575,6 +30581,37 @@ cat >>confdefs.h <<_ACEOF
 _ACEOF
 
 
+# Specify what should be the default of -fdiagnostics-urls option.
+
+# Check whether --with-diagnostics-urls was given.
+if test "${with_diagnostics_urls+set}" = set; then :
+  withval=$with_diagnostics_urls; case x"$withval" in
+   xnever)
+     DIAGNOSTICS_URLS_DEFAULT=DIAGNOSTICS_URL_NO
+     ;;
+   xauto)
+     DIAGNOSTICS_URLS_DEFAULT=DIAGNOSTICS_URL_AUTO
+     ;;
+   xauto-if-env)
+     DIAGNOSTICS_URLS_DEFAULT=-1
+     ;;
+   xalways)
+     DIAGNOSTICS_URLS_DEFAULT=DIAGNOSTICS_URL_YES
+     ;;
+   *)
+     as_fn_error $? "$withval is an invalid option to --with-diagnostics-urls" "$LINENO" 5
+     ;;
+ esac
+else
+  DIAGNOSTICS_URLS_DEFAULT=DIAGNOSTICS_URL_AUTO
+fi
+
+
+cat >>confdefs.h <<_ACEOF
+#define DIAGNOSTICS_URLS_DEFAULT $DIAGNOSTICS_URLS_DEFAULT
+_ACEOF
+
+
 # Generate gcc-driver-name.h containing GCC_DRIVER_NAME for the benefit
 # of jit/jit-playback.c.
 gcc_driver_version=`eval "${get_gcc_base_ver} $srcdir/BASE-VER"`
diff --git a/gcc/configure.ac b/gcc/configure.ac
index 671b9a67d81..0e6e475950d 100644
--- a/gcc/configure.ac
+++ b/gcc/configure.ac
@@ -6741,6 +6741,34 @@ AC_ARG_WITH([diagnostics-color],
 AC_DEFINE_UNQUOTED(DIAGNOSTICS_COLOR_DEFAULT, $DIAGNOSTICS_COLOR_DEFAULT,
 		   [The default for -fdiagnostics-color option])
 
+# Specify what should be the default of -fdiagnostics-urls option.
+AC_ARG_WITH([diagnostics-urls],
+[AC_HELP_STRING([--with-diagnostics-urls={never,auto,auto-if-env,always}],
+                [specify the default of -fdiagnostics-urls option
+                 auto-if-env stands for -fdiagnostics-urls=auto if
+                 GCC_URLS or TERM_URLS environment variable is present and
+                 -fdiagnostics-urls=never otherwise])],
+[case x"$withval" in
+   xnever)
+     DIAGNOSTICS_URLS_DEFAULT=DIAGNOSTICS_URL_NO
+     ;;
+   xauto)
+     DIAGNOSTICS_URLS_DEFAULT=DIAGNOSTICS_URL_AUTO
+     ;;
+   xauto-if-env)
+     DIAGNOSTICS_URLS_DEFAULT=-1
+     ;;
+   xalways)
+     DIAGNOSTICS_URLS_DEFAULT=DIAGNOSTICS_URL_YES
+     ;;
+   *)
+     AC_MSG_ERROR([$withval is an invalid option to --with-diagnostics-urls])
+     ;;
+ esac],
+[DIAGNOSTICS_URLS_DEFAULT=DIAGNOSTICS_URL_AUTO])
+AC_DEFINE_UNQUOTED(DIAGNOSTICS_URLS_DEFAULT, $DIAGNOSTICS_URLS_DEFAULT,
+		   [The default for -fdiagnostics-urls option])
+
 # Generate gcc-driver-name.h containing GCC_DRIVER_NAME for the benefit
 # of jit/jit-playback.c.
 gcc_driver_version=`eval "${get_gcc_base_ver} $srcdir/BASE-VER"`
diff --git a/gcc/diagnostic-color.c b/gcc/diagnostic-color.c
index d5547952921..b1baded2c9e 100644
--- a/gcc/diagnostic-color.c
+++ b/gcc/diagnostic-color.c
@@ -216,6 +216,7 @@ should_colorize (void)
 	  && GetConsoleMode (h, &m);
 #else
   char const *t = getenv ("TERM");
+  /* emacs M-x shell sets TERM="dumb".  */
   return t && strcmp (t, "dumb") != 0 && isatty (STDERR_FILENO);
 #endif
 }
@@ -239,20 +240,108 @@ colorize_init (diagnostic_color_rule_t rule)
     }
 }
 
-/* Determine if URLs should be enabled, based on RULE.
+/* Return URL_FORMAT_XXX which tells how we should emit urls
+   when in always mode.
+   We use GCC_URLS and if that is not defined TERM_URLS.
+   If neither is defined the feature is enabled by default.  */
+
+static diagnostic_url_format
+parse_env_vars_for_urls ()
+{
+  const char *p;
+
+  p = getenv ("GCC_URLS"); /* Plural! */
+  if (p == NULL)
+    p = getenv ("TERM_URLS");
+
+  if (p == NULL)
+    return URL_FORMAT_DEFAULT;
+
+  if (*p == '\0')
+    return URL_FORMAT_NONE;
+
+  if (!strcmp (p, "no"))
+    return URL_FORMAT_NONE;
+
+  if (!strcmp (p, "st"))
+    return URL_FORMAT_ST;
+
+  if (!strcmp (p, "bel"))
+    return URL_FORMAT_BEL;
+
+  return URL_FORMAT_DEFAULT;
+}
+
+/* Return true if we should use urls when in auto mode, false otherwise.  */
+
+static bool
+auto_enable_urls ()
+{
+#ifdef __MINGW32__
+  return false;
+#else
+  const char *term, *colorterm;
+
+  /* First check the terminal is capable of printing color escapes,
+     if not URLs won't work either.  */
+  if (!should_colorize ())
+    return false;
+
+  /* xfce4-terminal is known to not implement URLs at this time.
+     Recently new installations (0.8) will safely ignore the URL escape
+     sequences, but a large number of legacy installations (0.6.3) print
+     garbage when URLs are printed.  Therefore we lose nothing by
+     disabling this feature for that specific terminal type.  */
+  colorterm = getenv ("COLORTERM");
+  if (colorterm && !strcmp (colorterm, "xfce4-terminal"))
+    return false;
+
+  /* Old versions of gnome-terminal where URL escapes cause screen
+     corruptions set COLORTERM="gnome-terminal", recent versions
+     with working URL support set this to "truecolor".  */
+  if (colorterm && !strcmp (colorterm, "gnome-terminal"))
+    return false;
+
+  /* Since the following checks are less specific than the ones
+     above, let GCC_URLS and TERM_URLS override the decision.  */
+  if (getenv ("GCC_URLS") || getenv ("TERM_URLS"))
+    return true;
+
+  /* In an ssh session the COLORTERM is not there, but TERM=xterm
+     can be used as an indication of a incompatible terminal while
+     TERM=xterm-256color appears to be a working terminal.  */
+  term = getenv ("TERM");
+  if (!colorterm && term && !strcmp (term, "xterm"))
+    return false;
+
+  /* When logging in a linux over serial line, we see TERM=linux
+     and no COLORTERM, it is unlikely that the URL escapes will
+     work in that environmen either.  */
+  if (!colorterm && term && !strcmp (term, "linux"))
+    return false;
+
+  return true;
+#endif
+}
+
+/* Determine if URLs should be enabled, based on RULE,
+   and, if so, which format to use.
    This reuses the logic for colorization.  */
 
-bool
-diagnostic_urls_enabled_p (diagnostic_url_rule_t rule)
+diagnostic_url_format
+determine_url_format (diagnostic_url_rule_t rule)
 {
   switch (rule)
     {
     case DIAGNOSTICS_URL_NO:
-      return false;
+      return URL_FORMAT_NONE;
     case DIAGNOSTICS_URL_YES:
-      return true;
+      return parse_env_vars_for_urls ();
     case DIAGNOSTICS_URL_AUTO:
-      return should_colorize ();
+      if (auto_enable_urls ())
+	return parse_env_vars_for_urls ();
+      else
+	return URL_FORMAT_NONE;
     default:
       gcc_unreachable ();
     }
diff --git a/gcc/diagnostic-url.h b/gcc/diagnostic-url.h
index 6be056941f1..d28460b928b 100644
--- a/gcc/diagnostic-url.h
+++ b/gcc/diagnostic-url.h
@@ -31,6 +31,22 @@ typedef enum
   DIAGNOSTICS_URL_AUTO     = 2
 } diagnostic_url_rule_t;
 
-extern bool diagnostic_urls_enabled_p (diagnostic_url_rule_t);
+/* Tells whether URLs should be emitted, and, if so, how to
+   terminate strings within the escape sequence.   */
+enum diagnostic_url_format
+{
+  /* No URLs shall be emitted.  */
+  URL_FORMAT_NONE,
+
+  /* Use ST string termination.  */
+  URL_FORMAT_ST,
+
+  /* Use BEL string termination.  */
+  URL_FORMAT_BEL
+};
+
+const diagnostic_url_format URL_FORMAT_DEFAULT = URL_FORMAT_BEL;
+
+extern diagnostic_url_format determine_url_format (diagnostic_url_rule_t);
 
 #endif /* ! GCC_DIAGNOSTIC_URL_H */
diff --git a/gcc/diagnostic.c b/gcc/diagnostic.c
index 3386f070256..e4a08f76def 100644
--- a/gcc/diagnostic.c
+++ b/gcc/diagnostic.c
@@ -260,11 +260,26 @@ diagnostic_color_init (diagnostic_context *context, int value /*= -1 */)
 void
 diagnostic_urls_init (diagnostic_context *context, int value /*= -1 */)
 {
+  /* value == -1 is the default value.  */
   if (value < 0)
-    value = DIAGNOSTICS_COLOR_DEFAULT;
+    {
+      /* If DIAGNOSTICS_URLS_DEFAULT is -1, default to
+	 -fdiagnostics-urls=auto if GCC_URLS or TERM_URLS is in the
+	 environment, otherwise default to -fdiagnostics-urls=never,
+	 for other values default to that
+	 -fdiagnostics-urls={never,auto,always}.  */
+      if (DIAGNOSTICS_URLS_DEFAULT == -1)
+	{
+	  if (!getenv ("GCC_URLS") && !getenv ("TERM_URLS"))
+	    return;
+	  value = DIAGNOSTICS_URL_AUTO;
+	}
+      else
+	value = DIAGNOSTICS_URLS_DEFAULT;
+    }
 
-  context->printer->show_urls
-    = diagnostic_urls_enabled_p ((diagnostic_url_rule_t) value);
+  context->printer->url_format
+    = determine_url_format ((diagnostic_url_rule_t) value);
 }
 
 /* Do any cleaning up required after the last diagnostic is emitted.  */
diff --git a/gcc/doc/install.texi b/gcc/doc/install.texi
index 6ffafacff50..8ddebbb6267 100644
--- a/gcc/doc/install.texi
+++ b/gcc/doc/install.texi
@@ -2095,11 +2095,20 @@ GLIBC 2.11 or above, otherwise disabled.
 Tells GCC to use @var{choice} as the default for @option{-fdiagnostics-color=}
 option (if not used explicitly on the command line).  @var{choice}
 can be one of @samp{never}, @samp{auto}, @samp{always}, and @samp{auto-if-env}
-where @samp{auto} is the default.  @samp{auto-if-env} means that
-@option{-fdiagnostics-color=auto} will be the default if @code{GCC_COLORS}
-is present and non-empty in the environment, and
+where @samp{auto} is the default.  @samp{auto-if-env} makes
+@option{-fdiagnostics-color=auto} the default if @env{GCC_COLORS}
+is present and non-empty in the environment of the compiler, and
 @option{-fdiagnostics-color=never} otherwise.
 
+@item --with-diagnostics-urls=@var{choice}
+Tells GCC to use @var{choice} as the default for @option{-fdiagnostics-urls=}
+option (if not used explicitly on the command line).  @var{choice}
+can be one of @samp{never}, @samp{auto}, @samp{always}, and @samp{auto-if-env}
+where @samp{auto} is the default.  @samp{auto-if-env} makes
+@option{-fdiagnostics-urls=auto} the default if @env{GCC_URLS}
+or @env{TERM_URLS} is present and non-empty in the environment of the
+compiler, and @option{-fdiagnostics-urls=never} otherwise.
+
 @item --enable-lto
 @itemx --disable-lto
 Enable support for link-time optimization (LTO).  This is enabled by
diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
index bd9ecebf103..597151670be 100644
--- a/gcc/doc/invoke.texi
+++ b/gcc/doc/invoke.texi
@@ -3920,7 +3920,8 @@ or @samp{auto}.  The default depends on how the compiler has been configured,
 it can be any of the above @var{WHEN} options or also @samp{never}
 if @env{GCC_COLORS} environment variable isn't present in the environment,
 and @samp{auto} otherwise.
-@samp{auto} means to use color only when the standard error is a terminal.
+@samp{auto} makes GCC use color only when the standard error is a terminal,
+and when not executing in an emacs shell.
 The forms @option{-fdiagnostics-color} and @option{-fno-diagnostics-color} are
 aliases for @option{-fdiagnostics-color=always} and
 @option{-fdiagnostics-color=never}, respectively.
@@ -4033,14 +4034,46 @@ arguments in the C++ frontend.
 @item -fdiagnostics-urls[=@var{WHEN}]
 @opindex fdiagnostics-urls
 @cindex urls
+@vindex GCC_URLS @r{environment variable}
+@vindex TERM_URLS @r{environment variable}
 Use escape sequences to embed URLs in diagnostics.  For example, when
 @option{-fdiagnostics-show-option} emits text showing the command-line
 option controlling a diagnostic, embed a URL for documentation of that
 option.
 
 @var{WHEN} is @samp{never}, @samp{always}, or @samp{auto}.
-The default is @samp{auto}, which means to use URL escape sequences only
-when the standard error is a terminal.
+@samp{auto} makes GCC use URL escape sequences only when the standard error
+is a terminal, and when not executing in an emacs shell or any graphical
+terminal which is known to be incompatible with this feature, see below.
+
+The default depends on how the compiler has been configured.
+It can be any of the above @var{WHEN} options.
+
+GCC can also be configured (via the
+@option{--with-diagnostics-urls=auto-if-env} configure-time option)
+so that the default is affected by environment variables.
+Under such a configuration, GCC defaults to using @samp{auto}
+if either @env{GCC_URLS} or @env{TERM_URLS} environment variables are
+present and non-empty in the environment of the compiler, or @samp{never}
+if neither are.
+
+However, even with @option{-fdiagnostics-urls=always} the behavior is
+dependent on those environment variables:
+If @env{GCC_URLS} is set to empty or @samp{no}, do not embed URLs in
+diagnostics.  If set to @samp{st}, URLs use ST escape sequences.
+If set to @samp{bel}, the default, URLs use BEL escape sequences.
+Any other non-empty value enables the feature.
+If @env{GCC_URLS} is not set, use @env{TERM_URLS} as a fallback.
+Note: ST is an ANSI escape sequence, string terminator @samp{ESC \},
+BEL is an ASCII character, CTRL-G that usually sounds like a beep.
+
+At this time GCC tries to detect also a few terminals that are known to
+not implement the URL feature, and have bugs or at least had bugs in
+some versions that are still in use, where the URL escapes are likely
+to misbehave, i.e. print garbage on the screen.
+That list is currently xfce4-terminal, certain known to be buggy
+gnome-terminal versions, the linux console, and mingw.
+This check can be skipped with the @option{-fdiagnostics-urls=always}.
 
 @item -fno-diagnostics-show-option
 @opindex fno-diagnostics-show-option
diff --git a/gcc/pretty-print.c b/gcc/pretty-print.c
index 817c1059e08..dde138b0533 100644
--- a/gcc/pretty-print.c
+++ b/gcc/pretty-print.c
@@ -1647,7 +1647,7 @@ pretty_printer::pretty_printer (int maximum_length)
     need_newline (),
     translate_identifiers (true),
     show_color (),
-    show_urls (false)
+    url_format (URL_FORMAT_NONE)
 {
   pp_line_cutoff (this) = maximum_length;
   /* By default, we emit prefixes once per message.  */
@@ -1670,7 +1670,7 @@ pretty_printer::pretty_printer (const pretty_printer &other)
   need_newline (other.need_newline),
   translate_identifiers (other.translate_identifiers),
   show_color (other.show_color),
-  show_urls (other.show_urls)
+  url_format (other.url_format)
 {
   pp_line_cutoff (this) = maximum_length;
   /* By default, we emit prefixes once per message.  */
@@ -2171,8 +2171,19 @@ identifier_to_locale (const char *ident)
 void
 pp_begin_url (pretty_printer *pp, const char *url)
 {
-  if (pp->show_urls)
+  switch (pp->url_format)
+  {
+  case URL_FORMAT_NONE:
+    break;
+  case URL_FORMAT_ST:
+    pp_printf (pp, "\33]8;;%s\33\\", url);
+    break;
+  case URL_FORMAT_BEL:
     pp_printf (pp, "\33]8;;%s\a", url);
+    break;
+  default:
+    gcc_unreachable ();
+  }
 }
 
 /* If URL-printing is enabled, write a "close URL" escape sequence to PP.  */
@@ -2180,8 +2191,19 @@ pp_begin_url (pretty_printer *pp, const char *url)
 void
 pp_end_url (pretty_printer *pp)
 {
-  if (pp->show_urls)
+  switch (pp->url_format)
+  {
+  case URL_FORMAT_NONE:
+    break;
+  case URL_FORMAT_ST:
+    pp_string (pp, "\33]8;;\33\\");
+    break;
+  case URL_FORMAT_BEL:
     pp_string (pp, "\33]8;;\a");
+    break;
+  default:
+    gcc_unreachable ();
+  }
 }
 
 #if CHECKING_P
@@ -2490,7 +2512,7 @@ test_urls ()
 {
   {
     pretty_printer pp;
-    pp.show_urls = false;
+    pp.url_format = URL_FORMAT_NONE;
     pp_begin_url (&pp, "http://example.com");
     pp_string (&pp, "This is a link");
     pp_end_url (&pp);
@@ -2500,7 +2522,17 @@ test_urls ()
 
   {
     pretty_printer pp;
-    pp.show_urls = true;
+    pp.url_format = URL_FORMAT_ST;
+    pp_begin_url (&pp, "http://example.com");
+    pp_string (&pp, "This is a link");
+    pp_end_url (&pp);
+    ASSERT_STREQ ("\33]8;;http://example.com\33\\This is a link\33]8;;\33\\",
+		  pp_formatted_text (&pp));
+  }
+
+  {
+    pretty_printer pp;
+    pp.url_format = URL_FORMAT_BEL;
     pp_begin_url (&pp, "http://example.com");
     pp_string (&pp, "This is a link");
     pp_end_url (&pp);
diff --git a/gcc/pretty-print.h b/gcc/pretty-print.h
index 001468c966e..22892f12ab7 100644
--- a/gcc/pretty-print.h
+++ b/gcc/pretty-print.h
@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see
 #define GCC_PRETTY_PRINT_H
 
 #include "obstack.h"
+#include "diagnostic-url.h"
 
 /* Maximum number of format string arguments.  */
 #define PP_NL_ARGMAX   30
@@ -278,8 +279,8 @@ public:
   /* Nonzero means that text should be colorized.  */
   bool show_color;
 
-  /* Nonzero means that URLs should be emitted.  */
-  bool show_urls;
+  /* Whether URLs should be emitted, and which terminator to use.  */
+  diagnostic_url_format url_format;
 };
 
 static inline const char *
-- 
2.26.1

=== co-authored-by.patch ===
From d7a65edb629a010f7ef907d457343abcb569fab7 Mon Sep 17 00:00:00 2001
From: Martin Liska <mliska@suse.cz>
Date: Thu, 16 Apr 2020 15:39:22 +0200
Subject: [PATCH 1850/2034] List valid pairs for new and delete operators.

	PR c++/94314
	* cgraphclones.c (set_new_clone_decl_and_node_flags): Drop
	DECL_IS_REPLACEABLE_OPERATOR during cloning.
	* tree-ssa-dce.c (valid_new_delete_pair_p): New function.
	(propagate_necessity): Check operator names.

	PR c++/94314
	* g++.dg/pr94314.C: Do not use dg-additional-options
	and remove not needed stdio.h include.
	* g++.dg/pr94314-2.C: Likewise.
	* g++.dg/pr94314-3.C: Likewise.
	* g++.dg/pr94314-4.C: New test.

co-authored-By: Jakub Jelinek <jakub@redhat.com>
Co-Authored-by: John Miller <jm@example.com>
co-authored-by: John Miller2 <jm2@example.com>
---
 gcc/ChangeLog                    |  9 +++
 gcc/cgraphclones.c               |  2 +
 gcc/testsuite/ChangeLog          | 10 ++++
 gcc/testsuite/g++.dg/pr94314-2.C |  5 +-
 gcc/testsuite/g++.dg/pr94314-3.C |  5 +-
 gcc/testsuite/g++.dg/pr94314-4.C | 30 ++++++++++
 gcc/testsuite/g++.dg/pr94314.C   |  5 +-
 gcc/tree-ssa-dce.c               | 98 ++++++++++++++++++++++++++++----
 8 files changed, 142 insertions(+), 22 deletions(-)
 create mode 100644 gcc/testsuite/g++.dg/pr94314-4.C

diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 74dbeeb44c6..9e499ec9c86 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,12 @@
+2020-04-16  Martin Liska  <mliska@suse.cz>
+	    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/94314
+	* cgraphclones.c (set_new_clone_decl_and_node_flags): Drop
+	DECL_IS_REPLACEABLE_OPERATOR during cloning.
+	* tree-ssa-dce.c (valid_new_delete_pair_p): New function.
+	(propagate_necessity): Check operator names.
+
 2020-04-16  Richard Sandiford  <richard.sandiford@arm.com>
 
 	PR rtl-optimization/94605
diff --git a/gcc/cgraphclones.c b/gcc/cgraphclones.c
index c73b8f810f0..8f541a28b6e 100644
--- a/gcc/cgraphclones.c
+++ b/gcc/cgraphclones.c
@@ -165,6 +165,7 @@ set_new_clone_decl_and_node_flags (cgraph_node *new_node)
   DECL_STATIC_DESTRUCTOR (new_node->decl) = 0;
   DECL_SET_IS_OPERATOR_NEW (new_node->decl, 0);
   DECL_SET_IS_OPERATOR_DELETE (new_node->decl, 0);
+  DECL_IS_REPLACEABLE_OPERATOR (new_node->decl) = 0;
 
   new_node->externally_visible = 0;
   new_node->local = 1;
@@ -1030,6 +1031,7 @@ cgraph_node::create_version_clone_with_body
   DECL_STATIC_DESTRUCTOR (new_decl) = 0;
   DECL_SET_IS_OPERATOR_NEW (new_decl, 0);
   DECL_SET_IS_OPERATOR_DELETE (new_decl, 0);
+  DECL_IS_REPLACEABLE_OPERATOR (new_decl) = 0;
 
   /* Create the new version's call-graph node.
      and update the edges of the new node. */
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 756f1d759e6..94d2312022d 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,13 @@
+2020-04-16  Martin Liska  <mliska@suse.cz>
+	    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/94314
+	* g++.dg/pr94314.C: Do not use dg-additional-options
+	and remove not needed stdio.h include.
+	* g++.dg/pr94314-2.C: Likewise.
+	* g++.dg/pr94314-3.C: Likewise.
+	* g++.dg/pr94314-4.C: New test.
+
 2020-04-16  Patrick Palka  <ppalka@redhat.com>
 
 	PR c++/94475
diff --git a/gcc/testsuite/g++.dg/pr94314-2.C b/gcc/testsuite/g++.dg/pr94314-2.C
index 36b93ed6d4d..998ce601767 100644
--- a/gcc/testsuite/g++.dg/pr94314-2.C
+++ b/gcc/testsuite/g++.dg/pr94314-2.C
@@ -1,9 +1,6 @@
 /* PR c++/94314.  */
 /* { dg-do run } */
-/* { dg-options "-O2 -fdump-tree-cddce-details" } */
-/* { dg-additional-options "-fdelete-null-pointer-checks" } */
-
-#include <stdio.h>
+/* { dg-options "-O2 -fdump-tree-cddce-details -fdelete-null-pointer-checks" } */
 
 struct A
 {
diff --git a/gcc/testsuite/g++.dg/pr94314-3.C b/gcc/testsuite/g++.dg/pr94314-3.C
index 575ba9d8ad8..846a5d6a3d8 100644
--- a/gcc/testsuite/g++.dg/pr94314-3.C
+++ b/gcc/testsuite/g++.dg/pr94314-3.C
@@ -1,9 +1,6 @@
 /* PR c++/94314.  */
 /* { dg-do run } */
-/* { dg-options "-O2 --param early-inlining-insns=100 -fdump-tree-cddce-details" } */
-/* { dg-additional-options "-fdelete-null-pointer-checks" } */
-
-#include <stdio.h>
+/* { dg-options "-O2 --param early-inlining-insns=100 -fdump-tree-cddce-details -fdelete-null-pointer-checks" } */
 
 volatile int idx;
 
diff --git a/gcc/testsuite/g++.dg/pr94314-4.C b/gcc/testsuite/g++.dg/pr94314-4.C
new file mode 100644
index 00000000000..d097f29d4ad
--- /dev/null
+++ b/gcc/testsuite/g++.dg/pr94314-4.C
@@ -0,0 +1,30 @@
+/* PR c++/94314.  */
+/* { dg-do run { target c++11 } } */
+/* { dg-options "-O2 -fdump-tree-cddce-details -fdelete-null-pointer-checks" } */
+
+int count = 0;
+
+__attribute__((malloc, noinline)) void* operator new[](__SIZE_TYPE__ sz) {
+  ++count;
+  return ::operator new(sz);
+}
+
+void operator delete[](void* ptr) noexcept {
+  --count;
+  ::operator delete(ptr);
+}
+
+void operator delete[](void* ptr, __SIZE_TYPE__ sz) noexcept {
+  --count;
+  ::operator delete(ptr, sz);
+}
+
+int main() {
+  delete[] new int[1];
+  if (count != 0)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* { dg-final { scan-tree-dump-not "Deleting : operator delete" "cddce1"} } */
diff --git a/gcc/testsuite/g++.dg/pr94314.C b/gcc/testsuite/g++.dg/pr94314.C
index 86e651d10ba..4e5ae122e9f 100644
--- a/gcc/testsuite/g++.dg/pr94314.C
+++ b/gcc/testsuite/g++.dg/pr94314.C
@@ -1,9 +1,6 @@
 /* PR c++/94314.  */
 /* { dg-do run } */
-/* { dg-options "-O2 -fdump-tree-cddce-details" } */
-/* { dg-additional-options "-fdelete-null-pointer-checks" } */
-
-#include <stdio.h>
+/* { dg-options "-O2 -fdump-tree-cddce-details -fdelete-null-pointer-checks" } */
 
 struct A
 {
diff --git a/gcc/tree-ssa-dce.c b/gcc/tree-ssa-dce.c
index fd5f24c746c..757cfad5b5e 100644
--- a/gcc/tree-ssa-dce.c
+++ b/gcc/tree-ssa-dce.c
@@ -646,6 +646,77 @@ degenerate_phi_p (gimple *phi)
   return true;
 }
 
+/* Return that NEW_CALL and DELETE_CALL are a valid pair of new
+   and delete  operators.  */
+
+static bool
+valid_new_delete_pair_p (gimple *new_call, gimple *delete_call)
+{
+  tree new_asm = DECL_ASSEMBLER_NAME (gimple_call_fndecl (new_call));
+  tree delete_asm = DECL_ASSEMBLER_NAME (gimple_call_fndecl (delete_call));
+  const char *new_name = IDENTIFIER_POINTER (new_asm);
+  const char *delete_name = IDENTIFIER_POINTER (delete_asm);
+  unsigned int new_len = IDENTIFIER_LENGTH (new_asm);
+  unsigned int delete_len = IDENTIFIER_LENGTH (delete_asm);
+
+  if (new_len < 5 || delete_len < 6)
+    return false;
+  if (new_name[0] == '_')
+    ++new_name, --new_len;
+  if (new_name[0] == '_')
+    ++new_name, --new_len;
+  if (delete_name[0] == '_')
+    ++delete_name, --delete_len;
+  if (delete_name[0] == '_')
+    ++delete_name, --delete_len;
+  if (new_len < 4 || delete_len < 5)
+    return false;
+  /* *_len is now just the length after initial underscores.  */
+  if (new_name[0] != 'Z' || new_name[1] != 'n')
+    return false;
+  if (delete_name[0] != 'Z' || delete_name[1] != 'd')
+    return false;
+  /* _Znw must match _Zdl, _Zna must match _Zda.  */
+  if ((new_name[2] != 'w' || delete_name[2] != 'l')
+      && (new_name[2] != 'a' || delete_name[2] != 'a'))
+    return false;
+  /* 'j', 'm' and 'y' correspond to size_t.  */
+  if (new_name[3] != 'j' && new_name[3] != 'm' && new_name[3] != 'y')
+    return false;
+  if (delete_name[3] != 'P' || delete_name[4] != 'v')
+    return false;
+  if (new_len == 4
+      || (new_len == 18 && !memcmp (new_name + 4, "RKSt9nothrow_t", 14)))
+    {
+      /* _ZnXY or _ZnXYRKSt9nothrow_t matches
+	 _ZdXPv, _ZdXPvY and _ZdXPvRKSt9nothrow_t.  */
+      if (delete_len == 5)
+	return true;
+      if (delete_len == 6 && delete_name[5] == new_name[3])
+	return true;
+      if (delete_len == 19 && !memcmp (delete_name + 5, "RKSt9nothrow_t", 14))
+	return true;
+    }
+  else if ((new_len == 19 && !memcmp (new_name + 4, "St11align_val_t", 15))
+	   || (new_len == 33
+	       && !memcmp (new_name + 4, "St11align_val_tRKSt9nothrow_t", 29)))
+    {
+      /* _ZnXYSt11align_val_t or _ZnXYSt11align_val_tRKSt9nothrow_t matches
+	 _ZdXPvSt11align_val_t or _ZdXPvYSt11align_val_t or  or
+	 _ZdXPvSt11align_val_tRKSt9nothrow_t.  */
+      if (delete_len == 20 && !memcmp (delete_name + 5, "St11align_val_t", 15))
+	return true;
+      if (delete_len == 21
+	  && delete_name[5] == new_name[3]
+	  && !memcmp (delete_name + 6, "St11align_val_t", 15))
+	return true;
+      if (delete_len == 34
+	  && !memcmp (delete_name + 5, "St11align_val_tRKSt9nothrow_t", 29))
+	return true;
+    }
+  return false;
+}
+
 /* Propagate necessity using the operands of necessary statements.
    Process the uses on each statement in the worklist, and add all
    feeding statements which contribute to the calculation of this
@@ -824,16 +895,23 @@ propagate_necessity (bool aggressive)
 			   || DECL_FUNCTION_CODE (def_callee) == BUILT_IN_CALLOC))
 		      || DECL_IS_REPLACEABLE_OPERATOR_NEW_P (def_callee)))
 		{
-		  /* Delete operators can have alignment and (or) size as next
-		     arguments.  When being a SSA_NAME, they must be marked
-		     as necessary.  */
-		  if (is_delete_operator && gimple_call_num_args (stmt) >= 2)
-		    for (unsigned i = 1; i < gimple_call_num_args (stmt); i++)
-		      {
-			tree arg = gimple_call_arg (stmt, i);
-			if (TREE_CODE (arg) == SSA_NAME)
-			  mark_operand_necessary (arg);
-		      }
+		  if (is_delete_operator)
+		    {
+		      if (!valid_new_delete_pair_p (def_stmt, stmt))
+			mark_operand_necessary (gimple_call_arg (stmt, 0));
+
+		      /* Delete operators can have alignment and (or) size
+			 as next arguments.  When being a SSA_NAME, they
+			 must be marked as necessary.  */
+		      if (gimple_call_num_args (stmt) >= 2)
+			for (unsigned i = 1; i < gimple_call_num_args (stmt);
+			     i++)
+			  {
+			    tree arg = gimple_call_arg (stmt, i);
+			    if (TREE_CODE (arg) == SSA_NAME)
+			      mark_operand_necessary (arg);
+			  }
+		    }
 
 		  continue;
 		}
-- 
2.26.1

=== 1699-combine-Fix-split_i2i3-ICE-PR94291.patch ===
From c23c899aedf11069e992eed7358802b262d62f98 Mon Sep 17 00:00:00 2001
From: Jakub Jelinek <jakub@redhat.com>
Date: Tue, 7 Apr 2020 21:30:12 +0200
Subject: [PATCH 1699/2034] combine: Fix split_i2i3 ICE [PR94291]

The following testcase ICEs on armv7hl-linux-gnueabi.
try_combine is called on:
(gdb) p debug_rtx (i3)
(insn 20 12 22 2 (set (mem/c:SI (plus:SI (reg/f:SI 102 sfp)
                (const_int -4 [0xfffffffffffffffc])) [1 x+0 S4 A32])
        (reg:SI 125)) "pr94291.c":7:8 241 {*arm_movsi_insn}
     (expr_list:REG_DEAD (reg:SI 125)
        (nil)))
(gdb) p debug_rtx (i2)
(insn 12 7 20 2 (parallel [
            (set (reg:CC 100 cc)
                (compare:CC (reg:SI 121 [ <retval> ])
                    (const_int 0 [0])))
            (set (reg:SI 125)
                (reg:SI 121 [ <retval> ]))
        ]) "pr94291.c":7:8 248 {*movsi_compare0}
     (expr_list:REG_UNUSED (reg:CC 100 cc)
        (nil)))
and tries to recognize cc = r121 cmp 0; [sfp-4] = r121 parallel,
but that isn't recognized, so it splits it into two: split_i2i3
[sfp-4] = r121 followed by cc = r121 cmp 0 which is recognized, but
ICEs because the code below insist that the SET_DEST of newi2pat
(or first set in PARALLEL thereof) must be a REG or SUBREG of REG,
but it is a MEM in this case.  I don't see any condition that would
guarantee that, perhaps for the swap_i2i3 case it was somehow guaranteed.

As the code just wants to update LOG_LINKS and LOG_LINKS are only for
registers, not for MEM or anything else, the patch just doesn't update those
if it isn't a REG or SUBREG of REG.

2020-04-07  Jakub Jelinek  <jakub@redhat.com>

	PR rtl-optimization/94291
	PR rtl-optimization/84169
	* combine.c (try_combine): For split_i2i3, don't assume SET_DEST
	must be a REG or SUBREG of REG; if it is not one of these, don't
	update LOG_LINKs.

	* gcc.dg/pr94291.c: New test.
---
 gcc/ChangeLog                  |  8 +++++++
 gcc/combine.c                  | 42 +++++++++++++++++++---------------
 gcc/testsuite/ChangeLog        |  6 +++++
 gcc/testsuite/gcc.dg/pr94291.c | 14 ++++++++++++
 4 files changed, 51 insertions(+), 19 deletions(-)
 create mode 100644 gcc/testsuite/gcc.dg/pr94291.c

diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index a1ab9fb4ef3..12803e90b0a 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,11 @@
+2020-04-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/94291
+	PR rtl-optimization/84169
+	* combine.c (try_combine): For split_i2i3, don't assume SET_DEST
+	must be a REG or SUBREG of REG; if it is not one of these, don't
+	update LOG_LINKs.
+
 2020-04-07  Richard Biener  <rguenther@suse.de>
 
 	PR middle-end/94479
diff --git a/gcc/combine.c b/gcc/combine.c
index 58366a6d331..cff76cd3303 100644
--- a/gcc/combine.c
+++ b/gcc/combine.c
@@ -4351,25 +4351,29 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,
       if (GET_CODE (x) == PARALLEL)
 	x = XVECEXP (newi2pat, 0, 0);
 
-      /* It can only be a SET of a REG or of a SUBREG of a REG.  */
-      unsigned int regno = reg_or_subregno (SET_DEST (x));
-
-      bool done = false;
-      for (rtx_insn *insn = NEXT_INSN (i3);
-	   !done
-	   && insn
-	   && NONDEBUG_INSN_P (insn)
-	   && BLOCK_FOR_INSN (insn) == this_basic_block;
-	   insn = NEXT_INSN (insn))
-	{
-	  struct insn_link *link;
-	  FOR_EACH_LOG_LINK (link, insn)
-	    if (link->insn == i3 && link->regno == regno)
-	      {
-		link->insn = i2;
-		done = true;
-		break;
-	      }
+      if (REG_P (SET_DEST (x))
+	  || (GET_CODE (SET_DEST (x)) == SUBREG
+	      && REG_P (SUBREG_REG (SET_DEST (x)))))
+	{
+	  unsigned int regno = reg_or_subregno (SET_DEST (x));
+
+	  bool done = false;
+	  for (rtx_insn *insn = NEXT_INSN (i3);
+	       !done
+	       && insn
+	       && NONDEBUG_INSN_P (insn)
+	       && BLOCK_FOR_INSN (insn) == this_basic_block;
+	       insn = NEXT_INSN (insn))
+	    {
+	      struct insn_link *link;
+	      FOR_EACH_LOG_LINK (link, insn)
+		if (link->insn == i3 && link->regno == regno)
+		  {
+		    link->insn = i2;
+		    done = true;
+		    break;
+		  }
+	    }
 	}
     }
 
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 71b5a14bcbe..3cbf891d58d 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,9 @@
+2020-04-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/94291
+	PR rtl-optimization/84169
+	* gcc.dg/pr94291.c: New test.
+
 2020-04-07  Richard Biener  <rguenther@suse.de>
 
 	PR middle-end/94479
diff --git a/gcc/testsuite/gcc.dg/pr94291.c b/gcc/testsuite/gcc.dg/pr94291.c
new file mode 100644
index 00000000000..7daa2b01166
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr94291.c
@@ -0,0 +1,14 @@
+/* PR rtl-optimization/94291 */
+/* { dg-do compile } */
+/* { dg-options "-Og" } */
+
+unsigned a;
+
+unsigned
+foo (void)
+{
+  unsigned x
+    = (__builtin_sub_overflow ((long long) a, 0, &x)
+       ? 1 : (__INTPTR_TYPE__) __builtin_memmove (&x, foo, 1));
+  return a;
+}
-- 
2.26.1

=== 0001-Add-patch_area_size-and-patch_area_entry-to-crtl.patch ===
From 6607bdd99994c834f92fce924abdaea3405f62dc Mon Sep 17 00:00:00 2001
From: "H.J. Lu" <hjl.tools@gmail.com>
Date: Fri, 1 May 2020 21:03:10 -0700
Subject: [PATCH] Add patch_area_size and patch_area_entry to crtl

Currently patchable area is at the wrong place.  It is placed immediately
after function label and before .cfi_startproc.  A backend should be able
to add a pseudo patchable area instruction durectly into RTL.  This patch
adds patch_area_size and patch_area_entry to crtl so that the patchable
area info is available in RTL passes.

It also limits patch_area_size and patch_area_entry to 65535, which is
a reasonable maximum size for patchable area.

gcc/

	PR target/93492
	* cfgexpand.c (pass_expand::execute): Set crtl->patch_area_size
	and crtl->patch_area_entry.
	* emit-rtl.h (rtl_data): Add patch_area_size and patch_area_entry.
	* opts.c (common_handle_option): Limit
	function_entry_patch_area_size and function_entry_patch_area_start
	to USHRT_MAX.  Fix a typo in error message.
	* varasm.c (assemble_start_function): Use crtl->patch_area_size
	and crtl->patch_area_entry.
	* doc/invoke.texi: Document the maximum value for
	-fpatchable-function-entry.

gcc/c-family/

	PR target/12345
	* c-attribs.c (handle_patchable_function_entry_attribute): Limit
	value to USHRT_MAX (65535).

---
 gcc/ChangeLog                                 | 14 ++++++++
 gcc/c-family/ChangeLog                        |  6 ++++
 gcc/c-family/c-attribs.c                      |  9 +++++
 gcc/cfgexpand.c                               | 33 +++++++++++++++++++
 gcc/doc/invoke.texi                           |  1 +
 gcc/emit-rtl.h                                |  6 ++++
 gcc/opts.c                                    |  4 ++-
 gcc/testsuite/ChangeLog                       |  7 ++++
 .../patchable_function_entry-error-1.c        |  9 +++++
 .../patchable_function_entry-error-2.c        |  9 +++++
 .../patchable_function_entry-error-3.c        | 17 ++++++++++
 gcc/varasm.c                                  | 30 ++---------------
 12 files changed, 116 insertions(+), 29 deletions(-)
 create mode 100644 gcc/testsuite/c-c++-common/patchable_function_entry-error-1.c
 create mode 100644 gcc/testsuite/c-c++-common/patchable_function_entry-error-2.c
 create mode 100644 gcc/testsuite/c-c++-common/patchable_function_entry-error-3.c

diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index e85a8e8813e..fb776ba5a0e 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,17 @@
+2020-05-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/93492
+	* cfgexpand.c (pass_expand::execute): Set crtl->patch_area_size
+	and crtl->patch_area_entry.
+	* emit-rtl.h (rtl_data): Add patch_area_size and patch_area_entry.
+	* opts.c (common_handle_option): Limit
+	function_entry_patch_area_size and function_entry_patch_area_start
+	to USHRT_MAX.  Fix a typo in error message.
+	* varasm.c (assemble_start_function): Use crtl->patch_area_size
+	and crtl->patch_area_entry.
+	* doc/invoke.texi: Document the maximum value for
+	-fpatchable-function-entry.
+
 2020-05-01  Iain Sandoe  <iain@sandoe.co.uk>
 
 	* config/i386/darwin.h: Repair SUBTARGET_INIT_BUILTINS.
diff --git a/gcc/c-family/ChangeLog b/gcc/c-family/ChangeLog
index c429b49e68c..69ea1fdc4f3 100644
--- a/gcc/c-family/ChangeLog
+++ b/gcc/c-family/ChangeLog
@@ -1,3 +1,9 @@
+2020-05-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/93492
+	* c-attribs.c (handle_patchable_function_entry_attribute): Limit
+	value to USHRT_MAX (65535).
+
 2020-04-29  Jakub Jelinek  <jakub@redhat.com>
 
 	* c-format.c (PP_FORMAT_CHAR_TABLE): Add %{ and %}.
diff --git a/gcc/c-family/c-attribs.c b/gcc/c-family/c-attribs.c
index ac936d5bbbb..a101312c581 100644
--- a/gcc/c-family/c-attribs.c
+++ b/gcc/c-family/c-attribs.c
@@ -4553,6 +4553,15 @@ handle_patchable_function_entry_attribute (tree *, tree name, tree args,
 	  *no_add_attrs = true;
 	  return NULL_TREE;
 	}
+
+      if (tree_to_uhwi (val) > USHRT_MAX)
+	{
+	  warning (OPT_Wattributes,
+		   "%qE attribute argument %qE is out of range (> 65535)",
+		   name, val);
+	  *no_add_attrs = true;
+	  return NULL_TREE;
+	}
     }
   return NULL_TREE;
 }
diff --git a/gcc/cfgexpand.c b/gcc/cfgexpand.c
index a7ec77d5c85..86efa22bf60 100644
--- a/gcc/cfgexpand.c
+++ b/gcc/cfgexpand.c
@@ -6656,6 +6656,39 @@ pass_expand::execute (function *fun)
   if (crtl->tail_call_emit)
     fixup_tail_calls ();
 
+  unsigned HOST_WIDE_INT patch_area_size = function_entry_patch_area_size;
+  unsigned HOST_WIDE_INT patch_area_entry = function_entry_patch_area_start;
+
+  tree patchable_function_entry_attr
+    = lookup_attribute ("patchable_function_entry",
+			DECL_ATTRIBUTES (cfun->decl));
+  if (patchable_function_entry_attr)
+    {
+      tree pp_val = TREE_VALUE (patchable_function_entry_attr);
+      tree patchable_function_entry_value1 = TREE_VALUE (pp_val);
+
+      patch_area_size = tree_to_uhwi (patchable_function_entry_value1);
+      patch_area_entry = 0;
+      if (TREE_CHAIN (pp_val) != NULL_TREE)
+	{
+	  tree patchable_function_entry_value2
+	    = TREE_VALUE (TREE_CHAIN (pp_val));
+	  patch_area_entry = tree_to_uhwi (patchable_function_entry_value2);
+	}
+    }
+
+  if (patch_area_entry > patch_area_size)
+    {
+      if (patch_area_size > 0)
+	warning (OPT_Wattributes,
+		 "patchable function entry %wu exceeds size %wu",
+		 patch_area_entry, patch_area_size);
+      patch_area_entry = 0;
+    }
+
+  crtl->patch_area_size = patch_area_size;
+  crtl->patch_area_entry = patch_area_entry;
+
   /* BB subdivision may have created basic blocks that are only reachable
      from unlikely bbs but not marked as such in the profile.  */
   if (optimize)
diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
index 527d362533a..767d1f07801 100644
--- a/gcc/doc/invoke.texi
+++ b/gcc/doc/invoke.texi
@@ -14112,6 +14112,7 @@ If @code{N=0}, no pad location is recorded.
 The NOP instructions are inserted at---and maybe before, depending on
 @var{M}---the function entry address, even before the prologue.
 
+The maximum value of @var{N} and @var{M} is 65535.
 @end table
 
 
diff --git a/gcc/emit-rtl.h b/gcc/emit-rtl.h
index a878efe3cf7..3d6565c8a30 100644
--- a/gcc/emit-rtl.h
+++ b/gcc/emit-rtl.h
@@ -173,6 +173,12 @@ struct GTY(()) rtl_data {
         local stack.  */
   unsigned int stack_alignment_estimated;
 
+  /* How many NOP insns to place at each function entry by default.  */
+  unsigned short patch_area_size;
+
+  /* How far the real asm entry point is into this area.  */
+  unsigned short patch_area_entry;
+
   /* For reorg.  */
 
   /* Nonzero if function being compiled called builtin_return_addr or
diff --git a/gcc/opts.c b/gcc/opts.c
index c212a1a57dc..3dccef39701 100644
--- a/gcc/opts.c
+++ b/gcc/opts.c
@@ -2615,10 +2615,12 @@ common_handle_option (struct gcc_options *opts,
 	    function_entry_patch_area_start = 0;
 	  }
 	if (function_entry_patch_area_size < 0
+	    || function_entry_patch_area_size > USHRT_MAX
 	    || function_entry_patch_area_start < 0
+	    || function_entry_patch_area_start > USHRT_MAX
 	    || function_entry_patch_area_size 
 		< function_entry_patch_area_start)
-	  error ("invalid arguments for %<-fpatchable_function_entry%>");
+	  error ("invalid arguments for %<-fpatchable-function-entry%>");
 	free (patch_area_arg);
       }
       break;
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 176aa117904..185f9ea725e 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,10 @@
+2020-05-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/93492
+	* c-c++-common/patchable_function_entry-error-1.c: New test.
+	* c-c++-common/patchable_function_entry-error-2.c: Likewise.
+	* c-c++-common/patchable_function_entry-error-3.c: Likewise.
+
 2020-05-01  Patrick Palka  <ppalka@redhat.com>
 
 	PR c++/90880
diff --git a/gcc/testsuite/c-c++-common/patchable_function_entry-error-1.c b/gcc/testsuite/c-c++-common/patchable_function_entry-error-1.c
new file mode 100644
index 00000000000..f60bf46cfe3
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/patchable_function_entry-error-1.c
@@ -0,0 +1,9 @@
+/* { dg-do compile { target { ! { nvptx*-*-* visium-*-* } } } } */
+/* { dg-options "-O2 -fpatchable-function-entry=65536,1" } */
+/* { dg-additional-options "-fno-pie" { target sparc*-*-* } } */
+/* { dg-error "invalid arguments for '-fpatchable-function-entry'" "" { target *-*-* } 0 } */
+
+void
+foo (void)
+{
+}
diff --git a/gcc/testsuite/c-c++-common/patchable_function_entry-error-2.c b/gcc/testsuite/c-c++-common/patchable_function_entry-error-2.c
new file mode 100644
index 00000000000..90f88c78be7
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/patchable_function_entry-error-2.c
@@ -0,0 +1,9 @@
+/* { dg-do compile { target { ! { nvptx*-*-* visium-*-* } } } } */
+/* { dg-options "-O2 -fpatchable-function-entry=1,65536" } */
+/* { dg-additional-options "-fno-pie" { target sparc*-*-* } } */
+/* { dg-error "invalid arguments for '-fpatchable-function-entry'" "" { target *-*-* } 0 } */
+
+void
+foo (void)
+{
+}
diff --git a/gcc/testsuite/c-c++-common/patchable_function_entry-error-3.c b/gcc/testsuite/c-c++-common/patchable_function_entry-error-3.c
new file mode 100644
index 00000000000..4490e5c15ca
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/patchable_function_entry-error-3.c
@@ -0,0 +1,17 @@
+/* { dg-do compile { target { ! { nvptx*-*-* visium-*-* } } } } */
+/* { dg-additional-options "-fno-pie" { target sparc*-*-* } } */
+
+void
+ __attribute__((patchable_function_entry(65536)))
+foo1 (void) { /* { dg-warning "'patchable_function_entry' attribute argument '65536' is out of range" } */
+}
+
+void
+ __attribute__((patchable_function_entry(65536,1)))
+foo2 (void) { /* { dg-warning "'patchable_function_entry' attribute argument '65536' is out of range" } */
+}
+
+void
+ __attribute__((patchable_function_entry(65536,65536)))
+foo3 (void) { /* { dg-warning "'patchable_function_entry' attribute argument '65536' is out of range" } */
+}
diff --git a/gcc/varasm.c b/gcc/varasm.c
index 271a67abf56..f062e48071f 100644
--- a/gcc/varasm.c
+++ b/gcc/varasm.c
@@ -1857,34 +1857,8 @@ assemble_start_function (tree decl, const char *fnname)
   if (DECL_PRESERVE_P (decl))
     targetm.asm_out.mark_decl_preserved (fnname);
 
-  unsigned HOST_WIDE_INT patch_area_size = function_entry_patch_area_size;
-  unsigned HOST_WIDE_INT patch_area_entry = function_entry_patch_area_start;
-
-  tree patchable_function_entry_attr
-    = lookup_attribute ("patchable_function_entry", DECL_ATTRIBUTES (decl));
-  if (patchable_function_entry_attr)
-    {
-      tree pp_val = TREE_VALUE (patchable_function_entry_attr);
-      tree patchable_function_entry_value1 = TREE_VALUE (pp_val);
-
-      patch_area_size = tree_to_uhwi (patchable_function_entry_value1);
-      patch_area_entry = 0;
-      if (TREE_CHAIN (pp_val) != NULL_TREE)
-	{
-	  tree patchable_function_entry_value2
-	    = TREE_VALUE (TREE_CHAIN (pp_val));
-	  patch_area_entry = tree_to_uhwi (patchable_function_entry_value2);
-	}
-    }
-
-  if (patch_area_entry > patch_area_size)
-    {
-      if (patch_area_size > 0)
-	warning (OPT_Wattributes,
-		 "patchable function entry %wu exceeds size %wu",
-		 patch_area_entry, patch_area_size);
-      patch_area_entry = 0;
-    }
+  unsigned short patch_area_size = crtl->patch_area_size;
+  unsigned short patch_area_entry = crtl->patch_area_entry;
 
   /* Emit the patching area before the entry label, if any.  */
   if (patch_area_entry > 0)
-- 
2.26.2

=== 1957-c-generic-lambda-forwarding-function-PR94546.patch ===
From aedd04caa945260ea77fd22f29b77292f7dba72e Mon Sep 17 00:00:00 2001
From: Jason Merrill <jason@redhat.com>
Date: Wed, 22 Apr 2020 02:27:54 -0400
Subject: [PATCH 1957/2034] c++: generic lambda forwarding function [PR94546]

While instantiating test(Plot) we partially instantiate the generic lambda.
We look at forward<T>(rest)... and see that it's just replacing parameter
packs with new parameter packs and tries to do a direct substitution.  But
because register_parameter_specializations had built up a
NONTYPE_ARGUMENT_PACK around the new parameter pack, the substitution
failed.  So let's not wrap it that way.

gcc/cp/ChangeLog
2020-04-22  Jason Merrill  <jason@redhat.com>

	PR c++/94546
	* pt.c (register_parameter_specializations): If the instantiation is
	still a parameter pack, don't wrap it in a NONTYPE_ARGUMENT_PACK.
	(tsubst_pack_expansion, tsubst_expr): Adjust.
---
 gcc/cp/ChangeLog                              |  7 +++++
 gcc/cp/pt.c                                   | 28 +++++++------------
 .../g++.dg/cpp2a/lambda-generic-variadic20.C  | 23 +++++++++++++++
 3 files changed, 40 insertions(+), 18 deletions(-)
 create mode 100644 gcc/testsuite/g++.dg/cpp2a/lambda-generic-variadic20.C

diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
index 640e4948130..4b6691a77f0 100644
--- a/gcc/cp/ChangeLog
+++ b/gcc/cp/ChangeLog
@@ -1,3 +1,10 @@
+2020-04-22  Jason Merrill  <jason@redhat.com>
+
+	PR c++/94546
+	* pt.c (register_parameter_specializations): If the instantiation is
+	still a parameter pack, don't wrap it in a NONTYPE_ARGUMENT_PACK.
+	(tsubst_pack_expansion, tsubst_expr): Adjust.
+
 2020-04-22  Martin Sebor  <msebor@redhat.com>
 	    Jason Merrill  <jason@redhat.com>
 
diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
index 7bf249cee5c..2fe7b66707c 100644
--- a/gcc/cp/pt.c
+++ b/gcc/cp/pt.c
@@ -12753,7 +12753,6 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,
   tree pattern;
   tree pack, packs = NULL_TREE;
   bool unsubstituted_packs = false;
-  bool unsubstituted_fn_pack = false;
   int i, len = -1;
   tree result;
   bool need_local_specializations = false;
@@ -12833,19 +12832,15 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,
 	      else
 		arg_pack = make_fnparm_pack (arg_pack);
 	    }
-	  else if (argument_pack_element_is_expansion_p (arg_pack, 0))
-	    /* This argument pack isn't fully instantiated yet.  We set this
-	       flag rather than clear arg_pack because we do want to do the
-	       optimization below, and we don't want to substitute directly
-	       into the pattern (as that would expose a NONTYPE_ARGUMENT_PACK
-	       where it isn't expected).  */
-	    unsubstituted_fn_pack = true;
+	  else if (DECL_PACK_P (arg_pack))
+	    /* This argument pack isn't fully instantiated yet.  */
+	    arg_pack = NULL_TREE;
 	}
       else if (is_capture_proxy (parm_pack))
 	{
 	  arg_pack = retrieve_local_specialization (parm_pack);
-	  if (argument_pack_element_is_expansion_p (arg_pack, 0))
-	    unsubstituted_fn_pack = true;
+	  if (DECL_PACK_P (arg_pack))
+	    arg_pack = NULL_TREE;
 	}
       else
         {
@@ -12880,8 +12875,7 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,
 
           if (len < 0)
 	    len = my_len;
-          else if (len != my_len
-		   && !unsubstituted_fn_pack)
+	  else if (len != my_len)
             {
 	      if (!(complain & tf_error))
 		/* Fail quietly.  */;
@@ -12904,10 +12898,6 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,
 	  /* We can't substitute for this parameter pack.  We use a flag as
 	     well as the missing_level counter because function parameter
 	     packs don't have a level.  */
-          if (!(processing_template_decl || is_auto (parm_pack)))
-	    {
-	      gcc_unreachable ();
-	    }
 	  gcc_assert (processing_template_decl || is_auto (parm_pack));
 	  unsubstituted_packs = true;
 	}
@@ -17897,7 +17887,8 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,
 	      {
 		inst = (retrieve_local_specialization
 			(DECL_CAPTURED_VARIABLE (decl)));
-		gcc_assert (TREE_CODE (inst) == NONTYPE_ARGUMENT_PACK);
+		gcc_assert (TREE_CODE (inst) == NONTYPE_ARGUMENT_PACK
+			    || DECL_PACK_P (inst));
 	      }
 	    else
 	      inst = lookup_init_capture_pack (decl);
@@ -25315,7 +25306,8 @@ register_parameter_specializations (tree pattern, tree inst)
     }
   for (; tmpl_parm; tmpl_parm = DECL_CHAIN (tmpl_parm))
     {
-      if (!DECL_PACK_P (tmpl_parm))
+      if (!DECL_PACK_P (tmpl_parm)
+	  || (spec_parm && DECL_PACK_P (spec_parm)))
 	{
 	  register_local_specialization (spec_parm, tmpl_parm);
 	  spec_parm = DECL_CHAIN (spec_parm);
diff --git a/gcc/testsuite/g++.dg/cpp2a/lambda-generic-variadic20.C b/gcc/testsuite/g++.dg/cpp2a/lambda-generic-variadic20.C
new file mode 100644
index 00000000000..3d69dbb8e98
--- /dev/null
+++ b/gcc/testsuite/g++.dg/cpp2a/lambda-generic-variadic20.C
@@ -0,0 +1,23 @@
+// PR c++/94546
+// { dg-do compile { target c++2a } }
+
+template <class T> T&& forward(T&& t) { return static_cast<T&&>(t); }
+
+template <class X>
+void test(X&& plot)
+{
+    // Note: For brevity, this lambda function is only
+    // defined, not called nor assigned to a variable.
+    // Doing those things won't fix the error.
+    [&]<class... T>(T&&... rest)
+    {
+        plot(forward<T>(rest)...);
+    };
+}
+int main()
+{
+    auto Plot = [](auto&&...)
+    {
+    };
+    test(Plot);
+}
-- 
2.26.1

=== 0030-PR-c-92746-ICE-with-noexcept-of-function-concept-che.patch ===
From edabbec31e3bfc9a9757f80c8610706ed00e5a1a Mon Sep 17 00:00:00 2001
From: Jason Merrill <jason@redhat.com>
Date: Mon, 13 Jan 2020 18:13:46 -0500
Subject: [PATCH 0030/2034] 	PR c++/92746 - ICE with noexcept of function
 concept check.

Another place that needs to specially handle Concepts TS function-style
concepts.

	* except.c (check_noexcept_r): Handle concept-check.
---
 gcc/cp/ChangeLog                            | 3 +++
 gcc/cp/except.c                             | 2 ++
 gcc/testsuite/g++.dg/concepts/fn-concept3.C | 6 ++++++
 3 files changed, 11 insertions(+)
 create mode 100644 gcc/testsuite/g++.dg/concepts/fn-concept3.C

diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
index 59646c70fa4..4729e3d331d 100644
--- a/gcc/cp/ChangeLog
+++ b/gcc/cp/ChangeLog
@@ -1,5 +1,8 @@
 2020-01-13  Jason Merrill  <jason@redhat.com>
 
+	PR c++/92746 - ICE with noexcept of function concept check.
+	* except.c (check_noexcept_r): Handle concept-check.
+
 	PR c++/92582 - ICE with member template as requirement.
 	* pt.c (struct find_template_parameter_info): Add ctx_parms.
 	(any_template_parm_r): Handle TEMPLATE_DECL.
diff --git a/gcc/cp/except.c b/gcc/cp/except.c
index e073bd4d2bc..55b4b6af442 100644
--- a/gcc/cp/except.c
+++ b/gcc/cp/except.c
@@ -1117,6 +1117,8 @@ check_noexcept_r (tree *tp, int * /*walk_subtrees*/, void * /*data*/)
 
          We could use TREE_NOTHROW (t) for !TREE_PUBLIC fns, though... */
       tree fn = cp_get_callee (t);
+      if (concept_check_p (fn))
+	return NULL_TREE;
       tree type = TREE_TYPE (fn);
       gcc_assert (INDIRECT_TYPE_P (type));
       type = TREE_TYPE (type);
diff --git a/gcc/testsuite/g++.dg/concepts/fn-concept3.C b/gcc/testsuite/g++.dg/concepts/fn-concept3.C
new file mode 100644
index 00000000000..ecb7f6b12f7
--- /dev/null
+++ b/gcc/testsuite/g++.dg/concepts/fn-concept3.C
@@ -0,0 +1,6 @@
+// PR c++/92746
+// { dg-do compile { target c++17_only } }
+// { dg-options "-fconcepts" }
+
+template<typename T> concept bool C3() { return true; }
+static_assert(noexcept(C3<int>()), "function concept should be treated as if noexcept(true) specified");
-- 
2.26.1

=== 0129-Add-PR-number-to-change-log.patch ===
From f788c2d66a6ee1ded65dafccbc5e485d42af4808 Mon Sep 17 00:00:00 2001
From: Richard Sandiford <richard.sandiford@arm.com>
Date: Fri, 17 Jan 2020 12:22:58 +0000
Subject: [PATCH 0129/2034] Add PR number to change log

---
 gcc/ChangeLog | 1 +
 1 file changed, 1 insertion(+)

diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 6c6d586ca75..49ca5f92dec 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,5 +1,6 @@
 2020-01-17  Richard Sandiford  <richard.sandiford@arm.com>
 
+	PR target/93133
 	* config/aarch64/aarch64.h (REVERSIBLE_CC_MODE): Return false
 	for FP modes.
 	(REVERSE_CONDITION): Delete.
-- 
2.26.1

=== 0577-aarch64-Add-an-and.patch ===
From bba0c624c8b1d6e54dc58091dd21b0c2ab000434 Mon Sep 17 00:00:00 2001
From: Richard Sandiford <richard.sandiford@arm.com>
Date: Mon, 3 Feb 2020 21:43:44 +0000
Subject: [PATCH 0577/2034] aarch64: Add an and/ior-based movk pattern
 [PR87763]

This patch adds a second movk pattern that models the instruction
as a "normal" and/ior operation rather than an insertion.  It fixes
the third insv_1.c failure in PR87763, which was a regression from
GCC 8.

2020-02-06  Richard Sandiford  <richard.sandiford@arm.com>

gcc/
	PR target/87763
	* config/aarch64/aarch64-protos.h (aarch64_movk_shift): Declare.
	* config/aarch64/aarch64.c (aarch64_movk_shift): New function.
	* config/aarch64/aarch64.md (aarch64_movk<mode>): New pattern.

gcc/testsuite/
	PR target/87763
	* gcc.target/aarch64/movk_2.c: New test.
---
 gcc/ChangeLog                             |  7 ++
 gcc/config/aarch64/aarch64-protos.h       |  1 +
 gcc/config/aarch64/aarch64.c              | 24 +++++++
 gcc/config/aarch64/aarch64.md             | 17 +++++
 gcc/testsuite/ChangeLog                   |  5 ++
 gcc/testsuite/gcc.target/aarch64/movk_2.c | 78 +++++++++++++++++++++++
 6 files changed, 132 insertions(+)
 create mode 100644 gcc/testsuite/gcc.target/aarch64/movk_2.c

diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index efbbbf08225..cea8ffee99c 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,10 @@
+2020-02-06  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR target/87763
+	* config/aarch64/aarch64-protos.h (aarch64_movk_shift): Declare.
+	* config/aarch64/aarch64.c (aarch64_movk_shift): New function.
+	* config/aarch64/aarch64.md (aarch64_movk<mode>): New pattern.
+
 2020-02-06  Richard Sandiford  <richard.sandiford@arm.com>
 
 	PR rtl-optimization/87763
diff --git a/gcc/config/aarch64/aarch64-protos.h b/gcc/config/aarch64/aarch64-protos.h
index 24cc65a383a..d29975a8921 100644
--- a/gcc/config/aarch64/aarch64-protos.h
+++ b/gcc/config/aarch64/aarch64-protos.h
@@ -560,6 +560,7 @@ bool aarch64_sve_float_mul_immediate_p (rtx);
 bool aarch64_split_dimode_const_store (rtx, rtx);
 bool aarch64_symbolic_address_p (rtx);
 bool aarch64_uimm12_shift (HOST_WIDE_INT);
+int aarch64_movk_shift (const wide_int_ref &, const wide_int_ref &);
 bool aarch64_use_return_insn_p (void);
 const char *aarch64_output_casesi (rtx *);
 
diff --git a/gcc/config/aarch64/aarch64.c b/gcc/config/aarch64/aarch64.c
index 6581e4cb075..6a1b4099af1 100644
--- a/gcc/config/aarch64/aarch64.c
+++ b/gcc/config/aarch64/aarch64.c
@@ -7895,6 +7895,30 @@ aarch64_movw_imm (HOST_WIDE_INT val, scalar_int_mode mode)
 	  || (val & (((HOST_WIDE_INT) 0xffff) << 16)) == val);
 }
 
+/* Test whether:
+
+     X = (X & AND_VAL) | IOR_VAL;
+
+   can be implemented using:
+
+     MOVK X, #(IOR_VAL >> shift), LSL #shift
+
+   Return the shift if so, otherwise return -1.  */
+int
+aarch64_movk_shift (const wide_int_ref &and_val,
+		    const wide_int_ref &ior_val)
+{
+  unsigned int precision = and_val.get_precision ();
+  unsigned HOST_WIDE_INT mask = 0xffff;
+  for (unsigned int shift = 0; shift < precision; shift += 16)
+    {
+      if (and_val == ~mask && (ior_val & mask) == ior_val)
+	return shift;
+      mask <<= 16;
+    }
+  return -1;
+}
+
 /* VAL is a value with the inner mode of MODE.  Replicate it to fill a
    64-bit (DImode) integer.  */
 
diff --git a/gcc/config/aarch64/aarch64.md b/gcc/config/aarch64/aarch64.md
index 90eebce85c0..9c1f17d0f85 100644
--- a/gcc/config/aarch64/aarch64.md
+++ b/gcc/config/aarch64/aarch64.md
@@ -1282,6 +1282,23 @@ (define_insn "insv_imm<mode>"
   [(set_attr "type" "mov_imm")]
 )
 
+;; Match MOVK as a normal AND and IOR operation.
+(define_insn "aarch64_movk<mode>"
+  [(set (match_operand:GPI 0 "register_operand" "=r")
+	(ior:GPI (and:GPI (match_operand:GPI 1 "register_operand" "0")
+			  (match_operand:GPI 2 "const_int_operand"))
+		 (match_operand:GPI 3 "const_int_operand")))]
+  "aarch64_movk_shift (rtx_mode_t (operands[2], <MODE>mode),
+		       rtx_mode_t (operands[3], <MODE>mode)) >= 0"
+  {
+    int shift = aarch64_movk_shift (rtx_mode_t (operands[2], <MODE>mode),
+				    rtx_mode_t (operands[3], <MODE>mode));
+    operands[2] = gen_int_mode (UINTVAL (operands[3]) >> shift, SImode);
+    operands[3] = gen_int_mode (shift, SImode);
+    return "movk\\t%<w>0, #%X2, lsl %3";
+  }
+)
+
 (define_expand "movti"
   [(set (match_operand:TI 0 "nonimmediate_operand")
 	(match_operand:TI 1 "general_operand"))]
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 601bc336290..cdb26581b9c 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,8 @@
+2020-02-06  Richard Sandiford  <richard.sandiford@arm.com>
+
+	PR target/87763
+	* gcc.target/aarch64/movk_2.c: New test.
+
 2020-02-06  Marek Polacek  <polacek@redhat.com>
 
 	PR c++/93597 - ICE with lambda in operator function.
diff --git a/gcc/testsuite/gcc.target/aarch64/movk_2.c b/gcc/testsuite/gcc.target/aarch64/movk_2.c
new file mode 100644
index 00000000000..a0477ad5d42
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/movk_2.c
@@ -0,0 +1,78 @@
+/* { dg-do compile } */
+/* { dg-options "-O" } */
+/* { dg-final { check-function-bodies "**" "" } } */
+
+#include <stdint.h>
+
+#define H3 ((uint64_t) 0xffff << 48)
+#define H2 ((uint64_t) 0xffff << 32)
+#define H1 ((uint64_t) 0xffff << 16)
+#define H0 ((uint64_t) 0xffff)
+
+/*
+** f1:
+**	mov	w0, w1
+**	movk	w0, #0x9876(?:, lsl #?0)?
+**	ret
+*/
+uint32_t
+f1 (uint32_t dummy, uint32_t x)
+{
+  return (x & 0xffff0000) | 0x9876;
+}
+
+/*
+** f2:
+**	movk	w0, #0x1234, lsl #?16
+**	ret
+*/
+uint32_t
+f2 (uint32_t x)
+{
+  return (x & 0xffff) | 0x12340000;
+}
+
+/*
+** g1:
+**	movk	x0, #0x1234, lsl #?0
+**	ret
+*/
+uint64_t
+g1 (uint64_t x)
+{
+  return (x & (H3 | H2 | H1)) | 0x1234;
+}
+
+/*
+** g2:
+**	movk	x0, #0x900e, lsl #?16
+**	ret
+*/
+uint64_t
+g2 (uint64_t x)
+{
+  return (x & (H3 | H2 | H0)) | ((uint64_t) 0x900e << 16);
+}
+
+/*
+** g3:
+**	movk	x0, #0xee33, lsl #?32
+**	ret
+*/
+uint64_t
+g3 (uint64_t x)
+{
+  return (x & (H3 | H1 | H0)) | ((uint64_t) 0xee33 << 32);
+}
+
+/*
+** g4:
+**	mov	x0, x1
+**	movk	x0, #0x7654, lsl #?48
+**	ret
+*/
+uint64_t
+g4 (uint64_t dummy, uint64_t x)
+{
+  return (x & (H2 | H1 | H0)) | ((uint64_t) 0x7654 << 48);
+}
-- 
2.26.1

=== 1975-S-390-Fix-several-test-cases.patch ===
From 803596fe9591026a50b59ff961ebc114097677b5 Mon Sep 17 00:00:00 2001
From: Stefan Schulze Frielinghaus <stefansf@linux.ibm.com>
Date: Tue, 10 Mar 2020 10:49:28 +0100
Subject: [PATCH 1975/2034] S/390: Fix several test cases

gcc/ChangeLog:

2020-04-21  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>

	* config/s390/s390.md ("*<risbg_n>_ior_and_sr_ze<mode>"): Lift from SI
	mode to DSI. ("*trunc_sidi_and_subreg_ze<clobbercc_or_nocc>"): New
	insn pattern.

gcc/testsuite/ChangeLog:

2020-04-21  Stefan Schulze Frielinghaus  <stefansf@linux.ibm.com>

	* gcc.target/s390/addsub-signed-overflow-1.c: Fix options.
	* gcc.target/s390/addsub-signed-overflow-2.c: Fix options.
	* gcc.target/s390/bswap-1.c: Fix scan assembler regex.
	* gcc.target/s390/global-array-element-pic2.c: Fix scan assembler regex.
	* gcc.target/s390/load-relative-check.c: Fix options.
	* gcc.target/s390/morestack.c: Fix options.
	* gcc.target/s390/nobp-return-mem-z900.c: Temporarily silence this case.
	* gcc.target/s390/risbg-ll-1.c: Fix scan assembler regex.
	* gcc.target/s390/risbg-ll-2.c: Fix scan assembler regex.
	* gcc.target/s390/risbg-ll-3.c: Fix scan assembler regex.
	* gcc.target/s390/target-attribute/pr82012.c: Fix error message.
---
 gcc/config/s390/s390.md                       | 39 ++++++++++++-------
 .../s390/addsub-signed-overflow-1.c           |  2 +-
 .../s390/addsub-signed-overflow-2.c           |  2 +-
 gcc/testsuite/gcc.target/s390/bswap-1.c       |  8 ++--
 .../s390/global-array-element-pic2.c          |  4 +-
 .../gcc.target/s390/load-relative-check.c     |  2 +-
 gcc/testsuite/gcc.target/s390/morestack.c     |  2 +-
 .../gcc.target/s390/nobp-return-mem-z900.c    | 17 ++++++--
 gcc/testsuite/gcc.target/s390/risbg-ll-1.c    | 13 +++----
 gcc/testsuite/gcc.target/s390/risbg-ll-2.c    |  6 +--
 gcc/testsuite/gcc.target/s390/risbg-ll-3.c    |  2 +-
 .../s390/target-attribute/pr82012.c           |  2 +-
 12 files changed, 59 insertions(+), 40 deletions(-)

diff --git a/gcc/config/s390/s390.md b/gcc/config/s390/s390.md
index 44b59659e20..cf53ef1b791 100644
--- a/gcc/config/s390/s390.md
+++ b/gcc/config/s390/s390.md
@@ -3970,22 +3970,21 @@ (define_insn "*extzvdi<clobbercc_or_nocc>_lshiftrt"
   [(set_attr "op_type" "RIE")
    (set_attr "z10prop" "z10_super_E1")])
 
-; 32 bit: (a & -16) | ((b >> 8) & 15)
-(define_insn "*<risbg_n>_ior_and_sr_ze"
-  [(set (match_operand:SI 0 "register_operand" "=d")
-	(ior:SI (and:SI
-		 (match_operand:SI 1 "register_operand" "0")
-		 (match_operand:SI 2 "const_int_operand" ""))
-		(subreg:SI
-		 (zero_extract:DI
-		  (match_operand:DI 3 "register_operand" "d")
-		  (match_operand 4 "const_int_operand" "") ; size
+; (a & -16) | ((b >> 8) & 15)
+(define_insn "*<risbg_n>_ior_and_sr_ze<mode>"
+  [(set (match_operand:DSI 0 "register_operand" "=d")
+	(ior:DSI (and:DSI
+		  (match_operand:DSI 1 "register_operand" "0")
+		  (match_operand:DSI 2 "const_int_operand" ""))
+		 (zero_extract:DSI
+		  (match_operand:DSI 3 "register_operand" "d")
+		  (match_operand 4 "const_int_operand" "")  ; size
 		  (match_operand 5 "const_int_operand" "")) ; start
-		 4)))]
+		  ))]
   "<z10_or_zEC12_cond>
-   && EXTRACT_ARGS_IN_RANGE (INTVAL (operands[4]), INTVAL (operands[5]), 64)
+   && EXTRACT_ARGS_IN_RANGE (INTVAL (operands[4]), INTVAL (operands[5]), <DSI:bitsize>)
    && UINTVAL (operands[2]) == (HOST_WIDE_INT_M1U << UINTVAL (operands[4]))"
-  "<risbg_n>\t%0,%3,64-%4,63,%4+%5"
+  "<risbg_n>\t%0,%3,64-%4,63,(64-<DSI:bitsize>)+%4+%5"
   [(set_attr "op_type" "RIE")
    (set_attr "z10prop" "z10_super_E1")])
 
@@ -4237,6 +4236,20 @@ (define_insn "*trunc_sidi_and_subreg_lshrt<clobbercc_or_nocc>"
   [(set_attr "op_type" "RIE")
    (set_attr "z10prop" "z10_super_E1")])
 
+; (ui32)(((ui64)x) >> 12) & -4
+(define_insn "*trunc_sidi_and_subreg_ze<clobbercc_or_nocc>"
+  [(set (match_operand:SI 0 "register_operand" "=d")
+	(and:SI
+	 (subreg:SI (zero_extract:DI
+		     (match_operand:DI 1 "register_operand" "d")
+		     (const_int 32)
+		     (match_operand:SI 2 "nonzero_shift_count_operand" "")) 4)
+	 (match_operand:SI 3 "contiguous_bitmask_nowrap_operand" "")))]
+  "<z10_or_zEC12_cond>"
+  "<risbg_n>\t%0,%1,%t3,128+%f3,32+%2"
+  [(set_attr "op_type" "RIE")
+   (set_attr "z10prop" "z10_super_E1")])
+
 ; z = (x << c) | (y >> d) with (x << c) and (y >> d) not overlapping after shifting
 ;  -> z = y >> d; z = (x << c) | (z & ((1 << c) - 1))
 ;  -> z = y >> d; z = risbg;
diff --git a/gcc/testsuite/gcc.target/s390/addsub-signed-overflow-1.c b/gcc/testsuite/gcc.target/s390/addsub-signed-overflow-1.c
index 143220d5541..ebc02479587 100644
--- a/gcc/testsuite/gcc.target/s390/addsub-signed-overflow-1.c
+++ b/gcc/testsuite/gcc.target/s390/addsub-signed-overflow-1.c
@@ -1,5 +1,5 @@
 /* { dg-do run } */
-/* { dg-options "-O3 -mzarch --save-temps" } */
+/* { dg-options "-O3 -march=z13 -mzarch --save-temps" } */
 
 #include <stddef.h>
 #include <limits.h>
diff --git a/gcc/testsuite/gcc.target/s390/addsub-signed-overflow-2.c b/gcc/testsuite/gcc.target/s390/addsub-signed-overflow-2.c
index 798e489cece..8bd1a764bc6 100644
--- a/gcc/testsuite/gcc.target/s390/addsub-signed-overflow-2.c
+++ b/gcc/testsuite/gcc.target/s390/addsub-signed-overflow-2.c
@@ -1,5 +1,5 @@
 /* { dg-do run } */
-/* { dg-options "-O3 -mzarch --save-temps" } */
+/* { dg-options "-O3 -march=z13 -mzarch --save-temps" } */
 
 #include <stddef.h>
 #include <limits.h>
diff --git a/gcc/testsuite/gcc.target/s390/bswap-1.c b/gcc/testsuite/gcc.target/s390/bswap-1.c
index edfcdf888c0..c11a0ea780b 100644
--- a/gcc/testsuite/gcc.target/s390/bswap-1.c
+++ b/gcc/testsuite/gcc.target/s390/bswap-1.c
@@ -19,14 +19,14 @@ foo64b ()
 {
   return __builtin_bswap64 (u64);
 }
-/* { dg-final { scan-assembler-times "lrvg\t%r2,0\\(%r\[0-9\]*\\)" 1 { target lp64 } } } */
+/* { dg-final { scan-assembler-times "lrvg\t%r2,\[0-9\]+\\(%r\[0-9\]*\\)" 1 { target lp64 } } } */
 
 void
 foo64c (uint64_t a)
 {
   u64 = __builtin_bswap64 (a);
 }
-/* { dg-final { scan-assembler-times "strvg\t%r2,0\\(%r\[0-9\]*\\)" 1 { target lp64 } } } */
+/* { dg-final { scan-assembler-times "strvg\t%r2,\[0-9\]+\\(%r\[0-9\]*\\)" 1 { target lp64 } } } */
 
 
 
@@ -42,11 +42,11 @@ foo32b ()
 {
   return __builtin_bswap32 (u32);
 }
-/* { dg-final { scan-assembler-times "lrv\t%r2,0\\(%r\[0-9\]*\\)" 1 } } */
+/* { dg-final { scan-assembler-times "lrv\t%r2,\[0-9\]+\\(%r\[0-9\]*\\)" 1 } } */
 
 void
 foo32c (uint32_t a)
 {
   u32 = __builtin_bswap32 (a);
 }
-/* { dg-final { scan-assembler-times "strv\t%r2,0\\(%r\[0-9\]*\\)" 1 } } */
+/* { dg-final { scan-assembler-times "strv\t%r2,\[0-9\]+\\(%r\[0-9\]*\\)" 1 } } */
diff --git a/gcc/testsuite/gcc.target/s390/global-array-element-pic2.c b/gcc/testsuite/gcc.target/s390/global-array-element-pic2.c
index b9398a8042f..72b87d40b85 100644
--- a/gcc/testsuite/gcc.target/s390/global-array-element-pic2.c
+++ b/gcc/testsuite/gcc.target/s390/global-array-element-pic2.c
@@ -8,6 +8,6 @@ extern char *b;
 void c()
 {
   b = a + 4;
-  /* { dg-final { scan-assembler {(?n)\n\tlgrl\t%r\d+,a@GOTENT\n} } } */
-  /* { dg-final { scan-assembler-not {(?n)\n\tlarl\t%r\d+,a[^@]} } } */
+  /* { dg-final { scan-assembler "(?n)\n\tlgrl\t%r\\d+,a@GOTENT\n" } } */
+  /* { dg-final { scan-assembler-not "(?n)\n\tlarl\t%r\\d+,a\[^@\]" } } */
 }
diff --git a/gcc/testsuite/gcc.target/s390/load-relative-check.c b/gcc/testsuite/gcc.target/s390/load-relative-check.c
index 3d4671a6b3f..a55bc2442f1 100644
--- a/gcc/testsuite/gcc.target/s390/load-relative-check.c
+++ b/gcc/testsuite/gcc.target/s390/load-relative-check.c
@@ -1,6 +1,6 @@
 /* Check if load-relative instructions are created */
 /* { dg-do compile { target { s390*-*-* } } } */
-/* { dg-options "-O2 -march=z10 -mzarch" } */
+/* { dg-options "-O2 -march=z10 -mzarch -fno-section-anchors" } */
 
 /* { dg-final { scan-assembler "lgfrl\t%r.?,b.4" { target { lp64 } } } } */
 /* { dg-final { scan-assembler "lgfrl\t%r.?,s.12" { target { lp64 } } } } */
diff --git a/gcc/testsuite/gcc.target/s390/morestack.c b/gcc/testsuite/gcc.target/s390/morestack.c
index aa28b72aa6c..4cfa220e737 100644
--- a/gcc/testsuite/gcc.target/s390/morestack.c
+++ b/gcc/testsuite/gcc.target/s390/morestack.c
@@ -3,7 +3,7 @@
    pointer being correct.  */
 
 /* { dg-do run } */
-/* { dg-options "" } */
+/* { dg-options "-O2 -fsplit-stack" } */
 
 #include <stdlib.h>
 
diff --git a/gcc/testsuite/gcc.target/s390/nobp-return-mem-z900.c b/gcc/testsuite/gcc.target/s390/nobp-return-mem-z900.c
index 0b318115a8f..3d6aca1f95f 100644
--- a/gcc/testsuite/gcc.target/s390/nobp-return-mem-z900.c
+++ b/gcc/testsuite/gcc.target/s390/nobp-return-mem-z900.c
@@ -21,6 +21,15 @@ foo (int a)
     gl += bar (i);
 }
 
+void __attribute__((noinline,noclone))
+baz (int a)
+{
+  int i;
+
+  for (i = 0; i < a; i++)
+    gl += bar (i);
+}
+
 int
 main ()
 {
@@ -31,13 +40,13 @@ main ()
   return 0;
 }
 
-/* 1 x foo, 1 x main
-/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 2 } } */
+/* 1 x foo, 1 x baz, 1 x main */
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 3 } } */
 
-/* 1 x foo, conditional return, shrink wrapped
+/* 1 x foo, conditional return, shrink wrapped */
 /* { dg-final { scan-assembler "jge\t__s390_indirect_jump" } } */
 
-/* 1 x foo, conditional return, shrink wrapped
+/* 1 x baz, conditional return, shrink wrapped */
 /* { dg-final { scan-assembler "jgle\t__s390_indirect_jump" } } */
 
 /* { dg-final { scan-assembler "ex\t" } } */
diff --git a/gcc/testsuite/gcc.target/s390/risbg-ll-1.c b/gcc/testsuite/gcc.target/s390/risbg-ll-1.c
index 30350d04c45..1cac15820c0 100644
--- a/gcc/testsuite/gcc.target/s390/risbg-ll-1.c
+++ b/gcc/testsuite/gcc.target/s390/risbg-ll-1.c
@@ -214,14 +214,11 @@ i64 f18 (i64 v_foo)
 }
 
 // Test an arithmetic shift right in which some of the sign bits are kept.
-// This needs a separate shift and mask.
+// This needs a separate shift and mask on 31 bit.
 i32 f19 (i32 v_foo)
 {
-  /* Should be
-     { dg-final { scan-assembler "f19:\n\tsra\t%r2,28\n\tnilf\t%r2,30" { xfail { lp64 } } } }
-     but because a zeroextend is merged into the pattern it is actually
-     { dg-final { scan-assembler "f19:\n\tsra\t%r2,28\n\trisbg\t%r2,%r2,59,128\\\+62,0" { target { lp64 } } } }
-     { dg-final { scan-assembler "f19:\n\tsra\t%r2,28\n\tnilf\t%r2,30" { target { ! lp64 } } } } */
+  /* { dg-final { scan-assembler "f19:\n\trisbg\t%r2,%r2,59,128\\+62,64-28" { target { lp64 } } } } */
+  /* { dg-final { scan-assembler "f19:\n\tsra\t%r2,28\n\tnilf\t%r2,30" { target { ! lp64 } } } } */
   i32 v_shr = v_foo >> 28;
   i32 v_and = v_shr & 30;
   return v_and;
@@ -273,7 +270,7 @@ i64 f23 (i64 v_foo)
 // mask and rotate.
 i32 f24 (i32 v_foo)
 {
-  /* { dg-final { scan-assembler "f24:\n\tnilf\t%r2,254\n\trll\t%r2,%r2,29" } } */
+  /* { dg-final { scan-assembler "f24:\n\tnilf\t%r2,254\n\trll\t%r2,%r2,29\n" } } */
   i32 v_and = v_foo & 254;
   i32 v_parta = ((ui32)v_and) >> 3;
   i32 v_partb = v_and << 29;
@@ -478,7 +475,7 @@ i64 f42 (t42 v_x)
 // Check that we get the case where a 64-bit shift is used by a 32-bit and.
 i32 f43 (i64 v_x)
 {
-  /* { dg-final { scan-assembler "f43:\n\trisbg\t%r2,%r2,32,128\\\+61,64-12" { target { lp64 } } } } */
+  /* { dg-final { scan-assembler "f43:\n\trisbg\t%r2,%r2,32,128\\+61,32\\+20\n\tlgfr\t%r2,%r2" { target { lp64 } } } } */
   /* { dg-final { scan-assembler "f43:\n\trisbg\t%r3,%r2,0,0\\\+32-1,64-0-32\n\trisbg\t%r2,%r3,32,128\\\+61,64-12" { target { ! lp64 } } } } */
   i64 v_shr3 = ((ui64)v_x) >> 12;
   i32 v_shr3_tr = (ui32)v_shr3;
diff --git a/gcc/testsuite/gcc.target/s390/risbg-ll-2.c b/gcc/testsuite/gcc.target/s390/risbg-ll-2.c
index 754c17311dd..8bf1a0ff88b 100644
--- a/gcc/testsuite/gcc.target/s390/risbg-ll-2.c
+++ b/gcc/testsuite/gcc.target/s390/risbg-ll-2.c
@@ -34,7 +34,7 @@ i64 f2 (i64 v_a, i64 v_b)
 // Test a case with two ANDs and a shift.
 i32 f3 (i32 v_a, i32 v_b)
 {
-  /* { dg-final { scan-assembler "f3:\n\trisbg\t%r2,%r3,64-4,63,4\\\+52" } } */
+  /* { dg-final { scan-assembler "f3:\n\trisbg\t%r2,%r3,64-4,63,\\(64-32\\)\\+4\\+20\n\tlgfr\t%r2,%r2" } } */
   i32 v_anda = v_a & -16;
   i32 v_shr = ((ui32)v_b) >> 8;
   i32 v_andb = v_shr & 15;
@@ -45,8 +45,8 @@ i32 f3 (i32 v_a, i32 v_b)
 // ...and again with i64.
 i64 f4 (i64 v_a, i64 v_b)
 {
-  /* { dg-final { scan-assembler "f4:\n\trisbg\t%r2,%r3,60,60\\\+4-1,128-60-4-8" { target { lp64 } } } } */
-  /* { dg-final { scan-assembler "f4:\n\(\t.*\n\)*\trisbg\t%r5,%r5,64-4,128\\\+63,52\\\+4" { target { ! lp64 } } } } */
+  /* { dg-final { scan-assembler "f4:\n\trisbg\t%r2,%r3,64-4,63,\\(64-64\\)\\+4\\+52" { target { lp64 } } } } */
+  /* { dg-final { scan-assembler "f4:\n\(\t.*\n\)*\trisbg\t%r5,%r5,64-4,128\\+63,\\(64-64\\)\\+52\\+4" { target { ! lp64 } } } } */
   i64 v_anda = v_a & -16;
   i64 v_shr = ((ui64)v_b) >> 8;
   i64 v_andb = v_shr & 15;
diff --git a/gcc/testsuite/gcc.target/s390/risbg-ll-3.c b/gcc/testsuite/gcc.target/s390/risbg-ll-3.c
index 2a2db543cd9..90d37f2c1ce 100644
--- a/gcc/testsuite/gcc.target/s390/risbg-ll-3.c
+++ b/gcc/testsuite/gcc.target/s390/risbg-ll-3.c
@@ -11,7 +11,7 @@
 // On zEC12, we generally prefer RISBGN.
 i64 f1 (i64 v_a, i64 v_b)
 {
-/* { dg-final { scan-assembler "f1:\n\trisbgn\t%r2,%r3,60,60\\\+3-1,128-60-3-1" { target { lp64 } } } } */
+/* { dg-final { scan-assembler "f1:\n\trisbgn\t%r2,%r3,60,62,0" { target { lp64 } } } } */
 /* { dg-final { scan-assembler "f1:\n\trisbgn\t%r3,%r2,0,0\\\+32-1,64-0-32\n\trisbgn\t%r3,%r5,60,62,0\n" { target { ! lp64 } } } } */
   i64 v_anda = v_a & -15;
   i64 v_andb = v_b & 14;
diff --git a/gcc/testsuite/gcc.target/s390/target-attribute/pr82012.c b/gcc/testsuite/gcc.target/s390/target-attribute/pr82012.c
index 2e1f7ae57be..ad1bf76d4d2 100644
--- a/gcc/testsuite/gcc.target/s390/target-attribute/pr82012.c
+++ b/gcc/testsuite/gcc.target/s390/target-attribute/pr82012.c
@@ -34,7 +34,7 @@ int __attribute__ ((target ("soft-float"))) test2 (int a)
 
 /* Inlining needs to be rejected.  foo3 performs HW FP operation.  */
 
-int __attribute__ ((always_inline)) foo3 (int a) /* { dg-error "inlining failed in call to always_inline" } */
+int __attribute__ ((always_inline)) foo3 (int a) /* { dg-error "inlining failed in call to 'always_inline'" } */
 {
   g = (double) a / 2.0;
   return 0;
-- 
2.26.1

=== 1999-rs6000-Fix-C-14-vs.-C-17-ABI-bug-on-powerpc64le-PR94.patch ===
From a39ed81b8a0b46320a7c6ece3f7ad4c3f8519609 Mon Sep 17 00:00:00 2001
From: Jakub Jelinek <jakub@redhat.com>
Date: Thu, 23 Apr 2020 09:59:57 +0200
Subject: [PATCH 1999/2034] rs6000: Fix C++14 vs. C++17 ABI bug on powerpc64le
 [PR94707]

As mentioned in the PR and on IRC, the recently added struct-layout-1.exp
new tests FAIL on powerpc64le-linux (among other targets).
FAIL: tmpdir-g++.dg-struct-layout-1/t032 cp_compat_x_tst.o-cp_compat_y_tst.o execute
FAIL: tmpdir-g++.dg-struct-layout-1/t058 cp_compat_x_tst.o-cp_compat_y_tst.o execute
FAIL: tmpdir-g++.dg-struct-layout-1/t059 cp_compat_x_tst.o-cp_compat_y_tst.o execute
in particular.  The problem is that the presence or absence of the C++17
artificial empty base fields, which have non-zero TYPE_SIZE, but zero
DECL_SIZE, change the ABI decisions, if it is present (-std=c++17), the type
might not be considered homogeneous, while if it is absent (-std=c++14), it
can be.

The following patch fixes that and emits a -Wpsabi inform; perhaps more
often than it could, because the fact that rs6000_discover_homogeneous_aggregate
returns true when it didn't in in GCC 7/8/9 with -std=c++17 doesn't still
mean it will make a different ABI decision, but the warning triggered only
on the test I've changed (the struct-layout-1.exp tests use -w -Wno-psabi
already).

2020-04-23  Jakub Jelinek  <jakub@redhat.com>

	PR target/94707
	* config/rs6000/rs6000-call.c (rs6000_aggregate_candidate): Add
	cxx17_empty_base_seen argument.  Pass it to recursive calls.
	Ignore cxx17_empty_base_field_p fields after setting
	*cxx17_empty_base_seen to true.
	(rs6000_discover_homogeneous_aggregate): Adjust
	rs6000_aggregate_candidate caller.  With -Wpsabi, diagnose homogeneous
	aggregates with C++17 empty base fields.

	* g++.dg/tree-ssa/pr27830.C: Use -Wpsabi -w for -std=c++17 and higher.
---
 gcc/ChangeLog                           | 13 ++++++++++
 gcc/config/rs6000/rs6000-call.c         | 34 +++++++++++++++++++++----
 gcc/testsuite/ChangeLog                 |  3 +++
 gcc/testsuite/g++.dg/tree-ssa/pr27830.C |  2 ++
 4 files changed, 47 insertions(+), 5 deletions(-)

diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 06f7eda0033..93c3076eb86 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,5 +1,18 @@
 2020-04-23  Jakub Jelinek  <jakub@redhat.com>
 
+	PR target/94707
+	* config/rs6000/rs6000-call.c (rs6000_aggregate_candidate): Add
+	cxx17_empty_base_seen argument.  Pass it to recursive calls.
+	Ignore cxx17_empty_base_field_p fields after setting
+	*cxx17_empty_base_seen to true.
+	(rs6000_discover_homogeneous_aggregate): Adjust
+	rs6000_aggregate_candidate caller.  With -Wpsabi, diagnose homogeneous
+	aggregates with C++17 empty base fields.
+
+	PR c/94705
+	* attribs.c (decl_attribute): Don't diagnose attribute exclusions
+	if last_decl is error_mark_node or has such a TREE_TYPE.
+
 	PR c/94705
 	* attribs.c (decl_attribute): Don't diagnose attribute exclusions
 	if last_decl is error_mark_node or has such a TREE_TYPE.
diff --git a/gcc/config/rs6000/rs6000-call.c b/gcc/config/rs6000/rs6000-call.c
index e08621ace27..a9ae7ab70ca 100644
--- a/gcc/config/rs6000/rs6000-call.c
+++ b/gcc/config/rs6000/rs6000-call.c
@@ -5528,7 +5528,8 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {
    sub-tree.  */
 
 static int
-rs6000_aggregate_candidate (const_tree type, machine_mode *modep)
+rs6000_aggregate_candidate (const_tree type, machine_mode *modep,
+			    bool *cxx17_empty_base_seen)
 {
   machine_mode mode;
   HOST_WIDE_INT size;
@@ -5598,7 +5599,8 @@ rs6000_aggregate_candidate (const_tree type, machine_mode *modep)
 	    || TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)
 	  return -1;
 
-	count = rs6000_aggregate_candidate (TREE_TYPE (type), modep);
+	count = rs6000_aggregate_candidate (TREE_TYPE (type), modep,
+					    cxx17_empty_base_seen);
 	if (count == -1
 	    || !index
 	    || !TYPE_MAX_VALUE (index)
@@ -5636,7 +5638,14 @@ rs6000_aggregate_candidate (const_tree type, machine_mode *modep)
 	    if (TREE_CODE (field) != FIELD_DECL)
 	      continue;
 
-	    sub_count = rs6000_aggregate_candidate (TREE_TYPE (field), modep);
+	    if (cxx17_empty_base_field_p (field))
+	      {
+		*cxx17_empty_base_seen = true;
+		continue;
+	      }
+
+	    sub_count = rs6000_aggregate_candidate (TREE_TYPE (field), modep,
+						    cxx17_empty_base_seen);
 	    if (sub_count < 0)
 	      return -1;
 	    count += sub_count;
@@ -5669,7 +5678,8 @@ rs6000_aggregate_candidate (const_tree type, machine_mode *modep)
 	    if (TREE_CODE (field) != FIELD_DECL)
 	      continue;
 
-	    sub_count = rs6000_aggregate_candidate (TREE_TYPE (field), modep);
+	    sub_count = rs6000_aggregate_candidate (TREE_TYPE (field), modep,
+						    cxx17_empty_base_seen);
 	    if (sub_count < 0)
 	      return -1;
 	    count = count > sub_count ? count : sub_count;
@@ -5710,7 +5720,9 @@ rs6000_discover_homogeneous_aggregate (machine_mode mode, const_tree type,
       && AGGREGATE_TYPE_P (type))
     {
       machine_mode field_mode = VOIDmode;
-      int field_count = rs6000_aggregate_candidate (type, &field_mode);
+      bool cxx17_empty_base_seen = false;
+      int field_count = rs6000_aggregate_candidate (type, &field_mode,
+						    &cxx17_empty_base_seen);
 
       if (field_count > 0)
 	{
@@ -5725,6 +5737,18 @@ rs6000_discover_homogeneous_aggregate (machine_mode mode, const_tree type,
 		*elt_mode = field_mode;
 	      if (n_elts)
 		*n_elts = field_count;
+	      if (cxx17_empty_base_seen && warn_psabi)
+		{
+		  static const_tree last_reported_type;
+		  if (type != last_reported_type)
+		    {
+		      inform (input_location,
+			      "parameter passing for argument of type %qT "
+			      "when C++17 is enabled changed to match C++14 "
+			      "in GCC 10.1", type);
+		      last_reported_type = type;
+		    }
+		}
 	      return true;
 	    }
 	}
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 684e408c1a5..245c1512c76 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,5 +1,8 @@
 2020-04-23  Jakub Jelinek  <jakub@redhat.com>
 
+	PR target/94707
+	* g++.dg/tree-ssa/pr27830.C: Use -Wpsabi -w for -std=c++17 and higher.
+
 	PR c/94705
 	* gcc.dg/pr94705.c: New test.
 
diff --git a/gcc/testsuite/g++.dg/tree-ssa/pr27830.C b/gcc/testsuite/g++.dg/tree-ssa/pr27830.C
index 01c7fc18783..551ebc428cd 100644
--- a/gcc/testsuite/g++.dg/tree-ssa/pr27830.C
+++ b/gcc/testsuite/g++.dg/tree-ssa/pr27830.C
@@ -1,5 +1,7 @@
 /* { dg-do compile } */
 /* { dg-options "-O" } */
+/* Ignore ABI warnings for C++17 and later.  */
+/* { dg-additional-options "-Wno-psabi -w" { target c++17 } } */
 
 struct gc{};
 struct transform:public gc
-- 
2.26.1

=== 0001-Add-patch_area_size-and-patch_area_entry-to-crtl.patch ===
From 6607bdd99994c834f92fce924abdaea3405f62dc Mon Sep 17 00:00:00 2001
From: "H.J. Lu" <hjl.tools@gmail.com>
Date: Fri, 1 May 2020 21:03:10 -0700
Subject: [PATCH] Add patch_area_size and patch_area_entry to crtl

Currently patchable area is at the wrong place.  It is placed immediately
after function label and before .cfi_startproc.  A backend should be able
to add a pseudo patchable area instruction durectly into RTL.  This patch
adds patch_area_size and patch_area_entry to crtl so that the patchable
area info is available in RTL passes.

It also limits patch_area_size and patch_area_entry to 65535, which is
a reasonable maximum size for patchable area.

gcc/

	PR target/93492
	* cfgexpand.c (pass_expand::execute): Set crtl->patch_area_size
	and crtl->patch_area_entry.
	* emit-rtl.h (rtl_data): Add patch_area_size and patch_area_entry.
	* opts.c (common_handle_option): Limit
	function_entry_patch_area_size and function_entry_patch_area_start
	to USHRT_MAX.  Fix a typo in error message.
	* varasm.c (assemble_start_function): Use crtl->patch_area_size
	and crtl->patch_area_entry.
	* doc/invoke.texi: Document the maximum value for
	-fpatchable-function-entry.

gcc/c-family/

	PR target/12345
	* c-attribs.c (handle_patchable_function_entry_attribute): Limit
	value to USHRT_MAX (65535).

---
 gcc/ChangeLog                                 | 14 ++++++++
 gcc/c-family/ChangeLog                        |  6 ++++
 gcc/c-family/c-attribs.c                      |  9 +++++
 gcc/cfgexpand.c                               | 33 +++++++++++++++++++
 gcc/doc/invoke.texi                           |  1 +
 gcc/emit-rtl.h                                |  6 ++++
 gcc/opts.c                                    |  4 ++-
 gcc/testsuite/ChangeLog                       |  7 ++++
 .../patchable_function_entry-error-1.c        |  9 +++++
 .../patchable_function_entry-error-2.c        |  9 +++++
 .../patchable_function_entry-error-3.c        | 17 ++++++++++
 gcc/varasm.c                                  | 30 ++---------------
 12 files changed, 116 insertions(+), 29 deletions(-)
 create mode 100644 gcc/testsuite/c-c++-common/patchable_function_entry-error-1.c
 create mode 100644 gcc/testsuite/c-c++-common/patchable_function_entry-error-2.c
 create mode 100644 gcc/testsuite/c-c++-common/patchable_function_entry-error-3.c

diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index e85a8e8813e..fb776ba5a0e 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,17 @@
+2020-05-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/93492
+	* cfgexpand.c (pass_expand::execute): Set crtl->patch_area_size
+	and crtl->patch_area_entry.
+	* emit-rtl.h (rtl_data): Add patch_area_size and patch_area_entry.
+	* opts.c (common_handle_option): Limit
+	function_entry_patch_area_size and function_entry_patch_area_start
+	to USHRT_MAX.  Fix a typo in error message.
+	* varasm.c (assemble_start_function): Use crtl->patch_area_size
+	and crtl->patch_area_entry.
+	* doc/invoke.texi: Document the maximum value for
+	-fpatchable-function-entry.
+
 2020-05-01  Iain Sandoe  <iain@sandoe.co.uk>
 
 	* config/i386/darwin.h: Repair SUBTARGET_INIT_BUILTINS.
diff --git a/gcc/c-family/ChangeLog b/gcc/c-family/ChangeLog
index c429b49e68c..69ea1fdc4f3 100644
--- a/gcc/c-family/ChangeLog
+++ b/gcc/c-family/ChangeLog
@@ -1,3 +1,9 @@
+2020-05-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/93492
+	* c-attribs.c (handle_patchable_function_entry_attribute): Limit
+	value to USHRT_MAX (65535).
+
 2020-04-29  Jakub Jelinek  <jakub@redhat.com>
 
 	* c-format.c (PP_FORMAT_CHAR_TABLE): Add %{ and %}.
diff --git a/gcc/c-family/c-attribs.c b/gcc/c-family/c-attribs.c
index ac936d5bbbb..a101312c581 100644
--- a/gcc/c-family/c-attribs.c
+++ b/gcc/c-family/c-attribs.c
@@ -4553,6 +4553,15 @@ handle_patchable_function_entry_attribute (tree *, tree name, tree args,
 	  *no_add_attrs = true;
 	  return NULL_TREE;
 	}
+
+      if (tree_to_uhwi (val) > USHRT_MAX)
+	{
+	  warning (OPT_Wattributes,
+		   "%qE attribute argument %qE is out of range (> 65535)",
+		   name, val);
+	  *no_add_attrs = true;
+	  return NULL_TREE;
+	}
     }
   return NULL_TREE;
 }
diff --git a/gcc/cfgexpand.c b/gcc/cfgexpand.c
index a7ec77d5c85..86efa22bf60 100644
--- a/gcc/cfgexpand.c
+++ b/gcc/cfgexpand.c
@@ -6656,6 +6656,39 @@ pass_expand::execute (function *fun)
   if (crtl->tail_call_emit)
     fixup_tail_calls ();
 
+  unsigned HOST_WIDE_INT patch_area_size = function_entry_patch_area_size;
+  unsigned HOST_WIDE_INT patch_area_entry = function_entry_patch_area_start;
+
+  tree patchable_function_entry_attr
+    = lookup_attribute ("patchable_function_entry",
+			DECL_ATTRIBUTES (cfun->decl));
+  if (patchable_function_entry_attr)
+    {
+      tree pp_val = TREE_VALUE (patchable_function_entry_attr);
+      tree patchable_function_entry_value1 = TREE_VALUE (pp_val);
+
+      patch_area_size = tree_to_uhwi (patchable_function_entry_value1);
+      patch_area_entry = 0;
+      if (TREE_CHAIN (pp_val) != NULL_TREE)
+	{
+	  tree patchable_function_entry_value2
+	    = TREE_VALUE (TREE_CHAIN (pp_val));
+	  patch_area_entry = tree_to_uhwi (patchable_function_entry_value2);
+	}
+    }
+
+  if (patch_area_entry > patch_area_size)
+    {
+      if (patch_area_size > 0)
+	warning (OPT_Wattributes,
+		 "patchable function entry %wu exceeds size %wu",
+		 patch_area_entry, patch_area_size);
+      patch_area_entry = 0;
+    }
+
+  crtl->patch_area_size = patch_area_size;
+  crtl->patch_area_entry = patch_area_entry;
+
   /* BB subdivision may have created basic blocks that are only reachable
      from unlikely bbs but not marked as such in the profile.  */
   if (optimize)
diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
index 527d362533a..767d1f07801 100644
--- a/gcc/doc/invoke.texi
+++ b/gcc/doc/invoke.texi
@@ -14112,6 +14112,7 @@ If @code{N=0}, no pad location is recorded.
 The NOP instructions are inserted at---and maybe before, depending on
 @var{M}---the function entry address, even before the prologue.
 
+The maximum value of @var{N} and @var{M} is 65535.
 @end table
 
 
diff --git a/gcc/emit-rtl.h b/gcc/emit-rtl.h
index a878efe3cf7..3d6565c8a30 100644
--- a/gcc/emit-rtl.h
+++ b/gcc/emit-rtl.h
@@ -173,6 +173,12 @@ struct GTY(()) rtl_data {
         local stack.  */
   unsigned int stack_alignment_estimated;
 
+  /* How many NOP insns to place at each function entry by default.  */
+  unsigned short patch_area_size;
+
+  /* How far the real asm entry point is into this area.  */
+  unsigned short patch_area_entry;
+
   /* For reorg.  */
 
   /* Nonzero if function being compiled called builtin_return_addr or
diff --git a/gcc/opts.c b/gcc/opts.c
index c212a1a57dc..3dccef39701 100644
--- a/gcc/opts.c
+++ b/gcc/opts.c
@@ -2615,10 +2615,12 @@ common_handle_option (struct gcc_options *opts,
 	    function_entry_patch_area_start = 0;
 	  }
 	if (function_entry_patch_area_size < 0
+	    || function_entry_patch_area_size > USHRT_MAX
 	    || function_entry_patch_area_start < 0
+	    || function_entry_patch_area_start > USHRT_MAX
 	    || function_entry_patch_area_size 
 		< function_entry_patch_area_start)
-	  error ("invalid arguments for %<-fpatchable_function_entry%>");
+	  error ("invalid arguments for %<-fpatchable-function-entry%>");
 	free (patch_area_arg);
       }
       break;
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 176aa117904..185f9ea725e 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,10 @@
+2020-05-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/93492
+	* c-c++-common/patchable_function_entry-error-1.c: New test.
+	* c-c++-common/patchable_function_entry-error-2.c: Likewise.
+	* c-c++-common/patchable_function_entry-error-3.c: Likewise.
+
 2020-05-01  Patrick Palka  <ppalka@redhat.com>
 
 	PR c++/90880
diff --git a/gcc/testsuite/c-c++-common/patchable_function_entry-error-1.c b/gcc/testsuite/c-c++-common/patchable_function_entry-error-1.c
new file mode 100644
index 00000000000..f60bf46cfe3
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/patchable_function_entry-error-1.c
@@ -0,0 +1,9 @@
+/* { dg-do compile { target { ! { nvptx*-*-* visium-*-* } } } } */
+/* { dg-options "-O2 -fpatchable-function-entry=65536,1" } */
+/* { dg-additional-options "-fno-pie" { target sparc*-*-* } } */
+/* { dg-error "invalid arguments for '-fpatchable-function-entry'" "" { target *-*-* } 0 } */
+
+void
+foo (void)
+{
+}
diff --git a/gcc/testsuite/c-c++-common/patchable_function_entry-error-2.c b/gcc/testsuite/c-c++-common/patchable_function_entry-error-2.c
new file mode 100644
index 00000000000..90f88c78be7
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/patchable_function_entry-error-2.c
@@ -0,0 +1,9 @@
+/* { dg-do compile { target { ! { nvptx*-*-* visium-*-* } } } } */
+/* { dg-options "-O2 -fpatchable-function-entry=1,65536" } */
+/* { dg-additional-options "-fno-pie" { target sparc*-*-* } } */
+/* { dg-error "invalid arguments for '-fpatchable-function-entry'" "" { target *-*-* } 0 } */
+
+void
+foo (void)
+{
+}
diff --git a/gcc/testsuite/c-c++-common/patchable_function_entry-error-3.c b/gcc/testsuite/c-c++-common/patchable_function_entry-error-3.c
new file mode 100644
index 00000000000..4490e5c15ca
--- /dev/null
+++ b/gcc/testsuite/c-c++-common/patchable_function_entry-error-3.c
@@ -0,0 +1,17 @@
+/* { dg-do compile { target { ! { nvptx*-*-* visium-*-* } } } } */
+/* { dg-additional-options "-fno-pie" { target sparc*-*-* } } */
+
+void
+ __attribute__((patchable_function_entry(65536)))
+foo1 (void) { /* { dg-warning "'patchable_function_entry' attribute argument '65536' is out of range" } */
+}
+
+void
+ __attribute__((patchable_function_entry(65536,1)))
+foo2 (void) { /* { dg-warning "'patchable_function_entry' attribute argument '65536' is out of range" } */
+}
+
+void
+ __attribute__((patchable_function_entry(65536,65536)))
+foo3 (void) { /* { dg-warning "'patchable_function_entry' attribute argument '65536' is out of range" } */
+}
diff --git a/gcc/varasm.c b/gcc/varasm.c
index 271a67abf56..f062e48071f 100644
--- a/gcc/varasm.c
+++ b/gcc/varasm.c
@@ -1857,34 +1857,8 @@ assemble_start_function (tree decl, const char *fnname)
   if (DECL_PRESERVE_P (decl))
     targetm.asm_out.mark_decl_preserved (fnname);
 
-  unsigned HOST_WIDE_INT patch_area_size = function_entry_patch_area_size;
-  unsigned HOST_WIDE_INT patch_area_entry = function_entry_patch_area_start;
-
-  tree patchable_function_entry_attr
-    = lookup_attribute ("patchable_function_entry", DECL_ATTRIBUTES (decl));
-  if (patchable_function_entry_attr)
-    {
-      tree pp_val = TREE_VALUE (patchable_function_entry_attr);
-      tree patchable_function_entry_value1 = TREE_VALUE (pp_val);
-
-      patch_area_size = tree_to_uhwi (patchable_function_entry_value1);
-      patch_area_entry = 0;
-      if (TREE_CHAIN (pp_val) != NULL_TREE)
-	{
-	  tree patchable_function_entry_value2
-	    = TREE_VALUE (TREE_CHAIN (pp_val));
-	  patch_area_entry = tree_to_uhwi (patchable_function_entry_value2);
-	}
-    }
-
-  if (patch_area_entry > patch_area_size)
-    {
-      if (patch_area_size > 0)
-	warning (OPT_Wattributes,
-		 "patchable function entry %wu exceeds size %wu",
-		 patch_area_entry, patch_area_size);
-      patch_area_entry = 0;
-    }
+  unsigned short patch_area_size = crtl->patch_area_size;
+  unsigned short patch_area_entry = crtl->patch_area_entry;
 
   /* Emit the patching area before the entry label, if any.  */
   if (patch_area_entry > 0)
-- 
2.26.2

=== 0002-Bump-date.patch ===
From a139bafeec76732d964b99e8be3d61b3cab0359d Mon Sep 17 00:00:00 2001
From: Martin Liska <mliska@suse.cz>
Date: Tue, 12 May 2020 09:27:51 +0200
Subject: [PATCH 2/2] Bump date.

---
 gcc/DATESTAMP | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/gcc/DATESTAMP b/gcc/DATESTAMP
index c3d42a6f89a..b03d4a0feab 100644
--- a/gcc/DATESTAMP
+++ b/gcc/DATESTAMP
@@ -1 +1 @@
-20200111
+20200112
-- 
2.26.2

=== 0001-Just-test-it.patch ===
From 6b10b909c0b49ac7ace2cd53021b3ff7ffb2d3f4 Mon Sep 17 00:00:00 2001
From: Martin Liska <mliska@suse.cz>
Date: Tue, 12 May 2020 09:25:54 +0200
Subject: [PATCH 1/2] Just test it.

gcc/ChangeLog:

2020-05-12  Martin Liska  <mliska@suse.cz>

	PR ipa/12345
	* tree-vrp.c: Done.
	* tree.c: Done.
---
 gcc/tree-vrp.c | 2 ++
 gcc/tree.c     | 3 +++
 2 files changed, 5 insertions(+)

diff --git a/gcc/tree-vrp.c b/gcc/tree-vrp.c
index a8861670790..32722d2c714 100644
--- a/gcc/tree-vrp.c
+++ b/gcc/tree-vrp.c
@@ -1,3 +1,5 @@
+
+
 /* Support routines for Value Range Propagation (VRP).
    Copyright (C) 2005-2020 Free Software Foundation, Inc.
    Contributed by Diego Novillo <dnovillo@redhat.com>.
diff --git a/gcc/tree.c b/gcc/tree.c
index 0ddf002e9eb..fa7c6b28a4e 100644
--- a/gcc/tree.c
+++ b/gcc/tree.c
@@ -1,3 +1,6 @@
+
+
+
 /* Language-independent node constructors for parse phase of GNU compiler.
    Copyright (C) 1987-2020 Free Software Foundation, Inc.
 
-- 
2.26.2

=== trailing-whitespaces.patch ===
From eb7c7c524556df5364f03adc20f6a9db20858484 Mon Sep 17 00:00:00 2001
From: Jakub Jelinek <jakub@redhat.com>
Date: Mon, 13 Jan 2020 14:14:57 +0100
Subject: [PATCH 0004/2034] tree-opt: Fix bootstrap failure in
 tree-ssa-forwprop.c some more PR90838

2020-01-13  Jakub Jelinek  <jakub@redhat.com>   

	PR tree-optimization/90838
	* tree-ssa-forwprop.c (simplify_count_trailing_zeroes): Use
	SCALAR_INT_TYPE_MODE directly in CTZ_DEFINED_VALUE_AT_ZERO macro      
	argument rather than to initialize temporary for targets that
	don't use the mode argument at all.  Initialize ctzval to avoid  
	warning at -O0.
---
 gcc/ChangeLog           | 9 +++++++++
 gcc/tree-ssa-forwprop.c | 6 +++---
 2 files changed, 12 insertions(+), 3 deletions(-)

diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index a195863212e..f7df07343d1 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,12 @@
+2020-01-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/90838
+	* tree-ssa-forwprop.c (simplify_count_trailing_zeroes): Use
+	SCALAR_INT_TYPE_MODE directly in CTZ_DEFINED_VALUE_AT_ZERO macro
+	argument rather than to initialize temporary for targets that
+	don't use the mode argument at all.  Initialize ctzval to avoid
+	warning at -O0.
+
 2020-01-10  Thomas Schwinge  <thomas@codesourcery.com>
 
 	* tree.h (OMP_CLAUSE_USE_DEVICE_PTR_IF_PRESENT): New definition.
diff --git a/gcc/tree-ssa-forwprop.c b/gcc/tree-ssa-forwprop.c
index aac31d02b6c..56c470f6ecf 100644
--- a/gcc/tree-ssa-forwprop.c
+++ b/gcc/tree-ssa-forwprop.c
@@ -1920,10 +1920,10 @@ simplify_count_trailing_zeroes (gimple_stmt_iterator *gsi)
 				      res_ops[1], res_ops[2], zero_val))
     {
       tree type = TREE_TYPE (res_ops[0]);
-      HOST_WIDE_INT ctzval;
+      HOST_WIDE_INT ctzval = 0;
       HOST_WIDE_INT type_size = tree_to_shwi (TYPE_SIZE (type));
-      scalar_int_mode mode = SCALAR_INT_TYPE_MODE (type);
-      bool zero_ok = CTZ_DEFINED_VALUE_AT_ZERO (mode, ctzval) == 2;
+      bool zero_ok
+	= CTZ_DEFINED_VALUE_AT_ZERO (SCALAR_INT_TYPE_MODE (type), ctzval) == 2;
 
       /* Skip if there is no value defined at zero, or if we can't easily
 	 return the correct value for zero.  */
-- 
2.26.1

=== pr-check1.patch ===
From 5194b51ed9714808d88827531e91474895b6c706 Mon Sep 17 00:00:00 2001
From: Jason Merrill <jason@redhat.com>
Date: Thu, 16 Jan 2020 16:55:39 -0500
Subject: [PATCH 0121/2034] PR c++/93286 - ICE with __is_constructible and
 variadic template.

Here we had been recursing in tsubst_copy_and_build if type2 was a TREE_LIST
because that function knew how to deal with pack expansions, and tsubst
didn't.  But tsubst_copy_and_build expects to be dealing with expressions,
so we crash when trying to convert_from_reference a type.

gcc/cp/ChangeLog:
	PR ipa/12345
	* pt.c (tsubst) [TREE_LIST]: Handle pack expansion.
	(tsubst_copy_and_build) [TRAIT_EXPR]: Always use tsubst for type2.

gcc/testsuite/ChangeLog:
	* g++.dg/ext/is_constructible4.C: New file.
---
 gcc/cp/ChangeLog                             |  4 ++
 gcc/cp/pt.c                                  | 74 ++++++++++++++++++--
 gcc/testsuite/g++.dg/ext/is_constructible4.C | 18 +++++
 3 files changed, 89 insertions(+), 7 deletions(-)
 create mode 100644 gcc/testsuite/g++.dg/ext/is_constructible4.C

diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
index 3ca5d7a11b4..c37e461bcc5 100644
--- a/gcc/cp/ChangeLog
+++ b/gcc/cp/ChangeLog
@@ -1,5 +1,9 @@
 2020-01-16  Jason Merrill  <jason@redhat.com>
 
+	PR c++/93286 - ICE with __is_constructible and variadic template.
+	* pt.c (tsubst) [TREE_LIST]: Handle pack expansion.
+	(tsubst_copy_and_build) [TRAIT_EXPR]: Always use tsubst for type2.
+
 	PR c++/93280 - ICE with aggregate assignment and DMI.
 	* init.c (get_nsdmi): Set TARGET_EXPR_DIRECT_INIT_P here.
 	* typeck2.c (digest_nsdmi_init): Not here.
diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
index 9bb8cc13e5f..872f8ff8f52 100644
--- a/gcc/cp/pt.c
+++ b/gcc/cp/pt.c
@@ -15350,6 +15350,71 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)
 	if (t == void_list_node)
 	  return t;
 
+	if ((TREE_PURPOSE (t) && PACK_EXPANSION_P (TREE_PURPOSE (t)))
+	    || (TREE_VALUE (t) && PACK_EXPANSION_P (TREE_VALUE (t))))
+	  {
+	    /* We have pack expansions, so expand those and
+	       create a new list out of it.  */
+
+	    /* Expand the argument expressions.  */
+	    tree purposevec = NULL_TREE;
+	    if (TREE_PURPOSE (t))
+	      purposevec = tsubst_pack_expansion (TREE_PURPOSE (t), args,
+						  complain, in_decl);
+	    if (purposevec == error_mark_node)
+	      return error_mark_node;
+
+	    tree valuevec = NULL_TREE;
+	    if (TREE_VALUE (t))
+	      valuevec = tsubst_pack_expansion (TREE_VALUE (t), args,
+						complain, in_decl);
+	    if (valuevec == error_mark_node)
+	      return error_mark_node;
+
+	    /* Build the rest of the list.  */
+	    tree chain = TREE_CHAIN (t);
+	    if (chain && chain != void_type_node)
+	      chain = tsubst (chain, args, complain, in_decl);
+	    if (chain == error_mark_node)
+	      return error_mark_node;
+
+	    /* Determine the number of arguments.  */
+	    int len = -1;
+	    if (purposevec && TREE_CODE (purposevec) == TREE_VEC)
+	      {
+		len = TREE_VEC_LENGTH (purposevec);
+		gcc_assert (!valuevec || len == TREE_VEC_LENGTH (valuevec));
+	      }
+	    else if (TREE_CODE (valuevec) == TREE_VEC)
+	      len = TREE_VEC_LENGTH (valuevec);
+	    else
+	      {
+		/* Since we only performed a partial substitution into
+		   the argument pack, we only RETURN (a single list
+		   node.  */
+		if (purposevec == TREE_PURPOSE (t)
+		    && valuevec == TREE_VALUE (t)
+		    && chain == TREE_CHAIN (t))
+		  return t;
+
+		return tree_cons (purposevec, valuevec, chain);
+	      }
+
+	    /* Convert the argument vectors into a TREE_LIST.  */
+	    for (int i = len; i-- > 0; )
+	      {
+		purpose = (purposevec ? TREE_VEC_ELT (purposevec, i)
+			   : NULL_TREE);
+		value = (valuevec ? TREE_VEC_ELT (valuevec, i)
+			 : NULL_TREE);
+
+		/* Build the list (backwards).  */
+		chain = hash_tree_cons (purpose, value, chain);
+	      }
+
+	    return chain;
+	  }
+
 	purpose = TREE_PURPOSE (t);
 	if (purpose)
 	  {
@@ -20158,13 +20223,8 @@ tsubst_copy_and_build (tree t,
       {
 	tree type1 = tsubst (TRAIT_EXPR_TYPE1 (t), args,
 			     complain, in_decl);
-
-	tree type2 = TRAIT_EXPR_TYPE2 (t);
-	if (type2 && TREE_CODE (type2) == TREE_LIST)
-	  type2 = RECUR (type2);
-	else if (type2)
-	  type2 = tsubst (type2, args, complain, in_decl);
-
+	tree type2 = tsubst (TRAIT_EXPR_TYPE2 (t), args,
+			     complain, in_decl);
 	RETURN (finish_trait_expr (TRAIT_EXPR_LOCATION (t),
 				   TRAIT_EXPR_KIND (t), type1, type2));
       }
diff --git a/gcc/testsuite/g++.dg/ext/is_constructible4.C b/gcc/testsuite/g++.dg/ext/is_constructible4.C
new file mode 100644
index 00000000000..6dfe3c01661
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/is_constructible4.C
@@ -0,0 +1,18 @@
+// PR c++/93286
+// { dg-do compile { target c++14 } }
+
+struct A { static const bool value = true; };
+template <bool> using __bool_constant = A;
+template <typename... _Args>
+struct B : __bool_constant<__is_constructible(int, _Args...)> {};
+template <bool> using enable_if_t = int;
+template <typename... _Args> bool is_constructible_v = B<_Args...>::value;
+class C {
+  template <typename _Tp, typename = enable_if_t<is_constructible_v<_Tp>>>
+  C(_Tp &&);
+};
+using Effect_t = C;
+void fn1(Effect_t effect) {
+  int i;
+  [](int &effect) {}(i);
+}
-- 
2.26.1

=== 0020-IPA-Avoid-segfault-in-devirtualization_time_bonus-PR.patch ===
From 8472660b98a31b32b7d030c2cdc4d41d326364d5 Mon Sep 17 00:00:00 2001
From: Martin Jambor <mjambor@suse.cz>
Date: Mon, 13 Jan 2020 19:13:46 +0100
Subject: [PATCH 0020/2034] IPA: Avoid segfault in devirtualization_time_bonus
 (PR 93223)

2020-01-13  Martin Jambor  <mjambor@suse.cz>

	PR ipa/93223
	* ipa-cp.c (devirtualization_time_bonus): Check whether isummary is
	NULL.

	testsuite/
	* g++.dg/ipa/pr93223.C: New test.
---
 gcc/ipa-cp.c                       |  2 +-
 gcc/testsuite/g++.dg/ipa/pr93223.C | 62 ++++++++++++++++++++++++++++++
 2 files changed, 63 insertions(+), 1 deletion(-)
 create mode 100644 gcc/testsuite/g++.dg/ipa/pr93223.C

diff --git a/gcc/ipa-cp.c b/gcc/ipa-cp.c
index 612f3d0a89b..17da1d8e8a7 100644
--- a/gcc/ipa-cp.c
+++ b/gcc/ipa-cp.c
@@ -3158,7 +3158,7 @@ devirtualization_time_bonus (struct cgraph_node *node,
       if (avail < AVAIL_AVAILABLE)
 	continue;
       isummary = ipa_fn_summaries->get (callee);
-      if (!isummary->inlinable)
+      if (!isummary || !isummary->inlinable)
 	continue;
 
       int size = ipa_size_summaries->get (callee)->size;
diff --git a/gcc/testsuite/g++.dg/ipa/pr93223.C b/gcc/testsuite/g++.dg/ipa/pr93223.C
new file mode 100644
index 00000000000..87f98b5e244
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ipa/pr93223.C
@@ -0,0 +1,62 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -std=gnu++14" } */
+
+template <typename Function>
+bool run(const int item_count,
+         Function && process_range,
+         const int max_parallelism,
+         int* progress = nullptr)
+{
+    if (max_parallelism <= 1)
+    {
+        if (progress == nullptr)
+        {
+            return process_range(0);
+        }
+        else
+        {
+            auto result = true;
+            for (int i = 0; i != item_count && result; ++i)
+            {
+                (*progress)++;
+                result = process_range(i);
+            }
+            return result;
+        }
+    }
+
+    if (max_parallelism > 10)
+    {
+        if (progress == nullptr)
+        {
+            return process_range(0);
+        }
+        else
+        {
+            auto result = true;
+            for (int i = 0; i != item_count && result; ++i)
+            {
+                (*progress)++;
+                result = process_range(i);
+            }
+            return result;
+        }
+    }
+    return false;
+}
+
+namespace
+{
+__attribute__((optimize(0))) bool worker_fun(const int)
+{
+    return true;
+}
+}
+
+void demo(int n)
+{
+    for (int i = 0; i < n; ++i)
+    {
+        run(n, &worker_fun, n);
+    }
+}
-- 
2.26.1

=== 0043-Compare-TREE_ADDRESSABLE-and-TYPE_MODE-when-ODR-chec.patch ===
From 288c5324bf6e418dd94d718d1619464a4f68ff8e Mon Sep 17 00:00:00 2001
From: Jan Hubicka <jh@suse.cz>
Date: Tue, 14 Jan 2020 21:45:03 +0100
Subject: [PATCH 0043/2034] Compare TREE_ADDRESSABLE and TYPE_MODE when ODR
 checking types.

	PR lto/91576
	* ipa-devirt.c (odr_types_equivalent_p): Compare TREE_ADDRESSABLE and
	TYPE_MODE.

	* testsuite/g++.dg/lto/odr-8_0.C: New testcase.
	* testsuite/g++.dg/lto/odr-8_1.C: New testcase.
---
 gcc/ChangeLog                      |  6 ++++++
 gcc/ipa-devirt.c                   | 21 +++++++++++++++++++++
 gcc/testsuite/ChangeLog            |  6 ++++++
 gcc/testsuite/g++.dg/lto/odr-8_0.C |  7 +++++++
 gcc/testsuite/g++.dg/lto/odr-8_1.C | 12 ++++++++++++
 5 files changed, 52 insertions(+)
 create mode 100644 gcc/testsuite/g++.dg/lto/odr-8_0.C
 create mode 100644 gcc/testsuite/g++.dg/lto/odr-8_1.C

diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 38165123654..33ca91a6467 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,9 @@
+2020-01-14  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR lto/91576
+	* ipa-devirt.c (odr_types_equivalent_p): Compare TREE_ADDRESSABLE and
+	TYPE_MODE.
+
 2020-01-14  David Malcolm  <dmalcolm@redhat.com>
 
 	* Makefile.in (lang_opt_files): Add analyzer.opt.
diff --git a/gcc/ipa-devirt.c b/gcc/ipa-devirt.c
index f0031957375..b609a77701d 100644
--- a/gcc/ipa-devirt.c
+++ b/gcc/ipa-devirt.c
@@ -1544,6 +1544,27 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,
       return false;
     }
 
+  if (TREE_ADDRESSABLE (t1) != TREE_ADDRESSABLE (t2)
+      && COMPLETE_TYPE_P (t1) && COMPLETE_TYPE_P (t2))
+    {
+      warn_odr (t1, t2, NULL, NULL, warn, warned,
+		G_("one type needs to be constructed while other not"));
+      gcc_checking_assert (RECORD_OR_UNION_TYPE_P (t1));
+      return false;
+    }
+  /* There is no really good user facing warning for this.
+     Either the original reason for modes being different is lost during
+     streaming or we should catch earlier warnings.  We however must detect
+     the mismatch to avoid type verifier from cmplaining on mismatched
+     types between type and canonical type. See PR91576.  */
+  if (TYPE_MODE (t1) != TYPE_MODE (t2)
+      && COMPLETE_TYPE_P (t1) && COMPLETE_TYPE_P (t2))
+    {
+      warn_odr (t1, t2, NULL, NULL, warn, warned,
+		G_("memory layout mismatch"));
+      return false;
+    }
+
   gcc_assert (!TYPE_SIZE_UNIT (t1) || !TYPE_SIZE_UNIT (t2)
 	      || operand_equal_p (TYPE_SIZE_UNIT (t1),
 				  TYPE_SIZE_UNIT (t2), 0));
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 8e3b9105188..dc42601794b 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,9 @@
+2020-01-14  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR lto/91576
+	* testsuite/g++.dg/lto/odr-8_0.C: New testcase.
+	* testsuite/g++.dg/lto/odr-8_1.C: New testcase.
+
 2020-01-14  David Malcolm  <dmalcolm@redhat.com>
 
 	* gcc.dg/analyzer/CVE-2005-1689-minimal.c: New test.
diff --git a/gcc/testsuite/g++.dg/lto/odr-8_0.C b/gcc/testsuite/g++.dg/lto/odr-8_0.C
new file mode 100644
index 00000000000..59f51399fac
--- /dev/null
+++ b/gcc/testsuite/g++.dg/lto/odr-8_0.C
@@ -0,0 +1,7 @@
+// { dg-lto-do link }
+struct a {char c;}; // { dg-lto-message "8: 'struct a' violates the C\\+\\+ One Definition Rule" }
+int
+test (struct a *a)
+{
+  return a->c;
+}
diff --git a/gcc/testsuite/g++.dg/lto/odr-8_1.C b/gcc/testsuite/g++.dg/lto/odr-8_1.C
new file mode 100644
index 00000000000..742df8cc906
--- /dev/null
+++ b/gcc/testsuite/g++.dg/lto/odr-8_1.C
@@ -0,0 +1,12 @@
+--- a/gcc/testsuite/g++.dg/lto/odr-8_1.C
++++ b/gcc/testsuite/g++.dg/lto/odr-8_1.C
+@@ -1,9 +1,9 @@
+struct a {char c; a() {} a(struct a &) {}}; // { dg-lto-message "one type needs to be constructed while other not" }
+extern int test (struct a *a);
+int
+main()
+{
+  struct a a;
+  a.c=0;
+  return test(&a);
+}
-- 
2.26.1

=== 0096-GCC-PATCH-AArch64-Add-ACLE-intrinsics-for-dot-produc.patch ===
From 8c197c851e7528baba7cb837f34c05ba2242f705 Mon Sep 17 00:00:00 2001
From: Stam Markianos-Wright <stam.markianos-wright@arm.com>
Date: Thu, 16 Jan 2020 14:20:48 +0000
Subject: [PATCH 0096/2034] [GCC][PATCH][AArch64]Add ACLE intrinsics for dot
 product (usdot - vector, <us/su>dot - by element) for AArch64 AdvSIMD ARMv8.6
 Extension

gcc/ChangeLog:

2020-01-16  Stam Markianos-Wright  <stam.markianos-wright@arm.com>

	* config/aarch64/aarch64-builtins.c: (enum aarch64_type_qualifiers):
	New qualifier_lane_quadtup_index, TYPES_TERNOP_SSUS,
	TYPES_QUADOPSSUS_LANE_QUADTUP, TYPES_QUADOPSSSU_LANE_QUADTUP.
	(aarch64_simd_expand_args): Add case SIMD_ARG_LANE_QUADTUP_INDEX.
	(aarch64_simd_expand_builtin): Add qualifier_lane_quadtup_index.
	* config/aarch64/aarch64-simd-builtins.def (usdot, usdot_lane,
	usdot_laneq, sudot_lane,sudot_laneq): New.
	* config/aarch64/aarch64-simd.md (aarch64_usdot): New.
	(aarch64_<sur>dot_lane): New.
	* config/aarch64/arm_neon.h (vusdot_s32): New.
	(vusdotq_s32): New.
	(vusdot_lane_s32): New.
	(vsudot_lane_s32): New.
	* config/aarch64/iterators.md (DOTPROD_I8MM): New iterator.
	(UNSPEC_USDOT, UNSPEC_SUDOT): New unspecs.

gcc/testsuite/ChangeLog:

2020-01-16  Stam Markianos-Wright  <stam.markianos-wright@arm.com>

	* gcc.target/aarch64/advsimd-intrinsics/vdot-compile-3-1.c: New test.
	* gcc.target/aarch64/advsimd-intrinsics/vdot-compile-3-2.c: New test.
	* gcc.target/aarch64/advsimd-intrinsics/vdot-compile-3-3.c: New test.
	* gcc.target/aarch64/advsimd-intrinsics/vdot-compile-3-4.c: New test.
---
 gcc/ChangeLog                                 |  18 +++
 gcc/config/aarch64/aarch64-builtins.c         |  45 +++++-
 gcc/config/aarch64/aarch64-simd-builtins.def  |   5 +
 gcc/config/aarch64/aarch64-simd.md            |  34 +++++
 gcc/config/aarch64/arm_neon.h                 |  83 +++++++++++
 gcc/config/aarch64/iterators.md               |   7 +
 gcc/testsuite/ChangeLog                       |   7 +
 .../aarch64/advsimd-intrinsics/vdot-3-1.c     | 136 +++++++++++++++++
 .../aarch64/advsimd-intrinsics/vdot-3-2.c     | 137 ++++++++++++++++++
 .../aarch64/advsimd-intrinsics/vdot-3-3.c     |  31 ++++
 .../aarch64/advsimd-intrinsics/vdot-3-4.c     |  31 ++++
 11 files changed, 531 insertions(+), 3 deletions(-)
 create mode 100755 gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-1.c
 create mode 100755 gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-2.c
 create mode 100755 gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-3.c
 create mode 100755 gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-4.c

diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 9a949980699..49dcecb6777 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,21 @@
+2020-01-16  Stam Markianos-Wright  <stam.markianos-wright@arm.com>
+
+	* config/aarch64/aarch64-builtins.c: (enum aarch64_type_qualifiers):
+	New qualifier_lane_quadtup_index, TYPES_TERNOP_SSUS,
+	TYPES_QUADOPSSUS_LANE_QUADTUP, TYPES_QUADOPSSSU_LANE_QUADTUP.
+	(aarch64_simd_expand_args): Add case SIMD_ARG_LANE_QUADTUP_INDEX.
+	(aarch64_simd_expand_builtin): Add qualifier_lane_quadtup_index.
+	* config/aarch64/aarch64-simd-builtins.def (usdot, usdot_lane,
+	usdot_laneq, sudot_lane,sudot_laneq): New.
+	* config/aarch64/aarch64-simd.md (aarch64_usdot): New.
+	(aarch64_<sur>dot_lane): New.
+	* config/aarch64/arm_neon.h (vusdot_s32): New.
+	(vusdotq_s32): New.
+	(vusdot_lane_s32): New.
+	(vsudot_lane_s32): New.
+	* config/aarch64/iterators.md (DOTPROD_I8MM): New iterator.
+	(UNSPEC_USDOT, UNSPEC_SUDOT): New unspecs.
+
 2020-01-16  Martin Liska  <mliska@suse.cz>
 
 	* value-prof.c (dump_histogram_value): Fix
diff --git a/gcc/config/aarch64/aarch64-builtins.c b/gcc/config/aarch64/aarch64-builtins.c
index f0e0461b7f0..f50c4857e1c 100644
--- a/gcc/config/aarch64/aarch64-builtins.c
+++ b/gcc/config/aarch64/aarch64-builtins.c
@@ -110,6 +110,9 @@ enum aarch64_type_qualifiers
   /* Lane indices selected in pairs. - must be in range, and flipped for
      bigendian.  */
   qualifier_lane_pair_index = 0x800,
+  /* Lane indices selected in quadtuplets. - must be in range, and flipped for
+     bigendian.  */
+  qualifier_lane_quadtup_index = 0x1000,
 };
 
 typedef struct
@@ -176,6 +179,10 @@ aarch64_types_ternopu_imm_qualifiers[SIMD_MAX_BUILTIN_ARGS]
   = { qualifier_unsigned, qualifier_unsigned,
       qualifier_unsigned, qualifier_immediate };
 #define TYPES_TERNOPUI (aarch64_types_ternopu_imm_qualifiers)
+static enum aarch64_type_qualifiers
+aarch64_types_ternop_ssus_qualifiers[SIMD_MAX_BUILTIN_ARGS]
+  = { qualifier_none, qualifier_none, qualifier_unsigned, qualifier_none };
+#define TYPES_TERNOP_SSUS (aarch64_types_ternop_ssus_qualifiers)
 
 
 static enum aarch64_type_qualifiers
@@ -194,6 +201,19 @@ aarch64_types_quadopu_lane_qualifiers[SIMD_MAX_BUILTIN_ARGS]
       qualifier_unsigned, qualifier_lane_index };
 #define TYPES_QUADOPU_LANE (aarch64_types_quadopu_lane_qualifiers)
 
+static enum aarch64_type_qualifiers
+aarch64_types_quadopssus_lane_quadtup_qualifiers[SIMD_MAX_BUILTIN_ARGS]
+  = { qualifier_none, qualifier_none, qualifier_unsigned,
+      qualifier_none, qualifier_lane_quadtup_index };
+#define TYPES_QUADOPSSUS_LANE_QUADTUP \
+	(aarch64_types_quadopssus_lane_quadtup_qualifiers)
+static enum aarch64_type_qualifiers
+aarch64_types_quadopsssu_lane_quadtup_qualifiers[SIMD_MAX_BUILTIN_ARGS]
+  = { qualifier_none, qualifier_none, qualifier_none,
+      qualifier_unsigned, qualifier_lane_quadtup_index };
+#define TYPES_QUADOPSSSU_LANE_QUADTUP \
+	(aarch64_types_quadopsssu_lane_quadtup_qualifiers)
+
 static enum aarch64_type_qualifiers
 aarch64_types_quadopu_imm_qualifiers[SIMD_MAX_BUILTIN_ARGS]
   = { qualifier_unsigned, qualifier_unsigned, qualifier_unsigned,
@@ -1288,6 +1308,7 @@ typedef enum
   SIMD_ARG_LANE_INDEX,
   SIMD_ARG_STRUCT_LOAD_STORE_LANE_INDEX,
   SIMD_ARG_LANE_PAIR_INDEX,
+  SIMD_ARG_LANE_QUADTUP_INDEX,
   SIMD_ARG_STOP
 } builtin_simd_arg;
 
@@ -1377,9 +1398,25 @@ aarch64_simd_expand_args (rtx target, int icode, int have_retval,
 		  op[opc] = gen_int_mode (ENDIAN_LANE_N (nunits / 2, lane),
 					  SImode);
 		}
-	      /* Fall through - if the lane index isn't a constant then
-		 the next case will error.  */
-	      /* FALLTHRU */
+	      /* If the lane index isn't a constant then error out.  */
+	      goto constant_arg;
+	    case SIMD_ARG_LANE_QUADTUP_INDEX:
+	      /* Must be a previous operand into which this is an index and
+		 index is restricted to nunits / 4.  */
+	      gcc_assert (opc > 0);
+	      if (CONST_INT_P (op[opc]))
+		{
+		  machine_mode vmode = insn_data[icode].operand[opc - 1].mode;
+		  unsigned int nunits
+		    = GET_MODE_NUNITS (vmode).to_constant ();
+		  aarch64_simd_lane_bounds (op[opc], 0, nunits / 4, exp);
+		  /* Keep to GCC-vector-extension lane indices in the RTL.  */
+		  int lane = INTVAL (op[opc]);
+		  op[opc] = gen_int_mode (ENDIAN_LANE_N (nunits / 4, lane),
+					  SImode);
+		}
+	      /* If the lane index isn't a constant then error out.  */
+	      goto constant_arg;
 	    case SIMD_ARG_CONSTANT:
 constant_arg:
 	      if (!(*insn_data[icode].operand[opc].predicate)
@@ -1492,6 +1529,8 @@ aarch64_simd_expand_builtin (int fcode, tree exp, rtx target)
 	args[k] = SIMD_ARG_LANE_INDEX;
       else if (d->qualifiers[qualifiers_k] & qualifier_lane_pair_index)
 	args[k] = SIMD_ARG_LANE_PAIR_INDEX;
+      else if (d->qualifiers[qualifiers_k] & qualifier_lane_quadtup_index)
+	args[k] = SIMD_ARG_LANE_QUADTUP_INDEX;
       else if (d->qualifiers[qualifiers_k] & qualifier_struct_load_store_lane_index)
 	args[k] = SIMD_ARG_STRUCT_LOAD_STORE_LANE_INDEX;
       else if (d->qualifiers[qualifiers_k] & qualifier_immediate)
diff --git a/gcc/config/aarch64/aarch64-simd-builtins.def b/gcc/config/aarch64/aarch64-simd-builtins.def
index 57fc5933b43..4744dd1f6b2 100644
--- a/gcc/config/aarch64/aarch64-simd-builtins.def
+++ b/gcc/config/aarch64/aarch64-simd-builtins.def
@@ -212,10 +212,15 @@
   /* Implemented by aarch64_<sur><dotprod>{_lane}{q}<dot_mode>.  */
   BUILTIN_VB (TERNOP, sdot, 0)
   BUILTIN_VB (TERNOPU, udot, 0)
+  BUILTIN_VB (TERNOP_SSUS, usdot, 0)
   BUILTIN_VB (QUADOP_LANE, sdot_lane, 0)
   BUILTIN_VB (QUADOPU_LANE, udot_lane, 0)
   BUILTIN_VB (QUADOP_LANE, sdot_laneq, 0)
   BUILTIN_VB (QUADOPU_LANE, udot_laneq, 0)
+  BUILTIN_VB (QUADOPSSUS_LANE_QUADTUP, usdot_lane, 0)
+  BUILTIN_VB (QUADOPSSUS_LANE_QUADTUP, usdot_laneq, 0)
+  BUILTIN_VB (QUADOPSSSU_LANE_QUADTUP, sudot_lane, 0)
+  BUILTIN_VB (QUADOPSSSU_LANE_QUADTUP, sudot_laneq, 0)
 
   /* Implemented by aarch64_fcadd<rot><mode>.   */
   BUILTIN_VHSDF (BINOP, fcadd90, 0)
diff --git a/gcc/config/aarch64/aarch64-simd.md b/gcc/config/aarch64/aarch64-simd.md
index 2989096b170..9e56e8caf35 100644
--- a/gcc/config/aarch64/aarch64-simd.md
+++ b/gcc/config/aarch64/aarch64-simd.md
@@ -506,6 +506,20 @@ (define_insn "aarch64_<sur>dot<vsi2qi>"
   [(set_attr "type" "neon_dot<q>")]
 )
 
+;; These instructions map to the __builtins for the armv8.6a I8MM usdot
+;; (vector) Dot Product operation.
+(define_insn "aarch64_usdot<vsi2qi>"
+  [(set (match_operand:VS 0 "register_operand" "=w")
+	(plus:VS
+	  (unspec:VS [(match_operand:<VSI2QI> 2 "register_operand" "w")
+		      (match_operand:<VSI2QI> 3 "register_operand" "w")]
+	  UNSPEC_USDOT)
+	  (match_operand:VS 1 "register_operand" "0")))]
+  "TARGET_I8MM"
+  "usdot\\t%0.<Vtype>, %2.<Vdottype>, %3.<Vdottype>"
+  [(set_attr "type" "neon_dot<q>")]
+)
+
 ;; These expands map to the Dot Product optab the vectorizer checks for.
 ;; The auto-vectorizer expects a dot product builtin that also does an
 ;; accumulation into the provided register.
@@ -573,6 +587,26 @@ (define_insn "aarch64_<sur>dot_laneq<vsi2qi>"
   [(set_attr "type" "neon_dot<q>")]
 )
 
+;; These instructions map to the __builtins for the armv8.6a I8MM usdot, sudot
+;; (by element) Dot Product operations.
+(define_insn "aarch64_<DOTPROD_I8MM:sur>dot_lane<VB:isquadop><VS:vsi2qi>"
+  [(set (match_operand:VS 0 "register_operand" "=w")
+	(plus:VS
+	  (unspec:VS [(match_operand:<VS:VSI2QI> 2 "register_operand" "w")
+		      (match_operand:VB 3 "register_operand" "w")
+		      (match_operand:SI 4 "immediate_operand" "i")]
+	  DOTPROD_I8MM)
+	  (match_operand:VS 1 "register_operand" "0")))]
+  "TARGET_I8MM"
+  {
+    int nunits = GET_MODE_NUNITS (<VB:MODE>mode).to_constant ();
+    int lane = INTVAL (operands[4]);
+    operands[4] = gen_int_mode (ENDIAN_LANE_N (nunits / 4, lane), SImode);
+    return "<DOTPROD_I8MM:sur>dot\\t%0.<VS:Vtype>, %2.<VS:Vdottype>, %3.4b[%4]";
+  }
+  [(set_attr "type" "neon_dot<VS:q>")]
+)
+
 (define_expand "copysign<mode>3"
   [(match_operand:VHSDF 0 "register_operand")
    (match_operand:VHSDF 1 "register_operand")
diff --git a/gcc/config/aarch64/arm_neon.h b/gcc/config/aarch64/arm_neon.h
index eaba156e26c..c96214003dd 100644
--- a/gcc/config/aarch64/arm_neon.h
+++ b/gcc/config/aarch64/arm_neon.h
@@ -34611,6 +34611,89 @@ vrnd64xq_f64 (float64x2_t __a)
 
 #include "arm_bf16.h"
 
+/* AdvSIMD 8-bit Integer Matrix Multiply (I8MM) intrinsics.  */
+
+#pragma GCC push_options
+#pragma GCC target ("arch=armv8.2-a+i8mm")
+
+__extension__ extern __inline int32x2_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vusdot_s32 (int32x2_t __r, uint8x8_t __a, int8x8_t __b)
+{
+  return __builtin_aarch64_usdotv8qi_ssus (__r, __a, __b);
+}
+
+__extension__ extern __inline int32x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vusdotq_s32 (int32x4_t __r, uint8x16_t __a, int8x16_t __b)
+{
+  return __builtin_aarch64_usdotv16qi_ssus (__r, __a, __b);
+}
+
+__extension__ extern __inline int32x2_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vusdot_lane_s32 (int32x2_t __r, uint8x8_t __a, int8x8_t __b, const int __index)
+{
+  return __builtin_aarch64_usdot_lanev8qi_ssuss (__r, __a, __b, __index);
+}
+
+__extension__ extern __inline int32x2_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vusdot_laneq_s32 (int32x2_t __r, uint8x8_t __a, int8x16_t __b,
+		  const int __index)
+{
+  return __builtin_aarch64_usdot_laneqv8qi_ssuss (__r, __a, __b, __index);
+}
+
+__extension__ extern __inline int32x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vusdotq_lane_s32 (int32x4_t __r, uint8x16_t __a, int8x8_t __b,
+		  const int __index)
+{
+  return __builtin_aarch64_usdot_lanev16qi_ssuss (__r, __a, __b, __index);
+}
+
+__extension__ extern __inline int32x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vusdotq_laneq_s32 (int32x4_t __r, uint8x16_t __a, int8x16_t __b,
+		   const int __index)
+{
+  return __builtin_aarch64_usdot_laneqv16qi_ssuss (__r, __a, __b, __index);
+}
+
+__extension__ extern __inline int32x2_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vsudot_lane_s32 (int32x2_t __r, int8x8_t __a, uint8x8_t __b, const int __index)
+{
+  return __builtin_aarch64_sudot_lanev8qi_sssus (__r, __a, __b, __index);
+}
+
+__extension__ extern __inline int32x2_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vsudot_laneq_s32 (int32x2_t __r, int8x8_t __a, uint8x16_t __b,
+		  const int __index)
+{
+  return __builtin_aarch64_sudot_laneqv8qi_sssus (__r, __a, __b, __index);
+}
+
+__extension__ extern __inline int32x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vsudotq_lane_s32 (int32x4_t __r, int8x16_t __a, uint8x8_t __b,
+		  const int __index)
+{
+  return __builtin_aarch64_sudot_lanev16qi_sssus (__r, __a, __b, __index);
+}
+
+__extension__ extern __inline int32x4_t
+__attribute__ ((__always_inline__, __gnu_inline__, __artificial__))
+vsudotq_laneq_s32 (int32x4_t __r, int8x16_t __a, uint8x16_t __b,
+		   const int __index)
+{
+  return __builtin_aarch64_sudot_laneqv16qi_sssus (__r, __a, __b, __index);
+}
+
+#pragma GCC pop_options
+
 #undef __aarch64_vget_lane_any
 
 #undef __aarch64_vdup_lane_any
diff --git a/gcc/config/aarch64/iterators.md b/gcc/config/aarch64/iterators.md
index b9843b83c5f..83720d9802a 100644
--- a/gcc/config/aarch64/iterators.md
+++ b/gcc/config/aarch64/iterators.md
@@ -799,6 +799,8 @@ (define_c_enum "unspec"
     UNSPEC_USUBLT	; Used in aarch64-sve2.md.
     UNSPEC_USUBWB	; Used in aarch64-sve2.md.
     UNSPEC_USUBWT	; Used in aarch64-sve2.md.
+    UNSPEC_USDOT	; Used in aarch64-simd.md.
+    UNSPEC_SUDOT	; Used in aarch64-simd.md.
 ])
 
 ;; ------------------------------------------------------------------
@@ -1463,6 +1465,8 @@ (define_mode_attr VFMLA_SEL_W [(V2SF "V2HF") (V4SF "V4HF")])
 
 (define_mode_attr f16quad [(V2SF "") (V4SF "q")])
 
+(define_mode_attr isquadop [(V8QI "") (V16QI "q")])
+
 (define_code_attr f16mac [(plus "a") (minus "s")])
 
 ;; Map smax to smin and umax to umin.
@@ -2045,6 +2049,8 @@ (define_int_iterator BSL_DUP [1 2])
 
 (define_int_iterator DOTPROD [UNSPEC_SDOT UNSPEC_UDOT])
 
+(define_int_iterator DOTPROD_I8MM [UNSPEC_USDOT UNSPEC_SUDOT])
+
 (define_int_iterator ADDSUBHN [UNSPEC_ADDHN UNSPEC_RADDHN
 			       UNSPEC_SUBHN UNSPEC_RSUBHN])
 
@@ -2738,6 +2744,7 @@ (define_int_attr sur [(UNSPEC_SHADD "s") (UNSPEC_UHADD "u")
 		      (UNSPEC_URSHL  "ur") (UNSPEC_SRSHL  "sr")
 		      (UNSPEC_UQRSHL  "u") (UNSPEC_SQRSHL  "s")
 		      (UNSPEC_SDOT "s") (UNSPEC_UDOT "u")
+		      (UNSPEC_USDOT "us") (UNSPEC_SUDOT "su")
 ])
 
 (define_int_attr r [(UNSPEC_SQDMULH "") (UNSPEC_SQRDMULH "r")
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 0d8aa6063a7..8b01aa06a40 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,10 @@
+2020-01-16  Stam Markianos-Wright  <stam.markianos-wright@arm.com>
+
+	* gcc.target/aarch64/advsimd-intrinsics/vdot-compile-3-1.c: New test.
+	* gcc.target/aarch64/advsimd-intrinsics/vdot-compile-3-2.c: New test.
+	* gcc.target/aarch64/advsimd-intrinsics/vdot-compile-3-3.c: New test.
+	* gcc.target/aarch64/advsimd-intrinsics/vdot-compile-3-4.c: New test.
+
 2020-01-16  Andre Vieira  <andre.simoesdiasvieira@arm.com>
 
 	PR tree-optimization/92429
diff --git a/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-1.c b/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-1.c
new file mode 100755
index 00000000000..ac4f821e771
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-1.c
@@ -0,0 +1,136 @@
+/* { dg-do assemble { target { aarch64*-*-* } } } */
+/* { dg-require-effective-target arm_v8_2a_i8mm_ok } */
+/* { dg-add-options arm_v8_2a_i8mm }  */
+/* { dg-additional-options "-save-temps" } */
+/* { dg-final { check-function-bodies "**" "" {-O[^0]} } } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+
+#include <arm_neon.h>
+
+/* Unsigned-Signed Dot Product instructions.  */
+
+/*
+**ufoo:
+**	usdot	v0\.2s, v1\.8b, v2\.8b
+**	ret
+*/
+int32x2_t ufoo (int32x2_t r, uint8x8_t x, int8x8_t y)
+{
+  return vusdot_s32 (r, x, y);
+}
+
+/*
+**ufooq:
+**	usdot	v0\.4s, v1\.16b, v2\.16b
+**	ret
+*/
+int32x4_t ufooq (int32x4_t r, uint8x16_t x, int8x16_t y)
+{
+  return vusdotq_s32 (r, x, y);
+}
+
+/*
+**ufoo_lane:
+**	usdot	v0\.2s, v1\.8b, v2\.4b\[0\]
+**	ret
+*/
+int32x2_t ufoo_lane (int32x2_t r, uint8x8_t x, int8x8_t y)
+{
+  return vusdot_lane_s32 (r, x, y, 0);
+}
+
+/*
+**ufoo_laneq:
+**	usdot	v0\.2s, v1\.8b, v2\.4b\[2\]
+**	ret
+*/
+int32x2_t ufoo_laneq (int32x2_t r, uint8x8_t x, int8x16_t y)
+{
+  return vusdot_laneq_s32 (r, x, y, 2);
+}
+
+/*
+**ufooq_lane:
+**	usdot	v0\.4s, v1\.16b, v2\.4b\[1\]
+**	ret
+*/
+int32x4_t ufooq_lane (int32x4_t r, uint8x16_t x, int8x8_t y)
+{
+  return vusdotq_lane_s32 (r, x, y, 1);
+}
+
+/*
+**ufooq_laneq:
+**	usdot	v0\.4s, v1\.16b, v2\.4b\[3\]
+**	ret
+*/
+int32x4_t ufooq_laneq (int32x4_t r, uint8x16_t x, int8x16_t y)
+{
+  return vusdotq_laneq_s32 (r, x, y, 3);
+}
+
+
+/* Signed-Unsigned Dot Product instructions.  */
+
+/*
+**sfoo_lane:
+**	sudot	v0\.2s, v1\.8b, v2\.4b\[0\]
+**	ret
+*/
+int32x2_t sfoo_lane (int32x2_t r, int8x8_t x, uint8x8_t y)
+{
+  return vsudot_lane_s32 (r, x, y, 0);
+}
+
+/*
+**sfoo_laneq:
+**	sudot	v0\.2s, v1\.8b, v2\.4b\[2\]
+**	ret
+*/
+int32x2_t sfoo_laneq (int32x2_t r, int8x8_t x, uint8x16_t y)
+{
+  return vsudot_laneq_s32 (r, x, y, 2);
+}
+
+/*
+**sfooq_lane:
+**	sudot	v0\.4s, v1\.16b, v2\.4b\[1\]
+**	ret
+*/
+int32x4_t sfooq_lane (int32x4_t r, int8x16_t x, uint8x8_t y)
+{
+  return vsudotq_lane_s32 (r, x, y, 1);
+}
+
+/*
+**sfooq_laneq:
+**	sudot	v0\.4s, v1\.16b, v2\.4b\[3\]
+**	ret
+*/
+int32x4_t sfooq_laneq (int32x4_t r, int8x16_t x, uint8x16_t y)
+{
+  return vsudotq_laneq_s32 (r, x, y, 3);
+}
+
+/*
+**ufoo_untied:
+**	mov	v0\.8b, v1\.8b
+**	usdot	v0\.2s, v2\.8b, v3\.8b
+**	ret
+*/
+int32x2_t ufoo_untied (int32x2_t unused, int32x2_t r, uint8x8_t x, int8x8_t y)
+{
+  return vusdot_s32 (r, x, y);
+}
+
+/*
+**ufooq_laneq_untied:
+**	mov	v0\.16b, v1\.16b
+**	usdot	v0\.4s, v2\.16b, v3\.4b\[3\]
+**	ret
+*/
+int32x4_t ufooq_laneq_untied (int32x2_t unused, int32x4_t r, uint8x16_t x, int8x16_t y)
+{
+  return vusdotq_laneq_s32 (r, x, y, 3);
+}
+
diff --git a/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-2.c b/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-2.c
new file mode 100755
index 00000000000..96bca2356e4
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-2.c
@@ -0,0 +1,137 @@
+/* { dg-do assemble { target { aarch64*-*-* } } } */
+/* { dg-require-effective-target arm_v8_2a_i8mm_ok } */
+/* { dg-add-options arm_v8_2a_i8mm }  */
+/* { dg-additional-options "-mbig-endian -save-temps" } */
+/* { dg-final { check-function-bodies "**" "" {-O[^0]} } } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+
+#include <arm_neon.h>
+
+/* Unsigned-Signed Dot Product instructions.  */
+
+/*
+**ufoo:
+**	usdot	v0\.2s, v1\.8b, v2\.8b
+**	ret
+*/
+int32x2_t ufoo (int32x2_t r, uint8x8_t x, int8x8_t y)
+{
+  return vusdot_s32 (r, x, y);
+}
+
+/*
+**ufooq:
+**	usdot	v0\.4s, v1\.16b, v2\.16b
+**	ret
+*/
+int32x4_t ufooq (int32x4_t r, uint8x16_t x, int8x16_t y)
+{
+  return vusdotq_s32 (r, x, y);
+}
+
+/*
+**ufoo_lane:
+**	usdot	v0\.2s, v1\.8b, v2\.4b\[0\]
+**	ret
+*/
+int32x2_t ufoo_lane (int32x2_t r, uint8x8_t x, int8x8_t y)
+{
+  return vusdot_lane_s32 (r, x, y, 0);
+}
+
+/*
+**ufoo_laneq:
+**	usdot	v0\.2s, v1\.8b, v2\.4b\[2\]
+**	ret
+*/
+int32x2_t ufoo_laneq (int32x2_t r, uint8x8_t x, int8x16_t y)
+{
+  return vusdot_laneq_s32 (r, x, y, 2);
+}
+
+/*
+**ufooq_lane:
+**	usdot	v0\.4s, v1\.16b, v2\.4b\[1\]
+**	ret
+*/
+int32x4_t ufooq_lane (int32x4_t r, uint8x16_t x, int8x8_t y)
+{
+  return vusdotq_lane_s32 (r, x, y, 1);
+}
+
+/*
+**ufooq_laneq:
+**	usdot	v0\.4s, v1\.16b, v2\.4b\[3\]
+**	ret
+*/
+int32x4_t ufooq_laneq (int32x4_t r, uint8x16_t x, int8x16_t y)
+{
+  return vusdotq_laneq_s32 (r, x, y, 3);
+}
+
+
+/* Signed-Unsigned Dot Product instructions.  */
+
+/*
+**sfoo_lane:
+**	sudot	v0\.2s, v1\.8b, v2\.4b\[0\]
+**	ret
+*/
+int32x2_t sfoo_lane (int32x2_t r, int8x8_t x, uint8x8_t y)
+{
+  return vsudot_lane_s32 (r, x, y, 0);
+}
+
+/*
+**sfoo_laneq:
+**	sudot	v0\.2s, v1\.8b, v2\.4b\[2\]
+**	ret
+*/
+int32x2_t sfoo_laneq (int32x2_t r, int8x8_t x, uint8x16_t y)
+{
+  return vsudot_laneq_s32 (r, x, y, 2);
+}
+
+/*
+**sfooq_lane:
+**	sudot	v0\.4s, v1\.16b, v2\.4b\[1\]
+**	ret
+*/
+int32x4_t sfooq_lane (int32x4_t r, int8x16_t x, uint8x8_t y)
+{
+  return vsudotq_lane_s32 (r, x, y, 1);
+}
+
+/*
+**sfooq_laneq:
+**	sudot	v0\.4s, v1\.16b, v2\.4b\[3\]
+**	ret
+*/
+int32x4_t sfooq_laneq (int32x4_t r, int8x16_t x, uint8x16_t y)
+{
+  return vsudotq_laneq_s32 (r, x, y, 3);
+}
+
+/*
+**ufoo_untied:
+**	mov	v0\.8b, v1\.8b
+**	usdot	v0\.2s, v2\.8b, v3\.8b
+**	ret
+*/
+int32x2_t ufoo_untied (int32x2_t unused, int32x2_t r, uint8x8_t x, int8x8_t y)
+{
+  return vusdot_s32 (r, x, y);
+}
+
+/*
+**ufooq_laneq_untied:
+**	mov	v0\.16b, v1\.16b
+**	usdot	v0\.4s, v2\.16b, v3\.4b\[3\]
+**	ret
+*/
+int32x4_t ufooq_laneq_untied (int32x2_t unused, int32x4_t r, uint8x16_t x, int8x16_t y)
+{
+  return vusdotq_laneq_s32 (r, x, y, 3);
+}
+
+
diff --git a/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-3.c b/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-3.c
new file mode 100755
index 00000000000..18ecabef8dc
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-3.c
@@ -0,0 +1,31 @@
+/* { dg-do assemble { target { aarch64*-*-* } } } */
+/* { dg-require-effective-target arm_v8_2a_i8mm_ok } */
+/* { dg-add-options arm_v8_2a_i8mm }  */
+/* { dg-additional-options "--save-temps" } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+
+#include <arm_neon.h>
+
+int32x2_t ufoo_lane (int32x2_t r, uint8x8_t x, int8x8_t y)
+{
+  /* { dg-error "lane -1 out of range 0 - 1" "" { target *-*-* } 0 } */
+  return vusdot_lane_s32 (r, x, y, -1);
+}
+
+int32x2_t ufoo_laneq (int32x2_t r, uint8x8_t x, int8x16_t y)
+{
+  /* { dg-error "lane -1 out of range 0 - 3" "" { target *-*-* } 0 } */
+  return vusdot_laneq_s32 (r, x, y, -1);
+}
+
+int32x4_t ufooq_lane (int32x4_t r, uint8x16_t x, int8x8_t y)
+{
+  /* { dg-error "lane 2 out of range 0 - 1" "" { target *-*-* } 0 } */
+  return vusdotq_lane_s32 (r, x, y, 2);
+}
+
+int32x4_t ufooq_laneq (int32x4_t r, uint8x16_t x, int8x16_t y)
+{
+  /* { dg-error "lane 4 out of range 0 - 3" "" { target *-*-* } 0 } */
+  return vusdotq_laneq_s32 (r, x, y, 4);
+}
diff --git a/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-4.c b/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-4.c
new file mode 100755
index 00000000000..66c87d48694
--- /dev/null
+++ b/gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vdot-3-4.c
@@ -0,0 +1,31 @@
+/* { dg-do assemble { target { aarch64*-*-* } } } */
+/* { dg-require-effective-target arm_v8_2a_i8mm_ok } */
+/* { dg-add-options arm_v8_2a_i8mm }  */
+/* { dg-additional-options "--save-temps" } */
+/* { dg-skip-if "" { *-*-* } { "-fno-fat-lto-objects" } } */
+
+#include <arm_neon.h>
+
+int32x2_t sfoo_lane (int32x2_t r, int8x8_t x, uint8x8_t y)
+{
+  /* { dg-error "lane -1 out of range 0 - 1" "" { target *-*-* } 0 } */
+  return vsudot_lane_s32 (r, x, y, -1);
+}
+
+int32x2_t sfoo_laneq (int32x2_t r, int8x8_t x, uint8x16_t y)
+{
+  /* { dg-error "lane -1 out of range 0 - 3" "" { target *-*-* } 0 } */
+  return vsudot_laneq_s32 (r, x, y, -1);
+}
+
+int32x4_t sfooq_lane (int32x4_t r, int8x16_t x, uint8x8_t y)
+{
+  /* { dg-error "lane 2 out of range 0 - 1" "" { target *-*-* } 0 } */
+  return vsudotq_lane_s32 (r, x, y, 2);
+}
+
+int32x4_t sfooq_laneq (int32x4_t r, int8x16_t x, uint8x16_t y)
+{
+  /* { dg-error "lane 4 out of range 0 - 3" "" { target *-*-* } 0 } */
+  return vsudotq_laneq_s32 (r, x, y, 4);
+}
-- 
2.26.1

